# GS1 Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [GS1 Schemaå®è·µæ¡ˆä¾‹](#gs1-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šMegaRetailé›¶å”®ä¾›åº”é“¾æ•°å­—åŒ–è½¬å‹](#2-æ¡ˆä¾‹1megaretailé›¶å”®ä¾›åº”é“¾æ•°å­—åŒ–è½¬å‹)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 Schemaå®šä¹‰](#25-schemaå®šä¹‰)
    - [2.6 å®Œæ•´å®ç°ä»£ç ](#26-å®Œæ•´å®ç°ä»£ç )
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šç‰©æµGLNä½ç½®ç®¡ç†](#3-æ¡ˆä¾‹2ç‰©æµglnä½ç½®ç®¡ç†)
  - [4. æ¡ˆä¾‹3ï¼šåŒ…è£…SSCCè¿½è¸ª](#4-æ¡ˆä¾‹3åŒ…è£…ssccè¿½è¸ª)
  - [5. æ¡ˆä¾‹4ï¼šEPCISä¾›åº”é“¾è¿½æº¯](#5-æ¡ˆä¾‹4epcisä¾›åº”é“¾è¿½æº¯)
  - [6. æ¡ˆä¾‹5ï¼šGS1æ•°æ®å­˜å‚¨ä¸åˆ†æ](#6-æ¡ˆä¾‹5gs1æ•°æ®å­˜å‚¨ä¸åˆ†æ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›GS1 Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„æ¡ˆä¾‹ï¼Œæ¶µç›–GTINã€GLNã€SSCCã€EPCISç­‰åœºæ™¯ï¼Œé€‚ç”¨äºé›¶å”®ä¾›åº”é“¾æ•°å­—åŒ–è½¬å‹ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šMegaRetailé›¶å”®ä¾›åº”é“¾æ•°å­—åŒ–è½¬å‹

### 2.1 ä¼ä¸šèƒŒæ™¯

**MegaRetail**æ˜¯å…¨çƒç¬¬äºŒå¤§é›¶å”®å•†ï¼Œåœ¨35ä¸ªå›½å®¶æ‹¥æœ‰12,000+é—¨åº—ï¼Œå¹´è¥ä¸šé¢è¶…è¿‡1,200äº¿ç¾å…ƒï¼ŒSKUæ•°é‡è¶…è¿‡300ä¸‡ï¼Œä¾›åº”å•†ç½‘ç»œè¦†ç›–8,000+ä¼ä¸šã€‚

- **æˆç«‹æ—¶é—´**ï¼š1967å¹´
- **å‘˜å·¥è§„æ¨¡**ï¼š230ä¸‡äºº
- **å¹´åº“å­˜å‘¨è½¬**ï¼š500äº¿ç¾å…ƒ
- **ä¾›åº”å•†æ•°é‡**ï¼š8,000+æ´»è·ƒä¾›åº”å•†
- **ç‰©æµç½‘ç»œ**ï¼š350ä¸ªé…é€ä¸­å¿ƒï¼Œ25,000è¾†è¿è¾“è½¦è¾†
- **åŸç³»ç»Ÿ**ï¼šæ¡ç ç³»ç»Ÿåˆ†æ•£ï¼ŒERPä¸é—¨åº—POSæ•°æ®ä¸åŒæ­¥ï¼Œç¼ºè´§ç‡é«˜è¾¾8%

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **åº“å­˜å‡†ç¡®åº¦ä½** | ä¸¥é‡ | åº“å­˜å‡†ç¡®ç‡ä»…78%ï¼Œå¯¼è‡´ç¼ºè´§æŸå¤±å¹´è¾¾15äº¿ç¾å…ƒ |
| 2 | **äº§å“è¿½æº¯å›°éš¾** | é«˜ | é£Ÿå“å®‰å…¨äº‹ä»¶å“åº”æ—¶é—´å¹³å‡72å°æ—¶ï¼Œé¢ä¸´ç›‘ç®¡é£é™© |
| 3 | **ä¾›åº”é“¾å¯è§†åŒ–å·®** | é«˜ | ä»ä¾›åº”å•†åˆ°é—¨åº—çš„å…¨é“¾è·¯å¯è§æ€§ä¸è¶³30% |
| 4 | **æ–°å“ä¸Šæ¶æ…¢** | ä¸­ | æ–°äº§å“ä»é‡‡è´­åˆ°ä¸Šæ¶å¹³å‡45å¤©ï¼Œé”™å¤±å¸‚åœºæœºä¼š |
| 5 | **é€€è´§å¤„ç†ä½æ•ˆ** | ä¸­ | é€€è´§å¤„ç†å‘¨æœŸ14å¤©ï¼ŒæŸè€—ç‡é«˜è¾¾12% |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | åº“å­˜å‡†ç¡®ç‡ | 78% | 98% | 12ä¸ªæœˆ |
| 2 | é£Ÿå“å®‰å…¨å“åº”æ—¶é—´ | 72å°æ—¶ | <4å°æ—¶ | 18ä¸ªæœˆ |
| 3 | ä¾›åº”é“¾ç«¯åˆ°ç«¯å¯è§æ€§ | 30% | 95% | 18ä¸ªæœˆ |
| 4 | æ–°å“ä¸Šæ¶å‘¨æœŸ | 45å¤© | 14å¤© | 12ä¸ªæœˆ |
| 5 | é€€è´§å¤„ç†å‘¨æœŸ | 14å¤© | 3å¤© | 9ä¸ªæœˆ |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤§è§„æ¨¡æ•°æ®å¤„ç†**ï¼šæ—¥å‡å¤„ç†3äº¿æ¬¡æ‰«æäº‹ä»¶ï¼Œå³°å€¼è¾¾500,000æ¬¡/åˆ†é’Ÿ

2. **å…¨çƒæ ‡å‡†ç»Ÿä¸€**ï¼šéœ€ç»Ÿä¸€GTINã€GLNã€SSCCåœ¨å…¨çƒ12,000+é—¨åº—çš„åº”ç”¨

3. **é—ç•™ç³»ç»Ÿé›†æˆ**ï¼šéœ€ä¸SAPã€Oracleã€é—¨åº—POSã€WMSç­‰50+ç³»ç»Ÿæ— ç¼é›†æˆ

4. **å®æ—¶è¿½æº¯éœ€æ±‚**ï¼šé£Ÿå“å®‰å…¨äº‹ä»¶éœ€åœ¨4å°æ—¶å†…å®šä½å—å½±å“æ‰¹æ¬¡

5. **ä¾›åº”å•†åˆè§„**ï¼š8,000+ä¾›åº”å•†éœ€åœ¨18ä¸ªæœˆå†…å®ŒæˆGS1æ ‡å‡†å‡çº§

### 2.5 Schemaå®šä¹‰

**GTINäº§å“æ ‡è¯†Schema**ï¼š

```dsl
schema GS1_GTIN_Product {
  gtin: {
    gtin_type: Enum { GTIN8, GTIN12, GTIN13, GTIN14 } @value(GTIN13)
    gtin_identifier: String @value("1234567890128") @length(8..14)
    check_digit: Integer @value(8) @range(0..9)
    
    structure: {
      company_prefix: String @value("1234567") @length(4..12)
      item_reference: String @value("89012") @length(1..6)
    }
  } @required
  
  product_info: {
    brand_name: String @value("Premium Coffee")
    product_description: String @value("Organic Arabica Coffee Beans 500g")
    product_category: String @value("Food & Beverage")
    net_content: {
      value: Decimal @value(500.0)
      unit: Enum { G, KG, ML, L, OZ, LB } @value(G)
    }
    country_of_origin: String @value("CO") @length(2)
  }
  
  packaging: {
    hierarchy: List[PackageLevel] {
      base_unit: {
        level: Integer @value(1)
        gtin: String @value("1234567890128")
        quantity: Integer @value(1)
      }
      case: {
        level: Integer @value(2)
        gtin: String @value("2234567890125")
        quantity: Integer @value(12)
      }
      pallet: {
        level: Integer @value(3)
        sscc: String @value("012345678901234567")
        quantity: Integer @value(48)
      }
    }
  }
  
  traceability: {
    batch_lot: String @value("LOT-2025-A001")
    serial_number: Optional[String]
    expiry_date: Date @value("2025-12-31")
    production_date: Date @value("2025-01-15")
  }
} @standard("GS1_General_Specifications")
```

### 2.6 å®Œæ•´å®ç°ä»£ç 

```python
"""
MegaRetailé›¶å”®ä¾›åº”é“¾GS1æ ‡è¯†ç³»ç»Ÿ
æ”¯æŒGTINã€GLNã€SSCCç®¡ç†å’ŒEPCISè¿½æº¯
"""

import re
import json
import hashlib
from dataclasses import dataclass, field
from datetime import datetime, date
from decimal import Decimal
from enum import Enum
from typing import Optional, List, Dict, Any, Tuple
from collections import defaultdict


class GS1IdentifierType(Enum):
    """GS1æ ‡è¯†ç±»å‹"""
    GTIN = "GTIN"
    GLN = "GLN"
    SSCC = "SSCC"
    GRAI = "GRAI"
    GIAI = "GIAI"
    GSRN = "GSRN"


class PackageLevel(Enum):
    """åŒ…è£…å±‚çº§"""
    BASE_UNIT = 1
    CASE = 2
    PALLET = 3
    CONTAINER = 4


@dataclass
class GTIN:
    """å…¨çƒè´¸æ˜“é¡¹ç›®ç¼–å·"""
    identifier: str
    gtin_type: str = "GTIN13"
    
    def __post_init__(self):
        # æ¸…ç†å¹¶æ ‡å‡†åŒ–
        self.identifier = self.identifier.strip()
        if len(self.identifier) == 8:
            self.gtin_type = "GTIN8"
        elif len(self.identifier) == 12:
            self.gtin_type = "GTIN12"
        elif len(self.identifier) == 13:
            self.gtin_type = "GTIN13"
        elif len(self.identifier) == 14:
            self.gtin_type = "GTIN14"
    
    def validate(self) -> Tuple[bool, List[str]]:
        """éªŒè¯GTIN"""
        errors = []
        
        if not self.identifier.isdigit():
            errors.append("GTINå¿…é¡»å…¨æ˜¯æ•°å­—")
        
        if len(self.identifier) not in [8, 12, 13, 14]:
            errors.append(f"GTINé•¿åº¦æ— æ•ˆ: {len(self.identifier)}")
        
        # æ ¡éªŒä½éªŒè¯
        if len(errors) == 0 and not self._validate_check_digit():
            errors.append("GTINæ ¡éªŒä½æ— æ•ˆ")
        
        return len(errors) == 0, errors
    
    def _validate_check_digit(self) -> bool:
        """éªŒè¯æ ¡éªŒä½"""
        digits = [int(d) for d in self.identifier]
        check_digit = digits[-1]
        payload = digits[:-1]
        
        # è®¡ç®—æ ¡éªŒä½
        total = 0
        for i, d in enumerate(reversed(payload)):
            if i % 2 == 0:
                total += d * 3
            else:
                total += d
        
        calculated = (10 - (total % 10)) % 10
        return calculated == check_digit
    
    def calculate_check_digit(self, payload: str) -> int:
        """è®¡ç®—æ ¡éªŒä½"""
        digits = [int(d) for d in payload]
        total = 0
        for i, d in enumerate(reversed(digits)):
            if i % 2 == 0:
                total += d * 3
            else:
                total += d
        return (10 - (total % 10)) % 10
    
    def to_upc_a(self) -> str:
        """è½¬æ¢ä¸ºUPC-Aæ ¼å¼"""
        if len(self.identifier) == 12:
            return self.identifier
        elif len(self.identifier) == 13:
            return self.identifier[1:]  # ç§»é™¤é¦–ä½
        return self.identifier
    
    def to_gtin14(self) -> str:
        """è½¬æ¢ä¸ºGTIN-14"""
        if len(self.identifier) == 14:
            return self.identifier
        elif len(self.identifier) == 13:
            return "0" + self.identifier
        elif len(self.identifier) == 12:
            return "00" + self.identifier
        return self.identifier.zfill(14)
    
    @classmethod
    def from_upc_a(cls, upc: str) -> 'GTIN':
        """ä»UPC-Aåˆ›å»º"""
        return cls(identifier="0" + upc, gtin_type="GTIN13")


@dataclass
class GLN:
    """å…¨çƒä½ç½®ç¼–å·"""
    identifier: str
    location_name: str = ""
    location_type: str = ""
    address: Dict[str, str] = field(default_factory=dict)
    
    def validate(self) -> Tuple[bool, List[str]]:
        """éªŒè¯GLN"""
        errors = []
        
        if len(self.identifier) != 13:
            errors.append(f"GLNé•¿åº¦å¿…é¡»ä¸º13ä½: {len(self.identifier)}")
        
        if not self.identifier.isdigit():
            errors.append("GLNå¿…é¡»å…¨æ˜¯æ•°å­—")
        
        # æ ¡éªŒä½
        if len(errors) == 0:
            digits = [int(d) for d in self.identifier]
            check_digit = digits[-1]
            payload = digits[:-1]
            
            total = 0
            for i, d in enumerate(reversed(payload)):
                if i % 2 == 0:
                    total += d
                else:
                    total += d * 3
            
            calculated = (10 - (total % 10)) % 10
            if calculated != check_digit:
                errors.append("GLNæ ¡éªŒä½æ— æ•ˆ")
        
        return len(errors) == 0, errors


@dataclass
class SSCC:
    """ç³»åˆ—è´§è¿åŒ…è£…ç®±ä»£ç """
    identifier: str
    extension_digit: str = "0"
    
    def validate(self) -> Tuple[bool, List[str]]:
        """éªŒè¯SSCC"""
        errors = []
        
        if len(self.identifier) != 18:
            errors.append(f"SSCCé•¿åº¦å¿…é¡»ä¸º18ä½: {len(self.identifier)}")
        
        if not self.identifier.isdigit():
            errors.append("SSCCå¿…é¡»å…¨æ˜¯æ•°å­—")
        
        return len(errors) == 0, errors
    
    def to_gs1_element_string(self) -> str:
        """è½¬æ¢ä¸ºGS1å…ƒç´ å­—ç¬¦ä¸²"""
        return f"(00){self.identifier}"
    
    def to_human_readable(self) -> str:
        """è½¬æ¢ä¸ºäººç±»å¯è¯»æ ¼å¼"""
        return f"{self.identifier[:2]} {self.identifier[2:10]} {self.identifier[10:17]} {self.identifier[17]}"


@dataclass
class EPCIS_Event:
    """EPCISäº‹ä»¶"""
    event_id: str
    event_type: str  # ObjectEvent, AggregationEvent, TransactionEvent, TransformationEvent
    event_time: datetime
    event_timezone: str
    action: str  # ADD, OBSERVE, DELETE
    biz_step: str
    disposition: str
    read_point: str
    biz_location: str
    epc_list: List[str] = field(default_factory=list)
    parent_id: Optional[str] = None
    child_epcs: List[str] = field(default_factory=list)
    biz_transaction_list: List[Dict[str, str]] = field(default_factory=list)
    
    def to_json(self) -> Dict[str, Any]:
        """è½¬æ¢ä¸ºJSONæ ¼å¼"""
        return {
            "eventID": self.event_id,
            "type": self.event_type,
            "eventTime": self.event_time.isoformat(),
            "eventTimeZoneOffset": self.event_timezone,
            "action": self.action,
            "bizStep": self.biz_step,
            "disposition": self.disposition,
            "readPoint": {"id": self.read_point},
            "bizLocation": {"id": self.biz_location},
            "epcList": self.epc_list if self.epc_list else None,
            "parentID": self.parent_id,
            "childEPCs": self.child_epcs if self.child_epcs else None,
            "bizTransactionList": [{"type": bt["type"], "bizTransaction": bt["value"]} 
                                  for bt in self.biz_transaction_list] if self.biz_transaction_list else None
        }


class GS1Validator:
    """GS1éªŒè¯å™¨"""
    
    def validate_gtin(self, gtin: GTIN) -> Tuple[bool, List[str]]:
        """éªŒè¯GTIN"""
        return gtin.validate()
    
    def validate_gln(self, gln: GLN) -> Tuple[bool, List[str]]:
        """éªŒè¯GLN"""
        return gln.validate()
    
    def validate_sscc(self, sscc: SSCC) -> Tuple[bool, List[str]]:
        """éªŒè¯SSCC"""
        return sscc.validate()


class EPCISQueryEngine:
    """EPCISæŸ¥è¯¢å¼•æ“"""
    
    def __init__(self):
        self.events: Dict[str, EPCIS_Event] = {}
        self.epc_index: Dict[str, List[str]] = defaultdict(list)
        self.time_index: Dict[str, List[str]] = defaultdict(list)
    
    def add_event(self, event: EPCIS_Event):
        """æ·»åŠ äº‹ä»¶"""
        self.events[event.event_id] = event
        
        # ç´¢å¼•EPC
        for epc in event.epc_list:
            self.epc_index[epc].append(event.event_id)
        
        # ç´¢å¼•æ—¶é—´
        date_key = event.event_time.strftime("%Y-%m-%d")
        self.time_index[date_key].append(event.event_id)
    
    def query_by_epc(self, epc: str) -> List[EPCIS_Event]:
        """æŒ‰EPCæŸ¥è¯¢äº‹ä»¶"""
        event_ids = self.epc_index.get(epc, [])
        return [self.events[eid] for eid in event_ids]
    
    def query_trace_path(self, epc: str) -> List[Dict[str, Any]]:
        """æŸ¥è¯¢è¿½æº¯è·¯å¾„"""
        events = self.query_by_epc(epc)
        events.sort(key=lambda e: e.event_time)
        
        return [
            {
                "step": i + 1,
                "timestamp": e.event_time.isoformat(),
                "location": e.biz_location,
                "biz_step": e.biz_step,
                "action": e.action
            }
            for i, e in enumerate(events)
        ]
    
    def query_aggregation_children(self, parent_sscc: str) -> List[str]:
        """æŸ¥è¯¢èšåˆäº‹ä»¶çš„å­é¡¹"""
        children = []
        for event in self.events.values():
            if (event.event_type == "AggregationEvent" and 
                event.parent_id == parent_sscc and 
                event.action in ["ADD", "OBSERVE"]):
                children.extend(event.child_epcs)
        return children


class SupplyChainTracer:
    """ä¾›åº”é“¾è¿½æº¯å™¨"""
    
    def __init__(self, query_engine: EPCISQueryEngine):
        self.query_engine = query_engine
    
    def trace_forward(self, gtin: str, batch_lot: str) -> Dict[str, Any]:
        """æ­£å‘è¿½æº¯ï¼ˆä»ç”Ÿäº§åˆ°æ¶ˆè´¹ï¼‰"""
        # æ„å»ºSGTIN EPC
        sgtin = f"urn:epc:id:sgtin:{gtin[:7]}.{gtin[7:12]}.{batch_lot}"
        
        trace_path = self.query_engine.query_trace_path(sgtin)
        
        return {
            "trace_type": "forward",
            "gtin": gtin,
            "batch_lot": batch_lot,
            "epc": sgtin,
            "steps": len(trace_path),
            "trace_path": trace_path,
            "origin": trace_path[0] if trace_path else None,
            "destination": trace_path[-1] if trace_path else None
        }
    
    def trace_backward(self, gtin: str, batch_lot: str) -> Dict[str, Any]:
        """åå‘è¿½æº¯ï¼ˆä»æ¶ˆè´¹åˆ°ç”Ÿäº§ï¼‰"""
        sgtin = f"urn:epc:id:sgtin:{gtin[:7]}.{gtin[7:12]}.{batch_lot}"
        
        trace_path = self.query_engine.query_trace_path(sgtin)
        trace_path.reverse()
        
        return {
            "trace_type": "backward",
            "gtin": gtin,
            "batch_lot": batch_lot,
            "epc": sgtin,
            "steps": len(trace_path),
            "trace_path": trace_path,
            "origin": trace_path[-1] if trace_path else None,
            "current_location": trace_path[0] if trace_path else None
        }
    
    def find_affected_products(self, batch_lot: str, location: str) -> List[str]:
        """æŸ¥æ‰¾å—å½±å“çš„äº§å“ï¼ˆå¬å›åœºæ™¯ï¼‰"""
        affected = []
        for event in self.query_engine.events.values():
            if (any(batch_lot in epc for epc in event.epc_list) and
                event.biz_location == location):
                affected.extend(event.epc_list)
        return list(set(affected))


class GS1BarcodeEncoder:
    """GS1æ¡ç ç¼–ç å™¨"""
    
    def encode_gtin_14(self, gtin14: str) -> str:
        """ç¼–ç GTIN-14åˆ°GS1-128"""
        return f"(01){gtin14}"
    
    def encode_sscc(self, sscc: str) -> str:
        """ç¼–ç SSCCåˆ°GS1-128"""
        return f"(00){sscc}"
    
    def encode_batch_lot(self, gtin: str, batch: str, expiry: str) -> str:
        """ç¼–ç GTIN+æ‰¹æ¬¡+æœ‰æ•ˆæœŸ"""
        return f"(01){gtin}(10){batch}(17){expiry}"
    
    def parse_barcode(self, barcode: str) -> Dict[str, str]:
        """è§£æGS1æ¡ç """
        result = {}
        pattern = r'\((\d{2})\)([^\(]+)'
        matches = re.findall(pattern, barcode)
        
        ai_mapping = {
            "00": "sscc",
            "01": "gtin",
            "10": "batch_lot",
            "11": "production_date",
            "15": "best_before",
            "17": "expiry_date",
            "21": "serial_number",
            "30": "count"
        }
        
        for ai, value in matches:
            key = ai_mapping.get(ai, f"AI_{ai}")
            result[key] = value.strip()
        
        return result


def main():
    """ä¸»å‡½æ•° - æ¼”ç¤º"""
    # åˆ›å»ºGTIN
    gtin = GTIN(identifier="1234567890128")
    is_valid, errors = gtin.validate()
    print(f"GTINéªŒè¯: {'é€šè¿‡' if is_valid else 'å¤±è´¥'} {errors}")
    print(f"GTIN-14æ ¼å¼: {gtin.to_gtin14()}")
    
    # åˆ›å»ºGLN
    gln = GLN(
        identifier="1234567890123",
        location_name="Distribution Center A",
        location_type="WAREHOUSE",
        address={"city": "Shanghai", "country": "CN"}
    )
    is_valid, errors = gln.validate()
    print(f"\nGLNéªŒè¯: {'é€šè¿‡' if is_valid else 'å¤±è´¥'} {errors}")
    
    # åˆ›å»ºSSCC
    sscc = SSCC(identifier="012345678901234567")
    is_valid, errors = sscc.validate()
    print(f"\nSSCCéªŒè¯: {'é€šè¿‡' if is_valid else 'å¤±è´¥'}")
    print(f"SSCCå¯è¯»æ ¼å¼: {sscc.to_human_readable()}")
    
    # åˆ›å»ºEPCISäº‹ä»¶
    query_engine = EPCISQueryEngine()
    
    events = [
        EPCIS_Event(
            event_id="evt-001",
            event_type="ObjectEvent",
            event_time=datetime(2025, 1, 15, 10, 0, 0),
            event_timezone="+08:00",
            action="ADD",
            biz_step="urn:epcglobal:cbv:bizstep:receiving",
            disposition="urn:epcglobal:cbv:disp:in_progress",
            read_point="urn:epc:id:sgln:1234567890123.pos1",
            biz_location="urn:epc:id:sgln:1234567890123",
            epc_list=["urn:epc:id:sgtin:1234567.89012.LOT001"],
            biz_transaction_list=[{"type": "po", "value": "PO-2025-001"}]
        ),
        EPCIS_Event(
            event_id="evt-002",
            event_type="ObjectEvent",
            event_time=datetime(2025, 1, 16, 14, 0, 0),
            event_timezone="+08:00",
            action="OBSERVE",
            biz_step="urn:epcglobal:cbv:bizstep:shipping",
            disposition="urn:epcglobal:cbv:disp:in_transit",
            read_point="urn:epc:id:sgln:1234567890123.dock1",
            biz_location="urn:epc:id:sgln:1234567890123",
            epc_list=["urn:epc:id:sgtin:1234567.89012.LOT001"]
        ),
        EPCIS_Event(
            event_id="evt-003",
            event_type="ObjectEvent",
            event_time=datetime(2025, 1, 18, 9, 0, 0),
            event_timezone="+08:00",
            action="OBSERVE",
            biz_step="urn:epcglobal:cbv:bizstep:receiving",
            disposition="urn:epcglobal:cbv:disp:in_progress",
            read_point="urn:epc:id:sgln:9876543210987.pos1",
            biz_location="urn:epc:id:sgln:9876543210987",
            epc_list=["urn:epc:id:sgtin:1234567.89012.LOT001"]
        )
    ]
    
    for event in events:
        query_engine.add_event(event)
    
    # è¿½æº¯æŸ¥è¯¢
    tracer = SupplyChainTracer(query_engine)
    epc = "urn:epc:id:sgtin:1234567.89012.LOT001"
    
    print("\næ­£å‘è¿½æº¯:")
    forward = tracer.trace_forward("1234567890128", "LOT001")
    print(json.dumps(forward, indent=2, default=str))
    
    # æ¡ç ç¼–ç 
    encoder = GS1BarcodeEncoder()
    barcode = encoder.encode_batch_lot("12345678901234", "LOT001", "250131")
    print(f"\nGS1æ¡ç : {barcode}")
    
    parsed = encoder.parse_barcode(barcode)
    print(f"è§£æç»“æœ: {json.dumps(parsed, indent=2)}")


if __name__ == "__main__":
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| åº“å­˜å‡†ç¡®ç‡ | 78% | 98.5% | +20.5% |
| ç¼ºè´§ç‡ | 8% | 1.5% | -81% |
| é£Ÿå“å®‰å…¨å“åº”æ—¶é—´ | 72å°æ—¶ | 2.5å°æ—¶ | -96% |
| ä¾›åº”é“¾å¯è§æ€§ | 30% | 96% | +66% |
| æ–°å“ä¸Šæ¶å‘¨æœŸ | 45å¤© | 12å¤© | -73% |
| é€€è´§å¤„ç†å‘¨æœŸ | 14å¤© | 2.5å¤© | -82% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼ˆ24ä¸ªæœˆé¡¹ç›®å‘¨æœŸï¼‰ï¼š
- GS1æ ‡è¯†ç³»ç»Ÿï¼š1,200ä¸‡ç¾å…ƒ
- EPCISè¿½æº¯å¹³å°ï¼š800ä¸‡ç¾å…ƒ
- é—¨åº—ç³»ç»Ÿé›†æˆï¼š600ä¸‡ç¾å…ƒ
- ä¾›åº”å•†åŸ¹è®­ï¼š200ä¸‡ç¾å…ƒ
- **æ€»æŠ•èµ„**ï¼š2,800ä¸‡ç¾å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- ç¼ºè´§æŸå¤±å‡å°‘ï¼š8,500ä¸‡ç¾å…ƒ
- åº“å­˜ä¼˜åŒ–èŠ‚çº¦ï¼š3,200ä¸‡ç¾å…ƒ
- é€€è´§æŸè€—å‡å°‘ï¼š1,800ä¸‡ç¾å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š1.35äº¿ç¾å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š2.5ä¸ªæœˆ
- 3å¹´ROIï¼š1,346%

#### ç»éªŒæ•™è®­

**æˆåŠŸå› ç´ **ï¼š
1. **ä¾›åº”å•†ååŒ**ï¼šå»ºç«‹ä¾›åº”å•†é—¨æˆ·ï¼Œè‡ªåŠ©å®ŒæˆGTIN/GLNæ³¨å†Œ
2. **åˆ†é˜¶æ®µæ¨å¹¿**ï¼šå…ˆè¯•ç‚¹100å®¶é—¨åº—ï¼Œå†å…¨é¢æ¨å¹¿
3. **å…¨å‘˜åŸ¹è®­**ï¼šå¯¹230ä¸‡å‘˜å·¥è¿›è¡ŒGS1æ ‡å‡†åŸ¹è®­

**æŒ‘æˆ˜ä¸åº”å¯¹**ï¼š
1. **ä¸­å°ä¾›åº”å•†é˜»åŠ›**ï¼šæä¾›å…è´¹å·¥å…·å’Œå’¨è¯¢æœåŠ¡
2. **æ•°æ®è´¨é‡å‚å·®ä¸é½**ï¼šå»ºç«‹æ•°æ®è´¨é‡è¯„åˆ†ä½“ç³»
3. **è·¨å›½æ ‡å‡†å·®å¼‚**ï¼šå»ºç«‹åŒºåŸŸåŒ–æ˜ å°„è¡¨

---

## 3. æ¡ˆä¾‹2ï¼šç‰©æµGLNä½ç½®ç®¡ç†

è¯¦è§ `04_Transformation.md` ç¬¬3ç« ã€‚

## 4. æ¡ˆä¾‹3ï¼šåŒ…è£…SSCCè¿½è¸ª

è¯¦è§ `04_Transformation.md` ç¬¬4ç« ã€‚

## 5. æ¡ˆä¾‹4ï¼šEPCISä¾›åº”é“¾è¿½æº¯

è¯¦è§ `04_Transformation.md` ç¬¬5ç« ã€‚

## 6. æ¡ˆä¾‹5ï¼šGS1æ•°æ®å­˜å‚¨ä¸åˆ†æ

è¯¦è§ `04_Transformation.md` ç¬¬6ç« ã€‚

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

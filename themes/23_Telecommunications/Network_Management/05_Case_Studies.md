# ç½‘ç»œç®¡ç†Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
- [2. ä¼ä¸šèƒŒæ™¯](#2-ä¼ä¸šèƒŒæ™¯)
- [3. ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡](#3-ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡)
- [4. æŠ€æœ¯æŒ‘æˆ˜](#4-æŠ€æœ¯æŒ‘æˆ˜)
- [5. è§£å†³æ–¹æ¡ˆæ¶æ„](#5-è§£å†³æ–¹æ¡ˆæ¶æ„)
- [6. å®Œæ•´å®ç°ä»£ç ](#6-å®Œæ•´å®ç°ä»£ç )
- [7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ](#7-æ•ˆæœè¯„ä¼°ä¸roiåˆ†æ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ç½‘ç»œç®¡ç†Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®Œæ•´å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ç½‘ç»œç›‘æ§ã€æ€§èƒ½ç®¡ç†ã€é…ç½®ç®¡ç†ã€æ•…éšœç®¡ç†ã€å®‰å…¨ç®¡ç†ç­‰æ ¸å¿ƒç½‘ç»œç®¡ç†åœºæ™¯ã€‚

---

## 2. ä¼ä¸šèƒŒæ™¯

### 2.1 ä¼ä¸šæ¦‚å†µ

**ä¼ä¸šåç§°**ï¼šä¸­äº‘é€šä¿¡é›†å›¢æœ‰é™å…¬å¸ï¼ˆè™šæ„æ¡ˆä¾‹ä¼ä¸šï¼‰

**ç½‘ç»œè§„æ¨¡**ï¼š
- åŸºç«™ï¼š300ä¸‡+
- æ ¸å¿ƒç½‘å…ƒï¼š5000+
- ä¼ è¾“é“¾è·¯ï¼š100ä¸‡+å…¬é‡Œ
- æ•°æ®ä¸­å¿ƒï¼š50ä¸ª

---

## 3. ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡

### 3.1 äº”å¤§ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å…·ä½“è¡¨ç° | å½±å“ç¨‹åº¦ |
|------|------|----------|----------|
| 1 | **å‘Šè­¦é£æš´** | å•æ•…éšœäº§ç”Ÿå¤§é‡å…³è”å‘Šè­¦ | é«˜ |
| 2 | **æ ¹å› å®šä½éš¾** | æ•…éšœå®šä½æ—¶é—´é•¿ | é«˜ |
| 3 | **é…ç½®é”™è¯¯å¤š** | äººå·¥é…ç½®æ˜“å‡ºé”™ | é«˜ |
| 4 | **å®¹é‡é¢„æµ‹éš¾** | æ‰©å®¹å†³ç­–ç¼ºä¹ä¾æ® | ä¸­ |
| 5 | **å®‰å…¨é£é™©é«˜** | ç½‘ç»œæ”»å‡»é¢‘å‘ | é«˜ |

### 3.2 äº”å¤§ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å…·ä½“æŒ‡æ ‡ | å®ŒæˆæœŸé™ |
|------|------|----------|----------|
| 1 | **å‘Šè­¦å‹ç¼©** | å‘Šè­¦é‡å‡å°‘90% | 9ä¸ªæœˆ |
| 2 | **æ ¹å› å®šä½** | å®šä½æ—¶é—´<5åˆ†é’Ÿ | 12ä¸ªæœˆ |
| 3 | **é…ç½®è‡ªåŠ¨åŒ–** | 90%é…ç½®è‡ªåŠ¨ä¸‹å‘ | 9ä¸ªæœˆ |
| 4 | **æ™ºèƒ½é¢„æµ‹** | å®¹é‡é¢„æµ‹å‡†ç¡®ç‡>85% | 12ä¸ªæœˆ |
| 5 | **å®‰å…¨æ£€æµ‹** | å¨èƒæ£€æµ‹ç‡>99% | 12ä¸ªæœˆ |

---

## 4. æŠ€æœ¯æŒ‘æˆ˜

1. **å¤§è§„æ¨¡ç›‘æ§**ï¼šæµ·é‡ç½‘å…ƒçš„å®æ—¶ç›‘æ§
2. **å‘Šè­¦å…³è”åˆ†æ**ï¼šå¤šæºå‘Šè­¦çš„å…³è”å’Œæ ¹å› åˆ†æ
3. **æ„å›¾é©±åŠ¨ç½‘ç»œ**ï¼šåŸºäºæ„å›¾çš„è‡ªåŠ¨åŒ–é…ç½®
4. **AIè¿ç»´**ï¼šæœºå™¨å­¦ä¹ åœ¨ç½‘ç»œè¿ç»´ä¸­çš„åº”ç”¨
5. **å®‰å…¨æ€åŠ¿æ„ŸçŸ¥**ï¼šå…¨ç½‘å®‰å…¨æ€åŠ¿å®æ—¶ç›‘æ§

---

## 5. è§£å†³æ–¹æ¡ˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‘ˆç°å±‚                                    â”‚
â”‚  æ‹“æ‰‘è§†å›¾  å‘Šè­¦ä¸­å¿ƒ  æ€§èƒ½æŠ¥è¡¨  é…ç½®ç®¡ç†  å®‰å…¨å¤§å±            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    åˆ†æå±‚                                    â”‚
â”‚  æ ¹å› åˆ†æ  é¢„æµ‹åˆ†æ  å…³è”åˆ†æ  å¼‚å¸¸æ£€æµ‹  å¨èƒåˆ†æ            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    å¤„ç†å±‚                                    â”‚
â”‚  å‘Šè­¦å‹ç¼©  äº‹ä»¶å¤„ç†  é…ç½®ä¸‹å‘  è‡ªåŠ¨ä¿®å¤  ç­–ç•¥æ‰§è¡Œ            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    é‡‡é›†å±‚                                    â”‚
â”‚  SNMP  Telemetry  Syslog  Flow  Trap                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç½‘ç»œå±‚                                    â”‚
â”‚  æ— çº¿ç½‘  æ‰¿è½½ç½‘  æ ¸å¿ƒç½‘  ä¼ è¾“ç½‘  æ•°æ®ä¸­å¿ƒ                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ç½‘ç»œç®¡ç†Schemaå®è·µæ¡ˆä¾‹
ä¼ä¸šï¼šä¸­äº‘é€šä¿¡é›†å›¢æœ‰é™å…¬å¸
"""

import json
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, field
from enum import Enum
import random
import logging
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DeviceType(Enum):
    """è®¾å¤‡ç±»å‹"""
    BASE_STATION = "åŸºç«™"
    ROUTER = "è·¯ç”±å™¨"
    SWITCH = "äº¤æ¢æœº"
    FIREWALL = "é˜²ç«å¢™"
    SERVER = "æœåŠ¡å™¨"
    LOAD_BALANCER = "è´Ÿè½½å‡è¡¡"


class DeviceStatus(Enum):
    """è®¾å¤‡çŠ¶æ€"""
    NORMAL = "æ­£å¸¸"
    WARNING = "å‘Šè­¦"
    CRITICAL = "ä¸¥é‡"
    OFFLINE = "ç¦»çº¿"
    MAINTENANCE = "ç»´æŠ¤"


class AlarmSeverity(Enum):
    """å‘Šè­¦çº§åˆ«"""
    CRITICAL = "ç´§æ€¥"
    MAJOR = "é‡è¦"
    MINOR = "æ¬¡è¦"
    WARNING = "è­¦å‘Š"
    INFO = "æç¤º"


class AlarmStatus(Enum):
    """å‘Šè­¦çŠ¶æ€"""
    ACTIVE = "æ´»åŠ¨"
    ACKNOWLEDGED = "å·²ç¡®è®¤"
    CLEARED = "å·²æ¸…é™¤"


@dataclass
class NetworkDevice:
    """ç½‘ç»œè®¾å¤‡"""
    device_id: str
    name: str
    device_type: DeviceType
    ip_address: str
    location: str
    status: DeviceStatus = DeviceStatus.NORMAL
    
    # æ€§èƒ½æŒ‡æ ‡
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    disk_usage: float = 0.0
    temperature: float = 0.0
    
    # è¿æ¥å…³ç³»
    connected_devices: List[str] = field(default_factory=list)
    
    last_seen: datetime = field(default_factory=datetime.now)
    
    def update_metrics(self, cpu: float, memory: float, disk: float, temp: float):
        """æ›´æ–°æ€§èƒ½æŒ‡æ ‡"""
        self.cpu_usage = cpu
        self.memory_usage = memory
        self.disk_usage = disk
        self.temperature = temp
        self.last_seen = datetime.now()
        
        # æ›´æ–°çŠ¶æ€
        if cpu > 90 or memory > 95 or temp > 80:
            self.status = DeviceStatus.CRITICAL
        elif cpu > 70 or memory > 80 or temp > 70:
            self.status = DeviceStatus.WARNING
        else:
            self.status = DeviceStatus.NORMAL
    
    def to_dict(self) -> Dict:
        return {
            "device_id": self.device_id,
            "name": self.name,
            "device_type": self.device_type.value,
            "ip_address": self.ip_address,
            "location": self.location,
            "status": self.status.value,
            "metrics": {
                "cpu_usage": round(self.cpu_usage, 2),
                "memory_usage": round(self.memory_usage, 2),
                "disk_usage": round(self.disk_usage, 2),
                "temperature": round(self.temperature, 2)
            },
            "last_seen": self.last_seen.isoformat()
        }


@dataclass
class Alarm:
    """å‘Šè­¦"""
    alarm_id: str
    device_id: str
    alarm_type: str
    severity: AlarmSeverity
    description: str
    status: AlarmStatus = AlarmStatus.ACTIVE
    created_at: datetime = field(default_factory=datetime.now)
    cleared_at: Optional[datetime] = None
    root_cause: Optional[str] = None
    correlated_alarms: List[str] = field(default_factory=list)
    
    def clear(self):
        """æ¸…é™¤å‘Šè­¦"""
        self.status = AlarmStatus.CLEARED
        self.cleared_at = datetime.now()
    
    def to_dict(self) -> Dict:
        return {
            "alarm_id": self.alarm_id,
            "device_id": self.device_id,
            "alarm_type": self.alarm_type,
            "severity": self.severity.value,
            "description": self.description,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "duration_minutes": self._get_duration(),
            "root_cause": self.root_cause
        }
    
    def _get_duration(self) -> Optional[int]:
        """è·å–å‘Šè­¦æŒç»­æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰"""
        end_time = self.cleared_at or datetime.now()
        return int((end_time - self.created_at).total_seconds() / 60)


@dataclass
class NetworkConfig:
    """ç½‘ç»œé…ç½®"""
    config_id: str
    device_id: str
    config_type: str
    content: Dict[str, Any]
    version: str = "1.0"
    created_by: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    is_active: bool = True
    
    def to_dict(self) -> Dict:
        return {
            "config_id": self.config_id,
            "device_id": self.device_id,
            "config_type": self.config_type,
            "version": self.version,
            "created_by": self.created_by,
            "created_at": self.created_at.isoformat(),
            "is_active": self.is_active
        }


class AlarmCorrelationEngine:
    """å‘Šè­¦å…³è”å¼•æ“"""
    
    def __init__(self):
        self.correlation_rules: List[Dict] = []
        self.root_cause_patterns: Dict[str, str] = {}
    
    def add_correlation_rule(self, rule_name: str, source_types: List[str], 
                            target_type: str, time_window: int):
        """æ·»åŠ å…³è”è§„åˆ™"""
        self.correlation_rules.append({
            "name": rule_name,
            "source_types": source_types,
            "target_type": target_type,
            "time_window": time_window
        })
    
    def correlate_alarms(self, alarms: List[Alarm]) -> List[List[Alarm]]:
        """å…³è”å‘Šè­¦"""
        correlated_groups = []
        processed = set()
        
        for alarm in alarms:
            if alarm.alarm_id in processed:
                continue
            
            # æŸ¥æ‰¾å…³è”å‘Šè­¦
            group = [alarm]
            processed.add(alarm.alarm_id)
            
            for other in alarms:
                if other.alarm_id in processed:
                    continue
                
                # æ£€æŸ¥æ˜¯å¦å…³è”
                if self._is_correlated(alarm, other):
                    group.append(other)
                    processed.add(other.alarm_id)
            
            if len(group) > 1:
                correlated_groups.append(group)
        
        return correlated_groups
    
    def _is_correlated(self, alarm1: Alarm, alarm2: Alarm) -> bool:
        """æ£€æŸ¥ä¸¤ä¸ªå‘Šè­¦æ˜¯å¦å…³è”"""
        # æ—¶é—´çª—å£æ£€æŸ¥
        time_diff = abs((alarm1.created_at - alarm2.created_at).total_seconds())
        if time_diff > 300:  # 5åˆ†é’Ÿå†…
            return False
        
        # è®¾å¤‡å…³è”æ£€æŸ¥
        if alarm1.device_id == alarm2.device_id:
            return True
        
        return False
    
    def identify_root_cause(self, alarm_group: List[Alarm]) -> Optional[str]:
        """è¯†åˆ«æ ¹å› """
        if not alarm_group:
            return None
        
        # ä¼˜å…ˆé€‰æ‹©æœ€æ—©å‘ç”Ÿçš„ä¸¥é‡å‘Šè­¦
        sorted_alarms = sorted(alarm_group, key=lambda x: (x.created_at, 
                              list(AlarmSeverity).index(x.severity)))
        
        root_cause = sorted_alarms[0]
        return f"{root_cause.alarm_type} on {root_cause.device_id}"


class NetworkManager:
    """ç½‘ç»œç®¡ç†å™¨"""
    
    def __init__(self):
        self.devices: Dict[str, NetworkDevice] = {}
        self.alarms: Dict[str, Alarm] = {}
        self.configs: Dict[str, NetworkConfig] = {}
        self.correlation_engine = AlarmCorrelationEngine()
        self.performance_history: Dict[str, List[Dict]] = defaultdict(list)
        
        # åˆå§‹åŒ–å…³è”è§„åˆ™
        self._init_correlation_rules()
    
    def _init_correlation_rules(self):
        """åˆå§‹åŒ–å…³è”è§„åˆ™"""
        self.correlation_engine.add_correlation_rule(
            "é“¾è·¯æ•…éšœå…³è”", ["LINK_DOWN"], "CONNECTIVITY_LOSS", 300
        )
        self.correlation_engine.add_correlation_rule(
            "è®¾å¤‡æ•…éšœå…³è”", ["DEVICE_DOWN"], "SERVICE_IMPACT", 300
        )
    
    def add_device(self, device: NetworkDevice):
        """æ·»åŠ è®¾å¤‡"""
        self.devices[device.device_id] = device
        logger.info(f"Added device: {device.name}")
    
    def collect_metrics(self, device_id: str):
        """é‡‡é›†è®¾å¤‡æŒ‡æ ‡"""
        device = self.devices.get(device_id)
        if not device:
            return
        
        # æ¨¡æ‹ŸæŒ‡æ ‡é‡‡é›†
        device.update_metrics(
            cpu=random.uniform(20, 95),
            memory=random.uniform(30, 90),
            disk=random.uniform(40, 85),
            temp=random.uniform(40, 75)
        )
        
        # ä¿å­˜å†å²
        self.performance_history[device_id].append({
            "timestamp": datetime.now().isoformat(),
            "cpu": device.cpu_usage,
            "memory": device.memory_usage
        })
        
        # æ£€æŸ¥å‘Šè­¦
        self._check_thresholds(device)
    
    def _check_thresholds(self, device: NetworkDevice):
        """æ£€æŸ¥é˜ˆå€¼"""
        if device.cpu_usage > 90:
            self.create_alarm(
                device_id=device.device_id,
                alarm_type="HIGH_CPU",
                severity=AlarmSeverity.CRITICAL,
                description=f"CPUä½¿ç”¨ç‡è¶…è¿‡90%: {device.cpu_usage:.1f}%"
            )
        
        if device.memory_usage > 90:
            self.create_alarm(
                device_id=device.device_id,
                alarm_type="HIGH_MEMORY",
                severity=AlarmSeverity.MAJOR,
                description=f"å†…å­˜ä½¿ç”¨ç‡è¶…è¿‡90%: {device.memory_usage:.1f}%"
            )
    
    def create_alarm(self, device_id: str, alarm_type: str, 
                     severity: AlarmSeverity, description: str) -> Alarm:
        """åˆ›å»ºå‘Šè­¦"""
        alarm = Alarm(
            alarm_id=f"ALM-{uuid.uuid4().hex[:8].upper()}",
            device_id=device_id,
            alarm_type=alarm_type,
            severity=severity,
            description=description
        )
        
        self.alarms[alarm.alarm_id] = alarm
        logger.info(f"Created alarm: {alarm.alarm_id} - {alarm_type}")
        return alarm
    
    def correlate_and_compress(self):
        """å‘Šè­¦å…³è”å‹ç¼©"""
        active_alarms = [a for a in self.alarms.values() 
                        if a.status == AlarmStatus.ACTIVE]
        
        # å…³è”åˆ†ç»„
        groups = self.correlation_engine.correlate_alarms(active_alarms)
        
        compressed_count = 0
        for group in groups:
            root_cause = self.correlation_engine.identify_root_cause(group)
            
            # æ ‡è®°æ ¹å› 
            for alarm in group:
                alarm.root_cause = root_cause
                if alarm != group[0]:
                    # éæ ¹å› å‘Šè­¦å…³è”åˆ°æ ¹å› 
                    group[0].correlated_alarms.append(alarm.alarm_id)
                    compressed_count += 1
        
        logger.info(f"Alarm compression: {len(active_alarms)} -> {len(active_alarms) - compressed_count}")
        return compressed_count
    
    def auto_heal(self, alarm_id: str) -> bool:
        """è‡ªåŠ¨ä¿®å¤"""
        alarm = self.alarms.get(alarm_id)
        if not alarm:
            return False
        
        # æ¨¡æ‹Ÿè‡ªåŠ¨ä¿®å¤é€»è¾‘
        if alarm.alarm_type in ["HIGH_CPU", "HIGH_MEMORY"]:
            device = self.devices.get(alarm.device_id)
            if device:
                # æ¨¡æ‹Ÿè´Ÿè½½å‡è¡¡æˆ–é‡å¯
                device.update_metrics(
                    cpu=max(30, device.cpu_usage - 40),
                    memory=max(40, device.memory_usage - 30),
                    disk=device.disk_usage,
                    temp=device.temperature
                )
                alarm.clear()
                logger.info(f"Auto-healed alarm: {alarm_id}")
                return True
        
        return False
    
    def apply_config(self, device_id: str, config_content: Dict, 
                     config_type: str, created_by: str) -> NetworkConfig:
        """åº”ç”¨é…ç½®"""
        config = NetworkConfig(
            config_id=f"CFG-{uuid.uuid4().hex[:8].upper()}",
            device_id=device_id,
            config_type=config_type,
            content=config_content,
            created_by=created_by
        )
        
        # åœç”¨æ—§é…ç½®
        for cfg in self.configs.values():
            if cfg.device_id == device_id and cfg.config_type == config_type:
                cfg.is_active = False
        
        self.configs[config.config_id] = config
        logger.info(f"Applied config: {config.config_id} to {device_id}")
        return config
    
    def predict_capacity(self, device_id: str, days_ahead: int = 30) -> Dict:
        """é¢„æµ‹å®¹é‡"""
        history = self.performance_history.get(device_id, [])
        if len(history) < 7:
            return {"error": "Insufficient data"}
        
        # ç®€å•çš„çº¿æ€§é¢„æµ‹
        recent_cpu = [h["cpu"] for h in history[-7:]]
        avg_cpu = sum(recent_cpu) / len(recent_cpu)
        
        # å‡è®¾CPUä»¥æ¯å¤©0.5%å¢é•¿
        predicted_cpu = min(100, avg_cpu + days_ahead * 0.5)
        
        return {
            "device_id": device_id,
            "current_cpu_avg": round(avg_cpu, 2),
            "predicted_cpu": round(predicted_cpu, 2),
            "prediction_date": (datetime.now() + timedelta(days=days_ahead)).isoformat(),
            "recommendation": "å»ºè®®æ‰©å®¹" if predicted_cpu > 80 else "å®¹é‡å……è¶³"
        }
    
    def get_network_summary(self) -> Dict:
        """è·å–ç½‘ç»œæ‘˜è¦"""
        total_devices = len(self.devices)
        status_counts = defaultdict(int)
        for device in self.devices.values():
            status_counts[device.status.value] += 1
        
        active_alarms = len([a for a in self.alarms.values() 
                            if a.status == AlarmStatus.ACTIVE])
        
        severity_counts = defaultdict(int)
        for alarm in self.alarms.values():
            if alarm.status == AlarmStatus.ACTIVE:
                severity_counts[alarm.severity.value] += 1
        
        return {
            "total_devices": total_devices,
            "device_status": dict(status_counts),
            "total_alarms": len(self.alarms),
            "active_alarms": active_alarms,
            "alarm_severity": dict(severity_counts),
            "online_rate": round((total_devices - status_counts["ç¦»çº¿"]) / total_devices * 100, 2) if total_devices else 0
        }


def create_demo_network():
    """åˆ›å»ºæ¼”ç¤ºç½‘ç»œ"""
    manager = NetworkManager()
    
    # åˆ›å»ºè®¾å¤‡
    devices = [
        NetworkDevice("BS-001", "é¼“æ¥¼åŸºç«™-01", DeviceType.BASE_STATION, "10.0.1.1", "å—äº¬é¼“æ¥¼"),
        NetworkDevice("BS-002", "é¼“æ¥¼åŸºç«™-02", DeviceType.BASE_STATION, "10.0.1.2", "å—äº¬é¼“æ¥¼"),
        NetworkDevice("R-001", "æ ¸å¿ƒè·¯ç”±å™¨-01", DeviceType.ROUTER, "10.0.2.1", "å—äº¬ä¸­å¿ƒæœºæˆ¿"),
        NetworkDevice("S-001", "æ±‡èšäº¤æ¢æœº-01", DeviceType.SWITCH, "10.0.3.1", "å—äº¬ä¸­å¿ƒæœºæˆ¿"),
        NetworkDevice("FW-001", "é˜²ç«å¢™-01", DeviceType.FIREWALL, "10.0.4.1", "å—äº¬ä¸­å¿ƒæœºæˆ¿"),
    ]
    
    for device in devices:
        manager.add_device(device)
    
    # è®¾ç½®è®¾å¤‡è¿æ¥å…³ç³»
    manager.devices["BS-001"].connected_devices = ["R-001"]
    manager.devices["BS-002"].connected_devices = ["R-001"]
    manager.devices["R-001"].connected_devices = ["S-001"]
    manager.devices["S-001"].connected_devices = ["FW-001"]
    
    return manager


def main():
    """ä¸»å‡½æ•°"""
    print("=" * 80)
    print("ç½‘ç»œç®¡ç†Schemaå®è·µæ¡ˆä¾‹ - ä¸­äº‘é€šä¿¡")
    print("=" * 80)
    
    # åˆ›å»ºç½‘ç»œ
    print("\nã€æ­¥éª¤1ã€‘åˆå§‹åŒ–ç½‘ç»œç®¡ç†ç³»ç»Ÿ...")
    manager = create_demo_network()
    print(f"  è®¾å¤‡æ•°é‡: {len(manager.devices)}")
    
    # é‡‡é›†æŒ‡æ ‡
    print("\nã€æ­¥éª¤2ã€‘é‡‡é›†è®¾å¤‡æ€§èƒ½æŒ‡æ ‡...")
    for device_id in manager.devices:
        manager.collect_metrics(device_id)
    
    for device_id, device in manager.devices.items():
        print(f"  {device.name}: CPU={device.cpu_usage:.1f}%, çŠ¶æ€={device.status.value}")
    
    # å‘Šè­¦å‹ç¼©
    print("\nã€æ­¥éª¤3ã€‘å‘Šè­¦å…³è”å‹ç¼©...")
    compressed = manager.correlate_and_compress()
    active_alarms = [a for a in manager.alarms.values() if a.status == AlarmStatus.ACTIVE]
    print(f"  æ´»åŠ¨å‘Šè­¦: {len(active_alarms)}")
    print(f"  å‹ç¼©æ•°é‡: {compressed}")
    
    if active_alarms:
        print(f"  æ ¹å› å‘Šè­¦: {active_alarms[0].alarm_type} - {active_alarms[0].root_cause}")
    
    # è‡ªåŠ¨ä¿®å¤
    print("\nã€æ­¥éª¤4ã€‘è‡ªåŠ¨ä¿®å¤æ¼”ç¤º...")
    for alarm in list(manager.alarms.values())[:3]:
        if manager.auto_heal(alarm.alarm_id):
            print(f"  è‡ªåŠ¨ä¿®å¤: {alarm.alarm_id}")
    
    # å®¹é‡é¢„æµ‹
    print("\nã€æ­¥éª¤5ã€‘å®¹é‡é¢„æµ‹...")
    prediction = manager.predict_capacity("BS-001", days_ahead=30)
    print(f"  å½“å‰CPUå¹³å‡: {prediction['current_cpu_avg']}%")
    print(f"  30å¤©é¢„æµ‹: {prediction['predicted_cpu']}%")
    print(f"  å»ºè®®: {prediction['recommendation']}")
    
    # åº”ç”¨é…ç½®
    print("\nã€æ­¥éª¤6ã€‘åº”ç”¨é…ç½®...")
    config = manager.apply_config(
        device_id="R-001",
        config_content={
            "bgp": {"as_number": 65001, "neighbors": ["10.0.5.1"]},
            "ospf": {"area": 0, "networks": ["10.0.0.0/16"]}
        },
        config_type="è·¯ç”±é…ç½®",
        created_by="ç®¡ç†å‘˜å¼ ä¸‰"
    )
    print(f"  é…ç½®ID: {config.config_id}")
    print(f"  é…ç½®ç±»å‹: {config.config_type}")
    
    # ç½‘ç»œæ‘˜è¦
    print("\nã€æ­¥éª¤7ã€‘ç½‘ç»œæ•´ä½“çŠ¶æ€...")
    summary = manager.get_network_summary()
    print(f"  è®¾å¤‡æ€»æ•°: {summary['total_devices']}")
    print(f"  åœ¨çº¿ç‡: {summary['online_rate']}%")
    print(f"  æ´»åŠ¨å‘Šè­¦: {summary['active_alarms']}")
    
    print("\n" + "=" * 80)
    print("ç½‘ç»œç®¡ç†Schemaå®è·µæ¡ˆä¾‹æ‰§è¡Œå®Œæˆ")
    print("=" * 80)


if __name__ == "__main__":
    main()
```

---

## 7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ

### 7.1 å…³é”®ç»©æ•ˆæŒ‡æ ‡

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æ”¹å–„ |
|------|--------|--------|------|
| å‘Šè­¦é‡ | 10ä¸‡/å¤© | 5åƒ/å¤© | -95% |
| æ ¹å› å®šä½æ—¶é—´ | 30åˆ†é’Ÿ | 3åˆ†é’Ÿ | -90% |
| é…ç½®é”™è¯¯ç‡ | 5% | 0.2% | -96% |
| è‡ªåŠ¨ä¿®å¤ç‡ | 10% | 70% | +600% |
| é¢„æµ‹å‡†ç¡®ç‡ | N/A | 87% | - |

### 7.2 ROIåˆ†æ

**æŠ•èµ„**ï¼šÂ¥1500ä¸‡  
**å¹´æ”¶ç›Š**ï¼šÂ¥4500ä¸‡  
**ROI**ï¼š200%ï¼ˆ3å¹´ï¼‰

---

**åˆ›å»ºæ—¶é—´**ï¼š2026-02-15  
**ç‰ˆæœ¬**ï¼š1.0.0

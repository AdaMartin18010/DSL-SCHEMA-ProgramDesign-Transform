# é£Ÿå“è¡Œä¸šSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [é£Ÿå“è¡Œä¸šSchemaå®è·µæ¡ˆä¾‹](#é£Ÿå“è¡Œä¸šschemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šé£Ÿå“ç”Ÿäº§ç®¡ç†å’Œæ‰¹æ¬¡è¿½è¸ª](#2-æ¡ˆä¾‹1é£Ÿå“ç”Ÿäº§ç®¡ç†å’Œæ‰¹æ¬¡è¿½è¸ª)
    - [2.1 åœºæ™¯æè¿°](#21-åœºæ™¯æè¿°)
    - [2.2 Schemaå®šä¹‰](#22-schemaå®šä¹‰)
    - [2.3 å®ç°ä»£ç ](#23-å®ç°ä»£ç )
  - [3. æ¡ˆä¾‹2ï¼šé£Ÿå“å®‰å…¨å…¨ç¨‹è¿½æº¯](#3-æ¡ˆä¾‹2é£Ÿå“å®‰å…¨å…¨ç¨‹è¿½æº¯)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 Schemaå®šä¹‰](#32-schemaå®šä¹‰)
    - [3.3 å®ç°ä»£ç ](#33-å®ç°ä»£ç )
  - [4. æ¡ˆä¾‹3ï¼šé£Ÿå“è´¨é‡ç›‘æ§](#4-æ¡ˆä¾‹3é£Ÿå“è´¨é‡ç›‘æ§)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 Schemaå®šä¹‰](#42-schemaå®šä¹‰)
  - [5. æ¡ˆä¾‹4ï¼šGS1åˆ°EPCISæ¶ˆæ¯è½¬æ¢](#5-æ¡ˆä¾‹4gs1åˆ°epcisæ¶ˆæ¯è½¬æ¢)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 å®ç°ä»£ç ](#52-å®ç°ä»£ç )
  - [6. æ¡ˆä¾‹5ï¼šé£Ÿå“è¡Œä¸šæ•°æ®åˆ†æå’ŒæŠ¥è¡¨](#6-æ¡ˆä¾‹5é£Ÿå“è¡Œä¸šæ•°æ®åˆ†æå’ŒæŠ¥è¡¨)
    - [6.1 åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2 å®ç°ä»£ç ](#62-å®ç°ä»£ç )
    - [6.3 æ•°æ®åˆ†æç¤ºä¾‹](#63-æ•°æ®åˆ†æç¤ºä¾‹)
  - [7. æ¡ˆä¾‹6ï¼šå®Œæ•´è¿½æº¯é“¾ï¼ˆä»åŸæ–™åˆ°é”€å”®ï¼‰](#7-æ¡ˆä¾‹6å®Œæ•´è¿½æº¯é“¾ä»åŸæ–™åˆ°é”€å”®)
    - [7.1 åœºæ™¯æè¿°](#71-åœºæ™¯æè¿°)
    - [7.2 Schemaå®šä¹‰](#72-schemaå®šä¹‰)
    - [7.3 å®ç°ä»£ç ](#73-å®ç°ä»£ç )
  - [8. æ¡ˆä¾‹7ï¼šé—®é¢˜é£Ÿå“å¬å›ï¼ˆåå‘è¿½æº¯ï¼‰](#8-æ¡ˆä¾‹7é—®é¢˜é£Ÿå“å¬å›åå‘è¿½æº¯)
    - [8.1 åœºæ™¯æè¿°](#81-åœºæ™¯æè¿°)
    - [8.2 Schemaå®šä¹‰](#82-schemaå®šä¹‰)
    - [8.3 å®ç°ä»£ç ](#83-å®ç°ä»£ç )
  - [9. æ¡ˆä¾‹8ï¼šè´¨é‡æ£€æµ‹æµç¨‹](#9-æ¡ˆä¾‹8è´¨é‡æ£€æµ‹æµç¨‹)
    - [9.1 åœºæ™¯æè¿°](#91-åœºæ™¯æè¿°)
    - [9.2 å®ç°ä»£ç ](#92-å®ç°ä»£ç )
  - [10. æ¡ˆä¾‹9ï¼šæ‰¹æ¬¡è´¨é‡åˆ†æ](#10-æ¡ˆä¾‹9æ‰¹æ¬¡è´¨é‡åˆ†æ)
    - [10.1 åœºæ™¯æè¿°](#101-åœºæ™¯æè¿°)
    - [10.2 å®ç°ä»£ç ](#102-å®ç°ä»£ç )
  - [11. æ¡ˆä¾‹10ï¼šä¾›åº”å•†è´¨é‡è¯„ä¼°](#11-æ¡ˆä¾‹10ä¾›åº”å•†è´¨é‡è¯„ä¼°)
    - [11.1 åœºæ™¯æè¿°](#111-åœºæ™¯æè¿°)
    - [11.2 å®ç°ä»£ç ](#112-å®ç°ä»£ç )

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›é£Ÿå“è¡Œä¸šSchemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šé£Ÿå“ç”Ÿäº§ç®¡ç†å’Œæ‰¹æ¬¡è¿½è¸ª

### 2.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“åŠ å·¥å‚éœ€è¦ç®¡ç†é£Ÿå“ç”Ÿäº§æ‰¹æ¬¡ï¼Œè®°å½•ç”Ÿäº§æµç¨‹å’Œè´¨é‡æ£€æŸ¥ç‚¹ï¼Œ
ç¡®ä¿ç”Ÿäº§è¿‡ç¨‹ç¬¦åˆISO 22000æ ‡å‡†ï¼Œå¹¶æ”¯æŒæ‰¹æ¬¡è¿½æº¯ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦åˆ›å»ºå’Œç®¡ç†ç”Ÿäº§æ‰¹æ¬¡
- éœ€è¦è®°å½•ç”Ÿäº§æµç¨‹æ­¥éª¤
- éœ€è¦è®°å½•è´¨é‡æ£€æŸ¥ç‚¹
- éœ€è¦è¿½è¸ªåŸæ–™æ¥æº

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ProductionBatchManageråˆ›å»ºç”Ÿäº§æ‰¹æ¬¡ï¼Œä½¿ç”¨FoodTraceabilitySystem
è®°å½•ç”Ÿäº§äº‹ä»¶ï¼Œå®ç°å®Œæ•´çš„ç”Ÿäº§æ‰¹æ¬¡ç®¡ç†ã€‚

### 2.2 Schemaå®šä¹‰

è¯¦è§ç¬¬2.2èŠ‚åŸå§‹å®šä¹‰ã€‚

### 2.3 å®ç°ä»£ç 

**å®Œæ•´çš„é£Ÿå“ç”Ÿäº§ç®¡ç†å®ç°**ï¼š

```python
from food_industry_storage import FoodIndustryStorage
from production_batch_manager import ProductionBatchManager
from food_traceability_system import FoodTraceabilitySystem
from datetime import datetime, date

# åˆå§‹åŒ–å­˜å‚¨å’Œç®¡ç†å™¨
storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
batch_manager = ProductionBatchManager(storage)
traceability_system = FoodTraceabilitySystem(storage)

# åˆ›å»ºé£Ÿå“
food_data = {
    "food_id": "FOOD20250121001",
    "gtin": "12345678901234",
    "food_name": "æœ‰æœºé¢åŒ…",
    "food_category": "Grain",
    "food_type": "Bread",
    "brand_name": "å¥åº·å“ç‰Œ",
    "manufacturer": "é£Ÿå“åŠ å·¥å‚",
    "country_of_origin": "CN",
    "food_description": "æœ‰æœºå…¨éº¦é¢åŒ…",
    "production_date": date(2025, 1, 21),
    "expiry_date": date(2025, 1, 28),
    "shelf_life_days": 7,
    "storage_conditions": "å¸¸æ¸©å¹²ç‡¥ä¿å­˜"
}

food_id = storage.store_food(food_data)
print(f"Created food: {food_id}")

# åˆ›å»ºç”Ÿäº§æ‰¹æ¬¡
batch_data = {
    "batch_number": "BATCH20250121001",
    "batch_size": 1000,
    "production_date": date(2025, 1, 21),
    "production_time": datetime.now().time(),
    "production_location": "ç”Ÿäº§è½¦é—´A",
    "production_facility": "é£Ÿå“åŠ å·¥å‚",
    "production_line": "ç”Ÿäº§çº¿1"
}

batch_number = batch_manager.create_production_batch("FOOD20250121001", batch_data)
print(f"Created production batch: {batch_number}")

# è®°å½•ç”Ÿäº§äº‹ä»¶
events = [
    {
        "event_type": "Production",
        "event_location": "ç”Ÿäº§è½¦é—´A",
        "event_operator": "å¼ ä¸‰",
        "event_description": "é£Ÿå“ç”Ÿäº§å®Œæˆ"
    },
    {
        "event_type": "QualityCheck",
        "event_location": "è´¨æ£€å®éªŒå®¤",
        "event_operator": "ç‹äº”",
        "event_description": "è´¨é‡æ£€æŸ¥é€šè¿‡"
    },
    {
        "event_type": "Packaging",
        "event_location": "åŒ…è£…è½¦é—´",
        "event_operator": "æå››",
        "event_description": "é£Ÿå“åŒ…è£…å®Œæˆ"
    }
]

for event in events:
    event_id = traceability_system.add_traceability_event(
        "FOOD20250121001",
        batch_number,
        event["event_type"],
        event["event_location"],
        event["event_operator"],
        event["event_description"]
    )
    print(f"Recorded event: {event_id} - {event['event_type']}")

# è·å–æ‰¹æ¬¡ä¿¡æ¯
batch_info = batch_manager.get_batch_info(batch_number)
if batch_info:
    print(f"\nBatch information:")
    print(f"  Batch number: {batch_info['batch_number']}")
    print(f"  Batch size: {batch_info['batch_size']}")
    print(f"  Production date: {batch_info['production_date']}")
    print(f"  Production location: {batch_info['production_location']}")

# æŸ¥è¯¢æ‰¹æ¬¡è´¨é‡æ‘˜è¦
quality_summary = storage.get_batch_quality_summary(batch_number)
print(f"\nQuality summary:")
print(f"  Event count: {quality_summary.get('event_count', 0)}")
print(f"  Quality checks: {quality_summary.get('quality_check_count', 0)}")
```

---

## 3. æ¡ˆä¾‹2ï¼šé£Ÿå“å®‰å…¨å…¨ç¨‹è¿½æº¯

### 3.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“ä¾›åº”é“¾éœ€è¦å®ç°å…¨ç¨‹è¿½æº¯ï¼Œä»åŸæ–™ä¾›åº”å•†åˆ°ç”Ÿäº§å•†ã€åˆ†é”€å•†ã€
é›¶å”®å•†ï¼Œç¡®ä¿é£Ÿå“å®‰å…¨å’Œè´¨é‡å¯è¿½æº¯ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å»ºç«‹å®Œæ•´çš„è¿½æº¯é“¾
- éœ€è¦è®°å½•æ‰€æœ‰è¿½æº¯äº‹ä»¶
- éœ€è¦æ”¯æŒæ­£å‘è¿½æº¯ï¼ˆæ¥æºï¼‰å’Œåå‘è¿½æº¯ï¼ˆå»å‘ï¼‰
- éœ€è¦ç¬¦åˆISO 22005æ ‡å‡†

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨FoodTraceabilitySystemåˆ›å»ºè¿½æº¯é“¾ï¼Œè®°å½•æ‰€æœ‰è¿½æº¯äº‹ä»¶ï¼Œ
å®ç°æ­£å‘å’Œåå‘è¿½æº¯åŠŸèƒ½ã€‚

### 3.2 Schemaå®šä¹‰

è¯¦è§ç¬¬3.2èŠ‚åŸå§‹å®šä¹‰ã€‚

### 3.3 å®ç°ä»£ç 

**å®Œæ•´çš„é£Ÿå“å®‰å…¨è¿½æº¯å®ç°**ï¼š

```python
from food_industry_storage import FoodIndustryStorage
from food_traceability_system import FoodTraceabilitySystem
from datetime import datetime

# åˆå§‹åŒ–å­˜å‚¨å’Œè¿½æº¯ç³»ç»Ÿ
storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
traceability_system = FoodTraceabilitySystem(storage)

# åˆ›å»ºè¿½æº¯é“¾
traceability_data = {
    "supplier_name": "é¢ç²‰ä¾›åº”å•†",
    "supplier_gln": "1234567890123",
    "manufacturer_name": "é£Ÿå“åŠ å·¥å‚",
    "manufacturer_gln": "9876543210987",
    "distributor_name": "é£Ÿå“åˆ†é”€å•†",
    "distributor_gln": "1111111111111",
    "retailer_name": "è¶…å¸‚A",
    "retailer_gln": "2222222222222"
}

traceability_id = traceability_system.create_traceability_chain(
    "FOOD20250121001",
    "BATCH20250121001",
    traceability_data
)
print(f"Created traceability chain: {traceability_id}")

# è®°å½•è¿½æº¯äº‹ä»¶
events = [
    {
        "event_type": "Production",
        "event_location": "ç”Ÿäº§è½¦é—´A",
        "event_operator": "å¼ ä¸‰",
        "event_description": "é£Ÿå“ç”Ÿäº§å®Œæˆ"
    },
    {
        "event_type": "Packaging",
        "event_location": "åŒ…è£…è½¦é—´",
        "event_operator": "æå››",
        "event_description": "é£Ÿå“åŒ…è£…å®Œæˆ"
    },
    {
        "event_type": "Transportation",
        "event_location": "è¿è¾“é€”ä¸­",
        "event_operator": "ç‹äº”",
        "event_description": "é£Ÿå“è¿è¾“å¼€å§‹"
    },
    {
        "event_type": "Distribution",
        "event_location": "åˆ†é”€ä¸­å¿ƒA",
        "event_operator": "èµµå…­",
        "event_description": "é£Ÿå“åˆ°è¾¾åˆ†é”€ä¸­å¿ƒ"
    },
    {
        "event_type": "Retail",
        "event_location": "é—¨åº—A",
        "event_operator": "é’±ä¸ƒ",
        "event_description": "é£Ÿå“åˆ°è¾¾é›¶å”®é—¨åº—"
    }
]

for event in events:
    event_id = traceability_system.add_traceability_event(
        "FOOD20250121001",
        "BATCH20250121001",
        event["event_type"],
        event["event_location"],
        event["event_operator"],
        event["event_description"]
    )
    print(f"Recorded event: {event_id} - {event['event_type']}")

# è·å–è¿½æº¯é“¾
chain = traceability_system.get_traceability_chain("FOOD20250121001", "BATCH20250121001")
if chain:
    print(f"\nTraceability chain:")
    print(f"  Supplier: {chain.get('supplier_name')}")
    print(f"  Manufacturer: {chain.get('manufacturer_name')}")
    print(f"  Distributor: {chain.get('distributor_name')}")
    print(f"  Retailer: {chain.get('retailer_name')}")

# è·å–è¿½æº¯å†å²
history = traceability_system.get_traceability_history("FOOD20250121001", "BATCH20250121001")
print(f"\nTraceability history ({len(history)} events):")
for event in history:
    print(f"  {event['event_time']}: {event['event_type']} - {event['event_location']}")

# è¿½æº¯é£Ÿå“æ¥æº
origin_info = traceability_system.trace_food_origin("FOOD20250121001", "BATCH20250121001")
print(f"\nFood origin:")
print(f"  Supplier: {origin_info['origin_info']['supplier']}")
print(f"  Manufacturer: {origin_info['origin_info']['manufacturer']}")
if origin_info['origin_info']['first_event']:
    print(f"  First event: {origin_info['origin_info']['first_event']['event_type']}")

# è¿½æº¯é£Ÿå“å»å‘
destination_info = traceability_system.trace_food_destination("FOOD20250121001", "BATCH20250121001")
print(f"\nFood destination:")
print(f"  Distributor: {destination_info['destination_info']['distributor']}")
print(f"  Retailer: {destination_info['destination_info']['retailer']}")
if destination_info['destination_info']['last_event']:
    print(f"  Last event: {destination_info['destination_info']['last_event']['event_type']}")

# æŸ¥è¯¢è¿½æº¯äº‹ä»¶ç»Ÿè®¡
event_stats = storage.get_traceability_event_statistics("FOOD20250121001", "BATCH20250121001")
print(f"\nEvent statistics:")
print(f"  Total events: {event_stats['event_count']}")
print(f"  Event types: {event_stats['event_type_count']}")
print(f"  Locations: {event_stats['location_count']}")
```

---

## 4. æ¡ˆä¾‹3ï¼šé£Ÿå“è´¨é‡ç›‘æ§

### 4.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
ä½¿ç”¨HACCPæ ‡å‡†ç›‘æ§é£Ÿå“è´¨é‡ï¼ŒåŒ…æ‹¬è´¨é‡æ£€æµ‹å’Œè´¨é‡è¯ä¹¦ç®¡ç†ã€‚

### 4.2 Schemaå®šä¹‰

**é£Ÿå“è´¨é‡ç›‘æ§Schema**ï¼š

```json
{
  "food_id": "FOOD20250121001",
  "batch_number": "BATCH20250121001",
  "quality_records": [
    {
      "record_id": "RECORD001",
      "record_type": "Test",
      "record_time": "2025-01-21T11:00:00Z",
      "record_location": "è´¨æ£€å®éªŒå®¤",
      "record_operator": "è´¨æ£€å‘˜A",
      "record_result": "Pass",
      "record_document": "è´¨æ£€æŠ¥å‘Š001.pdf"
    },
    {
      "record_id": "RECORD002",
      "record_type": "Certificate",
      "record_time": "2025-01-21T12:00:00Z",
      "record_location": "è¯ä¹¦åŠå…¬å®¤",
      "record_operator": "è¯ä¹¦ç®¡ç†å‘˜",
      "record_result": "Pass",
      "record_document": "è´¨é‡è¯ä¹¦001.pdf"
    }
  ]
}
```

---

## 5. æ¡ˆä¾‹4ï¼šGS1åˆ°EPCISæ¶ˆæ¯è½¬æ¢

### 5.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“ä¼ä¸šéœ€è¦å°†GS1æ ‡å‡†çš„é£Ÿå“ä¿¡æ¯è½¬æ¢ä¸ºEPCISäº‹ä»¶æ ¼å¼ï¼Œ
ä»¥ä¾¿ä¸EPCISç³»ç»Ÿé›†æˆï¼Œå®ç°è·¨ç³»ç»Ÿçš„é£Ÿå“è¿½æº¯ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦è§£æGS1æ¡ç å’Œåº”ç”¨æ ‡è¯†ç¬¦
- éœ€è¦è½¬æ¢ä¸ºEPCISäº‹ä»¶æ ¼å¼
- éœ€è¦æ”¯æŒå¤šç§EPCISäº‹ä»¶ç±»å‹
- éœ€è¦ç”ŸæˆEPCIS XMLæ ¼å¼

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨GS1Parserè§£æGS1æ¡ç ï¼Œä½¿ç”¨GS1ToEPCISConverterè½¬æ¢ä¸ºEPCISäº‹ä»¶ã€‚

### 5.2 å®ç°ä»£ç 

**å®Œæ•´çš„GS1åˆ°EPCISè½¬æ¢å®ç°**ï¼š

```python
from gs1_parser import GS1Parser, GS1ToEPCISConverter

# åˆå§‹åŒ–è§£æå™¨å’Œè½¬æ¢å™¨
parser = GS1Parser()
converter = GS1ToEPCISConverter()

# è§£æGS1æ¡ç 
gs1_barcode = "011234567890123410BATCH001111250121"
gs1_data = parser.parse_gs1_barcode(gs1_barcode)
print(f"Parsed GS1 barcode:")
print(f"  GTIN: {gs1_data.get('gtin')}")
print(f"  Batch number: {gs1_data.get('batch_number')}")
print(f"  Production date: {gs1_data.get('production_date')}")

# GS1é£Ÿå“ä¿¡æ¯
food_info = {
    "food_id": "FOOD20250121001",
    "gtin": "12345678901234",
    "food_name": "æœ‰æœºé¢åŒ…",
    "food_category": "Grain",
    "batch_number": "BATCH20250121001",
    "production_date": "2025-01-21",
    "expiry_date": "2025-01-28",
    "production_location": "ç”Ÿäº§è½¦é—´A",
    "manufacturer_gln": "9876543210987"
}

# è½¬æ¢ä¸ºEPCIS ObjectEvent
object_event = converter.convert_food_info_to_object_event(food_info)
print(f"\nEPCIS ObjectEvent:")
print(f"  Event type: {object_event['eventType']}")
print(f"  EPC: {object_event['epcList'][0]}")
print(f"  Biz step: {object_event['bizStep']}")

# è½¬æ¢ä¸ºEPCIS XML
epcis_xml = converter.convert_to_epcis_xml(object_event)
print(f"\nEPCIS XML (first 500 chars):")
print(epcis_xml[:500])

# GS1ç”Ÿäº§ä¿¡æ¯
production_info = {
    "production_id": "PROD20250121001",
    "gtin": "12345678901234",
    "batch_number": "BATCH20250121001",
    "batch_size": 1000,
    "production_date": "2025-01-21",
    "production_location": "ç”Ÿäº§è½¦é—´A",
    "production_facility": "é£Ÿå“åŠ å·¥å‚",
    "production_line": "ç”Ÿäº§çº¿1",
    "manufacturer_gln": "9876543210987"
}

# è½¬æ¢ä¸ºEPCIS AggregationEvent
aggregation_event = converter.convert_production_info_to_aggregation_event(production_info)
print(f"\nEPCIS AggregationEvent:")
print(f"  Event type: {aggregation_event['eventType']}")
print(f"  Parent ID: {aggregation_event['parentID']}")
print(f"  Child EPC: {aggregation_event['childEPCs'][0]}")

# GS1è¿½æº¯ä¿¡æ¯
traceability_info = {
    "gtin": "12345678901234",
    "event_time": "2025-01-22T08:00:00Z",
    "event_type": "Transportation",
    "event_location": "è¿è¾“é€”ä¸­",
    "location_gln": "1111111111111",
    "biz_step": "shipping",
    "transaction_type": "PO",
    "transaction_id": "PO20250122001",
    "from_location": "ç”Ÿäº§è½¦é—´A",
    "to_location": "åˆ†é”€ä¸­å¿ƒA",
    "transport_method": "Truck"
}

# è½¬æ¢ä¸ºEPCIS TransactionEvent
transaction_event = converter.convert_traceability_info_to_transaction_event(traceability_info)
print(f"\nEPCIS TransactionEvent:")
print(f"  Event type: {transaction_event['eventType']}")
print(f"  Biz step: {transaction_event['bizStep']}")
print(f"  Transaction ID: {transaction_event['bizTransactionList'][0]['bizTransaction']}")
```

---

## 6. æ¡ˆä¾‹5ï¼šé£Ÿå“è¡Œä¸šæ•°æ®åˆ†æå’ŒæŠ¥è¡¨

### 6.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
ä½¿ç”¨PostgreSQLå­˜å‚¨é£Ÿå“è¡Œä¸šæ•°æ®ï¼Œæ”¯æŒé£Ÿå“è¿½æº¯ã€è´¨é‡æŸ¥è¯¢ã€
ç”Ÿäº§ç»Ÿè®¡å’Œè¿‡æœŸé£Ÿå“åˆ†æã€‚

### 6.2 å®ç°ä»£ç 

è¯¦è§ `04_Transformation.md` ç¬¬7ç« ã€‚

### 6.3 æ•°æ®åˆ†æç¤ºä¾‹

**é£Ÿå“è¡Œä¸šæ•°æ®åˆ†ææŸ¥è¯¢**ï¼š

```python
from food_industry_storage import FoodIndustryStorage
from datetime import datetime, timedelta

storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")

# æŸ¥è¯¢ç”Ÿäº§æ‰¹æ¬¡ç»Ÿè®¡
production_stats = storage.get_production_statistics(
    datetime.now() - timedelta(days=30)
)
print("Production Statistics (30 days):")
for stat in production_stats:
    print(f"  {stat['food_category']}:")
    print(f"    Batches: {stat['batch_count']}")
    print(f"    Total quantity: {stat['total_quantity']:.2f}")
    print(f"    Avg batch size: {stat['avg_batch_size']:.2f}")

# æŸ¥è¯¢è¿½æº¯äº‹ä»¶ç»Ÿè®¡
event_stats = storage.get_traceability_event_statistics(
    "FOOD20250121001",
    "BATCH20250121001"
)
print(f"\nTraceability Event Statistics:")
print(f"  Total events: {event_stats['event_count']}")
print(f"  Event types: {event_stats['event_type_count']}")
print(f"  Locations: {event_stats['location_count']}")

# æŸ¥è¯¢å³å°†è¿‡æœŸçš„é£Ÿå“
expiring_foods = storage.get_food_expiry_analysis(days_ahead=30)
print(f"\nExpiring Foods (next 30 days):")
for food in expiring_foods[:10]:  # æ˜¾ç¤ºå‰10ä¸ª
    print(f"  {food['food_name']} ({food['food_category']}):")
    print(f"    Expiry date: {food['expiry_date']}")
    print(f"    Days until expiry: {food['days_until_expiry']}")

# æŸ¥è¯¢æ‰¹æ¬¡è´¨é‡æ‘˜è¦
quality_summary = storage.get_batch_quality_summary("BATCH20250121001")
print(f"\nBatch Quality Summary:")
print(f"  Batch number: {quality_summary.get('batch_number')}")
print(f"  Batch size: {quality_summary.get('batch_size')}")
print(f"  Event count: {quality_summary.get('event_count', 0)}")
print(f"  Quality checks: {quality_summary.get('quality_check_count', 0)}")
```

---

## 7. æ¡ˆä¾‹6ï¼šå®Œæ•´è¿½æº¯é“¾ï¼ˆä»åŸæ–™åˆ°é”€å”®ï¼‰

### 7.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“å…¬å¸éœ€è¦å®ç°ä»åŸæ–™é‡‡è´­åˆ°æœ€ç»ˆé”€å”®çš„å®Œæ•´è¿½æº¯é“¾ï¼Œè®°å½•æ¯ä¸ªç¯èŠ‚çš„è¯¦ç»†ä¿¡æ¯ï¼Œç¡®ä¿é£Ÿå“å®‰å…¨å’Œåˆè§„æ€§ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦è®°å½•åŸæ–™ä¾›åº”å•†ä¿¡æ¯
- éœ€è¦è®°å½•ç”Ÿäº§è¿‡ç¨‹å„ç¯èŠ‚
- éœ€è¦è®°å½•è¿è¾“å’Œåˆ†é”€è¿‡ç¨‹
- éœ€è¦è®°å½•æœ€ç»ˆé”€å”®ä¿¡æ¯
- éœ€è¦æ”¯æŒæ­£å‘è¿½æº¯æŸ¥è¯¢

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨FoodTraceabilitySystemåˆ›å»ºå®Œæ•´çš„è¿½æº¯é“¾ï¼Œä½¿ç”¨trace_forwardæ–¹æ³•å®ç°æ­£å‘è¿½æº¯ã€‚

### 7.2 Schemaå®šä¹‰

**å®Œæ•´è¿½æº¯é“¾Schema**ï¼š

```json
{
  "food_id": "FOOD20250121001",
  "batch_number": "BATCH20250121001",
  "trace_path": [
    {
      "step": 1,
      "event_type": "RawMaterialReceived",
      "event_time": "2025-01-15T08:00:00Z",
      "location": "åŸæ–™ä»“åº“A",
      "description": "æ¥æ”¶åŸæ–™"
    },
    {
      "step": 2,
      "event_type": "ProductionStarted",
      "event_time": "2025-01-16T09:00:00Z",
      "location": "ç”Ÿäº§è½¦é—´A",
      "description": "å¼€å§‹ç”Ÿäº§"
    },
    {
      "step": 3,
      "event_type": "QualityCheck",
      "event_time": "2025-01-16T14:00:00Z",
      "location": "è´¨æ£€å®¤A",
      "description": "è´¨é‡æ£€æµ‹"
    },
    {
      "step": 4,
      "event_type": "Packaging",
      "event_time": "2025-01-17T10:00:00Z",
      "location": "åŒ…è£…è½¦é—´A",
      "description": "åŒ…è£…å®Œæˆ"
    },
    {
      "step": 5,
      "event_type": "Shipping",
      "event_time": "2025-01-18T08:00:00Z",
      "location": "ç‰©æµä¸­å¿ƒA",
      "description": "å‘è´§"
    },
    {
      "step": 6,
      "event_type": "RetailSale",
      "event_time": "2025-01-20T10:00:00Z",
      "location": "é›¶å”®åº—A",
      "description": "é”€å”®"
    }
  ]
}
```

### 7.3 å®ç°ä»£ç 

**å®Œæ•´çš„è¿½æº¯é“¾å®ç°**ï¼š

```python
from food_traceability_system import FoodTraceabilitySystem
from food_industry_storage import FoodIndustryStorage
from datetime import datetime

def complete_traceability_chain():
    """å®Œæ•´è¿½æº¯é“¾ç¤ºä¾‹"""
    storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
    traceability_system = FoodTraceabilitySystem(storage)

    food_id = "FOOD20250121001"
    batch_number = "BATCH20250121001"

    # åˆ›å»ºè¿½æº¯é“¾
    traceability_data = {
        "supplier_name": "åŸæ–™ä¾›åº”å•†A",
        "supplier_gln": "1111111111111",
        "manufacturer_name": "é£Ÿå“åŠ å·¥å‚A",
        "manufacturer_gln": "2222222222222",
        "distributor_name": "åˆ†é”€å•†A",
        "distributor_gln": "3333333333333",
        "retailer_name": "é›¶å”®åº—A",
        "retailer_gln": "4444444444444"
    }

    traceability_id = traceability_system.create_traceability_chain(
        food_id, batch_number, traceability_data
    )
    print(f"Created traceability chain: {traceability_id}")

    # æ·»åŠ è¿½æº¯äº‹ä»¶
    events = [
        {"type": "RawMaterialReceived", "location": "åŸæ–™ä»“åº“A", "description": "æ¥æ”¶åŸæ–™"},
        {"type": "ProductionStarted", "location": "ç”Ÿäº§è½¦é—´A", "description": "å¼€å§‹ç”Ÿäº§"},
        {"type": "QualityCheck", "location": "è´¨æ£€å®¤A", "description": "è´¨é‡æ£€æµ‹"},
        {"type": "Packaging", "location": "åŒ…è£…è½¦é—´A", "description": "åŒ…è£…å®Œæˆ"},
        {"type": "Shipping", "location": "ç‰©æµä¸­å¿ƒA", "description": "å‘è´§"},
        {"type": "RetailSale", "location": "é›¶å”®åº—A", "description": "é”€å”®"}
    ]

    for i, event in enumerate(events):
        event_time = datetime(2025, 1, 15 + i, 8 + i, 0, 0)
        traceability_system.add_traceability_event(
            food_id,
            batch_number,
            event["type"],
            event["location"],
            event_operator=f"Operator{i+1}",
            event_description=event["description"]
        )
        print(f"Added event: {event['type']} at {event['location']}")

    # æ­£å‘è¿½æº¯
    forward_trace = traceability_system.trace_forward(food_id, batch_number)
    print(f"\nForward Traceability:")
    print(f"  Origin: {forward_trace['origin']['manufacturer']}")
    print(f"  Destination: {forward_trace['destination']['retailer']}")
    print(f"  Total steps: {forward_trace['total_steps']}")
    print(f"\nTrace Path:")
    for step in forward_trace['trace_path']:
        print(f"  Step {step['step']}: {step['event_type']} at {step['location']} ({step['event_time']})")

    # è¿½æº¯è·¯å¾„å¯è§†åŒ–
    visualization = traceability_system.visualize_trace_path(food_id, batch_number, "forward")
    print(f"\nVisualization:")
    print(f"  Nodes: {len(visualization['visualization']['nodes'])}")
    print(f"  Edges: {len(visualization['visualization']['edges'])}")

    storage.close()

if __name__ == "__main__":
    complete_traceability_chain()
```

---

## 8. æ¡ˆä¾‹7ï¼šé—®é¢˜é£Ÿå“å¬å›ï¼ˆåå‘è¿½æº¯ï¼‰

### 8.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
å½“å‘ç°é£Ÿå“å­˜åœ¨è´¨é‡é—®é¢˜æ—¶ï¼Œéœ€è¦å¿«é€Ÿåå‘è¿½æº¯ï¼Œæ‰¾å‡ºæ‰€æœ‰å—å½±å“çš„äº§å“æ‰¹æ¬¡ï¼Œç¡®å®šé—®é¢˜æºå¤´ï¼Œå¹¶å¬å›æ‰€æœ‰ç›¸å…³äº§å“ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å¿«é€Ÿåå‘è¿½æº¯
- éœ€è¦æ‰¾å‡ºæ‰€æœ‰å—å½±å“æ‰¹æ¬¡
- éœ€è¦ç¡®å®šé—®é¢˜æºå¤´
- éœ€è¦ç”Ÿæˆå¬å›æ¸…å•

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨trace_backwardæ–¹æ³•å®ç°åå‘è¿½æº¯ï¼Œå¿«é€Ÿå®šä½é—®é¢˜æºå¤´å’Œæ‰€æœ‰å—å½±å“çš„äº§å“ã€‚

### 8.2 Schemaå®šä¹‰

**é—®é¢˜é£Ÿå“å¬å›Schema**ï¼š

```json
{
  "recall_id": "RECALL20250121001",
  "food_id": "FOOD20250121001",
  "batch_number": "BATCH20250121001",
  "issue_description": "æ£€æµ‹åˆ°ç»†èŒè¶…æ ‡",
  "recall_reason": "QualityIssue",
  "trace_backward_result": {
    "origin": {
      "supplier": "åŸæ–™ä¾›åº”å•†A",
      "manufacturer": "é£Ÿå“åŠ å·¥å‚A",
      "first_event": {...}
    },
    "trace_path": [...],
    "affected_batches": ["BATCH20250121001", "BATCH20250121002"]
  }
}
```

### 8.3 å®ç°ä»£ç 

**é—®é¢˜é£Ÿå“å¬å›å®ç°**ï¼š

```python
from food_traceability_system import FoodTraceabilitySystem
from food_industry_storage import FoodIndustryStorage
from datetime import datetime

def food_recall_example():
    """é—®é¢˜é£Ÿå“å¬å›ç¤ºä¾‹"""
    storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
    traceability_system = FoodTraceabilitySystem(storage)

    food_id = "FOOD20250121001"
    batch_number = "BATCH20250121001"

    # åå‘è¿½æº¯
    backward_trace = traceability_system.trace_backward(food_id, batch_number)
    print(f"Backward Traceability:")
    print(f"  Starting point: {backward_trace['starting_point']['retailer']}")
    print(f"  Origin: {backward_trace['origin']['manufacturer']}")
    print(f"  Total steps: {backward_trace['total_steps']}")

    print(f"\nTrace Path (backward):")
    for step in backward_trace['trace_path']:
        print(f"  Step {step['step']}: {step['event_type']} at {step['location']} ({step['event_time']})")

    # æŸ¥æ‰¾æ‰€æœ‰å—å½±å“æ‰¹æ¬¡ï¼ˆç®€åŒ–ï¼šå‡è®¾åŒä¸€åŸæ–™ä¾›åº”å•†çš„æ‰€æœ‰æ‰¹æ¬¡éƒ½å—å½±å“ï¼‰
    origin = backward_trace['origin']
    supplier = origin.get('supplier')

    # è·å–æ‰€æœ‰ä½¿ç”¨ç›¸åŒä¾›åº”å•†çš„æ‰¹æ¬¡
    affected_batches = []
    if supplier:
        # è¿™é‡Œåº”è¯¥æŸ¥è¯¢æ•°æ®åº“ï¼Œæ‰¾åˆ°æ‰€æœ‰ä½¿ç”¨ç›¸åŒä¾›åº”å•†çš„æ‰¹æ¬¡
        # ç®€åŒ–ç¤ºä¾‹
        affected_batches = [
            {"food_id": food_id, "batch_number": batch_number},
            {"food_id": food_id, "batch_number": "BATCH20250121002"}
        ]

    print(f"\nAffected Batches:")
    for batch in affected_batches:
        print(f"  {batch['food_id']} - {batch['batch_number']}")

    # ç”Ÿæˆå¬å›æ¸…å•
    recall_list = {
        "recall_id": f"RECALL_{datetime.now().strftime('%Y%m%d%H%M%S')}",
        "issue_description": "æ£€æµ‹åˆ°ç»†èŒè¶…æ ‡",
        "recall_reason": "QualityIssue",
        "origin": origin,
        "affected_batches": affected_batches,
        "recall_time": datetime.now()
    }

    print(f"\nRecall List:")
    print(f"  Recall ID: {recall_list['recall_id']}")
    print(f"  Issue: {recall_list['issue_description']}")
    print(f"  Affected batches: {len(recall_list['affected_batches'])}")

    storage.close()

if __name__ == "__main__":
    food_recall_example()
```

---

## 9. æ¡ˆä¾‹8ï¼šè´¨é‡æ£€æµ‹æµç¨‹

### 9.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“å…¬å¸éœ€è¦å»ºç«‹å®Œæ•´çš„è´¨é‡æ£€æµ‹æµç¨‹ï¼ŒåŒ…æ‹¬å®šä¹‰è´¨é‡æ£€æµ‹è§„åˆ™ã€æ‰§è¡Œè´¨é‡æ£€æµ‹ã€è§¦å‘è´¨é‡é¢„è­¦ã€ç”Ÿæˆè´¨é‡æŠ¥å‘Šã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®šä¹‰å¤šç§è´¨é‡æ£€æµ‹è§„åˆ™
- éœ€è¦å®æ—¶è´¨é‡æ£€æµ‹
- éœ€è¦è‡ªåŠ¨è§¦å‘é¢„è­¦
- éœ€è¦ç”Ÿæˆè´¨é‡æŠ¥å‘Š

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨QualityMonitorç±»å®ç°è´¨é‡æ£€æµ‹æµç¨‹ï¼Œæ”¯æŒå¤šç§æ£€æµ‹è§„åˆ™å’Œè‡ªåŠ¨é¢„è­¦ã€‚

### 9.2 å®ç°ä»£ç 

**è´¨é‡æ£€æµ‹æµç¨‹å®ç°**ï¼š

```python
from quality_monitor import QualityMonitor
from food_industry_storage import FoodIndustryStorage
from datetime import datetime

def quality_check_process():
    """è´¨é‡æ£€æµ‹æµç¨‹ç¤ºä¾‹"""
    storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
    quality_monitor = QualityMonitor(storage)

    # æ·»åŠ è´¨é‡æ£€æµ‹è§„åˆ™
    rules = [
        {
            "rule_id": "RULE001",
            "rule_name": "æ¸©åº¦ä¸Šé™æ£€æµ‹",
            "rule_type": "threshold",
            "parameter_name": "temperature_max",
            "threshold_value": 8.0,
            "severity": "high",
            "alert_message": "æ¸©åº¦è¶…è¿‡8Â°Cï¼Œä¸ç¬¦åˆå†·è—è¦æ±‚"
        },
        {
            "rule_id": "RULE002",
            "rule_name": "æ¹¿åº¦èŒƒå›´æ£€æµ‹",
            "rule_type": "range",
            "parameter_name": "humidity",
            "min_value": 40.0,
            "max_value": 60.0,
            "severity": "medium",
            "alert_message": "æ¹¿åº¦ä¸åœ¨40%-60%èŒƒå›´å†…"
        },
        {
            "rule_id": "RULE003",
            "rule_name": "pHå€¼æ£€æµ‹",
            "rule_type": "range",
            "parameter_name": "ph_value",
            "min_value": 6.5,
            "max_value": 7.5,
            "severity": "critical",
            "alert_message": "pHå€¼ä¸åœ¨6.5-7.5èŒƒå›´å†…ï¼Œå¯èƒ½å­˜åœ¨è´¨é‡é—®é¢˜"
        }
    ]

    for rule in rules:
        quality_monitor.add_quality_rule(rule["rule_id"], rule)
        print(f"Added quality rule: {rule['rule_name']}")

    # æ‰§è¡Œè´¨é‡æ£€æµ‹
    food_id = "FOOD20250121001"
    batch_number = "BATCH20250121001"

    quality_data = {
        "temperature_max": 7.5,
        "humidity": 55.0,
        "ph_value": 7.0,
        "bacteria_count": 100
    }

    check_result = quality_monitor.check_quality(food_id, batch_number, quality_data)
    print(f"\nQuality Check Result:")
    print(f"  Passed: {check_result['passed']}")
    print(f"  Quality Score: {check_result['quality_score']:.2f}")
    print(f"  Violations: {len(check_result['violations'])}")
    print(f"  Warnings: {len(check_result['warnings'])}")

    if check_result['violations']:
        print(f"\nViolations:")
        for violation in check_result['violations']:
            print(f"  - {violation['rule_name']}: {violation['message']}")

    if check_result['warnings']:
        print(f"\nWarnings:")
        for warning in check_result['warnings']:
            print(f"  - {warning['rule_name']}: {warning['message']}")

    # ç”Ÿæˆè´¨é‡æŠ¥å‘Š
    report = quality_monitor.generate_quality_report(
        food_id=food_id,
        batch_number=batch_number,
        start_date=datetime(2025, 1, 1),
        end_date=datetime.now()
    )

    print(f"\nQuality Report:")
    print(f"  Total checks: {report['summary']['total_checks']}")
    print(f"  Pass rate: {report['summary']['pass_rate']:.2f}%")
    print(f"  Average quality score: {report['summary']['average_quality_score']:.2f}")
    print(f"  Active alerts: {report['summary']['active_alerts']}")

    storage.close()

if __name__ == "__main__":
    quality_check_process()
```

---

## 10. æ¡ˆä¾‹9ï¼šæ‰¹æ¬¡è´¨é‡åˆ†æ

### 10.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“å…¬å¸éœ€è¦åˆ†æä¸åŒæ‰¹æ¬¡çš„è´¨é‡æ•°æ®ï¼Œè¯†åˆ«è´¨é‡è¶‹åŠ¿ï¼Œæ‰¾å‡ºè´¨é‡é—®é¢˜çš„æ ¹æœ¬åŸå› ï¼Œä¼˜åŒ–ç”Ÿäº§è¿‡ç¨‹ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦åˆ†æå¤šä¸ªæ‰¹æ¬¡çš„è´¨é‡æ•°æ®
- éœ€è¦è¯†åˆ«è´¨é‡è¶‹åŠ¿
- éœ€è¦æ‰¾å‡ºè´¨é‡é—®é¢˜æ¨¡å¼
- éœ€è¦ç”Ÿæˆåˆ†ææŠ¥å‘Š

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨è´¨é‡æ£€æµ‹æ•°æ®å’Œç»Ÿè®¡åˆ†æï¼Œå®ç°æ‰¹æ¬¡è´¨é‡åˆ†æå’Œè¶‹åŠ¿è¯†åˆ«ã€‚

### 10.2 å®ç°ä»£ç 

**æ‰¹æ¬¡è´¨é‡åˆ†æå®ç°**ï¼š

```python
from quality_monitor import QualityMonitor
from food_industry_storage import FoodIndustryStorage
from datetime import datetime, timedelta
from collections import defaultdict

def batch_quality_analysis():
    """æ‰¹æ¬¡è´¨é‡åˆ†æç¤ºä¾‹"""
    storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
    quality_monitor = QualityMonitor(storage)

    food_id = "FOOD20250121001"

    # è·å–æ‰€æœ‰æ‰¹æ¬¡çš„è´¨é‡æ£€æµ‹è®°å½•
    quality_checks = storage.get_quality_checks(
        food_id=food_id,
        start_date=datetime.now() - timedelta(days=30)
    )

    if not quality_checks:
        print("No quality checks found")
        return

    # æŒ‰æ‰¹æ¬¡åˆ†ç»„
    batch_quality = defaultdict(list)
    for check in quality_checks:
        batch_number = check.get("batch_number")
        batch_quality[batch_number].append(check)

    print(f"Batch Quality Analysis for {food_id}:")
    print(f"  Total batches: {len(batch_quality)}")

    # åˆ†ææ¯ä¸ªæ‰¹æ¬¡
    batch_stats = []
    for batch_number, checks in batch_quality.items():
        passed_count = sum(1 for c in checks if c.get("passed", False))
        total_count = len(checks)
        avg_score = sum(c.get("quality_score", 0) for c in checks) / total_count if total_count > 0 else 0

        # ç»Ÿè®¡è¿è§„ç±»å‹
        violation_types = defaultdict(int)
        for check in checks:
            for violation in check.get("violations", []):
                violation_types[violation.get("rule_name", "Unknown")] += 1

        batch_stats.append({
            "batch_number": batch_number,
            "total_checks": total_count,
            "passed_checks": passed_count,
            "pass_rate": (passed_count / total_count * 100) if total_count > 0 else 0,
            "avg_quality_score": avg_score,
            "violation_types": dict(violation_types)
        })

    # æ’åºï¼ˆæŒ‰è´¨é‡å¾—åˆ†ï¼‰
    batch_stats.sort(key=lambda x: x["avg_quality_score"], reverse=True)

    print(f"\nBatch Quality Ranking:")
    for i, stat in enumerate(batch_stats, 1):
        print(f"  {i}. {stat['batch_number']}:")
        print(f"     Pass rate: {stat['pass_rate']:.2f}%")
        print(f"     Avg quality score: {stat['avg_quality_score']:.2f}")
        if stat['violation_types']:
            print(f"     Violations: {', '.join(stat['violation_types'].keys())}")

    # è¯†åˆ«è´¨é‡è¶‹åŠ¿
    print(f"\nQuality Trends:")
    if len(batch_stats) >= 2:
        recent_batches = batch_stats[:5]
        avg_recent_score = sum(s["avg_quality_score"] for s in recent_batches) / len(recent_batches)

        older_batches = batch_stats[-5:] if len(batch_stats) > 5 else []
        if older_batches:
            avg_older_score = sum(s["avg_quality_score"] for s in older_batches) / len(older_batches)
            trend = "improving" if avg_recent_score > avg_older_score else "declining"
            print(f"  Quality trend: {trend}")
            print(f"  Recent avg score: {avg_recent_score:.2f}")
            print(f"  Older avg score: {avg_older_score:.2f}")

    # æ‰¾å‡ºå¸¸è§é—®é¢˜
    all_violations = defaultdict(int)
    for stat in batch_stats:
        for violation_type, count in stat["violation_types"].items():
            all_violations[violation_type] += count

    if all_violations:
        print(f"\nCommon Issues:")
        sorted_violations = sorted(all_violations.items(), key=lambda x: x[1], reverse=True)
        for violation_type, count in sorted_violations[:5]:
            print(f"  {violation_type}: {count} occurrences")

    storage.close()

if __name__ == "__main__":
    batch_quality_analysis()
```

---

## 11. æ¡ˆä¾‹10ï¼šä¾›åº”å•†è´¨é‡è¯„ä¼°

### 11.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
é£Ÿå“å…¬å¸éœ€è¦è¯„ä¼°ä¾›åº”å•†çš„è´¨é‡è¡¨ç°ï¼Œæ ¹æ®ä¾›åº”å•†æä¾›çš„åŸæ–™è´¨é‡æ•°æ®ï¼Œè¯„ä¼°ä¾›åº”å•†çš„å¯é æ€§ï¼Œä¼˜åŒ–ä¾›åº”å•†é€‰æ‹©ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¶é›†ä¾›åº”å•†è´¨é‡æ•°æ®
- éœ€è¦è¯„ä¼°ä¾›åº”å•†è´¨é‡è¡¨ç°
- éœ€è¦ç”Ÿæˆä¾›åº”å•†è´¨é‡æŠ¥å‘Š
- éœ€è¦æ”¯æŒä¾›åº”å•†æ’å

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨è´¨é‡æ£€æµ‹æ•°æ®å’Œè¿½æº¯é“¾ä¿¡æ¯ï¼Œå®ç°ä¾›åº”å•†è´¨é‡è¯„ä¼°å’Œæ’åã€‚

### 11.2 å®ç°ä»£ç 

**ä¾›åº”å•†è´¨é‡è¯„ä¼°å®ç°**ï¼š

```python
from food_traceability_system import FoodTraceabilitySystem
from food_industry_storage import FoodIndustryStorage
from quality_monitor import QualityMonitor
from datetime import datetime, timedelta
from collections import defaultdict

def supplier_quality_assessment():
    """ä¾›åº”å•†è´¨é‡è¯„ä¼°ç¤ºä¾‹"""
    storage = FoodIndustryStorage("postgresql://user:pass@localhost/food_industry")
    traceability_system = FoodTraceabilitySystem(storage)
    quality_monitor = QualityMonitor(storage)

    # è·å–æ‰€æœ‰è¿½æº¯é“¾
    # ç®€åŒ–ï¼šå‡è®¾å¯ä»¥ä»æ•°æ®åº“æŸ¥è¯¢æ‰€æœ‰è¿½æº¯é“¾
    suppliers = {}

    # æ¨¡æ‹Ÿä¾›åº”å•†æ•°æ®
    suppliers = {
        "ä¾›åº”å•†A": {
            "gln": "1111111111111",
            "batches": ["BATCH20250121001", "BATCH20250121002"],
            "quality_checks": []
        },
        "ä¾›åº”å•†B": {
            "gln": "2222222222222",
            "batches": ["BATCH20250121003", "BATCH20250121004"],
            "quality_checks": []
        }
    }

    # è·å–æ¯ä¸ªä¾›åº”å•†çš„è´¨é‡æ£€æµ‹æ•°æ®
    for supplier_name, supplier_data in suppliers.items():
        for batch_number in supplier_data["batches"]:
            checks = storage.get_quality_checks(batch_number=batch_number)
            supplier_data["quality_checks"].extend(checks)

    # è¯„ä¼°ä¾›åº”å•†è´¨é‡
    supplier_assessments = []

    for supplier_name, supplier_data in suppliers.items():
        checks = supplier_data["quality_checks"]

        if not checks:
            continue

        total_checks = len(checks)
        passed_checks = sum(1 for c in checks if c.get("passed", False))
        avg_score = sum(c.get("quality_score", 0) for c in checks) / total_checks if total_checks > 0 else 0

        # ç»Ÿè®¡è¿è§„
        violation_count = sum(len(c.get("violations", [])) for c in checks)
        critical_violations = sum(
            1 for c in checks
            for v in c.get("violations", [])
            if v.get("severity") == "critical"
        )

        supplier_assessments.append({
            "supplier_name": supplier_name,
            "gln": supplier_data["gln"],
            "total_checks": total_checks,
            "passed_checks": passed_checks,
            "pass_rate": (passed_checks / total_checks * 100) if total_checks > 0 else 0,
            "avg_quality_score": avg_score,
            "violation_count": violation_count,
            "critical_violations": critical_violations,
            "batches_count": len(supplier_data["batches"])
        })

    # æ’åºï¼ˆæŒ‰è´¨é‡å¾—åˆ†ï¼‰
    supplier_assessments.sort(key=lambda x: x["avg_quality_score"], reverse=True)

    print(f"Supplier Quality Assessment:")
    print(f"  Total suppliers: {len(supplier_assessments)}")

    print(f"\nSupplier Ranking:")
    for i, assessment in enumerate(supplier_assessments, 1):
        print(f"  {i}. {assessment['supplier_name']}:")
        print(f"     Pass rate: {assessment['pass_rate']:.2f}%")
        print(f"     Avg quality score: {assessment['avg_quality_score']:.2f}")
        print(f"     Violations: {assessment['violation_count']}")
        print(f"     Critical violations: {assessment['critical_violations']}")
        print(f"     Batches: {assessment['batches_count']}")

    # ç”Ÿæˆä¾›åº”å•†è´¨é‡æŠ¥å‘Š
    print(f"\nSupplier Quality Report:")
    for assessment in supplier_assessments:
        rating = "Excellent" if assessment["avg_quality_score"] >= 90 else \
                 "Good" if assessment["avg_quality_score"] >= 75 else \
                 "Fair" if assessment["avg_quality_score"] >= 60 else "Poor"

        print(f"  {assessment['supplier_name']}: {rating}")
        print(f"    Recommendation: {'Continue partnership' if assessment['avg_quality_score'] >= 75 else 'Review partnership'}")

    storage.close()

if __name__ == "__main__":
    supplier_quality_assessment()
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

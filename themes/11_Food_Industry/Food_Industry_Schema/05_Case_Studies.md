# é£Ÿå“è¡Œä¸šSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [é£Ÿå“è¡Œä¸šSchemaå®è·µæ¡ˆä¾‹](#é£Ÿå“è¡Œä¸šschemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šFreshFoodé›†å›¢é£Ÿå“å®‰å…¨è¿½æº¯ç³»ç»Ÿ](#2-æ¡ˆä¾‹1freshfoodé›†å›¢é£Ÿå“å®‰å…¨è¿½æº¯ç³»ç»Ÿ)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 Schemaå®šä¹‰](#25-schemaå®šä¹‰)
    - [2.6 å®Œæ•´å®ç°ä»£ç ](#26-å®Œæ•´å®ç°ä»£ç )
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šé£Ÿå“å®‰å…¨å…¨ç¨‹è¿½æº¯](#3-æ¡ˆä¾‹2é£Ÿå“å®‰å…¨å…¨ç¨‹è¿½æº¯)
  - [4. æ¡ˆä¾‹3ï¼šé£Ÿå“è´¨é‡ç›‘æ§](#4-æ¡ˆä¾‹3é£Ÿå“è´¨é‡ç›‘æ§)
  - [5. æ¡ˆä¾‹4ï¼šGS1åˆ°EPCISæ¶ˆæ¯è½¬æ¢](#5-æ¡ˆä¾‹4gs1åˆ°epcisæ¶ˆæ¯è½¬æ¢)
  - [6. æ¡ˆä¾‹5ï¼šé£Ÿå“è¡Œä¸šæ•°æ®åˆ†æå’ŒæŠ¥è¡¨](#6-æ¡ˆä¾‹5é£Ÿå“è¡Œä¸šæ•°æ®åˆ†æå’ŒæŠ¥è¡¨)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›é£Ÿå“è¡Œä¸šSchemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–é£Ÿå“è¿½æº¯ã€è´¨é‡ç›‘æ§ã€å¬å›ç®¡ç†ç­‰æ ¸å¿ƒåœºæ™¯ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šFreshFoodé›†å›¢é£Ÿå“å®‰å…¨è¿½æº¯ç³»ç»Ÿ

### 2.1 ä¼ä¸šèƒŒæ™¯

**FreshFoodé›†å›¢**æ˜¯å…¨çƒé¢†å…ˆçš„é£Ÿå“ç”Ÿäº§å’Œåˆ†é”€ä¼ä¸šï¼Œå¹´è¥ä¸šé¢80äº¿ç¾å…ƒï¼Œæ‹¥æœ‰120ä¸ªç”Ÿäº§åŸºåœ°ã€45ä¸ªé…é€ä¸­å¿ƒï¼Œäº§å“é”€å¾€80+å›½å®¶ï¼ŒSKUè¶…è¿‡5,000ä¸ªã€‚

- **æˆç«‹æ—¶é—´**ï¼š1985å¹´
- **å‘˜å·¥è§„æ¨¡**ï¼š35,000äºº
- **å¹´äº§é‡**ï¼š200ä¸‡å¨é£Ÿå“
- **ä¾›åº”å•†æ•°é‡**ï¼š3,500+åŸæ–™ä¾›åº”å•†
- **å®¢æˆ·è¦†ç›–**ï¼šè¶…å¸‚ã€é¤é¥®ã€ç”µå•†ç­‰20ä¸‡+å®¢æˆ·
- **åŸç³»ç»Ÿ**ï¼šçº¸è´¨è®°å½•ä¸ºä¸»ï¼Œç”µå­æ•°æ®åˆ†æ•£ï¼Œè¿½æº¯å›°éš¾

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **è¿½æº¯å“åº”æ…¢** | ä¸¥é‡ | é£Ÿå“å®‰å…¨äº‹ä»¶è¿½æº¯å¹³å‡éœ€48å°æ—¶ï¼Œé¢ä¸´ç›‘ç®¡å¤„ç½š |
| 2 | **å¬å›æ•ˆç‡ä½** | é«˜ | äº§å“å¬å›éœ€3-5å¤©ï¼Œå¬å›ç‡ä»…60%ï¼Œå‰©ä½™40%æµå…¥å¸‚åœº |
| 3 | **è´¨é‡æ•°æ®åˆ†æ•£** | é«˜ | è´¨æ£€æ•°æ®åˆ†æ•£åœ¨Excelå’Œçº¸è´¨è®°å½•ï¼Œæ— æ³•åˆ†æè¶‹åŠ¿ |
| 4 | **ä¾›åº”å•†ç®¡ç†éš¾** | é«˜ | 3,500+ä¾›åº”å•†èµ„è´¨ç®¡ç†å›°éš¾ï¼Œåˆè§„é£é™©é«˜ |
| 5 | **ä¿è´¨æœŸç®¡ç†å·®** | ä¸­ | è¿‡æœŸæŸè€—ç‡3%ï¼Œå¹´æŸå¤±2,400ä¸‡ç¾å…ƒ |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | è¿½æº¯å“åº”æ—¶é—´ | 48å°æ—¶ | <2å°æ—¶ | 12ä¸ªæœˆ |
| 2 | äº§å“å¬å›ç‡ | 60% | 95% | 12ä¸ªæœˆ |
| 3 | è´¨é‡æ•°æ®æ•°å­—åŒ–ç‡ | 20% | 95% | 9ä¸ªæœˆ |
| 4 | ä¾›åº”å•†åˆè§„ç‡ | 70% | 98% | 12ä¸ªæœˆ |
| 5 | è¿‡æœŸæŸè€—ç‡ | 3% | <0.5% | 9ä¸ªæœˆ |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤§è§„æ¨¡è¿½æº¯ç½‘ç»œ**ï¼šéœ€è¿½è¸ª5,000+ SKUä»å†œåœºåˆ°é¤æ¡Œçš„å…¨é“¾è·¯

2. **å¤šæ ‡å‡†å…¼å®¹**ï¼šéœ€æ”¯æŒGS1ã€EPCISã€GFSIã€FSMAç­‰å›½å†…å¤–æ ‡å‡†

3. **å®æ—¶æ•°æ®å¤„ç†**ï¼šæ—¥å‡500ä¸‡æ¡è¿½æº¯äº‹ä»¶ï¼Œå³°å€¼50ä¸‡æ¡/å°æ—¶

4. **å…¨çƒä¾›åº”é“¾**ï¼šéœ€è¦†ç›–35ä¸ªå›½å®¶çš„ç”Ÿäº§åŸºåœ°å’Œä¾›åº”å•†

5. **å¤šè¯­è¨€å¤šå¸ç§**ï¼šéœ€æ”¯æŒ8ç§è¯­è¨€å’Œ15ç§è´§å¸çš„å…¨çƒåŒ–è¿è¥

### 2.5 Schemaå®šä¹‰

**é£Ÿå“è¿½æº¯Schema**ï¼š

```dsl
schema FoodTraceability {
  food_product: {
    gtin: String @value("12345678901234") @length(14)
    batch_lot: String @value("LOT-2025-A001")
    serial_number: Optional[String]
    product_name: String @value("Organic Milk 1L")
    category: String @value("Dairy")
    brand: String @value("FreshFood")
    
    production: {
      production_date: Date @value("2025-01-15")
      expiry_date: Date @value("2025-02-15")
      production_facility: {
        gln: String @value("1234567890123")
        name: String @value("Farm A Dairy Plant")
        country: String @value("CN")
      }
      production_line: String @value("LINE-A01")
    }
    
    ingredients: List[Ingredient] {
      ingredient1: {
        name: String @value("Fresh Milk")
        percentage: Decimal @value(98.5)
        supplier: {
          gln: String @value("9876543210987")
          name: String @value("Farm A")
        }
        origin: String @value("CN-Hebei")
      }
      ingredient2: {
        name: String @value("Vitamin D")
        percentage: Decimal @value(1.5)
        supplier: {
          gln: String @value("1111111111111")
          name: String @value("NutriSupp Inc")
        }
      }
    }
  }
  
  trace_events: List[TraceEvent] {
    event1: {
      event_type: Enum { Production, Processing, Packaging, Shipping, Receiving, Retail }
      event_time: DateTime @value("2025-01-15T06:00:00Z")
      location: {
        gln: String @value("1234567890123")
        name: String @value("Farm A Dairy Plant")
      }
      actor: {
        id: String @value("OPER-001")
        name: String @value("å¼ ä¸‰")
        role: String @value("Production Operator")
      }
      certifications: List[String] @value(["ISO22000", "HACCP"])
    }
    event2: {
      event_type: Enum { QualityCheck }
      event_time: DateTime @value("2025-01-15T08:00:00Z")
      location: {
        gln: String @value("1234567890123")
        name: String @value("Quality Lab")
      }
      quality_data: {
        temperature: Decimal @value(4.0)
        ph_value: Decimal @value(6.7)
        fat_content: Decimal @value(3.5)
        test_result: Enum { Pass, Fail } @value(Pass)
      }
    }
  }
  
  logistics: {
    sscc: String @value("012345678901234567")
    shipper: {
      gln: String @value("1234567890123")
      name: String @value("Farm A Distribution")
    }
    receiver: {
      gln: String @value("2222222222222")
      name: String @value("Metro Supermarket")
    }
    transport: {
      mode: Enum { Truck, Rail, Air, Sea } @value(Truck)
      vehicle_id: String @value("TRUCK-001")
      temperature_controlled: Boolean @value(true)
      temperature_range: {
        min: Decimal @value(2.0)
        max: Decimal @value(6.0)
      }
    }
  }
} @standard("GS1_EPCIS_ISO22005")
```

### 2.6 å®Œæ•´å®ç°ä»£ç 

```python
"""
FreshFoodé›†å›¢é£Ÿå“å®‰å…¨è¿½æº¯ç³»ç»Ÿ
æ”¯æŒå…¨é“¾è·¯è¿½æº¯ã€è´¨é‡ç›‘æ§ã€å¬å›ç®¡ç†
"""

import uuid
import json
from dataclasses import dataclass, field
from datetime import datetime, date, timedelta
from decimal import Decimal
from enum import Enum
from typing import Optional, List, Dict, Any, Tuple
from collections import defaultdict


class EventType(Enum):
    """è¿½æº¯äº‹ä»¶ç±»å‹"""
    PRODUCTION = "production"
    PROCESSING = "processing"
    QUALITY_CHECK = "quality_check"
    PACKAGING = "packaging"
    SHIPPING = "shipping"
    RECEIVING = "receiving"
    STORAGE = "storage"
    RETAIL = "retail"
    SALE = "sale"
    CONSUMPTION = "consumption"


class QualityStatus(Enum):
    """è´¨é‡çŠ¶æ€"""
    PASS = "PASS"
    FAIL = "FAIL"
    PENDING = "PENDING"
    QUARANTINE = "QUARANTINE"


class RecallStatus(Enum):
    """å¬å›çŠ¶æ€"""
    INITIATED = "INITIATED"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    CANCELLED = "CANCELLED"


@dataclass
class Location:
    """ä½ç½®ä¿¡æ¯"""
    gln: str
    name: str
    address: str = ""
    country: str = ""
    location_type: str = ""  # production, warehouse, retail
    
    def to_dict(self) -> Dict[str, str]:
        return {
            "gln": self.gln,
            "name": self.name,
            "address": self.address,
            "country": self.country,
            "type": self.location_type
        }


@dataclass
class Actor:
    """æ“ä½œè€…"""
    actor_id: str
    name: str
    role: str
    organization: str = ""
    certifications: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.actor_id,
            "name": self.name,
            "role": self.role,
            "organization": self.organization,
            "certifications": self.certifications
        }


@dataclass
class QualityData:
    """è´¨é‡æ•°æ®"""
    temperature: Optional[float] = None
    humidity: Optional[float] = None
    ph_value: Optional[float] = None
    fat_content: Optional[float] = None
    protein_content: Optional[float] = None
    bacteria_count: Optional[int] = None
    test_result: QualityStatus = QualityStatus.PENDING
    tester: str = ""
    test_time: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "temperature": self.temperature,
            "humidity": self.humidity,
            "ph_value": self.ph_value,
            "fat_content": self.fat_content,
            "protein_content": self.protein_content,
            "bacteria_count": self.bacteria_count,
            "test_result": self.test_result.value,
            "tester": self.tester,
            "test_time": self.test_time.isoformat()
        }
    
    def is_compliant(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ç¬¦åˆæ ‡å‡†"""
        if self.test_result == QualityStatus.FAIL:
            return False
        if self.ph_value and not (6.0 <= self.ph_value <= 7.0):
            return False
        if self.bacteria_count and self.bacteria_count > 10000:
            return False
        return True


@dataclass
class TraceEvent:
    """è¿½æº¯äº‹ä»¶"""
    event_id: str
    event_type: EventType
    event_time: datetime
    location: Location
    actor: Actor
    gtin: str
    batch_lot: str
    quantity: int = 1
    unit: str = "EA"
    quality_data: Optional[QualityData] = None
    parent_events: List[str] = field(default_factory=list)
    child_events: List[str] = field(default_factory=list)
    certifications: List[str] = field(default_factory=list)
    notes: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "event_time": self.event_time.isoformat(),
            "location": self.location.to_dict(),
            "actor": self.actor.to_dict(),
            "gtin": self.gtin,
            "batch_lot": self.batch_lot,
            "quantity": self.quantity,
            "unit": self.unit,
            "quality_data": self.quality_data.to_dict() if self.quality_data else None,
            "certifications": self.certifications,
            "notes": self.notes
        }


@dataclass
class FoodProduct:
    """é£Ÿå“äº§å“"""
    gtin: str
    batch_lot: str
    product_name: str
    category: str
    brand: str
    production_date: date
    expiry_date: date
    production_location: Location
    ingredients: List[Dict[str, Any]] = field(default_factory=list)
    
    def days_until_expiry(self) -> int:
        """è®¡ç®—è·ç¦»è¿‡æœŸå¤©æ•°"""
        return (self.expiry_date - date.today()).days
    
    def is_expired(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦è¿‡æœŸ"""
        return date.today() > self.expiry_date
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "gtin": self.gtin,
            "batch_lot": self.batch_lot,
            "product_name": self.product_name,
            "category": self.category,
            "brand": self.brand,
            "production_date": self.production_date.isoformat(),
            "expiry_date": self.expiry_date.isoformat(),
            "days_until_expiry": self.days_until_expiry(),
            "is_expired": self.is_expired(),
            "production_location": self.production_location.to_dict(),
            "ingredients": self.ingredients
        }


@dataclass
class Recall:
    """å¬å›è®°å½•"""
    recall_id: str
    gtin: str
    batch_lot: str
    reason: str
    status: RecallStatus
    initiated_at: datetime
    initiated_by: str
    affected_quantity: int = 0
    recalled_quantity: int = 0
    trace_events: List[str] = field(default_factory=list)
    
    def get_recall_rate(self) -> float:
        """è·å–å¬å›ç‡"""
        if self.affected_quantity == 0:
            return 0.0
        return (self.recalled_quantity / self.affected_quantity) * 100
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "recall_id": self.recall_id,
            "gtin": self.gtin,
            "batch_lot": self.batch_lot,
            "reason": self.reason,
            "status": self.status.value,
            "initiated_at": self.initiated_at.isoformat(),
            "initiated_by": self.initiated_by,
            "affected_quantity": self.affected_quantity,
            "recalled_quantity": self.recalled_quantity,
            "recall_rate": self.get_recall_rate()
        }


class FoodTraceabilitySystem:
    """é£Ÿå“è¿½æº¯ç³»ç»Ÿ"""
    
    def __init__(self):
        self.products: Dict[str, FoodProduct] = {}
        self.events: Dict[str, TraceEvent] = {}
        self.product_events: Dict[str, List[str]] = defaultdict(list)
        self.batch_events: Dict[str, List[str]] = defaultdict(list)
        self.recalls: Dict[str, Recall] = {}
        self.locations: Dict[str, Location] = {}
        
        # ç»Ÿè®¡
        self.metrics = {
            "total_products": 0,
            "total_events": 0,
            "active_recalls": 0,
            "trace_queries": 0
        }
    
    def register_product(self, product: FoodProduct) -> str:
        """æ³¨å†Œäº§å“"""
        product_key = f"{product.gtin}:{product.batch_lot}"
        self.products[product_key] = product
        self.metrics["total_products"] += 1
        return product_key
    
    def add_event(self, event: TraceEvent) -> str:
        """æ·»åŠ è¿½æº¯äº‹ä»¶"""
        if not event.event_id:
            event.event_id = f"EVT-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"
        
        self.events[event.event_id] = event
        
        # ç´¢å¼•
        product_key = f"{event.gtin}:{event.batch_lot}"
        self.product_events[product_key].append(event.event_id)
        self.batch_events[event.batch_lot].append(event.event_id)
        
        self.metrics["total_events"] += 1
        return event.event_id
    
    def get_product_trace(self, gtin: str, batch_lot: str) -> List[TraceEvent]:
        """è·å–äº§å“è¿½æº¯é“¾"""
        product_key = f"{gtin}:{batch_lot}"
        event_ids = self.product_events.get(product_key, [])
        events = [self.events[eid] for eid in event_ids]
        events.sort(key=lambda e: e.event_time)
        self.metrics["trace_queries"] += 1
        return events
    
    def trace_forward(self, gtin: str, batch_lot: str) -> Dict[str, Any]:
        """æ­£å‘è¿½æº¯"""
        events = self.get_product_trace(gtin, batch_lot)
        
        origin = events[0] if events else None
        current = events[-1] if events else None
        
        return {
            "trace_type": "forward",
            "gtin": gtin,
            "batch_lot": batch_lot,
            "total_events": len(events),
            "origin": origin.to_dict() if origin else None,
            "current_location": current.location.to_dict() if current else None,
            "trace_path": [e.to_dict() for e in events]
        }
    
    def trace_backward(self, gtin: str, batch_lot: str) -> Dict[str, Any]:
        """åå‘è¿½æº¯"""
        events = self.get_product_trace(gtin, batch_lot)
        events.reverse()
        
        current = events[0] if events else None
        origin = events[-1] if events else None
        
        return {
            "trace_type": "backward",
            "gtin": gtin,
            "batch_lot": batch_lot,
            "total_events": len(events),
            "current_location": current.location.to_dict() if current else None,
            "origin": origin.to_dict() if origin else None,
            "trace_path": [e.to_dict() for e in events]
        }
    
    def get_expiring_products(self, days: int = 7) -> List[FoodProduct]:
        """è·å–å³å°†è¿‡æœŸäº§å“"""
        expiring = []
        for product in self.products.values():
            if 0 < product.days_until_expiry() <= days:
                expiring.append(product)
        return sorted(expiring, key=lambda p: p.days_until_expiry())
    
    def initiate_recall(self, gtin: str, batch_lot: str, reason: str, 
                       initiated_by: str) -> str:
        """å‘èµ·å¬å›"""
        recall = Recall(
            recall_id=f"REC-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            gtin=gtin,
            batch_lot=batch_lot,
            reason=reason,
            status=RecallStatus.INITIATED,
            initiated_at=datetime.now(),
            initiated_by=initiated_by
        )
        
        # è®¡ç®—å—å½±å“æ•°é‡
        events = self.get_product_trace(gtin, batch_lot)
        recall.affected_quantity = sum(e.quantity for e in events)
        recall.trace_events = [e.event_id for e in events]
        
        self.recalls[recall.recall_id] = recall
        self.metrics["active_recalls"] += 1
        
        return recall.recall_id
    
    def update_recall_status(self, recall_id: str, status: RecallStatus,
                            recalled_quantity: int = None):
        """æ›´æ–°å¬å›çŠ¶æ€"""
        if recall_id in self.recalls:
            recall = self.recalls[recall_id]
            recall.status = status
            if recalled_quantity is not None:
                recall.recalled_quantity = recalled_quantity
            
            if status == RecallStatus.COMPLETED:
                self.metrics["active_recalls"] -= 1
    
    def find_affected_products(self, ingredient_supplier: str, 
                              ingredient_batch: str) -> List[str]:
        """æŸ¥æ‰¾å—å½±å“äº§å“ï¼ˆåŸæ–™é—®é¢˜åœºæ™¯ï¼‰"""
        affected = []
        for product_key, product in self.products.items():
            for ingredient in product.ingredients:
                if (ingredient.get("supplier", {}).get("gln") == ingredient_supplier and
                    ingredient.get("batch") == ingredient_batch):
                    affected.append(product_key)
        return affected
    
    def get_quality_summary(self, gtin: str, batch_lot: str) -> Dict[str, Any]:
        """è·å–è´¨é‡æ‘˜è¦"""
        events = self.get_product_trace(gtin, batch_lot)
        
        quality_checks = [e for e in events if e.quality_data]
        passed = sum(1 for e in quality_checks 
                    if e.quality_data.test_result == QualityStatus.PASS)
        failed = sum(1 for e in quality_checks 
                    if e.quality_data.test_result == QualityStatus.FAIL)
        
        avg_temp = None
        temps = [e.quality_data.temperature for e in quality_checks 
                if e.quality_data and e.quality_data.temperature is not None]
        if temps:
            avg_temp = sum(temps) / len(temps)
        
        return {
            "gtin": gtin,
            "batch_lot": batch_lot,
            "total_quality_checks": len(quality_checks),
            "passed": passed,
            "failed": failed,
            "pass_rate": (passed / len(quality_checks) * 100) if quality_checks else 0,
            "average_temperature": avg_temp,
            "all_checks_passed": failed == 0
        }
    
    def get_metrics_report(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡æŠ¥å‘Š"""
        return {
            **self.metrics,
            "total_products": len(self.products),
            "total_events": len(self.events),
            "total_recalls": len(self.recalls),
            "expiring_7d": len(self.get_expiring_products(7)),
            "expiring_30d": len(self.get_expiring_products(30))
        }


def main():
    """ä¸»å‡½æ•° - æ¼”ç¤º"""
    # åˆ›å»ºè¿½æº¯ç³»ç»Ÿ
    system = FoodTraceabilitySystem()
    
    # åˆ›å»ºäº§å“
    production_location = Location(
        gln="1234567890123",
        name="FreshFood Dairy Plant",
        address="Industrial Zone A, Beijing",
        country="CN",
        location_type="production"
    )
    
    product = FoodProduct(
        gtin="12345678901234",
        batch_lot="LOT-2025-A001",
        product_name="Organic Milk 1L",
        category="Dairy",
        brand="FreshFood",
        production_date=date(2025, 1, 15),
        expiry_date=date(2025, 2, 15),
        production_location=production_location,
        ingredients=[
            {
                "name": "Fresh Milk",
                "percentage": 98.5,
                "supplier": {"gln": "9876543210987", "name": "Farm A"},
                "batch": "FARM-001"
            },
            {
                "name": "Vitamin D",
                "percentage": 1.5,
                "supplier": {"gln": "1111111111111", "name": "NutriSupp Inc"}
            }
        ]
    )
    
    product_key = system.register_product(product)
    print(f"æ³¨å†Œäº§å“: {product_key}")
    
    # æ·»åŠ è¿½æº¯äº‹ä»¶
    operator = Actor("OPER-001", "å¼ ä¸‰", "Production Operator", 
                    "FreshFood Dairy Plant", ["HACCP Certified"])
    
    events = [
        TraceEvent(
            event_id="",
            event_type=EventType.PRODUCTION,
            event_time=datetime(2025, 1, 15, 6, 0, 0),
            location=production_location,
            actor=operator,
            gtin=product.gtin,
            batch_lot=product.batch_lot,
            quantity=1000,
            certifications=["ISO22000", "HACCP"]
        ),
        TraceEvent(
            event_id="",
            event_type=EventType.QUALITY_CHECK,
            event_time=datetime(2025, 1, 15, 8, 0, 0),
            location=production_location,
            actor=Actor("QC-001", "æå››", "Quality Inspector"),
            gtin=product.gtin,
            batch_lot=product.batch_lot,
            quality_data=QualityData(
                temperature=4.0,
                ph_value=6.7,
                fat_content=3.5,
                protein_content=3.3,
                bacteria_count=5000,
                test_result=QualityStatus.PASS,
                tester="æå››"
            )
        ),
        TraceEvent(
            event_id="",
            event_type=EventType.PACKAGING,
            event_time=datetime(2025, 1, 15, 10, 0, 0),
            location=production_location,
            actor=operator,
            gtin=product.gtin,
            batch_lot=product.batch_lot,
            quantity=1000
        ),
        TraceEvent(
            event_id="",
            event_type=EventType.SHIPPING,
            event_time=datetime(2025, 1, 15, 14, 0, 0),
            location=production_location,
            actor=Actor("LOG-001", "ç‹äº”", "Logistics Coordinator"),
            gtin=product.gtin,
            batch_lot=product.batch_lot,
            quantity=1000
        )
    ]
    
    for event in events:
        event_id = system.add_event(event)
        print(f"æ·»åŠ äº‹ä»¶: {event.event_type.value} - {event_id}")
    
    # æ­£å‘è¿½æº¯
    print("\n=== æ­£å‘è¿½æº¯ ===")
    forward = system.trace_forward(product.gtin, product.batch_lot)
    print(f"æ€»äº‹ä»¶æ•°: {forward['total_events']}")
    print(f"å½“å‰ä½ç½®: {forward['current_location']['name']}")
    
    # è´¨é‡æ‘˜è¦
    print("\n=== è´¨é‡æ‘˜è¦ ===")
    quality = system.get_quality_summary(product.gtin, product.batch_lot)
    print(json.dumps(quality, indent=2))
    
    # å‘èµ·å¬å›ï¼ˆæ¨¡æ‹Ÿï¼‰
    recall_id = system.initiate_recall(
        product.gtin,
        product.batch_lot,
        "Detected bacteria above threshold in quality check",
        "Quality Manager"
    )
    print(f"\nå‘èµ·å¬å›: {recall_id}")
    
    recall = system.recalls[recall_id]
    print(f"å—å½±å“æ•°é‡: {recall.affected_quantity}")
    
    # ç³»ç»ŸæŒ‡æ ‡
    print("\n=== ç³»ç»ŸæŒ‡æ ‡ ===")
    metrics = system.get_metrics_report()
    print(json.dumps(metrics, indent=2))


if __name__ == "__main__":
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| è¿½æº¯å“åº”æ—¶é—´ | 48å°æ—¶ | 1.5å°æ—¶ | -97% |
| äº§å“å¬å›ç‡ | 60% | 94% | +57% |
| è´¨é‡æ•°æ®æ•°å­—åŒ–ç‡ | 20% | 96% | +76% |
| ä¾›åº”å•†åˆè§„ç‡ | 70% | 97% | +39% |
| è¿‡æœŸæŸè€—ç‡ | 3% | 0.4% | -87% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼ˆ18ä¸ªæœˆé¡¹ç›®å‘¨æœŸï¼‰ï¼š
- è¿½æº¯ç³»ç»Ÿå¼€å‘ï¼š1,200ä¸‡ç¾å…ƒ
- ç¡¬ä»¶åŸºç¡€è®¾æ–½ï¼š600ä¸‡ç¾å…ƒ
- ä¾›åº”å•†åŸ¹è®­ï¼š200ä¸‡ç¾å…ƒ
- **æ€»æŠ•èµ„**ï¼š2,000ä¸‡ç¾å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- è¿‡æœŸæŸè€—å‡å°‘ï¼š2,000ä¸‡ç¾å…ƒ
- å¬å›æ•ˆç‡æå‡ï¼š800ä¸‡ç¾å…ƒ
- ç›‘ç®¡åˆè§„é¿å…ï¼š500ä¸‡ç¾å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š3,300ä¸‡ç¾å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š7.3ä¸ªæœˆ
- 3å¹´ROIï¼š395%

#### ç»éªŒæ•™è®­

**æˆåŠŸå› ç´ **ï¼š
1. **ä¾›åº”å•†ååŒ**ï¼šå»ºç«‹ä¾›åº”å•†é—¨æˆ·ï¼Œè‡ªåŠ©å®Œæˆæ•°æ®å½•å…¥
2. **è‡ªåŠ¨åŒ–é‡‡é›†**ï¼šIoTè®¾å¤‡è‡ªåŠ¨é‡‡é›†æ¸©æ¹¿åº¦ç­‰æ•°æ®
3. **åŒºå—é“¾å­˜è¯**ï¼šå…³é”®æ•°æ®ä¸Šé“¾ï¼Œå¢å¼ºå¯ä¿¡åº¦

**æŒ‘æˆ˜ä¸åº”å¯¹**ï¼š
1. **ä¸­å°ä¾›åº”å•†æŠ€æœ¯èƒ½åŠ›**ï¼šæä¾›æ‰‹æœºAPPç®€åŒ–æ“ä½œ
2. **å…¨çƒæ ‡å‡†å·®å¼‚**ï¼šå»ºç«‹æ ‡å‡†æ˜ å°„åº“ï¼Œè‡ªåŠ¨è½¬æ¢
3. **æ•°æ®é‡å¤§**ï¼šé‡‡ç”¨åˆ†å±‚å­˜å‚¨ï¼Œçƒ­ç‚¹æ•°æ®SSDï¼Œå†å²æ•°æ®å½’æ¡£

---

## 3. æ¡ˆä¾‹2ï¼šé£Ÿå“å®‰å…¨å…¨ç¨‹è¿½æº¯

è¯¦è§ `04_Transformation.md` ç¬¬3ç« ã€‚

## 4. æ¡ˆä¾‹3ï¼šé£Ÿå“è´¨é‡ç›‘æ§

è¯¦è§ `04_Transformation.md` ç¬¬4ç« ã€‚

## 5. æ¡ˆä¾‹4ï¼šGS1åˆ°EPCISæ¶ˆæ¯è½¬æ¢

è¯¦è§ `04_Transformation.md` ç¬¬2ç« ã€‚

## 6. æ¡ˆä¾‹5ï¼šé£Ÿå“è¡Œä¸šæ•°æ®åˆ†æå’ŒæŠ¥è¡¨

è¯¦è§ `04_Transformation.md` ç¬¬6ç« ã€‚

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

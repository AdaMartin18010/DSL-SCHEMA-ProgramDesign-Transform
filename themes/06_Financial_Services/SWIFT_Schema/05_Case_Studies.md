# SWIFT Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [SWIFT Schemaå®è·µæ¡ˆä¾‹](#swift-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šSwiftNeté“¶è¡Œè·¨å¢ƒæ”¯ä»˜ç½‘ç»œå‡çº§](#2-æ¡ˆä¾‹1swiftneté“¶è¡Œè·¨å¢ƒæ”¯ä»˜ç½‘ç»œå‡çº§)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 Schemaå®šä¹‰](#25-schemaå®šä¹‰)
    - [2.6 å®Œæ•´å®ç°ä»£ç ](#26-å®Œæ•´å®ç°ä»£ç )
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šMT202é“¶è¡Œé—´è½¬è´¦](#3-æ¡ˆä¾‹2mt202é“¶è¡Œé—´è½¬è´¦)
  - [4. æ¡ˆä¾‹3ï¼šSWIFT gpiæ”¯ä»˜è¿½è¸ª](#4-æ¡ˆä¾‹3swift-gpiæ”¯ä»˜è¿½è¸ª)
  - [5. æ¡ˆä¾‹4ï¼šMTåˆ°MXè½¬æ¢](#5-æ¡ˆä¾‹4mtåˆ°mxè½¬æ¢)
  - [6. æ¡ˆä¾‹5ï¼šSWIFTæ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ](#6-æ¡ˆä¾‹5swiftæ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›SWIFT Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–MTæ¶ˆæ¯ã€gpiæ”¯ä»˜è¿½è¸ªã€ISO 20022è¿ç§»ç­‰åœºæ™¯ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šSwiftNeté“¶è¡Œè·¨å¢ƒæ”¯ä»˜ç½‘ç»œå‡çº§

### 2.1 ä¼ä¸šèƒŒæ™¯

**SwiftNeté“¶è¡Œç½‘ç»œ**æ˜¯ç”±85å®¶å›½é™…é“¶è¡Œç»„æˆçš„è·¨å¢ƒæ”¯ä»˜è”ç›Ÿï¼Œå¹´å¤„ç†è·¨å¢ƒæ”¯ä»˜äº¤æ˜“é‡è¶…è¿‡2500ä¸‡ç¬”ï¼Œè¦†ç›–120ä¸ªå›½å®¶ï¼Œæ˜¯å…¨çƒè´¸æ˜“é‡‘èçš„é‡è¦åŸºç¡€è®¾æ–½ã€‚

- **æˆç«‹æ—¶é—´**ï¼š1998å¹´
- **æˆå‘˜é“¶è¡Œ**ï¼š85å®¶å›½é™…é“¶è¡Œ
- **å¹´äº¤æ˜“é‡**ï¼š2500ä¸‡ç¬”è·¨å¢ƒæ”¯ä»˜
- **å¹´äº¤æ˜“é¢**ï¼š4.5ä¸‡äº¿ç¾å…ƒ
- **åŸç³»ç»Ÿ**ï¼šä¸»è¦åŸºäºSWIFT MTæ ‡å‡†ï¼ŒMT103å æ¯”65%ï¼ŒMT202å æ¯”30%
- **æŠ€æœ¯å€ºåŠ¡**ï¼šéƒ¨åˆ†æˆå‘˜é“¶è¡Œä»ä½¿ç”¨COBOLç³»ç»Ÿï¼Œä¸SWIFT gpiä¸å…¼å®¹

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | å…·ä½“è¡¨ç° |
|------|------|----------|----------|
| 1 | **æ”¯ä»˜çŠ¶æ€ä¸é€æ˜** | ä¸¥é‡ | å®¢æˆ·æ— æ³•è¿½è¸ªæ”¯ä»˜è¿›åº¦ï¼Œ60%çš„æŸ¥è¯¢éœ€è¦äººå·¥å“åº” |
| 2 | **è´¹ç”¨ä¿¡æ¯ç¼ºå¤±** | é«˜ | MTæ ¼å¼æ— æ³•ä¼ é€’å®Œæ•´è´¹ç”¨æ˜ç»†ï¼Œå¯¼è‡´35%çš„è´¹ç”¨äº‰è®® |
| 3 | **å¤„ç†æ—¶é—´é•¿** | é«˜ | è·¨å¢ƒæ”¯ä»˜å¹³å‡è€—æ—¶2-5ä¸ªå·¥ä½œæ—¥ï¼Œå®¢æˆ·æ»¡æ„åº¦ä½ |
| 4 | **åˆè§„æ£€æŸ¥åˆ†æ•£** | é«˜ | å„é“¶è¡Œç‹¬ç«‹è¿›è¡Œåˆ¶è£ç­›æŸ¥ï¼Œé‡å¤æ£€æŸ¥å¢åŠ æˆæœ¬ |
| 5 | **å¼‚å¸¸å¤„ç†æ…¢** | ä¸­ | æ”¯ä»˜å¼‚å¸¸å¹³å‡è§£å†³æ—¶é—´48å°æ—¶ï¼Œå½±å“èµ„é‡‘å‘¨è½¬ |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | æ”¯ä»˜è¿½è¸ªè¦†ç›–ç‡ | 15% | 100% | 12ä¸ªæœˆ |
| 2 | å¹³å‡æ”¯ä»˜å¤„ç†æ—¶é—´ | 3.5å¤© | <1å¤© | 18ä¸ªæœˆ |
| 3 | è´¹ç”¨é€æ˜åº¦ | 40% | 95% | 12ä¸ªæœˆ |
| 4 | å®¢æˆ·æŸ¥è¯¢å“åº”æ—¶é—´ | 4å°æ—¶ | <5åˆ†é’Ÿ | 6ä¸ªæœˆ |
| 5 | ç›´é€šå¤„ç†ç‡ | 65% | 92% | 12ä¸ªæœˆ |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **SWIFT gpié›†æˆ**ï¼šéœ€è¦åœ¨ä¸ä¸­æ–­ç°æœ‰MTæµç¨‹çš„æƒ…å†µä¸‹ï¼Œé€æ­¥å¼•å…¥gpiè¿½è¸ªèƒ½åŠ›

2. **ISO 20022è¿ç§»**ï¼šæˆå‘˜é“¶è¡Œç³»ç»Ÿå¼‚æ„ï¼Œè¿ç§»è¿›åº¦ä¸ä¸€ï¼Œéœ€æ”¯æŒåŒå‘è½¬æ¢

3. **å®æ—¶æ¶ˆæ¯å¤„ç†**ï¼šgpiè¦æ±‚30åˆ†é’Ÿå†…ç¡®è®¤æ”¯ä»˜çŠ¶æ€ï¼Œå¯¹ç³»ç»Ÿå“åº”æ—¶é—´è¦æ±‚æé«˜

4. **å¤šå¸ç§æ¸…ç®—**ï¼šæ”¯æŒ35ç§è´§å¸çš„å®æ—¶æ±‡ç‡å¤„ç†å’Œè´§å¸å…‘æ¢

5. **ç›‘ç®¡åˆè§„ä¸€è‡´æ€§**ï¼šéœ€è¦å»ºç«‹è”ç›Ÿçº§åˆ«çš„åˆ¶è£ç­›æŸ¥å’Œåæ´—é’±å…±äº«æœºåˆ¶

### 2.5 Schemaå®šä¹‰

**MT103è·¨å¢ƒæ”¯ä»˜Schema**ï¼š

```dsl
schema MT103CrossBorderPayment {
  field_20: String @value("REF123456789") @tag(":20:")

  field_23B: Enum { CRED } @value(CRED) @tag(":23B:")

  field_32A: DateAmountCurrency {
    date: Date @value("250121") @format("YYMMDD")
    currency: String @value("USD")
    amount: Decimal @value(10000.00) @precision(15,2)
  } @tag(":32A:")

  field_50A: PartyIdentifier {
    account: String @value("1234567890")
    name_and_address: String @value("ABC COMPANY\n123 MAIN ST\nNEW YORK NY 10001")
  } @tag(":50A:")

  field_59: Beneficiary {
    account: String @value("9876543210")
    name_and_address: String @value("XYZ CORPORATION\n456 BROADWAY\nLONDON EC1A 1BB")
  } @tag(":59:")

  field_71A: Enum { SHA } @value(SHA) @tag(":71A:")

  field_72: Optional<String> @tag(":72:")
} @standard("SWIFT_MT103")
```

### 2.6 å®Œæ•´å®ç°ä»£ç 

```python
"""
SwiftNeté“¶è¡Œè·¨å¢ƒæ”¯ä»˜å¤„ç†ç³»ç»Ÿ
æ”¯æŒMTæ¶ˆæ¯è§£æã€gpiè¿½è¸ªã€ISO 20022è½¬æ¢
"""

import re
import uuid
import hashlib
from dataclasses import dataclass, field
from datetime import datetime, date
from decimal import Decimal, ROUND_HALF_UP
from enum import Enum
from typing import Optional, List, Dict, Any, Tuple
from abc import ABC, abstractmethod
import json


class MTFieldType(Enum):
    """MTå­—æ®µç±»å‹"""
    TEXT = "TEXT"
    NUMERIC = "NUMERIC"
    AMOUNT = "AMOUNT"
    DATE = "DATE"
    CHOICE = "CHOICE"


class GPIStatus(Enum):
    """gpiæ”¯ä»˜çŠ¶æ€"""
    ACSP = "ACSP"  # AcceptedSettlementInProcess
    ACSC = "ACSC"  # AcceptedSettlementCompleted
    ACWC = "ACWC"  # AcceptedWithChange
    PART = "PART"  # PartiallyAccepted
    PDNG = "PDNG"  # Pending
    RJCT = "RJCT"  # Rejected


@dataclass
class MTField:
    """MTæ¶ˆæ¯å­—æ®µ"""
    tag: str
    value: str
    field_type: MTFieldType = MTFieldType.TEXT
    
    def parse_amount(self) -> Optional[Tuple[str, Decimal, str]]:
        """è§£æé‡‘é¢å­—æ®µ (32Aæ ¼å¼: YYMMDDCURRENCYAMOUNT)"""
        if self.field_type == MTFieldType.AMOUNT and len(self.value) >= 10:
            dt_str = self.value[:6]
            currency = self.value[6:9]
            amount_str = self.value[9:].replace(',', '.')
            try:
                dt = datetime.strptime(dt_str, "%y%m%d")
                amount = Decimal(amount_str).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                return currency, amount, dt.strftime("%Y-%m-%d")
            except (ValueError, IndexError):
                pass
        return None
    
    def parse_party(self) -> Dict[str, str]:
        """è§£æå‚ä¸æ–¹å­—æ®µ (50A/59æ ¼å¼)"""
        lines = self.value.split('\n')
        result = {"account": "", "name": "", "address": ""}
        if lines:
            result["account"] = lines[0].strip()
            if len(lines) > 1:
                result["name"] = lines[1].strip()
            if len(lines) > 2:
                result["address"] = '\n'.join(lines[2:]).strip()
        return result


@dataclass
class MT103Message:
    """MT103æ¶ˆæ¯æ•°æ®ç±»"""
    sender_bic: str
    receiver_bic: str
    message_type: str = "103"
    fields: Dict[str, MTField] = field(default_factory=dict)
    uetr: Optional[str] = None  # SWIFT gpiå”¯ä¸€ç«¯å¯¹ç«¯äº¤æ˜“å‚è€ƒ
    
    @property
    def transaction_reference(self) -> Optional[str]:
        return self.fields.get(":20:").value if ":20:" in self.fields else None
    
    @property
    def amount_info(self) -> Optional[Tuple[str, Decimal, str]]:
        field_32a = self.fields.get(":32A:")
        if field_32a:
            return field_32a.parse_amount()
        return None
    
    @property
    def ordering_customer(self) -> Dict[str, str]:
        field_50a = self.fields.get(":50A:") or self.fields.get(":50K:")
        if field_50a:
            return field_50a.parse_party()
        return {}
    
    @property
    def beneficiary(self) -> Dict[str, str]:
        field_59 = self.fields.get(":59:") or self.fields.get(":59A:")
        if field_59:
            return field_59.parse_party()
        return {}
    
    def validate(self) -> Tuple[bool, List[str]]:
        """éªŒè¯MT103æ¶ˆæ¯"""
        errors = []
        
        required_fields = [":20:", ":23B:", ":32A:", ":50A:", ":59:"]
        for field_tag in required_fields:
            if field_tag not in self.fields:
                errors.append(f"ç¼ºå°‘å¿…éœ€å­—æ®µ: {field_tag}")
        
        # éªŒè¯é‡‘é¢
        if ":32A:" in self.fields:
            amount_info = self.amount_info
            if amount_info is None:
                errors.append("å­—æ®µ32Aæ ¼å¼æ— æ•ˆ")
            elif amount_info[1] <= 0:
                errors.append("é‡‘é¢å¿…é¡»å¤§äº0")
        
        # éªŒè¯BIC
        if not re.match(r'^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$', self.sender_bic):
            errors.append(f"å‘é€æ–¹BICæ ¼å¼æ— æ•ˆ: {self.sender_bic}")
        if not re.match(r'^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$', self.receiver_bic):
            errors.append(f"æ¥æ”¶æ–¹BICæ ¼å¼æ— æ•ˆ: {self.receiver_bic}")
        
        return len(errors) == 0, errors
    
    def to_swift_format(self) -> str:
        """è½¬æ¢ä¸ºSWIFT MTæ ¼å¼"""
        lines = [
            "{1:F01" + self.sender_bic + "0000000000}",
            "{2:I103" + self.receiver_bic + "N}",
            "{4:",
        ]
        for tag, field in sorted(self.fields.items()):
            lines.append(f"{tag}{field.value}")
        lines.append("-}")
        return "\n".join(lines)
    
    @classmethod
    def parse(cls, swift_text: str) -> 'MT103Message':
        """è§£æSWIFT MTæ–‡æœ¬"""
        lines = swift_text.strip().split('\n')
        sender_bic = ""
        receiver_bic = ""
        fields = {}
        
        for line in lines:
            if line.startswith("{1:F01"):
                sender_bic = line[6:14]
            elif line.startswith("{2:I103"):
                receiver_bic = line[7:15]
            elif line.startswith(":"):
                tag_end = line.find(":", 1)
                if tag_end > 0:
                    tag = line[:tag_end+1]
                    value = line[tag_end+1:]
                    field_type = MTFieldType.AMOUNT if tag == ":32A:" else MTFieldType.TEXT
                    fields[tag] = MTField(tag, value, field_type)
        
        return cls(sender_bic=sender_bic, receiver_bic=receiver_bic, fields=fields)


@dataclass
class GPITrackingEvent:
    """gpiè¿½è¸ªäº‹ä»¶"""
    event_id: str
    uetr: str
    timestamp: datetime
    status: GPIStatus
    location: str
    bank_bic: str
    additional_info: Optional[str] = None


@dataclass
class SWIFTGPIMessage:
    """SWIFT gpiæ¶ˆæ¯"""
    uetr: str
    transaction_status: GPIStatus
    initiation_time: datetime
    last_update_time: datetime
    debtor_agent: str
    creditor_agent: str
    instructed_amount: Decimal
    instructed_currency: str
    events: List[GPITrackingEvent] = field(default_factory=list)
    
    def get_status_description(self) -> str:
        """è·å–çŠ¶æ€æè¿°"""
        descriptions = {
            GPIStatus.ACSP: "æ”¯ä»˜æ­£åœ¨å¤„ç†ä¸­ï¼Œå°šæœªå®Œæˆç»“ç®—",
            GPIStatus.ACSC: "æ”¯ä»˜å·²å®Œæˆç»“ç®—",
            GPIStatus.ACWC: "æ”¯ä»˜å·²æ¥å—ä½†æœ‰ä¿®æ”¹",
            GPIStatus.PART: "æ”¯ä»˜éƒ¨åˆ†æ¥å—",
            GPIStatus.PDNG: "æ”¯ä»˜å¾…å¤„ç†",
            GPIStatus.RJCT: "æ”¯ä»˜è¢«æ‹’ç»"
        }
        return descriptions.get(self.transaction_status, "æœªçŸ¥çŠ¶æ€")
    
    def get_processing_time_hours(self) -> float:
        """è·å–å¤„ç†æ—¶é•¿ï¼ˆå°æ—¶ï¼‰"""
        return (self.last_update_time - self.initiation_time).total_seconds() / 3600


class SanctionsScreeningService:
    """åˆ¶è£ç­›æŸ¥æœåŠ¡"""
    
    def __init__(self):
        self.sanctions_list = set()  # åˆ¶è£åå•
        self.pep_list = set()  # æ”¿æ²»æ•æ„Ÿäººç‰©åå•
    
    def screen_party(self, party_info: Dict[str, str]) -> Tuple[bool, List[str]]:
        """ç­›æŸ¥å‚ä¸æ–¹"""
        alerts = []
        name = party_info.get("name", "").upper()
        account = party_info.get("account", "")
        
        # æ£€æŸ¥åˆ¶è£åå•
        for sanctioned in self.sanctions_list:
            if sanctioned in name:
                alerts.append(f"åˆ¶è£åå•å‘½ä¸­: {sanctioned}")
        
        # æ£€æŸ¥PEPåå•
        for pep in self.pep_list:
            if pep in name:
                alerts.append(f"PEPåå•å‘½ä¸­: {pep}")
        
        return len(alerts) == 0, alerts
    
    def screen_message(self, message: MT103Message) -> Tuple[bool, Dict[str, List[str]]]:
        """ç­›æŸ¥æ•´ä¸ªæ¶ˆæ¯"""
        results = {}
        is_clean = True
        
        # ç­›æŸ¥æ±‡æ¬¾äºº
        debtor = message.ordering_customer
        clean, alerts = self.screen_party(debtor)
        if not clean:
            results["debtor"] = alerts
            is_clean = False
        
        # ç­›æŸ¥æ”¶æ¬¾äºº
        creditor = message.beneficiary
        clean, alerts = self.screen_party(creditor)
        if not clean:
            results["creditor"] = alerts
            is_clean = False
        
        return is_clean, results


class SWIFTMessageProcessor:
    """SWIFTæ¶ˆæ¯å¤„ç†å™¨"""
    
    def __init__(self, sanctions_service: SanctionsScreeningService):
        self.sanctions_service = sanctions_service
        self.gpi_messages: Dict[str, SWIFTGPIMessage] = {}
        self.processed_messages: Dict[str, MT103Message] = {}
        self.metrics = {
            "total_received": 0,
            "validated": 0,
            "sanctions_blocked": 0,
            "gpi_tracked": 0,
            "settled": 0
        }
    
    def process_mt103(self, message: MT103Message) -> Dict[str, Any]:
        """å¤„ç†MT103æ¶ˆæ¯"""
        result = {
            "message_id": message.transaction_reference,
            "status": "RECEIVED",
            "timestamp": datetime.now().isoformat(),
            "details": {}
        }
        
        self.metrics["total_received"] += 1
        
        # 1. éªŒè¯æ¶ˆæ¯
        is_valid, errors = message.validate()
        if not is_valid:
            result["status"] = "REJECTED"
            result["details"]["validation_errors"] = errors
            return result
        
        self.metrics["validated"] += 1
        result["status"] = "VALIDATED"
        
        # 2. åˆ¶è£ç­›æŸ¥
        is_clean, screening_results = self.sanctions_service.screen_message(message)
        if not is_clean:
            result["status"] = "SANCTIONS_BLOCKED"
            result["details"]["sanctions_alerts"] = screening_results
            self.metrics["sanctions_blocked"] += 1
            return result
        
        # 3. åˆ›å»ºgpiè¿½è¸ª
        if message.uetr:
            gpi_msg = SWIFTGPIMessage(
                uetr=message.uetr,
                transaction_status=GPIStatus.ACSP,
                initiation_time=datetime.now(),
                last_update_time=datetime.now(),
                debtor_agent=message.sender_bic,
                creditor_agent=message.receiver_bic,
                instructed_amount=message.amount_info[1] if message.amount_info else Decimal("0"),
                instructed_currency=message.amount_info[0] if message.amount_info else "",
                events=[
                    GPITrackingEvent(
                        event_id=str(uuid.uuid4()),
                        uetr=message.uetr,
                        timestamp=datetime.now(),
                        status=GPIStatus.ACSP,
                        location="ORIGINATING_BANK",
                        bank_bic=message.sender_bic,
                        additional_info="Payment received and validated"
                    )
                ]
            )
            self.gpi_messages[message.uetr] = gpi_msg
            self.metrics["gpi_tracked"] += 1
            result["details"]["gpi_status"] = gpi_msg.transaction_status.value
        
        # 4. å­˜å‚¨æ¶ˆæ¯
        if message.transaction_reference:
            self.processed_messages[message.transaction_reference] = message
        
        result["status"] = "PROCESSING"
        return result
    
    def update_gpi_status(self, uetr: str, status: GPIStatus, location: str, 
                         bank_bic: str, info: Optional[str] = None) -> bool:
        """æ›´æ–°gpiçŠ¶æ€"""
        if uetr not in self.gpi_messages:
            return False
        
        gpi_msg = self.gpi_messages[uetr]
        gpi_msg.transaction_status = status
        gpi_msg.last_update_time = datetime.now()
        
        event = GPITrackingEvent(
            event_id=str(uuid.uuid4()),
            uetr=uetr,
            timestamp=datetime.now(),
            status=status,
            location=location,
            bank_bic=bank_bic,
            additional_info=info
        )
        gpi_msg.events.append(event)
        
        if status == GPIStatus.ACSC:
            self.metrics["settled"] += 1
        
        return True
    
    def get_gpi_tracking(self, uetr: str) -> Optional[SWIFTGPIMessage]:
        """è·å–gpiè¿½è¸ªä¿¡æ¯"""
        return self.gpi_messages.get(uetr)
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–å¤„ç†æŒ‡æ ‡"""
        total = self.metrics["total_received"]
        return {
            **self.metrics,
            "validation_rate": (self.metrics["validated"] / total * 100) if total > 0 else 0,
            "gpi_coverage": (self.metrics["gpi_tracked"] / total * 100) if total > 0 else 0,
            "settlement_rate": (self.metrics["settled"] / self.metrics["gpi_tracked"] * 100) 
                              if self.metrics["gpi_tracked"] > 0 else 0
        }


class SWIFTMessageRouter:
    """SWIFTæ¶ˆæ¯è·¯ç”±å™¨"""
    
    def __init__(self):
        self.routing_table: Dict[str, Dict[str, Any]] = {}
        self.correspondent_banks: Dict[str, List[str]] = {}
    
    def add_route(self, currency: str, destination_country: str, 
                  intermediary_bic: Optional[str], beneficiary_bic: str):
        """æ·»åŠ è·¯ç”±"""
        key = f"{currency}:{destination_country}"
        self.routing_table[key] = {
            "intermediary": intermediary_bic,
            "beneficiary": beneficiary_bic
        }
    
    def find_route(self, currency: str, beneficiary_bic: str) -> Optional[Dict[str, Any]]:
        """æŸ¥æ‰¾æœ€ä¼˜è·¯ç”±"""
        country = beneficiary_bic[4:6] if len(beneficiary_bic) >= 6 else ""
        key = f"{currency}:{country}"
        return self.routing_table.get(key)
    
    def build_mt103_with_routing(self, base_message: MT103Message, 
                                 beneficiary_bic: str) -> MT103Message:
        """æ„å»ºå¸¦è·¯ç”±ä¿¡æ¯çš„MT103"""
        message = MT103Message(
            sender_bic=base_message.sender_bic,
            receiver_bic=base_message.receiver_bic,
            message_type="103",
            fields=base_message.fields.copy(),
            uetr=base_message.uetr or str(uuid.uuid4()).upper()
        )
        
        # æŸ¥æ‰¾è·¯ç”±
        amount_info = base_message.amount_info
        if amount_info:
            currency = amount_info[0]
            route = self.find_route(currency, beneficiary_bic)
            if route:
                # æ·»åŠ ä¸­é—´è¡Œä¿¡æ¯
                if route.get("intermediary"):
                    message.fields[":56A:"] = MTField(":56A:", route["intermediary"])
        
        return message


def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºç”¨æ³•"""
    # åˆå§‹åŒ–æœåŠ¡
    sanctions_service = SanctionsScreeningService()
    processor = SWIFTMessageProcessor(sanctions_service)
    router = SWIFTMessageRouter()
    
    # æ·»åŠ è·¯ç”±
    router.add_route("USD", "GB", "CHASUS33", "BARCGB22")
    router.add_route("EUR", "DE", "COBADEFF", "DEUTDEFF")
    
    # åˆ›å»ºç¤ºä¾‹MT103æ¶ˆæ¯
    mt103_text = """{1:F01CITIUS33AXXX0000000000}
{2:I103BARCGB22XXXXN}
{4:
:20:REFERENCE123
:23B:CRED
:32A:250121USD50000,00
:50A:/1234567890
ABC COMPANY
123 MAIN STREET
NEW YORK NY 10001
:59:/9876543210
XYZ CORPORATION
456 BROADWAY
LONDON EC1A 1BB
:71A:SHA
-}"""
    
    message = MT103Message.parse(mt103_text)
    message.uetr = str(uuid.uuid4()).upper()
    
    print(f"è§£æçš„MT103æ¶ˆæ¯:")
    print(f"  äº¤æ˜“å‚è€ƒ: {message.transaction_reference}")
    print(f"  é‡‘é¢ä¿¡æ¯: {message.amount_info}")
    print(f"  æ±‡æ¬¾äºº: {message.ordering_customer}")
    print(f"  æ”¶æ¬¾äºº: {message.beneficiary}")
    print(f"  UETR: {message.uetr}")
    
    # å¤„ç†æ¶ˆæ¯
    result = processor.process_mt103(message)
    print(f"\nå¤„ç†ç»“æœ: {json.dumps(result, indent=2, default=str)}")
    
    # æ›´æ–°gpiçŠ¶æ€
    processor.update_gpi_status(
        message.uetr,
        GPIStatus.ACSC,
        "BENEFICIARY_BANK",
        "BARCGB22",
        "Payment credited to beneficiary account"
    )
    
    # æŸ¥è¯¢è¿½è¸ªä¿¡æ¯
    tracking = processor.get_gpi_tracking(message.uetr)
    if tracking:
        print(f"\ngpiè¿½è¸ªä¿¡æ¯:")
        print(f"  çŠ¶æ€: {tracking.transaction_status.value}")
        print(f"  å¤„ç†æ—¶é•¿: {tracking.get_processing_time_hours():.2f}å°æ—¶")
        print(f"  äº‹ä»¶æ•°: {len(tracking.events)}")
    
    # æ‰“å°ç»Ÿè®¡
    print(f"\nå¤„ç†ç»Ÿè®¡: {json.dumps(processor.get_metrics(), indent=2)}")


if __name__ == "__main__":
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| gpiè¿½è¸ªè¦†ç›–ç‡ | 15% | 98% | +83% |
| å¹³å‡å¤„ç†æ—¶é—´ | 3.5å¤© | 18å°æ—¶ | -79% |
| è´¹ç”¨é€æ˜åº¦ | 40% | 96% | +56% |
| å®¢æˆ·æŸ¥è¯¢å“åº” | 4å°æ—¶ | 2åˆ†é’Ÿ | -99% |
| ç›´é€šå¤„ç†ç‡ | 65% | 94% | +29% |
| å¼‚å¸¸è§£å†³æ—¶é—´ | 48å°æ—¶ | 6å°æ—¶ | -87% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼ˆ18ä¸ªæœˆé¡¹ç›®å‘¨æœŸï¼‰ï¼š
- SWIFT gpiæ¥å…¥è´¹ï¼š450ä¸‡ç¾å…ƒ
- ç³»ç»Ÿå¼€å‘ï¼š680ä¸‡ç¾å…ƒ
- åŸºç¡€è®¾æ–½å‡çº§ï¼š320ä¸‡ç¾å…ƒ
- æˆå‘˜é“¶è¡ŒåŸ¹è®­ï¼š150ä¸‡ç¾å…ƒ
- **æ€»æŠ•èµ„**ï¼š1600ä¸‡ç¾å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- æŸ¥è¯¢å¤„ç†æˆæœ¬èŠ‚çº¦ï¼š800ä¸‡ç¾å…ƒ
- äº‰è®®å¤„ç†æˆæœ¬èŠ‚çº¦ï¼š1200ä¸‡ç¾å…ƒ
- å®¢æˆ·ç•™å­˜æå‡ï¼š2400ä¸‡ç¾å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š4400ä¸‡ç¾å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š4.4ä¸ªæœˆ
- 3å¹´ROIï¼š725%

#### ç»éªŒæ•™è®­

**æˆåŠŸå› ç´ **ï¼š
1. **æ¸è¿›å¼è¿ç§»**ï¼šå…ˆæ¥å…¥gpiè¿½è¸ªï¼Œå†æ¨è¿›ISO 20022å…¨é¢è¿ç§»
2. **å…±äº«æœåŠ¡**ï¼šå»ºç«‹è”ç›Ÿçº§åˆ¶è£ç­›æŸ¥ä¸­å¿ƒï¼Œé¿å…é‡å¤å»ºè®¾
3. **æ ‡å‡†åŒ–API**ï¼šç»Ÿä¸€æ¥å£è§„èŒƒï¼Œæˆå‘˜é“¶è¡Œå¹³å‡é›†æˆæ—¶é—´ä»6ä¸ªæœˆé™è‡³6å‘¨

**æŒ‘æˆ˜ä¸åº”å¯¹**ï¼š
1. **æˆå‘˜é“¶è¡Œæ­¥è°ƒä¸ä¸€**ï¼šè®¾ç«‹æŠ€æœ¯æ´åŠ©åŸºé‡‘ï¼Œå¸®åŠ©å°å‹é“¶è¡Œå‡çº§
2. **æ•°æ®éšç§æ‹…å¿§**ï¼šé‡‡ç”¨é›¶çŸ¥è¯†è¯æ˜æŠ€æœ¯ï¼Œåœ¨ä¿æŠ¤éšç§å‰æä¸‹å®Œæˆåˆè§„æ£€æŸ¥
3. **å†å²ç³»ç»Ÿå…¼å®¹**ï¼šä¿ç•™MT-MXè½¬æ¢ç½‘å…³è‡³å°‘5å¹´

---

## 3. æ¡ˆä¾‹2ï¼šMT202é“¶è¡Œé—´è½¬è´¦

è¯¦è§ `04_Transformation.md` ç¬¬3ç« ã€‚

## 4. æ¡ˆä¾‹3ï¼šSWIFT gpiæ”¯ä»˜è¿½è¸ª

è¯¦è§ `04_Transformation.md` ç¬¬4ç« ã€‚

## 5. æ¡ˆä¾‹4ï¼šMTåˆ°MXè½¬æ¢

è¯¦è§ `04_Transformation.md` ç¬¬2ç« ã€‚

## 6. æ¡ˆä¾‹5ï¼šSWIFTæ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ

è¯¦è§ `04_Transformation.md` ç¬¬6ç« ã€‚

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

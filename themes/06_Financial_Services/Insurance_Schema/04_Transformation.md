# ä¿é™©ä¸šåŠ¡Schemaè½¬æ¢åº”ç”¨

## ğŸ“‘ ç›®å½•

- [ä¿é™©ä¸šåŠ¡Schemaè½¬æ¢åº”ç”¨](#ä¿é™©ä¸šåŠ¡schemaè½¬æ¢åº”ç”¨)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. è½¬æ¢ä½“ç³»æ¦‚è¿°](#1-è½¬æ¢ä½“ç³»æ¦‚è¿°)
    - [1.1 è½¬æ¢ç›®æ ‡](#11-è½¬æ¢ç›®æ ‡)
    - [1.2 è½¬æ¢æ¶æ„](#12-è½¬æ¢æ¶æ„)
  - [2. ä¿å•ç”Ÿå‘½å‘¨æœŸè½¬æ¢](#2-ä¿å•ç”Ÿå‘½å‘¨æœŸè½¬æ¢)
    - [2.1 æŠ•ä¿ç”³è¯·è½¬æ¢](#21-æŠ•ä¿ç”³è¯·è½¬æ¢)
    - [2.2 ä¿å•æ‰¿ä¿è½¬æ¢](#22-ä¿å•æ‰¿ä¿è½¬æ¢)
    - [2.3 ä¿å…¨å˜æ›´è½¬æ¢](#23-ä¿å…¨å˜æ›´è½¬æ¢)
    - [2.4 ä¿å•ç»­æœŸè½¬æ¢](#24-ä¿å•ç»­æœŸè½¬æ¢)
  - [3. ç†èµ”æµç¨‹è½¬æ¢](#3-ç†èµ”æµç¨‹è½¬æ¢)
    - [3.1 ç†èµ”æŠ¥æ¡ˆè½¬æ¢](#31-ç†èµ”æŠ¥æ¡ˆè½¬æ¢)
    - [3.2 æŸ¥å‹˜å®šæŸè½¬æ¢](#32-æŸ¥å‹˜å®šæŸè½¬æ¢)
    - [3.3 ç†ç®—æ ¸èµ”è½¬æ¢](#33-ç†ç®—æ ¸èµ”è½¬æ¢)
  - [4. ACORDæ ‡å‡†è½¬æ¢](#4-acordæ ‡å‡†è½¬æ¢)
    - [4.1 ä¿å•åˆ°ACORDè½¬æ¢](#41-ä¿å•åˆ°acordè½¬æ¢)
    - [4.2 ç†èµ”åˆ°ACORDè½¬æ¢](#42-ç†èµ”åˆ°acordè½¬æ¢)
    - [4.3 ACORDåˆ°å†…éƒ¨æ ¼å¼è½¬æ¢](#43-acordåˆ°å†…éƒ¨æ ¼å¼è½¬æ¢)
  - [5. IFRS 17è½¬æ¢](#5-ifrs-17è½¬æ¢)
    - [5.1 ä¿å•åˆ°IFRS 17åˆåŒç»„è½¬æ¢](#51-ä¿å•åˆ°ifrs-17åˆåŒç»„è½¬æ¢)
    - [5.2 å±¥çº¦ç°é‡‘æµè®¡ç®—](#52-å±¥çº¦ç°é‡‘æµè®¡ç®—)
    - [5.3 CSMè®¡ç®—ä¸æ‘Šé”€](#53-csmè®¡ç®—ä¸æ‘Šé”€)
  - [6. ä¿é™©æ•°æ®å­˜å‚¨ä¸åˆ†æ](#6-ä¿é™©æ•°æ®å­˜å‚¨ä¸åˆ†æ)
    - [6.1 PostgreSQLä¿é™©æ•°æ®å­˜å‚¨](#61-postgresqlä¿é™©æ•°æ®å­˜å‚¨)
    - [6.2 ä¿é™©ä¸šåŠ¡åˆ†ææŸ¥è¯¢](#62-ä¿é™©ä¸šåŠ¡åˆ†ææŸ¥è¯¢)
  - [7. è½¬æ¢éªŒè¯ä¸æµ‹è¯•](#7-è½¬æ¢éªŒè¯ä¸æµ‹è¯•)
    - [7.1 æ•°æ®ä¸€è‡´æ€§éªŒè¯](#71-æ•°æ®ä¸€è‡´æ€§éªŒè¯)
    - [7.2 ä¸šåŠ¡è§„åˆ™éªŒè¯](#72-ä¸šåŠ¡è§„åˆ™éªŒè¯)
  - [8. ç²¾ç®—è®¡ç®—è½¬æ¢](#8-ç²¾ç®—è®¡ç®—è½¬æ¢)
    - [8.1 å‡†å¤‡é‡‘è¯„ä¼°è½¬æ¢](#81-å‡†å¤‡é‡‘è¯„ä¼°è½¬æ¢)
    - [8.2 ä¿è´¹è®¡ç®—è½¬æ¢](#82-ä¿è´¹è®¡ç®—è½¬æ¢)

---

## 1. è½¬æ¢ä½“ç³»æ¦‚è¿°

### 1.1 è½¬æ¢ç›®æ ‡

ä¿é™©ä¸šåŠ¡Schemaè½¬æ¢ä½“ç³»æ”¯æŒä»¥ä¸‹è½¬æ¢ç›®æ ‡ï¼š

1. **ä¿å•ç”Ÿå‘½å‘¨æœŸè½¬æ¢**ï¼šæŠ•ä¿ã€æ‰¿ä¿ã€ä¿å…¨ã€ç»­æœŸã€ç†èµ”
2. **ACORDæ ‡å‡†è½¬æ¢**ï¼šå†…éƒ¨æ ¼å¼ä¸ACORDæ ‡å‡†äº’è½¬
3. **IFRS 17è½¬æ¢**ï¼šä¼ ç»Ÿä¼šè®¡åˆ°IFRS 17ä¼šè®¡
4. **ç›‘ç®¡æŠ¥é€è½¬æ¢**ï¼šå¿ä»˜èƒ½åŠ›æŠ¥å‘Šã€ä¸šåŠ¡ç»Ÿè®¡æŠ¥é€
5. **å†ä¿é™©è½¬æ¢**ï¼šåˆ†ä¿ã€è½¬åˆ†ä¿æ•°æ®å¤„ç†
6. **æ•°æ®å­˜å‚¨è½¬æ¢**ï¼šä¸šåŠ¡æ•°æ®åˆ°åˆ†ææ•°æ®ä»“åº“

**è½¬æ¢å‡½æ•°å®šä¹‰**ï¼š

```text
Insurance_Transform = {
  policy_lifecycle_transform: PolicyEvent Ã— State â†’ PolicyState',
  acord_transform: InternalFormat â†” ACORDFormat,
  ifrs17_transform: Policy Ã— AccountingBasis â†’ IFRS17Contract,
  regulatory_transform: Data Ã— ReportTemplate â†’ RegulatoryReport,
  reinsurance_transform: Cession Ã— Treaty â†’ ReinsuranceEntry,
  analytics_transform: Transaction Ã— Schema â†’ AnalyticsRecord
}
```

### 1.2 è½¬æ¢æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        è½¬æ¢æ¶æ„å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ä¸šåŠ¡ç³»ç»Ÿå±‚      â”‚     è½¬æ¢å¼•æ“å±‚     â”‚       ç›®æ ‡ç³»ç»Ÿå±‚         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ ¸å¿ƒä¿é™©ç³»ç»Ÿ       â”‚   Schemaè§£æå™¨     â”‚    ACORDå¹³å°            â”‚
â”‚ ç†èµ”ç³»ç»Ÿ          â”‚   æ•°æ®æ˜ å°„å¼•æ“      â”‚    IFRS 17ç³»ç»Ÿ          â”‚
â”‚ ç²¾ç®—ç³»ç»Ÿ          â”‚   ç²¾ç®—è®¡ç®—å¼•æ“      â”‚    ç›‘ç®¡æŠ¥é€ç³»ç»Ÿ          â”‚
â”‚ å†ä¿é™©ç³»ç»Ÿ        â”‚   ä¼šè®¡å¼•æ“         â”‚    æ•°æ®ä»“åº“              â”‚
â”‚ æ¸ é“ç³»ç»Ÿ          â”‚   é”™è¯¯å¤„ç†         â”‚    åˆ†æå¹³å°              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                    â”‚                    â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     ç›‘æ§ä¸æ²»ç†å±‚       â”‚
                    â”‚  æ—¥å¿—ã€å®¡è®¡ã€è´¨é‡ç›‘æ§   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ä¿å•ç”Ÿå‘½å‘¨æœŸè½¬æ¢

### 2.1 æŠ•ä¿ç”³è¯·è½¬æ¢

**æŠ•ä¿å•æ ¼å¼è½¬æ¢**ï¼š

```python
def transform_proposal_to_policy(proposal: ProposalApplication) -> Policy:
    """å°†æŠ•ä¿ç”³è¯·è½¬æ¢ä¸ºä¿å•"""
    policy = Policy()
    
    # ä¿å•åŸºç¡€ä¿¡æ¯
    policy.policy_id = generate_policy_id()
    policy.policy_number = generate_policy_number(proposal.product_code)
    policy.proposal_number = proposal.proposal_number
    
    # äº§å“ä¿¡æ¯
    policy.product_code = proposal.product_code
    policy.product_name = proposal.product_name
    policy.product_type = map_product_type(proposal.product_type)
    
    # ä¿é™©æœŸé—´
    policy.policy_term = proposal.policy_term
    policy.policy_term_unit = proposal.policy_term_unit
    policy.effective_date = proposal.requested_effective_date
    policy.expiry_date = calculate_expiry_date(
        proposal.requested_effective_date,
        proposal.policy_term,
        proposal.policy_term_unit
    )
    
    # åˆå§‹çŠ¶æ€
    policy.policy_status = PolicyStatus.INFORCE
    
    # é”€å”®æ¸ é“
    policy.channel_type = proposal.channel_type
    policy.sales_code = proposal.sales_code
    policy.organization_code = proposal.organization_code
    
    # æ—¶é—´æˆ³
    policy.issue_date = datetime.now().date()
    policy.input_date = datetime.now()
    policy.last_modified = datetime.now()
    
    # ä¿é™©è´£ä»»è½¬æ¢
    policy.policy_coverages = []
    for prop_coverage in proposal.coverages:
        coverage = transform_proposal_coverage(prop_coverage)
        coverage.policy_id = policy.policy_id
        policy.policy_coverages.append(coverage)
    
    # ä¿è´¹ä¿¡æ¯è½¬æ¢
    policy.premium_info = calculate_premium_info(policy.policy_coverages)
    
    # å½“äº‹äººä¿¡æ¯è½¬æ¢
    policy.policy_parties = PolicyParties()
    policy.policy_parties.policyholder = transform_proposal_policyholder(
        proposal.policyholder
    )
    policy.policy_parties.insured = transform_proposal_insured(
        proposal.insured
    )
    policy.policy_parties.beneficiaries = [
        transform_proposal_beneficiary(b) 
        for b in proposal.beneficiaries
    ]
    
    return policy

def transform_proposal_coverage(prop_coverage: ProposalCoverage) -> PolicyCoverage:
    """è½¬æ¢æŠ•ä¿è´£ä»»ä¸ºä¿å•è´£ä»»"""
    coverage = PolicyCoverage()
    
    coverage.coverage_id = generate_coverage_id()
    coverage.coverage_code = prop_coverage.coverage_code
    coverage.coverage_name = prop_coverage.coverage_name
    coverage.coverage_type = prop_coverage.coverage_type
    
    # ä¿é¢ä¸ä¿è´¹
    coverage.sum_assured = prop_coverage.sum_assured
    coverage.premium = prop_coverage.calculated_premium
    coverage.premium_frequency = prop_coverage.premium_frequency
    coverage.premium_term = prop_coverage.premium_term
    coverage.premium_term_unit = prop_coverage.premium_term_unit
    
    # è´£ä»»æœŸé—´
    coverage.coverage_start_date = prop_coverage.start_date
    coverage.coverage_end_date = prop_coverage.end_date
    
    # ç­‰å¾…æœŸä¸å…è´£æœŸ
    coverage.waiting_period_days = prop_coverage.waiting_period_days
    coverage.survival_period_days = prop_coverage.survival_period_days
    
    # çŠ¶æ€
    coverage.status = CoverageStatus.ACTIVE
    
    # ç‰¹æ®Šæ¡æ¬¾
    coverage.exclusions = prop_coverage.exclusions
    coverage.special_clauses = prop_coverage.special_clauses
    
    return coverage
```

### 2.2 ä¿å•æ‰¿ä¿è½¬æ¢

**æ ¸ä¿å†³å®šè½¬æ¢**ï¼š

```python
def transform_underwriting_decision(policy: Policy, 
                                     decision: UnderwritingDecision) -> Policy:
    """æ ¹æ®æ ¸ä¿å†³å®šæ›´æ–°ä¿å•"""
    
    if decision.decision_type == UnderwritingDecisionType.ACCEPT:
        # æ ‡å‡†ä½“æ‰¿ä¿
        policy.policy_status = PolicyStatus.INFORCE
        policy.underwriting_result = UnderwritingResult.STANDARD
        
    elif decision.decision_type == UnderwritingDecisionType.ACCEPT_RATED:
        # åŠ è´¹æ‰¿ä¿
        policy.policy_status = PolicyStatus.INFORCE
        policy.underwriting_result = UnderwritingResult.RATED
        
        # åº”ç”¨åŠ è´¹
        for coverage in policy.policy_coverages:
            if coverage.coverage_code in decision.rated_coverages:
                rating = decision.rated_coverages[coverage.coverage_code]
                coverage.premium = coverage.premium * (1 + rating.loading_rate)
        
        # é‡æ–°è®¡ç®—æ€»ä¿è´¹
        policy.premium_info = recalculate_premium_info(policy.policy_coverages)
        
    elif decision.decision_type == UnderwritingDecisionType.ACCEPT_EXCLUSION:
        # é™¤å¤–æ‰¿ä¿
        policy.policy_status = PolicyStatus.INFORCE
        policy.underwriting_result = UnderwritingResult.EXCLUSION
        
        # åº”ç”¨é™¤å¤–æ¡æ¬¾
        for coverage in policy.policy_coverages:
            if coverage.coverage_code in decision.exclusion_clauses:
                exclusion = decision.exclusion_clauses[coverage.coverage_code]
                coverage.exclusions = coverage.exclusions or []
                coverage.exclusions.extend(exclusion.exclusions)
        
    elif decision.decision_type == UnderwritingDecisionType.DECLINE:
        # æ‹’ä¿
        policy.policy_status = PolicyStatus.TERMINATED
        policy.underwriting_result = UnderwritingResult.DECLINED
        policy.decline_reason = decision.decline_reason
        
    elif decision.decision_type == UnderwritingDecisionType.POSTPONE:
        # å»¶æœŸ
        policy.policy_status = PolicyStatus.PROPOSAL
        policy.underwriting_result = UnderwritingResult.POSTPONED
        policy.postpone_until = decision.postpone_until
        policy.postpone_reason = decision.postpone_reason
    
    policy.underwriting_date = decision.decision_date
    policy.underwriter = decision.underwriter_id
    policy.last_modified = datetime.now()
    
    return policy
```

### 2.3 ä¿å…¨å˜æ›´è½¬æ¢

**ä¿å…¨å˜æ›´å¤„ç†**ï¼š

```python
def transform_endorsement(policy: Policy, 
                          endorsement: EndorsementApplication) -> Policy:
    """å¤„ç†ä¿å•ä¿å…¨å˜æ›´"""
    
    # åˆ›å»ºæ‰¹å•
    endorsement_record = Endorsement()
    endorsement_record.endorsement_id = generate_endorsement_id()
    endorsement_record.policy_id = policy.policy_id
    endorsement_record.endorsement_type = endorsement.endorsement_type
    endorsement_record.effective_date = endorsement.effective_date
    endorsement_record.application_date = datetime.now().date()
    
    if endorsement.endorsement_type == EndorsementType.CONTACT_CHANGE:
        # è”ç³»æ–¹å¼å˜æ›´
        policy.policy_parties.policyholder.contact_info.phone = \
            endorsement.new_phone
        policy.policy_parties.policyholder.contact_info.email = \
            endorsement.new_email
        policy.policy_parties.policyholder.contact_info.address = \
            endorsement.new_address
            
    elif endorsement.endorsement_type == EndorsementType.BENEFICIARY_CHANGE:
        # å—ç›Šäººå˜æ›´
        policy.policy_parties.beneficiaries = [
            transform_beneficiary(b) for b in endorsement.new_beneficiaries
        ]
        
        # éªŒè¯å—ç›Šäººä»½é¢æ€»å’Œ
        total_share = sum(b.share_percentage for b in policy.policy_parties.beneficiaries)
        if abs(total_share - 100) > 0.01:
            raise ValueError(f"Beneficiary shares must sum to 100%, got {total_share}%")
            
    elif endorsement.endorsement_type == EndorsementType.SUM_ASSURED_INCREASE:
        # ä¿é¢å¢åŠ 
        coverage = find_coverage(policy, endorsement.coverage_code)
        coverage.sum_assured = endorsement.new_sum_assured
        
        # è®¡ç®—æ–°å¢ä¿è´¹
        additional_premium = calculate_additional_premium(
            coverage, 
            endorsement.new_sum_assured - endorsement.old_sum_assured,
            endorsement.effective_date
        )
        
        endorsement_record.additional_premium = additional_premium
        coverage.premium += additional_premium
        
        # é‡æ–°è®¡ç®—æ€»ä¿è´¹
        policy.premium_info = recalculate_premium_info(policy.policy_coverages)
        
    elif endorsement.endorsement_type == EndorsementType.PAID_UP:
        # å‡é¢äº¤æ¸…
        policy.policy_status = PolicyStatus.PAID_UP
        
        for coverage in policy.policy_coverages:
            # è®¡ç®—ç°é‡‘ä»·å€¼
            cash_value = calculate_cash_value(policy, coverage)
            
            # è®¡ç®—æ–°ä¿é¢
            new_sum_assured = calculate_paid_up_sum_assured(
                coverage, cash_value
            )
            
            coverage.sum_assured = new_sum_assured
            coverage.premium = 0
            coverage.premium_term = 0
            
        policy.premium_info.total_premium = 0
        policy.premium_info.payment_status = PaymentStatus.PAID
        
    elif endorsement.endorsement_type == EndorsementType.SURRENDER:
        # é€€ä¿
        surrender_value = calculate_surrender_value(policy)
        
        policy.policy_status = PolicyStatus.SURRENDERED
        policy.surrender_date = datetime.now().date()
        policy.surrender_value = surrender_value
        
        for coverage in policy.policy_coverages:
            coverage.status = CoverageStatus.CANCELLED
            coverage.coverage_end_date = datetime.now().date()
    
    policy.endorsements.append(endorsement_record)
    policy.version += 1
    policy.last_modified = datetime.now()
    
    return policy
```

### 2.4 ä¿å•ç»­æœŸè½¬æ¢

**ç»­æœŸå¤„ç†**ï¼š

```python
def transform_renewal(policy: Policy, renewal_date: date) -> Policy:
    """å¤„ç†ä¿å•ç»­æœŸ"""
    
    # æ£€æŸ¥æ˜¯å¦å¯ç»­æœŸ
    if policy.policy_status != PolicyStatus.INFORCE:
        raise ValueError(f"Policy {policy.policy_number} is not inforce")
    
    # åˆ›å»ºç»­æœŸè®°å½•
    renewal = Renewal()
    renewal.renewal_id = generate_renewal_id()
    renewal.policy_id = policy.policy_id
    renewal.renewal_date = renewal_date
    
    # è®¡ç®—åº”ç¼´ä¿è´¹
    renewal_due = calculate_renewal_due(policy, renewal_date)
    renewal.renewal_premium = renewal_due.premium_amount
    renewal.due_date = renewal_due.due_date
    
    # æ›´æ–°ä¿è´¹ä¿¡æ¯
    policy.premium_info.next_due_date = renewal_due.due_date
    policy.premium_info.next_due_amount = renewal_due.premium_amount
    policy.premium_info.payment_status = PaymentStatus.DUE
    
    policy.renewals.append(renewal)
    policy.last_modified = datetime.now()
    
    return policy

def process_premium_payment(policy: Policy, 
                            payment: PremiumPayment) -> Policy:
    """å¤„ç†ä¿è´¹ç¼´çº³"""
    
    # éªŒè¯æ”¯ä»˜é‡‘é¢
    if payment.amount < policy.premium_info.next_due_amount:
        raise ValueError("Payment amount less than due amount")
    
    # æ›´æ–°å·²ç¼´ä¿è´¹
    policy.premium_info.total_paid_premium += payment.amount
    policy.premium_info.total_paid_periods += 1
    
    # è®¡ç®—ä¸‹ä¸€ç¼´è´¹æœŸ
    next_due = calculate_next_due_date(
        policy.premium_info.next_due_date,
        policy.policy_coverages[0].premium_frequency
    )
    
    policy.premium_info.next_due_date = next_due
    policy.premium_info.next_due_amount = calculate_next_premium(policy)
    policy.premium_info.payment_status = PaymentStatus.PAID
    
    # å¦‚æœä¹‹å‰æ˜¯å¤±æ•ˆçŠ¶æ€ï¼Œæ¢å¤æœ‰æ•ˆ
    if policy.policy_status == PolicyStatus.LAPSED:
        policy.policy_status = PolicyStatus.REINSTATED
        policy.reinstatement_date = datetime.now().date()
    
    policy.last_modified = datetime.now()
    
    return policy
```

---

## 3. ç†èµ”æµç¨‹è½¬æ¢

### 3.1 ç†èµ”æŠ¥æ¡ˆè½¬æ¢

**æŠ¥æ¡ˆç™»è®°è½¬æ¢**ï¼š

```python
def transform_claim_notification(notification: ClaimNotification) -> Claim:
    """å°†ç†èµ”æŠ¥æ¡ˆè½¬æ¢ä¸ºç†èµ”æ¡ˆä»¶"""
    claim = Claim()
    
    # åŸºæœ¬ä¿¡æ¯
    claim.claim_id = generate_claim_id()
    claim.claim_number = generate_claim_number()
    claim.policy_id = notification.policy_id
    
    # æŸ¥æ‰¾ä¿å•å’Œè´£ä»»
    policy = find_policy(notification.policy_id)
    claim.coverage_id = determine_coverage(policy, notification.incident_type)
    
    # å‡ºé™©ä¿¡æ¯
    claim.date_of_loss = notification.date_of_loss
    claim.time_of_loss = notification.time_of_loss
    claim.place_of_loss = notification.place_of_loss
    claim.cause_of_loss = notification.cause_of_loss
    claim.loss_description = notification.loss_description
    
    # æŠ¥æ¡ˆä¿¡æ¯
    claim.reported_date = datetime.now()
    claim.reported_by = notification.reporter_name
    claim.reporter_phone = notification.reporter_phone
    claim.report_channel = notification.report_channel
    
    # äº‹æ•…ç±»å‹
    claim.incident_type = notification.incident_type
    claim.claim_type = determine_claim_type(policy, notification.incident_type)
    
    # åˆå§‹çŠ¶æ€
    claim.claim_status = ClaimStatus.REGISTERED
    
    # åˆ†é…
    claim.assigned_branch = policy.organization_code
    claim.assigned_adjuster = assign_adjuster(claim)
    
    # æ—¶é—´æˆ³
    claim.created_at = datetime.now()
    claim.updated_at = datetime.now()
    
    # éªŒè¯ä¿å•æœ‰æ•ˆæ€§
    if policy.policy_status != PolicyStatus.INFORCE:
        claim.claim_status = ClaimStatus.REJECTED
        claim.rejection_reason = f"Policy status is {policy.policy_status}"
    
    # éªŒè¯æ˜¯å¦åœ¨ä¿é™©æœŸé—´å†…
    if not (policy.effective_date <= notification.date_of_loss <= policy.expiry_date):
        claim.claim_status = ClaimStatus.REJECTED
        claim.rejection_reason = "Loss date outside policy period"
    
    return claim
```

### 3.2 æŸ¥å‹˜å®šæŸè½¬æ¢

**æŸ¥å‹˜å®šæŸå¤„ç†**ï¼š

```python
def transform_survey_assessment(claim: Claim, 
                                 survey: SurveyReport) -> Claim:
    """å¤„ç†æŸ¥å‹˜å®šæŸç»“æœ"""
    
    assessment = ClaimAssessment()
    assessment.assessment_id = generate_assessment_id()
    assessment.claim_id = claim.claim_id
    
    # æŸ¥å‹˜ä¿¡æ¯
    assessment.survey_date = survey.survey_date
    assessment.surveyor_name = survey.surveyor_name
    assessment.survey_report = survey.report
    assessment.survey_findings = survey.findings
    
    # æŸå¤±è¯„ä¼°
    assessment.loss_assessment = LossAssessment()
    assessment.loss_assessment.assessed_amount = survey.total_assessed_amount
    assessment.loss_assessment.assessment_currency = survey.currency
    assessment.loss_assessment.assessment_basis = survey.assessment_basis
    assessment.loss_assessment.depreciation_rate = survey.depreciation_rate
    assessment.loss_assessment.salvage_value = survey.salvage_value
    assessment.loss_assessment.deductible = survey.deductible_amount
    
    # æŸå¤±æ˜ç»†
    assessment.loss_assessment.loss_items = [
        transform_loss_item(item) for item in survey.loss_items
    ]
    
    # è´£ä»»è®¤å®š
    assessment.liability_assessment = LiabilityAssessment()
    assessment.liability_assessment.is_liability_accepted = survey.is_liability_accepted
    assessment.liability_assessment.liability_percentage = survey.liability_percentage
    assessment.liability_assessment.rejection_reason = survey.rejection_reason
    assessment.liability_assessment.policy_applicable = survey.policy_applicable
    assessment.liability_assessment.exclusion_applicable = survey.exclusion_applicable
    assessment.liability_assessment.exclusion_clauses = survey.exclusion_clauses
    
    assessment.assessment_date = datetime.now()
    assessment.assessor = survey.surveyor_name
    
    claim.claim_assessment = assessment
    
    # æ›´æ–°çŠ¶æ€
    if survey.is_liability_accepted:
        claim.claim_status = ClaimStatus.UNDER_ASSESSMENT
    else:
        claim.claim_status = ClaimStatus.REJECTED
    
    claim.updated_at = datetime.now()
    
    return claim
```

### 3.3 ç†ç®—æ ¸èµ”è½¬æ¢

**ç†ç®—å¤„ç†**ï¼š

```python
def transform_claim_calculation(claim: Claim, 
                                 calculation: ClaimCalculationInput) -> Claim:
    """å¤„ç†ç†ç®—è®¡ç®—"""
    
    calc = ClaimCalculation()
    calc.calculation_id = generate_calculation_id()
    calc.claim_id = claim.claim_id
    
    assessment = claim.claim_assessment.loss_assessment
    
    # æ¯›èµ”æ¬¾é¢
    calc.gross_claim_amount = assessment.assessed_amount
    
    # æ‰£å‡é¡¹
    calc.deductible_amount = assessment.deductible
    calc.depreciation_amount = assessment.assessed_amount * assessment.depreciation_rate
    calc.salvage_recovery = assessment.salvage_value
    calc.subrogation_recovery = calculation.subrogation_recovery or 0
    calc.previous_payments = calculation.previous_payments or 0
    
    # å‡€èµ”æ¬¾é¢
    calc.net_claim_amount = (
        calc.gross_claim_amount
        - calc.deductible_amount
        - calc.depreciation_amount
        - calc.salvage_recovery
        - calc.subrogation_recovery
        - calc.previous_payments
    )
    
    # ç¡®ä¿éè´Ÿ
    calc.net_claim_amount = max(0, calc.net_claim_amount)
    
    # åˆ©æ¯
    calc.interest_amount = calculate_claim_interest(
        claim.date_of_loss,
        datetime.now().date(),
        calc.net_claim_amount
    )
    
    # æ€»èµ”ä»˜é¢
    calc.total_payable_amount = calc.net_claim_amount + calc.interest_amount
    
    # ç†ç®—æ˜ç»†
    calc.calculation_details = []
    for coverage_calc in calculation.coverage_calculations:
        detail = CalculationDetail()
        detail.coverage_code = coverage_calc.coverage_code
        detail.benefit_type = coverage_calc.benefit_type
        detail.claimed_amount = coverage_calc.claimed_amount
        detail.approved_amount = coverage_calc.approved_amount
        detail.deduction_reason = coverage_calc.deduction_reason
        calc.calculation_details.append(detail)
    
    calc.calculation_date = datetime.now()
    calc.calculator = calculation.calculator_id
    
    claim.claim_calculation = calc
    claim.claim_status = ClaimStatus.PENDING_APPROVAL
    claim.updated_at = datetime.now()
    
    return claim

def process_claim_approval(claim: Claim, 
                           approval: ClaimApproval) -> Claim:
    """å¤„ç†ç†èµ”å®¡æ‰¹"""
    
    if approval.decision == ApprovalDecision.APPROVED:
        claim.claim_status = ClaimStatus.APPROVED
        claim.approved_amount = claim.claim_calculation.total_payable_amount
        
        # åˆ›å»ºæ”¯ä»˜è®°å½•
        payment = ClaimPayment()
        payment.payment_id = generate_payment_id()
        payment.claim_id = claim.claim_id
        payment.calculation_id = claim.claim_calculation.calculation_id
        payment.payment_amount = claim.approved_amount
        payment.payment_currency = claim.claim_assessment.loss_assessment.assessment_currency
        payment.payment_type = PaymentType.CLAIM_PAYMENT
        
        # æ”¶æ¬¾äººä¿¡æ¯
        payment.payee = determine_payee(claim, approval)
        payment.payment_method = approval.payment_method
        payment.payment_status = PaymentStatus.PENDING
        payment.requested_date = datetime.now()
        
        claim.claim_payment = payment
        claim.claim_status = ClaimStatus.PAYMENT_PENDING
        
    elif approval.decision == ApprovalDecision.REJECTED:
        claim.claim_status = ClaimStatus.REJECTED
        claim.rejection_reason = approval.rejection_reason
        
    elif approval.decision == ApprovalDecision.PARTIAL:
        claim.claim_status = ClaimStatus.APPROVED
        claim.approved_amount = approval.partial_amount
        # é‡æ–°ç†ç®—...
    
    claim.approved_by = approval.approver_id
    claim.approved_at = datetime.now()
    claim.updated_at = datetime.now()
    
    return claim
```

---

## 4. ACORDæ ‡å‡†è½¬æ¢

### 4.1 ä¿å•åˆ°ACORDè½¬æ¢

```python
def convert_policy_to_acord(policy: Policy) -> ACORDPolicy:
    """å°†å†…éƒ¨ä¿å•æ ¼å¼è½¬æ¢ä¸ºACORDæ ¼å¼"""
    acord = ACORDPolicy()
    
    # SignonRq
    acord.signon_rq = SignonRq()
    acord.signon_rq.signon_pswd = SignonPswd()
    acord.signon_rq.signon_pswd.cust_id = CustId()
    acord.signon_rq.signon_pswd.cust_id.sp_name = "Insurance Company"
    acord.signon_rq.signon_pswd.cust_id.cust_login_id = "system"
    acord.signon_rq.client_dt = datetime.now()
    
    # InsuranceSvcRq
    acord.insurance_svc_rq = InsuranceSvcRq()
    acord.insurance_svc_rq.rq_uid = generate_uuid()
    
    # PolicyInqRsï¼ˆæŸ¥è¯¢å“åº”ï¼‰
    acord.insurance_svc_rq.policy_inq_rs = PolicyInqRs()
    
    # ä¿å•ä¿¡æ¯
    acord_policy = AcordPolicy()
    acord_policy.policy_number = policy.policy_number
    acord_policy.company_product_code = policy.product_code
    acord_policy.effective_dt = policy.effective_date
    acord_policy.expiration_dt = policy.expiry_date
    
    # ä¿å•æŒæœ‰äºº
    acord_policy.named_insured = NamedInsured()
    acord_policy.named_insured.comml_name = \
        policy.policy_parties.policyholder.name
    acord_policy.named_insured.addr = convert_address_to_acord(
        policy.policy_parties.policyholder.contact_info.address
    )
    
    # ä¿é™©è´£ä»»
    acord_policy.coverage = []
    for cov in policy.policy_coverages:
        acord_cov = Coverage()
        acord_cov.coverage_cd = cov.coverage_code
        acord_cov.coverage_desc = cov.coverage_name
        acord_cov.limit = Limit()
        acord_cov.limit.format_currency_amt = FormatCurrencyAmt()
        acord_cov.limit.format_currency_amt.amt = float(cov.sum_assured)
        acord_cov.limit.format_currency_amt.currency_cd = policy.premium_info.premium_currency if hasattr(policy.premium_info, 'premium_currency') else 'CNY'
        
        acord_cov.current_term_amt = CurrentTermAmt()
        acord_cov.current_term_amt.format_currency_amt = FormatCurrencyAmt()
        acord_cov.current_term_amt.format_currency_amt.amt = float(cov.premium)
        
        acord_policy.coverage.append(acord_cov)
    
    acord.insurance_svc_rq.policy_inq_rs.policy = acord_policy
    
    # SignoffRq
    acord.signoff_rq = SignoffRq()
    acord.signoff_rq.client_dt = datetime.now()
    
    return acord

def convert_address_to_acord(address: PostalAddress) -> Addr:
    """è½¬æ¢åœ°å€ä¸ºACORDæ ¼å¼"""
    acord_addr = Addr()
    
    acord_addr.addr1 = address.address_line[0] if address.address_line else ""
    acord_addr.addr2 = address.address_line[1] if len(address.address_line) > 1 else ""
    acord_addr.city = address.city
    acord_addr.state_prov_cd = address.state_province or ""
    acord_addr.postal_code = address.postal_code or ""
    acord_addr.country_cd = address.country
    
    return acord_addr
```

### 4.2 ç†èµ”åˆ°ACORDè½¬æ¢

```python
def convert_claim_to_acord(claim: Claim) -> ACORDClaim:
    """å°†å†…éƒ¨ç†èµ”æ ¼å¼è½¬æ¢ä¸ºACORDæ ¼å¼"""
    acord = ACORDClaim()
    
    # ClaimInqRs
    acord.claim_inq_rs = ClaimInqRs()
    acord.claim_inq_rs.rq_uid = generate_uuid()
    
    # ç†èµ”ä¿¡æ¯
    acord_claim = AcordClaim()
    acord_claim.claim_number = claim.claim_number
    acord_claim.policy_number = claim.policy_number
    acord_claim.loss_dt = claim.date_of_loss
    acord_claim.reported_dt = claim.reported_date
    
    # äº‹æ•…è¯¦æƒ…
    acord_claim.loss_info = LossInfo()
    acord_claim.loss_info.cause_of_loss = claim.cause_of_loss
    acord_claim.loss_info.loss_description = claim.loss_description
    acord_claim.loss_info.loss_addr = Addr()
    acord_claim.loss_info.loss_addr.addr1 = claim.place_of_loss
    
    # ç†èµ”çŠ¶æ€
    acord_claim.claim_status_cd = map_claim_status_to_acord(claim.claim_status)
    
    # æŸå¤±è¯„ä¼°
    if claim.claim_assessment:
        acord_claim.claim_amount = FormatCurrencyAmt()
        acord_claim.claim_amount.amt = float(
            claim.claim_assessment.loss_assessment.assessed_amount
        )
        acord_claim.claim_amount.currency_cd = \
            claim.claim_assessment.loss_assessment.assessment_currency
    
    # èµ”ä»˜é‡‘é¢
    if claim.claim_calculation:
        acord_claim.settlement_amount = FormatCurrencyAmt()
        acord_claim.settlement_amount.amt = float(
            claim.claim_calculation.total_payable_amount
        )
    
    acord.claim_inq_rs.claim = acord_claim
    
    return acord

def map_claim_status_to_acord(status: ClaimStatus) -> str:
    """æ˜ å°„ç†èµ”çŠ¶æ€åˆ°ACORDä»£ç """
    status_mapping = {
        ClaimStatus.REGISTERED: "01",
        ClaimStatus.UNDER_INVESTIGATION: "02",
        ClaimStatus.UNDER_ASSESSMENT: "03",
        ClaimStatus.PENDING_APPROVAL: "04",
        ClaimStatus.APPROVED: "05",
        ClaimStatus.REJECTED: "06",
        ClaimStatus.PAYMENT_PENDING: "07",
        ClaimStatus.PAID: "08",
        ClaimStatus.CLOSED: "09"
    }
    return status_mapping.get(status, "99")
```

### 4.3 ACORDåˆ°å†…éƒ¨æ ¼å¼è½¬æ¢

```python
def convert_acord_to_policy(acord: ACORDPolicy) -> Policy:
    """å°†ACORDæ ¼å¼è½¬æ¢ä¸ºå†…éƒ¨ä¿å•æ ¼å¼"""
    policy = Policy()
    
    acord_policy = acord.insurance_svc_rq.policy_inq_rs.policy
    
    # ä¿å•ä¿¡æ¯
    policy.policy_number = acord_policy.policy_number
    policy.product_code = acord_policy.company_product_code
    policy.effective_date = acord_policy.effective_dt
    policy.expiry_date = acord_policy.expiration_dt
    
    # æŠ•ä¿äºº
    policy.policy_parties = PolicyParties()
    policy.policy_parties.policyholder = Party()
    policy.policy_parties.policyholder.name = acord_policy.named_insured.comml_name
    policy.policy_parties.policyholder.contact_info = ContactInformation()
    policy.policy_parties.policyholder.contact_info.address = \
        convert_acord_to_address(acord_policy.named_insured.addr)
    
    # ä¿é™©è´£ä»»
    policy.policy_coverages = []
    for acord_cov in acord_policy.coverage:
        cov = PolicyCoverage()
        cov.coverage_code = acord_cov.coverage_cd
        cov.coverage_name = acord_cov.coverage_desc
        cov.sum_assured = Decimal(str(acord_cov.limit.format_currency_amt.amt))
        cov.premium = Decimal(str(acord_cov.current_term_amt.format_currency_amt.amt))
        policy.policy_coverages.append(cov)
    
    return policy
```

---

## 5. IFRS 17è½¬æ¢

### 5.1 ä¿å•åˆ°IFRS 17åˆåŒç»„è½¬æ¢

```python
def convert_policy_to_ifrs17_group(policy: Policy) -> IFRS17ContractGroup:
    """å°†ä¿å•è½¬æ¢ä¸ºIFRS 17åˆåŒç»„"""
    
    contract_group = IFRS17ContractGroup()
    contract_group.group_id = generate_group_id()
    
    # åˆåŒç»„è¯†åˆ«ï¼ˆæŒ‰IFRS 17ç»„åˆæ ‡å‡†ï¼‰
    contract_group.portfolio = policy.product_code
    contract_group.profitability = determine_profitability(policy)
    contract_group.initial_recognition_year = policy.effective_date.year
    
    # é€‰æ‹©è®¡é‡æ¨¡å‹
    contract_group.measurement_model = select_measurement_model(policy)
    
    # åˆå§‹ç¡®è®¤
    contract_group.initial_recognition_date = policy.effective_date
    
    # å±¥çº¦ç°é‡‘æµ
    contract_group.fulfilment_cash_flows = calculate_fulfilment_cash_flows(policy)
    
    # åˆåŒæœåŠ¡è¾¹é™…
    contract_group.csm = calculate_csm(contract_group.fulfilment_cash_flows)
    
    # äºæŸéƒ¨åˆ†ï¼ˆå¦‚é€‚ç”¨ï¼‰
    if contract_group.csm < 0:
        contract_group.loss_component = -contract_group.csm
        contract_group.csm = 0
    
    return contract_group

def determine_profitability(policy: Policy) -> Profitability:
    """ç¡®å®šåˆåŒç»„ç›ˆåˆ©èƒ½åŠ›"""
    # ç®€åŒ–é€»è¾‘ï¼šæ ¹æ®äº§å“ç±»å‹å’Œå®šä»·åˆ©æ¶¦ç‡åˆ¤æ–­
    profitable_products = ['TERM_LIFE', 'WHOLE_LIFE', 'ENDOWMENT']
    onerous_products = ['GUARANTEED_ANNUITY', 'LONG_TERM_CARE']
    
    if policy.product_type in onerous_products:
        return Profitability.ONEROUS
    elif policy.product_type in profitable_products:
        return Profitability.PROFITABLE
    else:
        return Profitability.PROFITABLE

def select_measurement_model(policy: Policy) -> MeasurementModel:
    """é€‰æ‹©è®¡é‡æ¨¡å‹"""
    # çŸ­æœŸåˆåŒä½¿ç”¨PAA
    if policy.policy_term <= 1:
        return MeasurementModel.PAA
    
    # å…·æœ‰ç›¸æœºå‚ä¸åˆ†çº¢ç‰¹å¾çš„ä½¿ç”¨VFA
    if has_discretionary_participation_features(policy):
        return MeasurementModel.VFA
    
    # é»˜è®¤ä½¿ç”¨GMM
    return MeasurementModel.GMM
```

### 5.2 å±¥çº¦ç°é‡‘æµè®¡ç®—

```python
def calculate_fulfilment_cash_flows(policy: Policy) -> FulfilmentCashFlows:
    """è®¡ç®—å±¥çº¦ç°é‡‘æµ"""
    
    fcf = FulfilmentCashFlows()
    
    # æœªæ¥ç°é‡‘æµä¼°è®¡
    future_cf = estimate_future_cash_flows(policy)
    fcf.estimates_of_future_cash_flows = future_cf.total_pv
    
    # æŠ˜ç°æ•ˆåº”
    discount_rate = get_discount_rate(policy.currency, policy.policy_term)
    fcf.discount_effect = calculate_discount_effect(future_cf, discount_rate)
    
    # éé‡‘èé£é™©é£é™©è°ƒæ•´
    fcf.risk_adjustment = calculate_risk_adjustment(policy, future_cf)
    
    return fcf

def estimate_future_cash_flows(policy: Policy) -> FutureCashFlows:
    """ä¼°è®¡æœªæ¥ç°é‡‘æµ"""
    
    fcf = FutureCashFlows()
    fcf.cash_flows = []
    
    current_date = datetime.now().date()
    
    # æŒ‰å¹´åº¦é¢„æµ‹ç°é‡‘æµ
    for year in range(policy.policy_term):
        projection_date = add_years(current_date, year)
        
        annual_cf = AnnualCashFlow()
        annual_cf.year = year + 1
        annual_cf.date = projection_date
        
        # ä¿è´¹ç°é‡‘æµ
        if year < policy.policy_coverages[0].premium_term:
            annual_cf.premium = policy.premium_info.total_premium
        else:
            annual_cf.premium = 0
        
        # ç†èµ”ç°é‡‘æµï¼ˆç®€åŒ–å‡è®¾ï¼‰
        claim_rate = get_claim_rate(policy.product_type)
        annual_cf.claims = policy.policy_coverages[0].sum_assured * claim_rate
        
        # è´¹ç”¨ç°é‡‘æµ
        annual_cf.expenses = get_maintenance_expense(policy) * (1 + 0.02) ** year
        
        # å‡€ç°é‡‘æµ
        annual_cf.net_cash_flow = (
            annual_cf.premium - annual_cf.claims - annual_cf.expenses
        )
        
        fcf.cash_flows.append(annual_cf)
    
    # è®¡ç®—ç°å€¼
    fcf.total_pv = sum(
        cf.net_cash_flow / ((1 + discount_rate) ** cf.year)
        for cf in fcf.cash_flows
    )
    
    return fcf

def calculate_risk_adjustment(policy: Policy, 
                               future_cf: FutureCashFlows) -> Decimal:
    """è®¡ç®—éé‡‘èé£é™©é£é™©è°ƒæ•´"""
    
    # ä½¿ç”¨ç½®ä¿¡åº¦æŠ€æœ¯ï¼ˆ75th percentileï¼‰
    confidence_level = 0.75
    
    # è®¡ç®—éé‡‘èé£é™©åˆ†å¸ƒ
    risk_distribution = simulate_non_financial_risk(policy, future_cf)
    
    # å–åˆ†ä½æ•°
    risk_adjustment = risk_distribution.quantile(confidence_level) - \
                      risk_distribution.expected_value()
    
    return max(0, risk_adjustment)
```

### 5.3 CSMè®¡ç®—ä¸æ‘Šé”€

```python
def calculate_csm(fcf: FulfilmentCashFlows) -> Decimal:
    """è®¡ç®—åˆåŒæœåŠ¡è¾¹é™…"""
    
    # CSM = max(0, -PVFP)
    # PVFP = å±¥çº¦ç°é‡‘æµç°å€¼ï¼ˆä¸å«èèµ„æˆåˆ†ï¼‰
    
    pvfp = -fcf.estimates_of_future_cash_flows
    
    csm = max(0, pvfp)
    
    return csm

def amortize_csm(contract_group: IFRS17ContractGroup, 
                 reporting_date: date) -> Decimal:
    """æ‘Šé”€åˆåŒæœåŠ¡è¾¹é™…"""
    
    # è®¡ç®—è¦†ç›–èŒƒå›´å•ä½
    coverage_units = calculate_coverage_units(contract_group)
    
    # å½“æœŸåº”æ‘Šé”€å•ä½
    current_period_cu = get_current_period_coverage_units(
        contract_group, reporting_date
    )
    
    # é¢„è®¡å‰©ä½™å•ä½
    remaining_cu = sum(cu.units for cu in coverage_units 
                       if cu.period > reporting_date.year)
    
    # å½“æœŸæ‘Šé”€æ¯”ä¾‹
    amortization_ratio = current_period_cu / (current_period_cu + remaining_cu)
    
    # å½“æœŸæ‘Šé”€é‡‘é¢
    current_amortization = contract_group.csm * amortization_ratio
    
    # æ›´æ–°CSM
    contract_group.csm -= current_amortization
    
    return current_amortization

def calculate_coverage_units(contract_group: IFRS17ContractGroup) -> List[CoverageUnit]:
    """è®¡ç®—è¦†ç›–èŒƒå›´å•ä½"""
    
    coverage_units = []
    
    # åŸºäºä¿é¢å’Œä¿å•æ•°é‡è®¡ç®—
    for year in range(contract_group.remaining_coverage_period):
        cu = CoverageUnit()
        cu.period = contract_group.initial_recognition_year + year
        
        # è€ƒè™‘é¢„æœŸèµ”ä»˜ã€ä¿é¢ã€ä¿å•æ•°é‡
        expected_claims = estimate_expected_claims(contract_group, year)
        sum_assured = get_remaining_sum_assured(contract_group, year)
        policy_count = get_expected_policy_count(contract_group, year)
        
        # ç»¼åˆè®¡ç®—å•ä½
        cu.units = expected_claims * 0.4 + sum_assured * 0.3 + policy_count * 0.3
        
        coverage_units.append(cu)
    
    return coverage_units
```

---

## 6. ä¿é™©æ•°æ®å­˜å‚¨ä¸åˆ†æ

### 6.1 PostgreSQLä¿é™©æ•°æ®å­˜å‚¨

```python
import psycopg2
import json
from datetime import datetime
from decimal import Decimal

class InsuranceDataStorage:
    """ä¿é™©ä¸šåŠ¡æ•°æ®å­˜å‚¨ç³»ç»Ÿ"""

    def __init__(self, connection_string: str):
        self.conn = psycopg2.connect(connection_string)
        self.cur = self.conn.cursor()
        self._create_tables()

    def _create_tables(self):
        """åˆ›å»ºä¿é™©æ•°æ®è¡¨"""
        
        # ä¿å•è¡¨
        self.cur.execute("""
            CREATE TABLE IF NOT EXISTS policies (
                id BIGSERIAL PRIMARY KEY,
                policy_id VARCHAR(30) UNIQUE NOT NULL,
                policy_number VARCHAR(30) UNIQUE NOT NULL,
                proposal_number VARCHAR(30) NOT NULL,
                product_code VARCHAR(20) NOT NULL,
                product_name VARCHAR(200) NOT NULL,
                product_type VARCHAR(30) NOT NULL,
                policy_term INTEGER NOT NULL,
                effective_date DATE NOT NULL,
                expiry_date DATE NOT NULL,
                policy_status VARCHAR(20) NOT NULL,
                channel_type VARCHAR(20) NOT NULL,
                organization_code VARCHAR(20) NOT NULL,
                issue_date DATE NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ä¿é™©è´£ä»»è¡¨
        self.cur.execute("""
            CREATE TABLE IF NOT EXISTS coverages (
                id BIGSERIAL PRIMARY KEY,
                coverage_id VARCHAR(30) UNIQUE NOT NULL,
                policy_id VARCHAR(30) NOT NULL REFERENCES policies(policy_id),
                coverage_code VARCHAR(10) NOT NULL,
                coverage_name VARCHAR(100) NOT NULL,
                coverage_type VARCHAR(10) NOT NULL,
                sum_assured DECIMAL(15,2) NOT NULL,
                premium DECIMAL(12,2) NOT NULL,
                premium_frequency VARCHAR(20) NOT NULL,
                premium_term INTEGER NOT NULL,
                status VARCHAR(20) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ç†èµ”è¡¨
        self.cur.execute("""
            CREATE TABLE IF NOT EXISTS claims (
                id BIGSERIAL PRIMARY KEY,
                claim_id VARCHAR(30) UNIQUE NOT NULL,
                claim_number VARCHAR(30) UNIQUE NOT NULL,
                policy_id VARCHAR(30) NOT NULL REFERENCES policies(policy_id),
                coverage_id VARCHAR(30) NOT NULL,
                date_of_loss DATE NOT NULL,
                place_of_loss VARCHAR(200) NOT NULL,
                cause_of_loss VARCHAR(500) NOT NULL,
                reported_date TIMESTAMP NOT NULL,
                incident_type VARCHAR(30) NOT NULL,
                claim_type VARCHAR(30) NOT NULL,
                claim_status VARCHAR(30) NOT NULL,
                assessed_amount DECIMAL(15,2),
                approved_amount DECIMAL(15,2),
                paid_amount DECIMAL(15,2),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ä¿è´¹è®°å½•è¡¨
        self.cur.execute("""
            CREATE TABLE IF NOT EXISTS premium_payments (
                id BIGSERIAL PRIMARY KEY,
                payment_id VARCHAR(30) UNIQUE NOT NULL,
                policy_id VARCHAR(30) NOT NULL REFERENCES policies(policy_id),
                payment_type VARCHAR(20) NOT NULL,
                amount DECIMAL(12,2) NOT NULL,
                currency VARCHAR(3) NOT NULL,
                payment_date DATE NOT NULL,
                payment_method VARCHAR(20) NOT NULL,
                status VARCHAR(20) NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # åˆ›å»ºç´¢å¼•
        self.cur.execute("""
            CREATE INDEX IF NOT EXISTS idx_claims_policy 
            ON claims(policy_id)
        """)
        self.cur.execute("""
            CREATE INDEX IF NOT EXISTS idx_claims_status 
            ON claims(claim_status)
        """)
        self.cur.execute("""
            CREATE INDEX IF NOT EXISTS idx_coverages_policy 
            ON coverages(policy_id)
        """)
        
        self.conn.commit()

    def store_policy(self, policy_data: dict):
        """å­˜å‚¨ä¿å•"""
        self.cur.execute("""
            INSERT INTO policies 
            (policy_id, policy_number, proposal_number, product_code, product_name,
             product_type, policy_term, effective_date, expiry_date, policy_status,
             channel_type, organization_code, issue_date)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (policy_id) DO UPDATE SET
            policy_status = EXCLUDED.policy_status,
            updated_at = CURRENT_TIMESTAMP
        """, (
            policy_data['policy_id'],
            policy_data['policy_number'],
            policy_data['proposal_number'],
            policy_data['product_code'],
            policy_data['product_name'],
            policy_data['product_type'],
            policy_data['policy_term'],
            policy_data['effective_date'],
            policy_data['expiry_date'],
            policy_data['policy_status'],
            policy_data['channel_type'],
            policy_data['organization_code'],
            policy_data['issue_date']
        ))
        self.conn.commit()

    def store_claim(self, claim_data: dict):
        """å­˜å‚¨ç†èµ”"""
        self.cur.execute("""
            INSERT INTO claims 
            (claim_id, claim_number, policy_id, coverage_id, date_of_loss,
             place_of_loss, cause_of_loss, reported_date, incident_type,
             claim_type, claim_status, assessed_amount, approved_amount, paid_amount)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT (claim_id) DO UPDATE SET
            claim_status = EXCLUDED.claim_status,
            assessed_amount = EXCLUDED.assessed_amount,
            approved_amount = EXCLUDED.approved_amount,
            paid_amount = EXCLUDED.paid_amount,
            updated_at = CURRENT_TIMESTAMP
        """, (
            claim_data['claim_id'],
            claim_data['claim_number'],
            claim_data['policy_id'],
            claim_data['coverage_id'],
            claim_data['date_of_loss'],
            claim_data['place_of_loss'],
            claim_data['cause_of_loss'],
            claim_data['reported_date'],
            claim_data['incident_type'],
            claim_data['claim_type'],
            claim_data['claim_status'],
            claim_data.get('assessed_amount'),
            claim_data.get('approved_amount'),
            claim_data.get('paid_amount')
        ))
        self.conn.commit()
```

### 6.2 ä¿é™©ä¸šåŠ¡åˆ†ææŸ¥è¯¢

```python
class InsuranceAnalytics:
    """ä¿é™©ä¸šåŠ¡åˆ†ææŸ¥è¯¢"""
    
    def __init__(self, storage: InsuranceDataStorage):
        self.storage = storage
    
    def get_premium_summary(self, start_date: date, end_date: date) -> dict:
        """è·å–ä¿è´¹æ±‡æ€»"""
        self.storage.cur.execute("""
            SELECT 
                product_type,
                COUNT(DISTINCT policy_id) as policy_count,
                SUM(amount) as total_premium
            FROM premium_payments
            WHERE payment_date BETWEEN %s AND %s
            AND status = 'COMPLETED'
            GROUP BY product_type
        """, (start_date, end_date))
        
        results = self.storage.cur.fetchall()
        return {
            row[0]: {
                'policy_count': row[1],
                'total_premium': float(row[2])
            }
            for row in results
        }
    
    def get_claim_statistics(self, start_date: date, end_date: date) -> dict:
        """è·å–ç†èµ”ç»Ÿè®¡"""
        self.storage.cur.execute("""
            SELECT 
                claim_status,
                COUNT(*) as claim_count,
                SUM(assessed_amount) as total_assessed,
                SUM(approved_amount) as total_approved,
                SUM(paid_amount) as total_paid
            FROM claims
            WHERE date_of_loss BETWEEN %s AND %s
            GROUP BY claim_status
        """, (start_date, end_date))
        
        results = self.storage.cur.fetchall()
        return {
            row[0]: {
                'claim_count': row[1],
                'total_assessed': float(row[2]) if row[2] else 0,
                'total_approved': float(row[3]) if row[3] else 0,
                'total_paid': float(row[4]) if row[4] else 0
            }
            for row in results
        }
    
    def get_loss_ratio(self, product_type: str, year: int) -> float:
        """è®¡ç®—èµ”ä»˜ç‡"""
        # å·²èµšä¿è´¹
        self.storage.cur.execute("""
            SELECT SUM(amount)
            FROM premium_payments
            WHERE product_type = %s
            AND EXTRACT(YEAR FROM payment_date) = %s
        """, (product_type, year))
        
        earned_premium = self.storage.cur.fetchone()[0] or 0
        
        # å·²ä»˜èµ”æ¬¾
        self.storage.cur.execute("""
            SELECT SUM(paid_amount)
            FROM claims
            WHERE incident_type = %s
            AND EXTRACT(YEAR FROM date_of_loss) = %s
            AND claim_status IN ('PAID', 'CLOSED')
        """, (product_type, year))
        
        incurred_claims = self.storage.cur.fetchone()[0] or 0
        
        if earned_premium == 0:
            return 0.0
        
        return float(incurred_claims / earned_premium)
```

---

## 7. è½¬æ¢éªŒè¯ä¸æµ‹è¯•

### 7.1 æ•°æ®ä¸€è‡´æ€§éªŒè¯

```python
class InsuranceDataValidator:
    """ä¿é™©æ•°æ®éªŒè¯å™¨"""
    
    def validate_policy_integrity(self, policy: Policy) -> ValidationResult:
        """éªŒè¯ä¿å•å®Œæ•´æ€§"""
        result = ValidationResult()
        
        # éªŒè¯ä¿å•æœŸé—´
        if policy.effective_date >= policy.expiry_date:
            result.add_error("Effective date must be before expiry date")
        
        # éªŒè¯ä¿é¢å’Œä¿è´¹
        for coverage in policy.policy_coverages:
            if coverage.sum_assured <= 0:
                result.add_error(f"Sum assured must be positive for coverage {coverage.coverage_code}")
            if coverage.premium < 0:
                result.add_error(f"Premium cannot be negative for coverage {coverage.coverage_code}")
        
        # éªŒè¯å—ç›Šäººä»½é¢
        if policy.policy_parties.beneficiaries:
            total_share = sum(b.share_percentage 
                            for b in policy.policy_parties.beneficiaries)
            if abs(total_share - 100) > 0.01:
                result.add_error(f"Beneficiary shares must sum to 100%, got {total_share}%")
        
        return result
    
    def validate_claim_integrity(self, claim: Claim) -> ValidationResult:
        """éªŒè¯ç†èµ”å®Œæ•´æ€§"""
        result = ValidationResult()
        
        # éªŒè¯å‡ºé™©æ—¥æœŸåœ¨ä¿é™©æœŸé—´å†…
        policy = find_policy(claim.policy_id)
        if not (policy.effective_date <= claim.date_of_loss <= policy.expiry_date):
            result.add_error("Loss date must be within policy period")
        
        # éªŒè¯èµ”æ¬¾é‡‘é¢
        if claim.claim_calculation:
            if claim.claim_calculation.net_claim_amount < 0:
                result.add_error("Net claim amount cannot be negative")
            
            if claim.claim_payment:
                if claim.claim_payment.payment_amount > claim.claim_calculation.total_payable_amount:
                    result.add_error("Payment amount cannot exceed total payable")
        
        return result
```

### 7.2 ä¸šåŠ¡è§„åˆ™éªŒè¯

```python
class InsuranceBusinessRules:
    """ä¿é™©ä¸šåŠ¡è§„åˆ™éªŒè¯"""
    
    def validate_insurable_interest(self, policy: Policy) -> bool:
        """éªŒè¯ä¿é™©åˆ©ç›Š"""
        # æŠ•ä¿äººå¿…é¡»å¯¹è¢«ä¿é™©äººæœ‰ä¿é™©åˆ©ç›Š
        if policy.policy_parties.insured.relationship_to_policyholder == Relationship.SELF:
            return True
        
        valid_relationships = [
            Relationship.SPOUSE,
            Relationship.CHILD,
            Relationship.PARENT
        ]
        
        return policy.policy_parties.insured.relationship_to_policyholder in valid_relationships
    
    def validate_age_limit(self, policy: Policy) -> ValidationResult:
        """éªŒè¯å¹´é¾„é™åˆ¶"""
        result = ValidationResult()
        
        insured_age = calculate_age(policy.policy_parties.insured.date_of_birth)
        
        # ä¸åŒäº§å“çš„å¹´é¾„é™åˆ¶
        age_limits = {
            'TERM_LIFE': (18, 65),
            'WHOLE_LIFE': (0, 70),
            'ENDOWMENT': (0, 60),
            'ANNUITY': (18, 75)
        }
        
        min_age, max_age = age_limits.get(policy.product_type, (0, 100))
        
        if insured_age < min_age:
            result.add_error(f"Insured age {insured_age} below minimum {min_age}")
        
        if insured_age > max_age:
            result.add_error(f"Insured age {insured_age} above maximum {max_age}")
        
        return result
```

---

## 8. ç²¾ç®—è®¡ç®—è½¬æ¢

### 8.1 å‡†å¤‡é‡‘è¯„ä¼°è½¬æ¢

```python
def transform_claims_to_triangle(claims: List[Claim], 
                                  origin_period: str = 'yearly',
                                  development_period: str = 'yearly') -> TriangleData:
    """å°†ç†èµ”æ•°æ®è½¬æ¢ä¸ºä¸‰è§’å½¢æ•°æ®"""
    
    triangle = TriangleData()
    
    # æŒ‰äº‹æ•…å¹´å’Œè¿›å±•å¹´ç»„ç»‡æ•°æ®
    origin_years = sorted(set(get_origin_year(c, origin_period) for c in claims))
    triangle.origin_periods = origin_years
    
    dev_years = list(range(len(origin_years)))
    triangle.development_periods = dev_years
    
    # æ„å»ºç´¯ç§¯èµ”æ¬¾ä¸‰è§’å½¢
    values = []
    for origin in origin_years:
        row = []
        for dev in dev_years:
            # è®¡ç®—ç´¯ç§¯èµ”æ¬¾
            cumulative_paid = sum(
                c.paid_amount for c in claims
                if get_origin_year(c, origin_period) == origin
                and get_development_year(c, origin_period) <= dev
            )
            row.append(cumulative_paid)
        values.append(row)
    
    triangle.values = values
    triangle.cumulative = True
    
    return triangle

def apply_chain_ladder(triangle: TriangleData) -> ReserveEstimate:
    """åº”ç”¨é“¾æ¢¯æ³•è®¡ç®—å‡†å¤‡é‡‘"""
    
    estimate = ReserveEstimate()
    
    # è®¡ç®—è¿›å±•å› å­
    factors = []
    for j in range(len(triangle.development_periods) - 1):
        numerator = sum(triangle.values[i][j+1] 
                       for i in range(len(triangle.values) - j - 1))
        denominator = sum(triangle.values[i][j] 
                         for i in range(len(triangle.values) - j - 1))
        factor = numerator / denominator if denominator > 0 else 1
        factors.append(factor)
    
    # é¢„æµ‹ç»ˆæèµ”æ¬¾
    ultimate_claims = []
    case_reserves = []
    
    for i, origin in enumerate(triangle.origin_periods):
        current_cumulative = triangle.values[i][-1]
        
        # åº”ç”¨å°¾éƒ¨å› å­é¢„æµ‹
        remaining_factor = 1
        for f in factors[i:]:
            remaining_factor *= f
        
        ultimate = current_cumulative * remaining_factor
        ultimate_claims.append(ultimate)
        
        # æœªå†³èµ”æ¬¾
        case_reserve = ultimate - current_cumulative
        case_reserves.append(case_reserve)
    
    estimate.case_reserve = sum(case_reserves)
    estimate.ibnr_reserve = estimate.case_reserve * 0.2  # ç®€åŒ–å‡è®¾
    estimate.total_reserve = estimate.case_reserve + estimate.ibnr_reserve
    
    return estimate
```

### 8.2 ä¿è´¹è®¡ç®—è½¬æ¢

```python
def transform_pricing_to_premium(pricing_model: PricingModel,
                                  insured: Insured) -> PremiumCalculation:
    """å°†å®šä»·æ¨¡å‹è½¬æ¢ä¸ºä¿è´¹è®¡ç®—"""
    
    calc = PremiumCalculation()
    
    # åŸºç¡€é£é™©ä¿è´¹
    mortality_rate = get_mortality_rate(
        pricing_model.pricing_assumptions.mortality_table,
        insured.age,
        insured.gender
    )
    
    sum_assured = 100000  # ç¤ºä¾‹ä¿é¢
    
    calc.risk_premium = sum_assured * mortality_rate * \
                        pricing_model.pricing_assumptions.mortality_adjustment
    
    # å‚¨è“„ä¿è´¹ï¼ˆå¦‚é€‚ç”¨ï¼‰
    if pricing_model.product_type in ['WHOLE_LIFE', 'ENDOWMENT']:
        calc.savings_premium = calculate_savings_premium(
            pricing_model, sum_assured
        )
    
    # è´¹ç”¨ä¿è´¹
    calc.cost_premium = (
        pricing_model.pricing_assumptions.maintenance_expense_per_policy +
        sum_assured * pricing_model.pricing_assumptions.maintenance_expense_rate
    )
    
    # åŸºç¡€ä¿è´¹
    calc.base_premium = calc.risk_premium + calc.savings_premium
    
    # é™„åŠ è´¹ç”¨
    acquisition_loading = calc.base_premium * \
                          pricing_model.pricing_assumptions.acquisition_cost_rate
    profit_loading = calc.base_premium * 0.05  # 5%åˆ©æ¶¦é™„åŠ 
    
    calc.loading = acquisition_loading + profit_loading + calc.cost_premium
    
    # æ€»ä¿è´¹
    calc.total_premium = calc.base_premium + calc.loading
    
    # åˆ†è§£
    calc.mortality_cost = calc.risk_premium
    calc.expense_loading = calc.loading
    calc.profit_loading = profit_loading
    calc.contingency_loading = 0
    
    return calc
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

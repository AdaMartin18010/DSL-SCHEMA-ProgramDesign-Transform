# ä¿é™©ä¸šåŠ¡Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [ä¿é™©ä¸šåŠ¡Schemaå®è·µæ¡ˆä¾‹](#ä¿é™©ä¸šåŠ¡schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šå¤§å‹ä¿é™©å…¬å¸æ ¸å¿ƒç³»ç»Ÿå‡çº§](#2-æ¡ˆä¾‹1å¤§å‹ä¿é™©å…¬å¸æ ¸å¿ƒç³»ç»Ÿå‡çº§)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 Schemaå®šä¹‰](#25-schemaå®šä¹‰)
    - [2.6 ä»£ç å®ç°](#26-ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šäº’è”ç½‘ä¿é™©æ™ºèƒ½æ ¸ä¿ç³»ç»Ÿ](#3-æ¡ˆä¾‹2äº’è”ç½‘ä¿é™©æ™ºèƒ½æ ¸ä¿ç³»ç»Ÿ)
    - [3.1 ä¼ä¸šèƒŒæ™¯](#31-ä¼ä¸šèƒŒæ™¯)
    - [3.2 ä¸šåŠ¡ç—›ç‚¹](#32-ä¸šåŠ¡ç—›ç‚¹)
    - [3.3 ä¸šåŠ¡ç›®æ ‡](#33-ä¸šåŠ¡ç›®æ ‡)
    - [3.4 æŠ€æœ¯æŒ‘æˆ˜](#34-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.5 Schemaå®šä¹‰](#35-schemaå®šä¹‰)
    - [3.6 ä»£ç å®ç°](#36-ä»£ç å®ç°)
    - [3.7 æ•ˆæœè¯„ä¼°](#37-æ•ˆæœè¯„ä¼°)
  - [4. æ¡ˆä¾‹3ï¼šä¿é™©ç†èµ”æ™ºèƒ½åæ¬ºè¯ˆå¹³å°](#4-æ¡ˆä¾‹3ä¿é™©ç†èµ”æ™ºèƒ½åæ¬ºè¯ˆå¹³å°)
    - [4.1 ä¼ä¸šèƒŒæ™¯](#41-ä¼ä¸šèƒŒæ™¯)
    - [4.2 ä¸šåŠ¡ç—›ç‚¹](#42-ä¸šåŠ¡ç—›ç‚¹)
    - [4.3 ä¸šåŠ¡ç›®æ ‡](#43-ä¸šåŠ¡ç›®æ ‡)
    - [4.4 æŠ€æœ¯æŒ‘æˆ˜](#44-æŠ€æœ¯æŒ‘æˆ˜)
    - [4.5 Schemaå®šä¹‰](#45-schemaå®šä¹‰)
    - [4.6 ä»£ç å®ç°](#46-ä»£ç å®ç°)
    - [4.7 æ•ˆæœè¯„ä¼°](#47-æ•ˆæœè¯„ä¼°)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ä¿é™©ä¸šåŠ¡Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„ä¸‰ä¸ªå…¸å‹æ¡ˆä¾‹ï¼Œæ¶µç›–å¤§å‹ä¿é™©å…¬å¸æ ¸å¿ƒç³»ç»Ÿå‡çº§ã€äº’è”ç½‘ä¿é™©æ™ºèƒ½æ ¸ä¿ç³»ç»Ÿã€ä¿é™©ç†èµ”æ™ºèƒ½åæ¬ºè¯ˆå¹³å°ç­‰åœºæ™¯ï¼Œå±•ç¤ºDSL Schemaåœ¨ä¿é™©äº§å“ç®¡ç†ã€æ™ºèƒ½æ ¸ä¿ã€ç†èµ”é£æ§ç­‰é¢†åŸŸçš„å®é™…åº”ç”¨ä»·å€¼ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šå¤§å‹ä¿é™©å…¬å¸æ ¸å¿ƒç³»ç»Ÿå‡çº§

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šä¸­å›½äººå¯¿XXåˆ†å…¬å¸ï¼ˆåŒ–åï¼šåå®‰ä¿é™©é›†å›¢ï¼‰  
**ä¼ä¸šè§„æ¨¡**ï¼šæ€»èµ„äº§è§„æ¨¡è¶…è¿‡1.2ä¸‡äº¿å…ƒï¼Œå¹´åº¦ä¿è´¹æ”¶å…¥è¶…è¿‡3,000äº¿å…ƒï¼ŒæœåŠ¡å®¢æˆ·è¶…è¿‡1.5äº¿äººï¼Œæ‹¥æœ‰å„çº§åˆ†æ”¯æœºæ„3,000ä½™å®¶  
**ä¸šåŠ¡èŒƒå›´**ï¼šæ¶µç›–äººå¯¿ä¿é™©ã€å¥åº·ä¿é™©ã€æ„å¤–ä¼¤å®³ä¿é™©ã€å…»è€ä¿é™©ã€èµ„äº§ç®¡ç†ç­‰å…¨ç‰Œç…§ä¿é™©ä¸šåŠ¡  
**ç³»ç»Ÿç°çŠ¶**ï¼šæ ¸å¿ƒç³»ç»Ÿå»ºäº2005å¹´ï¼Œé‡‡ç”¨AS/400å°å‹æœºæ¶æ„ï¼Œä½¿ç”¨RPGè¯­è¨€å¼€å‘ï¼Œäº§å“å‚æ•°åŒ–ç¨‹åº¦ä½ï¼Œæ–°äº§å“å¼€å‘å‘¨æœŸé•¿è¾¾6-8ä¸ªæœˆ

åå®‰ä¿é™©é›†å›¢ä½œä¸ºå›½å†…é¢†å…ˆçš„ç»¼åˆæ€§ä¿é™©é›†å›¢ï¼Œå…¶ä¼ ç»Ÿæ ¸å¿ƒç³»ç»Ÿå·²æ— æ³•æ”¯æ’‘ä¸šåŠ¡å¿«é€Ÿå‘å±•ã€‚éšç€äº’è”ç½‘ä¿é™©ã€åœºæ™¯åŒ–ä¿é™©ã€å®šåˆ¶åŒ–ä¿é™©ç­‰æ–°ä¸šæ€å…´èµ·ï¼Œç³»ç»ŸåƒµåŒ–ã€äº§å“åˆ›æ–°èƒ½åŠ›å¼±ã€å®¢æˆ·ä½“éªŒå·®ç­‰é—®é¢˜æ—¥ç›Šå‡¸æ˜¾ï¼Œæ€¥éœ€è¿›è¡Œæ ¸å¿ƒç³»ç»Ÿæ¶æ„å‡çº§ã€‚

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹é¢†åŸŸ | å…·ä½“é—®é¢˜æè¿° | ä¸šåŠ¡å½±å“ |
|------|----------|--------------|----------|
| 1 | **äº§å“åˆ›æ–°æ…¢** | æ–°äº§å“ä¸Šçº¿å‘¨æœŸ6-8ä¸ªæœˆï¼Œéœ€ä¿®æ”¹å¤§é‡ä»£ç å’Œè¿›è¡Œå¤šè½®æµ‹è¯•ï¼Œæ— æ³•å¿«é€Ÿå“åº”å¸‚åœºéœ€æ±‚ | é”™å¤±äº’è”ç½‘ä¿é™©çº¢åˆ©ï¼Œå¸‚åœºä»½é¢ä¸‹æ»‘ |
| 2 | **æ¸ é“å‰²è£‚** | ä¸ªé™©ã€å›¢é™©ã€é“¶ä¿ã€ç”µé”€ã€ç½‘é”€ç­‰æ¸ é“æ•°æ®ç‹¬ç«‹ï¼Œå®¢æˆ·ä¿¡æ¯ä¸äº’é€šï¼ŒåŒä¸€å®¢æˆ·åœ¨ä¸åŒæ¸ é“è¢«è§†ä¸ºä¸åŒå®¢æˆ· | äº¤å‰é”€å”®å›°éš¾ï¼Œå®¢æˆ·ä½“éªŒå·® |
| 3 | **ä¿å•ç®¡ç†å¤æ‚** | ä¼ ç»Ÿä¿å•é‡‡ç”¨å›ºå®šæ ¼å¼ï¼Œéš¾ä»¥æ”¯æŒä¸‡èƒ½é™©ã€æŠ•è¿é™©ç­‰å¤æ‚äº§å“çš„çµæ´»è´¦æˆ·ç®¡ç† | å¤æ‚äº§å“è¿è¥æˆæœ¬é«˜ï¼Œå·®é”™ç‡é«˜ |
| 4 | **ç²¾ç®—å®šä»·æ»å** | ç²¾ç®—æ•°æ®åˆ†æ•£ï¼Œåˆ†æå‘¨æœŸé•¿ï¼Œæ— æ³•åŸºäºå®æ—¶æ•°æ®è¿›è¡ŒåŠ¨æ€å®šä»· | å®šä»·ç²¾å‡†åº¦ä½ï¼Œæ‰¿ä¿åˆ©æ¶¦æ³¢åŠ¨å¤§ |
| 5 | **åˆè§„å‹åŠ›å¤§** | ç›‘ç®¡æŠ¥é€éœ€è¦æ‰‹å·¥æ•´åˆå¤šä¸ªç³»ç»Ÿæ•°æ®ï¼ŒæŠ¥é€è´¨é‡å·®ï¼Œåˆè§„é£é™©é«˜ | ç›‘ç®¡æ£€æŸ¥é—®é¢˜å¤šï¼Œæ•´æ”¹æˆæœ¬é«˜ |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ç»´åº¦ | å…·ä½“ç›®æ ‡ | é¢„æœŸæŒ‡æ ‡ |
|------|----------|----------|----------|
| 1 | **äº§å“åˆ›æ–°** | å»ºç«‹äº§å“å·¥å‚ï¼Œå®ç°ä¿é™©äº§å“å‚æ•°åŒ–é…ç½®å’Œå¿«é€Ÿç»„è£… | æ–°äº§å“ä¸Šçº¿å‘¨æœŸç¼©çŸ­è‡³2å‘¨ |
| 2 | **å®¢æˆ·ç»Ÿä¸€** | å»ºç«‹ç»Ÿä¸€å®¢æˆ·è§†å›¾ï¼Œå®ç°å…¨æ¸ é“å®¢æˆ·ä¿¡æ¯å…±äº« | å®¢æˆ·è¯†åˆ«å‡†ç¡®ç‡>99.5% |
| 3 | **çµæ´»è´¦æˆ·** | æ”¯æŒä¸‡èƒ½é™©ã€æŠ•è¿é™©ç­‰å¤æ‚äº§å“çš„çµæ´»è´¦æˆ·ç®¡ç† | è´¦æˆ·å¤„ç†æ•ˆç‡æå‡10å€ |
| 4 | **æ™ºèƒ½å®šä»·** | å»ºç«‹åŸºäºå¤§æ•°æ®çš„ç²¾å‡†å®šä»·æ¨¡å‹ï¼Œæ”¯æŒåŠ¨æ€è´¹ç‡è°ƒæ•´ | å®šä»·ç²¾å‡†åº¦æå‡30% |
| 5 | **ç›‘ç®¡åˆè§„** | å®ç°ç›‘ç®¡æ•°æ®è‡ªåŠ¨é‡‡é›†ã€æ ¡éªŒå’ŒæŠ¥é€ | ç›‘ç®¡æŠ¥é€è‡ªåŠ¨åŒ–ç‡>95% |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ç¼–å· | æŒ‘æˆ˜é¢†åŸŸ | å…·ä½“æè¿° | è§£å†³æ–¹æ¡ˆ |
|----------|----------|----------|----------|
| 1 | **äº§å“æ¨¡å‹æŠ½è±¡** | ä¿é™©äº§å“ç»“æ„å¤æ‚ï¼ˆæ¡æ¬¾ã€è´¹ç‡ã€è´£ä»»ã€ç‰¹çº¦ï¼‰ï¼Œä¸åŒé™©ç§å·®å¼‚å¤§ï¼Œéœ€å»ºç«‹ç»Ÿä¸€çš„äº§å“å…ƒæ¨¡å‹ | åŸºäºSchemaå®šä¹‰ä¿é™©äº§å“DSLï¼Œæ”¯æŒè´£ä»»ç»„åˆã€æ¡ä»¶è´¹ç‡ã€å¤šç»´åº¦ç‰¹çº¦ |
| 2 | **ç²¾ç®—æ•°æ®å®‰å…¨** | ç²¾ç®—æ•°æ®æ¶‰åŠå•†ä¸šæœºå¯†å’Œå®¢æˆ·éšç§ï¼Œéœ€ä¸¥æ ¼ç®¡æ§è®¿é—®æƒé™ï¼ŒåŒæ—¶æ”¯æŒå¤æ‚åˆ†æ | Schemaæ ‡è®°æ•°æ®æ•æ„Ÿåº¦ï¼ŒRBAC+ABACæ··åˆæƒé™æ¨¡å‹ï¼Œæ•°æ®è„±æ•å±•ç¤º |
| 3 | **å†å²æ•°æ®è¿ç§»** | 20å¹´å†å²ä¿å•æ•°æ®è¶…è¿‡50TBï¼Œæ•°æ®æ ¼å¼ä¸ç»Ÿä¸€ï¼Œéœ€ä¿è¯è¿ç§»è¿‡ç¨‹ä¿å•æƒç›Šæ— æŸ | åŒè½¨å¹¶è¡Œæ¶æ„ï¼ŒSchemaæ˜ å°„è½¬æ¢ï¼Œè¿ç§»è¿‡ç¨‹æƒç›Šè¯•ç®—æ ¡éªŒ |
| 4 | **é«˜å¹¶å‘å¤„ç†** | å¼€é—¨çº¢ç­‰ä¸šåŠ¡é«˜å³°æœŸæ—¥ä¿å•é‡è¶…è¿‡100ä¸‡å•ï¼Œéœ€æ”¯æŒé«˜å¹¶å‘æŠ•ä¿å’Œä¿å…¨å¤„ç† | å¾®æœåŠ¡æ¶æ„+è¯»å†™åˆ†ç¦»ï¼Œæ ¸å¿ƒæŠ•ä¿é“¾è·¯å¼‚æ­¥åŒ–ï¼ŒRedisç¼“å­˜çƒ­ç‚¹æ•°æ® |
| 5 | **å¤šæ¸ é“ååŒ** | ä»£ç†äººAPPã€å®˜ç½‘ã€å¾®ä¿¡å…¬ä¼—å·ã€é“¶ä¿é€šç­‰å¤šæ¸ é“åŒæ—¶æ¥å…¥ï¼Œéœ€ä¿è¯æ•°æ®ä¸€è‡´æ€§ | åŸºäºSchemaçš„APIç½‘å…³ï¼Œç»Ÿä¸€æ¥å…¥æ ‡å‡†ï¼Œåˆ†å¸ƒå¼äº‹åŠ¡Sagaæ¨¡å¼ |

### 2.5 Schemaå®šä¹‰

**ä¿é™©äº§å“é…ç½®Schema**ï¼š

```dsl
schema InsuranceProduct {
  // äº§å“åŸºç¡€ä¿¡æ¯
  product_basic: ProductBasicInfo {
    product_code: String @value("P2025L00001") @primary_key
    product_name: String @value("åå®‰åº·å®ç»ˆèº«é‡å¤§ç–¾ç—…ä¿é™©")
    product_type: Enum @value("LIFE_HEALTH")  // å¥åº·é™©
    product_category: Enum @value("CRITICAL_ILLNESS")  // é‡ç–¾é™©
    insurance_type: Enum @value("TERM_LIFE")  // å®šæœŸå¯¿é™©
    sale_status: Enum @value("ON_SALE")
    
    // ç›‘ç®¡æœºæ„å¤‡æ¡ˆä¿¡æ¯
    regulatory_info: RegulatoryInfo {
      approval_number: String @value("P0001-2025-A001")
      approval_date: Date @value("2025-01-01")
      regulatory_category: String @value("äººèº«é™©"
      filing_company: String @value("åå®‰ä¿é™©é›†å›¢")
    }
  }

  // æŠ•ä¿è§„åˆ™
  underwriting_rules: UnderwritingRules {
    // æŠ•ä¿å¹´é¾„é™åˆ¶
    age_limit: AgeLimit {
      min_age_days: Int @value(28)  // æœ€å°28å¤©
      max_age_years: Int @value(60)  // æœ€å¤§60å²
    }
    
    // ä¿é¢é™åˆ¶
    sum_assured_limit: SumAssuredLimit {
      min_amount: Decimal @value(100000.00)
      max_amount: Decimal @value(5000000.00)
      amount_step: Decimal @value(10000.00)
    }
    
    // ç¼´è´¹è§„åˆ™
    payment_rules: PaymentRules {
      payment_methods: List[Enum] @value(["LUMP_SUM", "ANNUAL", "MONTHLY"])
      payment_periods: List[Int] @value([1, 5, 10, 15, 20, 30])
      grace_period_days: Int @value(60)
      reinstatement_period_years: Int @value(2)
    }
    
    // èŒä¸šé™åˆ¶
    occupation_limit: OccupationLimit {
      allowed_categories: List[Int] @value([1, 2, 3, 4])  // 1-4ç±»èŒä¸š
      excluded_occupations: List[String] @value(["é«˜ç©ºä½œä¸š", "æ½œæ°´å‘˜"])
    }
    
    // å¥åº·å‘ŠçŸ¥
    health_declaration: HealthDeclaration {
      required: Boolean @value(true)
      questions: List[Question] {
        q1: Question {
          question_id: String @value("HD001")
          question_text: String @value("æ˜¯å¦æ›¾è¢«è¯Šæ–­æˆ–æ²»ç–—è¿‡ä»¥ä¸‹ç–¾ç—…ï¼šæ¶æ€§è‚¿ç˜¤...")
          answer_type: Enum @value("YES_NO")
          follow_up_action: String @value("MANUAL_REVIEW")
        }
      }
    }
  }

  // ä¿é™©è´£ä»»
  coverage_liabilities: List[CoverageLiability] {
    // é‡å¤§ç–¾ç—…ä¿é™©é‡‘
    liability1: CoverageLiability {
      liability_code: String @value("LIAB_001")
      liability_name: String @value("é‡å¤§ç–¾ç—…ä¿é™©é‡‘")
      liability_type: Enum @value("BASIC")
      payment_type: Enum @value("LUMP_SUM")
      
      // è´£ä»»è®¡ç®—
      calculation: CalculationRule {
        basis: Enum @value("SUM_ASSURED")
        multiplier: Decimal @value(1.0)
        min_amount: Decimal @value(100000.00)
        max_amount: Decimal @value(5000000.00)
      }
      
      // è¦†ç›–ç—…ç§
      covered_diseases: CoveredDiseases {
        total_count: Int @value(120)
        critical_illnesses: List[String] @value(["æ¶æ€§è‚¿ç˜¤", "æ€¥æ€§å¿ƒè‚Œæ¢—å¡", "è„‘ä¸­é£åé—ç—‡"])
        disease_grouping: Boolean @value(true)
        group_count: Int @value(6)
        max_claims_per_group: Int @value(1)
      }
      
      // ç­‰å¾…æœŸ
      waiting_period: WaitingPeriod {
        days: Int @value(180)
        exception: String @value("æ„å¤–ä¼¤å®³æ— ç­‰å¾…æœŸ")
      }
    }
    
    // è½»ç—‡ç–¾ç—…ä¿é™©é‡‘
    liability2: CoverageLiability {
      liability_code: String @value("LIAB_002")
      liability_name: String @value("è½»ç—‡ç–¾ç—…ä¿é™©é‡‘")
      liability_type: Enum @value("ADDITIONAL")
      
      calculation: CalculationRule {
        basis: Enum @value("SUM_ASSURED")
        multiplier: Decimal @value(0.3)
        max_claims: Int @value(3)
      }
      
      covered_diseases: CoveredDiseases {
        total_count: Int @value(40)
        waiting_period: WaitingPeriod {
          days: Int @value(90)
        }
      }
    }
    
    // èº«æ•…ä¿é™©é‡‘
    liability3: CoverageLiability {
      liability_code: String @value("LIAB_003")
      liability_name: String @value("èº«æ•…ä¿é™©é‡‘")
      liability_type: Enum @value("BASIC")
      
      calculation: CalculationRule {
        basis: Enum @value("MAX")
        options: List[String] @value(["SUM_ASSURED", "PAID_PREMIUM", "CASH_VALUE"])
      }
    }
  }

  // è´¹ç‡è¡¨
  premium_rates: PremiumRateTable {
    rate_type: Enum @value("AGE_GENDER_SMOKING")
    currency: String @value("CNY")
    unit: Decimal @value(1000.00)  // æ¯åƒå…ƒä¿é¢è´¹ç‡
    
    // è´¹ç‡åˆ†æ¡£
    rate_tiers: List[RateTier] {
      tier1: RateTier {
        age_range: Range @value([0, 30])
        gender: Enum @value("MALE")
        smoking_status: Enum @value("NON_SMOKER")
        rate_per_thousand: Decimal @value(2.5)
      }
      tier2: RateTier {
        age_range: Range @value([0, 30])
        gender: Enum @value("FEMALE")
        smoking_status: Enum @value("NON_SMOKER")
        rate_per_thousand: Decimal @value(2.2)
      }
    }
    
    // ä¼˜æƒ è§„åˆ™
    discount_rules: List[DiscountRule] {
      rule1: DiscountRule {
        rule_code: String @value("DISC_001")
        condition: String @value("payment_method == 'LUMP_SUM'")
        discount_rate: Decimal @value(0.95)
        description: String @value("è¶¸äº¤ä¼˜æƒ 5%")
      }
    }
  }

  // ç°é‡‘ä»·å€¼è¡¨
  cash_value_table: CashValueTable {
    calculation_method: Enum @value("PROSPECTIVE")
    surrender_charge_period: Int @value(5)
    
    // é€€ä¿è´¹ç”¨ç‡
    surrender_charges: List[SurrenderCharge] {
      year1: SurrenderCharge {
        policy_year: Int @value(1)
        charge_rate: Decimal @value(0.05)
      }
      year2: SurrenderCharge {
        policy_year: Int @value(2)
        charge_rate: Decimal @value(0.03)
      }
      year3: SurrenderCharge {
        policy_year: Int @value(3)
        charge_rate: Decimal @value(0.01)
      }
    }
  }

  // ç‰¹åˆ«çº¦å®š
  special_clauses: List[SpecialClause] {
    clause1: SpecialClause {
      clause_code: String @value("SC001")
      clause_type: Enum @value("EXCLUSION")
      clause_text: String @value("é—ä¼ æ€§ç–¾ç—…ã€å…ˆå¤©æ€§ç•¸å½¢ä¸åœ¨ä¿éšœèŒƒå›´")
      effective_date: Date @value("2025-01-01")
    }
  }

  // ç‰ˆæœ¬ç®¡ç†
  version_info: VersionInfo {
    version: String @value("1.0.0")
    effective_date: Date @value("2025-01-01")
    expiry_date: Optional[Date]
    created_by: String @value("äº§å“ç®¡ç†éƒ¨")
    approved_by: String @value("æ€»ç²¾ç®—å¸ˆ")
    approval_date: Date @value("2024-12-15")
  }
} @standard("CIRC äººèº«é™©äº§å“æ¡æ¬¾æ ¼å¼") @regulatory_filing_required(true)
```

---

### 2.6 ä»£ç å®ç°

**ä¿é™©äº§å“å·¥å‚ä¸ä¿å•ç®¡ç†ç³»ç»Ÿå®Œæ•´å®ç°**ï¼š

```python
"""
ä¿é™©äº§å“å·¥å‚ä¸ä¿å•ç®¡ç†ç³»ç»Ÿ - åŸºäºDSL Schemaé©±åŠ¨æ¶æ„
æ”¯æŒäº§å“å‚æ•°åŒ–é…ç½®ã€æ™ºèƒ½æ ¸ä¿ã€çµæ´»è´¦æˆ·ç®¡ç†
"""

import asyncio
import json
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Optional, Any, Union, Callable
from functools import lru_cache
import uuid

import redis.asyncio as redis
import asyncpg
from jinja2 import Template

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("InsuranceCoreSystem")


class ProductType(Enum):
    """äº§å“ç±»å‹"""
    LIFE_HEALTH = "å¥åº·é™©"
    LIFE_ENDOWMENT = "ä¸¤å…¨é™©"
    LIFE_ANNUITY = "å¹´é‡‘é™©"
    LIFE_WHOLE = "ç»ˆèº«å¯¿é™©"
    LIFE_TERM = "å®šæœŸå¯¿é™©"
    ACCIDENT = "æ„å¤–é™©"


class LiabilityType(Enum):
    """è´£ä»»ç±»å‹"""
    BASIC = "åŸºæœ¬è´£ä»»"
    ADDITIONAL = "é™„åŠ è´£ä»»"
    RIDER = "é™„åŠ é™©"


class PaymentType(Enum):
    """ç»™ä»˜ç±»å‹"""
    LUMP_SUM = "ä¸€æ¬¡æ€§ç»™ä»˜"
    ANNUITY = "å¹´é‡‘ç»™ä»˜"
    REIMBURSEMENT = "æŠ¥é”€"


class PolicyStatus(Enum):
    """ä¿å•çŠ¶æ€"""
    PENDING = "å¾…ç”Ÿæ•ˆ"
    INFORCE = "æœ‰æ•ˆ"
    LAPSED = "å¤±æ•ˆ"
    SURRENDERED = "é€€ä¿"
    MATURED = "æ»¡æœŸ"
    CLAIMED = "å·²ç†èµ”"


@dataclass
class AgeLimit:
    """å¹´é¾„é™åˆ¶"""
    min_age_days: int
    max_age_years: int


@dataclass
class SumAssuredLimit:
    """ä¿é¢é™åˆ¶"""
    min_amount: Decimal
    max_amount: Decimal
    amount_step: Decimal


@dataclass
class CalculationRule:
    """è®¡ç®—è§„åˆ™"""
    basis: str
    multiplier: Decimal = Decimal('1.0')
    min_amount: Decimal = Decimal('0')
    max_amount: Decimal = Decimal('999999999')
    options: List[str] = field(default_factory=list)


@dataclass
class CoverageLiability:
    """ä¿é™©è´£ä»»"""
    liability_code: str
    liability_name: str
    liability_type: LiabilityType
    payment_type: PaymentType
    calculation: CalculationRule
    waiting_period_days: int = 0
    max_claims: int = 1


@dataclass
class RateTier:
    """è´¹ç‡åˆ†æ¡£"""
    age_range: tuple
    gender: str
    smoking_status: str
    rate_per_thousand: Decimal


@dataclass
class InsuranceProduct:
    """ä¿é™©äº§å“å®ä½“"""
    product_code: str
    product_name: str
    product_type: ProductType
    sale_status: str
    approval_number: str
    
    # æŠ•ä¿è§„åˆ™
    age_limit: AgeLimit
    sum_assured_limit: SumAssuredLimit
    payment_methods: List[str]
    payment_periods: List[int]
    grace_period_days: int
    
    # è´£ä»»å’Œè´¹ç‡
    liabilities: List[CoverageLiability]
    rate_tiers: List[RateTier]
    currency: str = "CNY"
    
    # ç‰ˆæœ¬
    version: str = "1.0.0"
    effective_date: datetime = field(default_factory=datetime.now)


@dataclass
class Insured:
    """è¢«ä¿é™©äºº"""
    name: str
    gender: str
    birth_date: datetime
    id_type: str
    id_number: str
    occupation_code: str
    occupation_name: str
    smoking_status: str = "NON_SMOKER"
    height_cm: int = 0
    weight_kg: int = 0
    health_declaration: Dict = field(default_factory=dict)


@dataclass
class Policy:
    """ä¿å•å®ä½“"""
    policy_number: str
    product_code: str
    policy_status: PolicyStatus
    
    # æŠ•ä¿äººä¿¡æ¯
    applicant_name: str
    applicant_id_number: str
    applicant_phone: str
    
    # è¢«ä¿é™©äºº
    insured: Insured
    
    // ä¿å•è¦ç´ 
    sum_assured: Decimal
    premium: Decimal
    payment_method: str
    payment_period: int
    coverage_period: int
    
    // æ—¥æœŸ
    application_date: datetime
    effective_date: datetime
    first_premium_date: datetime
    next_premium_due_date: datetime
    maturity_date: datetime
    
    // è´¦æˆ·ä¿¡æ¯ï¼ˆä¸‡èƒ½é™©/æŠ•è¿é™©ï¼‰
    account_value: Decimal = Decimal('0')
    accumulated_premium: Decimal = Decimal('0')
    
    // çŠ¶æ€
    total_premiums_paid: Decimal = Decimal('0')
    lapse_date: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)


class ProductFactory:
    """äº§å“å·¥å‚ - åŸºäºSchemaçš„äº§å“é…ç½®ç®¡ç†"""
    
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.products: Dict[str, InsuranceProduct] = {}
    
    async def initialize(self):
        """åˆå§‹åŒ–äº§å“å·¥å‚"""
        self.redis_client = redis.Redis(
            host='localhost', port=6379, db=1, decode_responses=True
        )
        await self._load_products()
        logger.info("äº§å“å·¥å‚åˆå§‹åŒ–å®Œæˆ")
    
    async def _load_products(self):
        """åŠ è½½äº§å“é…ç½®"""
        # æ¨¡æ‹ŸåŠ è½½äº§å“
        product_data = {
            "product_code": "P2025L00001",
            "product_name": "åå®‰åº·å®ç»ˆèº«é‡å¤§ç–¾ç—…ä¿é™©",
            "product_type": "LIFE_HEALTH",
            "sale_status": "ON_SALE",
            "approval_number": "P0001-2025-A001",
            "age_limit": {"min_age_days": 28, "max_age_years": 60},
            "sum_assured_limit": {"min_amount": 100000, "max_amount": 5000000, "amount_step": 10000},
            "payment_methods": ["LUMP_SUM", "ANNUAL", "MONTHLY"],
            "payment_periods": [1, 5, 10, 15, 20, 30],
            "grace_period_days": 60,
            "liabilities": [
                {
                    "liability_code": "LIAB_001",
                    "liability_name": "é‡å¤§ç–¾ç—…ä¿é™©é‡‘",
                    "liability_type": "BASIC",
                    "payment_type": "LUMP_SUM",
                    "calculation": {"basis": "SUM_ASSURED", "multiplier": 1.0},
                    "waiting_period_days": 180,
                    "max_claims": 1
                },
                {
                    "liability_code": "LIAB_002",
                    "liability_name": "è½»ç—‡ç–¾ç—…ä¿é™©é‡‘",
                    "liability_type": "ADDITIONAL",
                    "payment_type": "LUMP_SUM",
                    "calculation": {"basis": "SUM_ASSURED", "multiplier": 0.3},
                    "waiting_period_days": 90,
                    "max_claims": 3
                }
            ],
            "rate_tiers": [
                {"age_range": [0, 30], "gender": "MALE", "smoking_status": "NON_SMOKER", "rate_per_thousand": 2.5},
                {"age_range": [0, 30], "gender": "FEMALE", "smoking_status": "NON_SMOKER", "rate_per_thousand": 2.2},
                {"age_range": [31, 40], "gender": "MALE", "smoking_status": "NON_SMOKER", "rate_per_thousand": 4.2},
                {"age_range": [31, 40], "gender": "FEMALE", "smoking_status": "NON_SMOKER", "rate_per_thousand": 3.8},
                {"age_range": [41, 50], "gender": "MALE", "smoking_status": "NON_SMOKER", "rate_per_thousand": 8.5},
                {"age_range": [41, 50], "gender": "FEMALE", "smoking_status": "NON_SMOKER", "rate_per_thousand": 7.2}
            ]
        }
        
        product = self._parse_product(product_data)
        self.products[product.product_code] = product
    
    def _parse_product(self, data: Dict) -> InsuranceProduct:
        """è§£æäº§å“æ•°æ®"""
        liabilities = []
        for liab_data in data.get("liabilities", []):
            liabilities.append(CoverageLiability(
                liability_code=liab_data["liability_code"],
                liability_name=liab_data["liability_name"],
                liability_type=LiabilityType(liab_data["liability_type"]),
                payment_type=PaymentType(liab_data["payment_type"]),
                calculation=CalculationRule(**liab_data["calculation"]),
                waiting_period_days=liab_data.get("waiting_period_days", 0),
                max_claims=liab_data.get("max_claims", 1)
            ))
        
        rate_tiers = []
        for tier_data in data.get("rate_tiers", []):
            rate_tiers.append(RateTier(
                age_range=tuple(tier_data["age_range"]),
                gender=tier_data["gender"],
                smoking_status=tier_data["smoking_status"],
                rate_per_thousand=Decimal(str(tier_data["rate_per_thousand"]))
            ))
        
        return InsuranceProduct(
            product_code=data["product_code"],
            product_name=data["product_name"],
            product_type=ProductType(data["product_type"]),
            sale_status=data["sale_status"],
            approval_number=data["approval_number"],
            age_limit=AgeLimit(**data["age_limit"]),
            sum_assured_limit=SumAssuredLimit(
                min_amount=Decimal(str(data["sum_assured_limit"]["min_amount"])),
                max_amount=Decimal(str(data["sum_assured_limit"]["max_amount"])),
                amount_step=Decimal(str(data["sum_assured_limit"]["amount_step"]))
            ),
            payment_methods=data["payment_methods"],
            payment_periods=data["payment_periods"],
            grace_period_days=data["grace_period_days"],
            liabilities=liabilities,
            rate_tiers=rate_tiers
        )
    
    def get_product(self, product_code: str) -> Optional[InsuranceProduct]:
        """è·å–äº§å“"""
        return self.products.get(product_code)
    
    def calculate_premium(self, product_code: str, 
                         sum_assured: Decimal,
                         insured_age: int,
                         insured_gender: str,
                         smoking_status: str,
                         payment_method: str,
                         payment_period: int) -> Dict:
        """è®¡ç®—ä¿è´¹"""
        product = self.get_product(product_code)
        if not product:
            return {"error": "äº§å“ä¸å­˜åœ¨"}
        
        # æŸ¥æ‰¾è´¹ç‡
        rate = self._find_rate(product, insured_age, insured_gender, smoking_status)
        if not rate:
            return {"error": "æœªæ‰¾åˆ°åŒ¹é…è´¹ç‡"}
        
        # è®¡ç®—å¹´ç¼´ä¿è´¹
        annual_premium = sum_assured / Decimal('1000') * rate.rate_per_thousand
        
        # æ ¹æ®ç¼´è´¹æ–¹å¼è°ƒæ•´
        if payment_method == "LUMP_SUM":
            # è¶¸äº¤ï¼Œè®¡ç®—ç°å€¼
            premium = annual_premium * Decimal(str(payment_period)) * Decimal('0.95')
        elif payment_method == "ANNUAL":
            premium = annual_premium
        elif payment_method == "MONTHLY":
            premium = annual_premium / Decimal('12') * Decimal('1.05')
        else:
            premium = annual_premium
        
        return {
            "product_code": product_code,
            "sum_assured": float(sum_assured),
            "annual_premium": float(annual_premium),
            "premium": float(premium.quantize(Decimal('0.01'))),
            "payment_method": payment_method,
            "payment_period": payment_period,
            "rate_per_thousand": float(rate.rate_per_thousand)
        }
    
    def _find_rate(self, product: InsuranceProduct, age: int, gender: str, smoking: str) -> Optional[RateTier]:
        """æŸ¥æ‰¾åŒ¹é…è´¹ç‡"""
        for tier in product.rate_tiers:
            if (tier.age_range[0] <= age <= tier.age_range[1] and
                tier.gender == gender and
                tier.smoking_status == smoking):
                return tier
        return None
    
    def validate_application(self, product_code: str, application: Dict) -> List[Dict]:
        """æ ¡éªŒæŠ•ä¿ç”³è¯·"""
        product = self.get_product(product_code)
        if not product:
            return [{"field": "product", "error": "äº§å“ä¸å­˜åœ¨"}]
        
        errors = []
        
        # æ ¡éªŒå¹´é¾„
        age = application.get("insured_age", 0)
        if age < product.age_limit.min_age_days / 365:
            errors.append({"field": "age", "error": f"å¹´é¾„ä½äºæœ€ä½è¦æ±‚{product.age_limit.min_age_days}å¤©"})
        if age > product.age_limit.max_age_years:
            errors.append({"field": "age", "error": f"å¹´é¾„è¶…è¿‡æœ€é«˜é™åˆ¶{product.age_limit.max_age_years}å²"})
        
        # æ ¡éªŒä¿é¢
        sum_assured = Decimal(str(application.get("sum_assured", 0)))
        if sum_assured < product.sum_assured_limit.min_amount:
            errors.append({"field": "sum_assured", "error": f"ä¿é¢ä½äºæœ€ä½è¦æ±‚{product.sum_assured_limit.min_amount}"})
        if sum_assured > product.sum_assured_limit.max_amount:
            errors.append({"field": "sum_assured", "error": f"ä¿é¢è¶…è¿‡æœ€é«˜é™åˆ¶{product.sum_assured_limit.max_amount}"})
        
        # æ ¡éªŒç¼´è´¹æ–¹å¼
        payment_method = application.get("payment_method")
        if payment_method not in product.payment_methods:
            errors.append({"field": "payment_method", "error": f"ä¸æ”¯æŒçš„ç¼´è´¹æ–¹å¼: {payment_method}"})
        
        # æ ¡éªŒç¼´è´¹æœŸé—´
        payment_period = application.get("payment_period", 0)
        if payment_period not in product.payment_periods:
            errors.append({"field": "payment_period", "error": f"ä¸æ”¯æŒçš„ç¼´è´¹æœŸé—´: {payment_period}"})
        
        return errors


class UnderwritingEngine:
    """æ™ºèƒ½æ ¸ä¿å¼•æ“"""
    
    def __init__(self):
        self.rules = self._load_underwriting_rules()
    
    def _load_underwriting_rules(self) -> List[Dict]:
        """åŠ è½½æ ¸ä¿è§„åˆ™"""
        return [
            {
                "rule_id": "UW_001",
                "name": "å¹´é¾„è¶…é™",
                "condition": lambda app: app.get("insured_age", 0) > 55,
                "decision": "DECLINE",
                "priority": 100
            },
            {
                "rule_id": "UW_002",
                "name": "BMIè¶…æ ‡",
                "condition": lambda app: self._calc_bmi(app) > 32,
                "decision": "RATED_UP",
                "loading": 1.25,
                "priority": 80
            },
            {
                "rule_id": "UW_003",
                "name": "é«˜å±èŒä¸š",
                "condition": lambda app: app.get("occupation_category", 1) > 4,
                "decision": "DECLINE",
                "priority": 100
            },
            {
                "rule_id": "UW_004",
                "name": "å¥åº·å‘ŠçŸ¥å¼‚å¸¸",
                "condition": lambda app: any(app.get("health_declaration", {}).values()),
                "decision": "MANUAL_REVIEW",
                "priority": 90
            },
            {
                "rule_id": "UW_005",
                "name": "ä¿é¢è¿‡é«˜",
                "condition": lambda app: Decimal(str(app.get("sum_assured", 0))) > Decimal('2000000'),
                "decision": "FINANCIAL_UNDERWRITING",
                "priority": 70
            }
        ]
    
    def _calc_bmi(self, application: Dict) -> float:
        """è®¡ç®—BMI"""
        height_m = application.get("height_cm", 170) / 100
        weight_kg = application.get("weight_kg", 65)
        if height_m > 0:
            return weight_kg / (height_m ** 2)
        return 0
    
    async def underwrite(self, application: Dict) -> Dict:
        """æ‰§è¡Œæ ¸ä¿"""
        decisions = []
        final_decision = "ACCEPT"
        loading = Decimal('1.0')
        
        for rule in sorted(self.rules, key=lambda r: r["priority"], reverse=True):
            try:
                if rule["condition"](application):
                    decisions.append({
                        "rule_id": rule["rule_id"],
                        "rule_name": rule["name"],
                        "decision": rule["decision"]
                    })
                    
                    # æ›´æ–°æœ€ç»ˆå†³ç­–
                    if rule["decision"] == "DECLINE":
                        final_decision = "DECLINE"
                        break
                    elif rule["decision"] == "MANUAL_REVIEW":
                        final_decision = "MANUAL_REVIEW"
                    elif rule["decision"] == "RATED_UP":
                        if final_decision not in ["DECLINE", "MANUAL_REVIEW"]:
                            final_decision = "RATED_UP"
                            loading *= Decimal(str(rule.get("loading", 1.0)))
            except Exception as e:
                logger.error(f"æ ¸ä¿è§„åˆ™ {rule['rule_id']} æ‰§è¡Œå¤±è´¥: {e}")
        
        return {
            "decision": final_decision,
            "decision_desc": {
                "ACCEPT": "æ ‡å‡†ä½“æ‰¿ä¿",
                "RATED_UP": "åŠ è´¹æ‰¿ä¿",
                "EXCLUSION": "é™¤å¤–æ‰¿ä¿",
                "MANUAL_REVIEW": "äººå·¥æ ¸ä¿",
                "DECLINE": "æ‹’ä¿"
            }.get(final_decision, final_decision),
            "loading": float(loading),
            "triggered_rules": decisions,
            "underwriting_time": datetime.now().isoformat()
        }


class PolicyManagementSystem:
    """ä¿å•ç®¡ç†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.db_pool: Optional[asyncpg.Pool] = None
        self.product_factory = ProductFactory()
        self.underwriting_engine = UnderwritingEngine()
    
    async def initialize(self):
        """åˆå§‹åŒ–ç³»ç»Ÿ"""
        self.redis_client = redis.Redis(
            host='localhost', port=6379, db=1, decode_responses=True
        )
        self.db_pool = await asyncpg.create_pool(
            host='localhost', port=5432,
            user='admin', password='admin',
            database='insurance_core'
        )
        await self.product_factory.initialize()
        logger.info("ä¿å•ç®¡ç†ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ")
    
    async def submit_application(self, application: Dict) -> Dict:
        """æäº¤æŠ•ä¿ç”³è¯·"""
        try:
            product_code = application.get("product_code")
            
            # 1. äº§å“æ ¡éªŒ
            errors = self.product_factory.validate_application(product_code, application)
            if errors:
                return {
                    "code": "VALIDATION_ERROR",
                    "message": "æŠ•ä¿ç”³è¯·æ ¡éªŒå¤±è´¥",
                    "errors": errors
                }
            
            # 2. æ™ºèƒ½æ ¸ä¿
            uw_result = await self.underwriting_engine.underwrite(application)
            
            if uw_result["decision"] == "DECLINE":
                return {
                    "code": "UNDERWRITING_DECLINE",
                    "message": "æœªé€šè¿‡æ ¸ä¿",
                    "underwriting_result": uw_result
                }
            
            # 3. è®¡ç®—ä¿è´¹
            premium_result = self.product_factory.calculate_premium(
                product_code=product_code,
                sum_assured=Decimal(str(application.get("sum_assured", 0))),
                insured_age=application.get("insured_age", 30),
                insured_gender=application.get("insured_gender", "MALE"),
                smoking_status=application.get("smoking_status", "NON_SMOKER"),
                payment_method=application.get("payment_method", "ANNUAL"),
                payment_period=application.get("payment_period", 20)
            )
            
            # 4. åº”ç”¨åŠ è´¹ç³»æ•°
            if uw_result["decision"] == "RATED_UP":
                premium_result["premium"] *= uw_result["loading"]
                premium_result["premium"] = round(premium_result["premium"], 2)
            
            # 5. ç”ŸæˆæŠ•ä¿å•å·
            application_no = f"APP{datetime.now().strftime('%Y%m%d')}{uuid.uuid4().hex[:8].upper()}"
            
            # 6. å­˜å‚¨æŠ•ä¿ç”³è¯·
            await self._store_application(application_no, application, uw_result, premium_result)
            
            return {
                "code": "SUCCESS",
                "message": "æŠ•ä¿ç”³è¯·æäº¤æˆåŠŸ",
                "data": {
                    "application_no": application_no,
                    "underwriting_result": uw_result,
                    "premium": premium_result,
                    "next_steps": ["æ”¯ä»˜é¦–æœŸä¿è´¹"] if uw_result["decision"] == "ACCEPT" else ["ç­‰å¾…äººå·¥æ ¸ä¿"]
                }
            }
            
        except Exception as e:
            logger.error(f"æŠ•ä¿ç”³è¯·æäº¤å¤±è´¥: {e}")
            return {"code": "SYSTEM_ERROR", "message": f"ç³»ç»Ÿå¼‚å¸¸: {str(e)}"}
    
    async def issue_policy(self, application_no: str, payment_confirmation: Dict) -> Dict:
        """æ‰¿ä¿å‡ºå•"""
        try:
            # 1. æŸ¥è¯¢æŠ•ä¿ç”³è¯·
            application = await self._get_application(application_no)
            if not application:
                return {"code": "NOT_FOUND", "message": "æŠ•ä¿ç”³è¯·ä¸å­˜åœ¨"}
            
            # 2. æ ¡éªŒæ”¯ä»˜
            if not await self._verify_payment(payment_confirmation):
                return {"code": "PAYMENT_FAILED", "message": "æ”¯ä»˜æ ¡éªŒå¤±è´¥"}
            
            # 3. ç”Ÿæˆä¿å•å·
            policy_number = f"POL{datetime.now().strftime('%Y%m%d')}{uuid.uuid4().hex[:8].upper()}"
            
            # 4. åˆ›å»ºä¿å•
            policy = await self._create_policy(policy_number, application)
            
            # 5. å­˜å‚¨ä¿å•
            await self._store_policy(policy)
            
            # 6. å‘é€ç”µå­ä¿å•
            await self._send_e_policy(policy)
            
            return {
                "code": "SUCCESS",
                "message": "ä¿å•æ‰¿ä¿æˆåŠŸ",
                "data": {
                    "policy_number": policy_number,
                    "effective_date": policy.effective_date.isoformat(),
                    "first_premium_date": policy.first_premium_date.isoformat(),
                    "next_premium_due_date": policy.next_premium_due_date.isoformat()
                }
            }
            
        except Exception as e:
            logger.error(f"æ‰¿ä¿å‡ºå•å¤±è´¥: {e}")
            return {"code": "SYSTEM_ERROR", "message": f"ç³»ç»Ÿå¼‚å¸¸: {str(e)}"}
    
    async def _store_application(self, application_no: str, application: Dict, 
                                 uw_result: Dict, premium: Dict):
        """å­˜å‚¨æŠ•ä¿ç”³è¯·"""
        key = f"application:{application_no}"
        data = {
            "application_no": application_no,
            "application_data": application,
            "underwriting_result": uw_result,
            "premium": premium,
            "status": "PENDING_PAYMENT",
            "created_at": datetime.now().isoformat()
        }
        await self.redis_client.setex(key, 86400, json.dumps(data))
    
    async def _get_application(self, application_no: str) -> Optional[Dict]:
        """æŸ¥è¯¢æŠ•ä¿ç”³è¯·"""
        key = f"application:{application_no}"
        data = await self.redis_client.get(key)
        return json.loads(data) if data else None
    
    async def _verify_payment(self, confirmation: Dict) -> bool:
        """æ ¡éªŒæ”¯ä»˜"""
        # æ¨¡æ‹Ÿæ”¯ä»˜æ ¡éªŒ
        return confirmation.get("status") == "SUCCESS"
    
    async def _create_policy(self, policy_number: str, application: Dict) -> Policy:
        """åˆ›å»ºä¿å•"""
        app_data = application.get("application_data", {})
        premium_data = application.get("premium", {})
        
        effective_date = datetime.now() + timedelta(days=1)
        
        return Policy(
            policy_number=policy_number,
            product_code=app_data.get("product_code"),
            policy_status=PolicyStatus.INFORCE,
            applicant_name=app_data.get("applicant_name"),
            applicant_id_number=app_data.get("applicant_id_number"),
            applicant_phone=app_data.get("applicant_phone"),
            insured=Insured(
                name=app_data.get("insured_name"),
                gender=app_data.get("insured_gender"),
                birth_date=datetime.strptime(app_data.get("insured_birth_date", "1990-01-01"), "%Y-%m-%d"),
                id_type="ID_CARD",
                id_number=app_data.get("insured_id_number"),
                occupation_code=app_data.get("occupation_code"),
                occupation_name=app_data.get("occupation_name")
            ),
            sum_assured=Decimal(str(app_data.get("sum_assured", 0))),
            premium=Decimal(str(premium_data.get("premium", 0))),
            payment_method=app_data.get("payment_method", "ANNUAL"),
            payment_period=app_data.get("payment_period", 20),
            coverage_period=app_data.get("coverage_period", 30),
            application_date=datetime.now(),
            effective_date=effective_date,
            first_premium_date=effective_date,
            next_premium_due_date=effective_date + timedelta(days=365),
            maturity_date=effective_date + timedelta(days=365 * app_data.get("coverage_period", 30)),
            total_premiums_paid=Decimal(str(premium_data.get("premium", 0)))
        )
    
    async def _store_policy(self, policy: Policy):
        """å­˜å‚¨ä¿å•"""
        key = f"policy:{policy.policy_number}"
        await self.redis_client.setex(key, 86400 * 365, json.dumps({
            "policy_number": policy.policy_number,
            "product_code": policy.product_code,
            "policy_status": policy.policy_status.value,
            "applicant_name": policy.applicant_name,
            "sum_assured": float(policy.sum_assured),
            "premium": float(policy.premium),
            "effective_date": policy.effective_date.isoformat()
        }))
    
    async def _send_e_policy(self, policy: Policy):
        """å‘é€ç”µå­ä¿å•"""
        logger.info(f"å‘é€ç”µå­ä¿å•è‡³: {policy.applicant_phone}")


# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºä¿é™©æ ¸å¿ƒç³»ç»Ÿä½¿ç”¨"""
    system = PolicyManagementSystem()
    await system.initialize()
    
    # æäº¤æŠ•ä¿ç”³è¯·
    application = {
        "product_code": "P2025L00001",
        "applicant_name": "å¼ ä¸‰",
        "applicant_id_number": "110101199001011234",
        "applicant_phone": "13800138000",
        "insured_name": "å¼ ä¸‰",
        "insured_gender": "MALE",
        "insured_age": 35,
        "insured_birth_date": "1990-01-01",
        "insured_id_number": "110101199001011234",
        "occupation_code": "001",
        "occupation_name": "ä¼ä¸šç®¡ç†äººå‘˜",
        "occupation_category": 2,
        "sum_assured": 1000000,
        "payment_method": "ANNUAL",
        "payment_period": 20,
        "coverage_period": 30,
        "height_cm": 175,
        "weight_kg": 70,
        "smoking_status": "NON_SMOKER",
        "health_declaration": {
            "q1": False,
            "q2": False,
            "q3": False
        }
    }
    
    result = await system.submit_application(application)
    print(f"æŠ•ä¿ç»“æœ: {json.dumps(result, ensure_ascii=False, indent=2)}")
    
    # å¦‚æœæ ¸ä¿é€šè¿‡ï¼Œæ¨¡æ‹Ÿæ”¯ä»˜å¹¶æ‰¿ä¿
    if result.get("code") == "SUCCESS":
        application_no = result["data"]["application_no"]
        payment_confirmation = {"status": "SUCCESS", "amount": result["data"]["premium"]["premium"]}
        
        policy_result = await system.issue_policy(application_no, payment_confirmation)
        print(f"\næ‰¿ä¿ç»“æœ: {json.dumps(policy_result, ensure_ascii=False, indent=2)}")


if __name__ == "__main__":
    asyncio.run(main())
```


### 2.7 æ•ˆæœè¯„ä¼°

#### 2.7.1 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ç±»åˆ« | æŒ‡æ ‡é¡¹ | å‡çº§å‰ | å‡çº§å | æå‡å¹…åº¦ |
|----------|--------|--------|--------|----------|
| **äº§å“åˆ›æ–°** | æ–°äº§å“ä¸Šçº¿å‘¨æœŸ | 6-8ä¸ªæœˆ | 2å‘¨ | **ç¼©çŸ­96%** |
| | äº§å“é…ç½®æ•ˆç‡ | äººå·¥ç¼–ç  | å‚æ•°åŒ–é…ç½® | **æ•ˆç‡æå‡10å€** |
| | äº§å“ç‰ˆæœ¬ç®¡ç† | æ— ç‰ˆæœ¬æ§åˆ¶ | å…¨ç”Ÿå‘½å‘¨æœŸç®¡ç† | **è§„èŒƒæ€§100%** |
| | äº§å“æµ‹è¯•å‘¨æœŸ | 4å‘¨ | 3å¤© | **ç¼©çŸ­82%** |
| **æ ¸ä¿æ•ˆç‡** | æ ‡å‡†ä½“è‡ªåŠ¨æ ¸ä¿ç‡ | 15% | 78% | **æå‡63%** |
| | æ ¸ä¿å¹³å‡æ—¶æ•ˆ | 3å¤© | 5åˆ†é’Ÿ | **æå‡99.7%** |
| | äººå·¥æ ¸ä¿å·¥ä½œé‡ | 100% | 22% | **é™ä½78%** |
| | æ ¸ä¿å‡†ç¡®ç‡ | 85% | 97% | **æå‡12%** |
| **ä¿å•ç®¡ç†** | ä¿å•æŸ¥è¯¢å“åº” | 5ç§’ | 200ms | **æå‡96%** |
| | ä¿å…¨å¤„ç†æ—¶æ•ˆ | 2å¤© | å®æ—¶ | **å®æ—¶åŒ–** |
| | ä¿å•å˜æ›´æˆåŠŸç‡ | 92% | 99.5% | **æå‡7.5%** |
| | è´¦æˆ·è®¡ç®—ç²¾åº¦ | åˆ† | å˜ | **ç²¾åº¦æå‡10å€** |
| **å®¢æˆ·æœåŠ¡** | ç”µå­ä¿å•å‘é€æ—¶æ•ˆ | 24å°æ—¶ | å®æ—¶ | **å®æ—¶åŒ–** |
| | å®¢æˆ·è‡ªåŠ©æœåŠ¡ç‡ | 30% | 75% | **æå‡45%** |
| | å®¢æˆ·æ»¡æ„åº¦ | 82% | 94% | **æå‡12%** |
| | æŠ•è¯‰ç‡ | 0.8% | 0.15% | **é™ä½81%** |
| **ç›‘ç®¡åˆè§„** | ç›‘ç®¡æŠ¥é€æ—¶æ•ˆ | T+5 | T+1 | **ç¼©çŸ­80%** |
| | æ•°æ®å‡†ç¡®ç‡ | 88% | 99.2% | **æå‡11.2%** |
| | åˆè§„æ£€æŸ¥é€šè¿‡ç‡ | 75% | 98% | **æå‡23%** |

#### 2.7.2 ä¸šåŠ¡ä»·å€¼è¯„ä¼°

| ä»·å€¼ç»´åº¦ | å…·ä½“æ”¶ç›Š | é‡åŒ–æŒ‡æ ‡ | ROIè®¡ç®— |
|----------|----------|----------|---------|
| **äº§å“åˆ›æ–°æ”¶ç›Š** | æ–°äº§å“å¿«é€Ÿä¸Šçº¿å¸¦æ¥çš„ä¿è´¹å¢é•¿ | å¹´åº¦æ–°å¢ä¿è´¹ï¼šÂ¥18äº¿ | 3å¹´ç´¯è®¡ï¼šÂ¥54äº¿ |
| **è¿è¥æˆæœ¬èŠ‚çº¦** | æ ¸ä¿äººåŠ›æˆæœ¬ã€ä¿å•ç®¡ç†æˆæœ¬é™ä½ | å¹´åº¦èŠ‚çº¦æˆæœ¬ï¼šÂ¥6,500ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥1.95äº¿ |
| **é£é™©æŸå¤±å‡å°‘** | æ ¸ä¿å‡†ç¡®ç‡æå‡å¸¦æ¥çš„èµ”ä»˜å‡å°‘ | å¹´åº¦å‡å°‘æŸå¤±ï¼šÂ¥2,800ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥8,400ä¸‡ |
| **å®¢æˆ·ä½“éªŒä»·å€¼** | å®¢æˆ·æ»¡æ„åº¦æå‡å¸¦æ¥çš„ç»­ä¿ç‡å¢é•¿ | ç»­ä¿ç‡æå‡15% | å®¢æˆ·ç»ˆèº«ä»·å€¼æå‡Â¥32äº¿ |
| **åˆè§„ä»·å€¼** | ç›‘ç®¡æŠ¥é€è‡ªåŠ¨åŒ–ã€åˆè§„æˆæœ¬é™ä½ | åˆè§„æˆæœ¬é™ä½60% | å¹´åº¦èŠ‚çº¦Â¥3,000ä¸‡ |

**æ€»æŠ•èµ„å›æŠ¥ç‡ï¼ˆROIï¼‰**ï¼š
- é¡¹ç›®æ€»æŠ•èµ„ï¼šÂ¥4.8äº¿ï¼ˆå«ç³»ç»Ÿå»ºè®¾ã€æ•°æ®è¿ç§»ã€äººå‘˜åŸ¹è®­ï¼‰
- é¦–å¹´æ”¶ç›Šï¼šÂ¥24.8äº¿
- 3å¹´ç´¯è®¡æ”¶ç›Šï¼šÂ¥96.25äº¿
- **3å¹´ROI = 1,905%**
- **æŠ•èµ„å›æ”¶æœŸ = 2.3ä¸ªæœˆ**

#### 2.7.3 ç»éªŒæ•™è®­

**æˆåŠŸç»éªŒ**ï¼š

1. **äº§å“DSLæ ‡å‡†åŒ–**ï¼šå»ºç«‹äº†ç»Ÿä¸€çš„ä¿é™©äº§å“é¢†åŸŸç‰¹å®šè¯­è¨€ï¼ˆDSLï¼‰ï¼Œå°†äº§å“è¦ç´ æŠ½è±¡ä¸º12å¤§ç±»ã€200+å±æ€§ï¼Œæ”¯æŒä»»æ„ç»„åˆé…ç½®ã€‚äº§å“DSLä½¿ä¸šåŠ¡äººå‘˜èƒ½å¤Ÿç›´æ¥å‚ä¸äº§å“è®¾è®¡ï¼Œå¼€å‘æ²Ÿé€šæ•ˆç‡æå‡70%ã€‚

2. **å¾®æœåŠ¡+äº‹ä»¶é©±åŠ¨**ï¼šæ ¸å¿ƒç³»ç»Ÿæ‹†åˆ†ä¸ºäº§å“ã€æ‰¿ä¿ã€ä¿å…¨ã€ç†èµ”ã€è´¢åŠ¡ç­‰8ä¸ªå¾®æœåŠ¡ï¼Œé€šè¿‡Kafkaäº‹ä»¶æ€»çº¿è¿›è¡Œå¼‚æ­¥é€šä¿¡ã€‚æœåŠ¡è§£è€¦ä½¿å•æœåŠ¡æ•…éšœä¸å½±å“å…¨å±€ï¼Œç³»ç»Ÿå¯ç”¨æ€§è¾¾99.99%ã€‚

3. **æ•°æ®åŒè½¨å¹¶è¡Œ**ï¼šæ–°æ—§ç³»ç»Ÿå¹¶è¡Œè¿è¡Œ6ä¸ªæœˆï¼Œæ¯æ—¥è¿›è¡Œæ•°æ®å¯¹è´¦å’Œå·®å¼‚åˆ†æã€‚Schemaæ˜ å°„å·¥å…·ç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼Œè¿ç§»è¿‡ç¨‹é›¶ä¿å•æƒç›ŠæŸå¤±ã€‚

**æ•™è®­ä¸æ”¹è¿›**ï¼š

1. **é—ç•™æ¥å£å…¼å®¹**ï¼š300+å¤–å›´ç³»ç»Ÿæ¥å£æ ¼å¼ä¸ä¸€ï¼ŒåˆæœŸé›†æˆå·¥ä½œé‡è¶…é¢„æœŸã€‚æ”¹è¿›ï¼šå»ºç«‹APIç½‘å…³ï¼Œç»Ÿä¸€æ¥å…¥æ ‡å‡†ï¼Œæä¾›SDKç®€åŒ–é›†æˆã€‚

2. **ç²¾ç®—æ¨¡å‹è¿ç§»**ï¼šä¼ ç»Ÿç²¾ç®—æ¨¡å‹ä»£ç é€»è¾‘å¤æ‚ï¼Œè¿ç§»è¿‡ç¨‹ä¸­å‘ç°å¤šå¤„éšå¼å‡è®¾ã€‚æ”¹è¿›ï¼šå»ºç«‹ç²¾ç®—æ¨¡å‹çŸ¥è¯†åº“ï¼Œè¯¦ç»†è®°å½•æ¯ä¸ªè®¡ç®—å…¬å¼çš„ä¸šåŠ¡å«ä¹‰ã€‚

3. **ç»„ç»‡å˜é©ç®¡ç†**ï¼šæ ¸å¿ƒç³»ç»Ÿå‡çº§æ¶‰åŠ20+éƒ¨é—¨åä½œï¼ŒåˆæœŸåè°ƒæˆæœ¬é«˜ã€‚æ”¹è¿›ï¼šæˆç«‹é¡¹ç›®PMOï¼Œå»ºç«‹å‘¨ä¾‹ä¼šæœºåˆ¶ï¼Œè®¾ç«‹ä¸“é¡¹æ¿€åŠ±ã€‚

---

## 3. æ¡ˆä¾‹2ï¼šäº’è”ç½‘ä¿é™©æ™ºèƒ½æ ¸ä¿ç³»ç»Ÿ

### 3.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šä¼—å®‰åœ¨çº¿XXäº‹ä¸šéƒ¨ï¼ˆåŒ–åï¼šäº‘ä¿ç§‘æŠ€ï¼‰  
**ä¼ä¸šè§„æ¨¡**ï¼šå¹´åº¦ä¿è´¹æ”¶å…¥è¶…è¿‡80äº¿å…ƒï¼ŒæœåŠ¡å®¢æˆ·è¶…è¿‡5,000ä¸‡äººï¼Œæ—¥å‡æŠ•ä¿é‡è¶…è¿‡10ä¸‡å•  
**ä¸šåŠ¡ç‰¹è‰²**ï¼šä¸“æ³¨äº’è”ç½‘åœºæ™¯ä¿é™©ï¼Œæ¶µç›–é€€è´§è¿è´¹é™©ã€æ„å¤–é™©ã€å¥åº·é™©ã€è´¢äº§é™©ç­‰ç¢ç‰‡åŒ–é™©ç§  
**æ ¸ä¿ç°çŠ¶**ï¼šä¼ ç»Ÿäººå·¥æ ¸ä¿æ— æ³•æ»¡è¶³äº’è”ç½‘é«˜å¹¶å‘éœ€æ±‚ï¼Œé«˜å³°æœŸæ ¸ä¿ç§¯å‹ä¸¥é‡ï¼Œå®¢æˆ·æµå¤±ç‡é«˜

äº‘ä¿ç§‘æŠ€ä½œä¸ºå›½å†…é¢†å…ˆçš„äº’è”ç½‘ä¿é™©å…¬å¸ï¼Œå…¶ä¸šåŠ¡æ¨¡å¼é«˜åº¦ä¾èµ–çº¿ä¸Šè‡ªåŠ¨æ ¸ä¿ã€‚éšç€ä¸šåŠ¡å¿«é€Ÿå¢é•¿ï¼Œæ—¥å‡æ ¸ä¿è¯·æ±‚ä»1ä¸‡æ¿€å¢è‡³10ä¸‡+ï¼Œä¼ ç»Ÿæ ¸ä¿ç³»ç»Ÿé¢ä¸´ä¸¥å³»æŒ‘æˆ˜ã€‚åŒæ—¶ï¼Œäº’è”ç½‘ä¿é™©æ¬ºè¯ˆæ‰‹æ®µå±‚å‡ºä¸ç©·ï¼Œæ€¥éœ€æ„å»ºæ™ºèƒ½åŒ–ã€å®æ—¶åŒ–çš„æ ¸ä¿é£æ§ä½“ç³»ã€‚

### 3.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹é¢†åŸŸ | å…·ä½“é—®é¢˜æè¿° | ä¸šåŠ¡å½±å“ |
|------|----------|--------------|----------|
| 1 | **æ ¸ä¿æ—¶æ•ˆæ…¢** | é«˜å³°æœŸæ ¸ä¿é˜Ÿåˆ—ç§¯å‹ï¼Œå¹³å‡ç­‰å¾…æ—¶é—´è¶…è¿‡30ç§’ï¼Œå®¢æˆ·æµå¤±ç‡é«˜è¾¾40% | ä¿è´¹æŸå¤±ä¸¥é‡ï¼Œè·å®¢æˆæœ¬æµªè´¹ |
| 2 | **é€†é€‰æ‹©ä¸¥é‡** | æ— æ³•æœ‰æ•ˆè¯†åˆ«å¸¦ç—…æŠ•ä¿ã€è¶…é¢æŠ•ä¿ç­‰é€†é€‰æ‹©è¡Œä¸ºï¼Œèµ”ä»˜ç‡å±…é«˜ä¸ä¸‹ | ç»¼åˆæˆæœ¬ç‡(COR)é«˜è¾¾105% |
| 3 | **æ¬ºè¯ˆè¯†åˆ«å¼±** | å›¢ä¼™æ¬ºè¯ˆã€è™šå‡èº«ä»½ã€éª—ä¿æ¡ˆä»¶é¢‘å‘ï¼Œå¹´æ¬ºè¯ˆæŸå¤±è¶…è¿‡Â¥2,000ä¸‡ | ç›´æ¥ç»æµæŸå¤±ï¼Œåˆè§„é£é™© |
| 4 | **é£æ§è§„åˆ™åƒµåŒ–** | é£æ§è§„åˆ™ç¡¬ç¼–ç ï¼Œè°ƒæ•´éœ€è¦å‘ç‰ˆï¼Œå“åº”å¸‚åœºå˜åŒ–æ…¢ | é»‘äº§å¯¹æŠ—è¢«åŠ¨ï¼Œé£é™©æ•å£å¤§ |
| 5 | **æ•°æ®åˆ©ç”¨ä¸è¶³** | æ‹¥æœ‰æµ·é‡æŠ•ä¿æ•°æ®ä½†æœªå……åˆ†åˆ©ç”¨ï¼Œé£æ§ä¸»è¦ä¾èµ–ç®€å•è§„åˆ™ | ç²¾å‡†é£æ§èƒ½åŠ›å¼± |

### 3.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ç»´åº¦ | å…·ä½“ç›®æ ‡ | é¢„æœŸæŒ‡æ ‡ |
|------|----------|----------|----------|
| 1 | **å®æ—¶æ ¸ä¿** | å®ç°æ¯«ç§’çº§æ™ºèƒ½æ ¸ä¿å†³ç­–ï¼Œæ”¯æ’‘é«˜å¹¶å‘æŠ•ä¿ | æ ¸ä¿å“åº”<100msï¼Œååé‡>50,000TPS |
| 2 | **ç²¾å‡†é£æ§** | æ„å»ºAIé©±åŠ¨çš„é£é™©è¯†åˆ«æ¨¡å‹ï¼Œç²¾å‡†æ‹¦æˆªé«˜é£é™©æŠ•ä¿ | é€†é€‰æ‹©è¯†åˆ«ç‡>90%ï¼Œè¯¯æ€ç‡<3% |
| 3 | **åŠ¨æ€å¯¹æŠ—** | å»ºç«‹è§„åˆ™åŠ¨æ€è°ƒæ•´æœºåˆ¶ï¼Œå¿«é€Ÿå“åº”æ–°å‹æ¬ºè¯ˆæ‰‹æ®µ | è§„åˆ™è°ƒæ•´æ—¶æ•ˆ<1å°æ—¶ |
| 4 | **æ™ºèƒ½å®šä»·** | åŸºäºé£é™©è¯„åˆ†å®ç°åƒäººåƒä»·ï¼Œä¼˜åŒ–æ‰¿ä¿åˆ©æ¶¦ | å®šä»·ç²¾å‡†åº¦æå‡25% |
| 5 | **åˆè§„é€æ˜** | å»ºç«‹å¯è§£é‡Šçš„é£æ§å†³ç­–ä½“ç³»ï¼Œæ»¡è¶³ç›‘ç®¡è¦æ±‚ | å†³ç­–å¯è§£é‡Šç‡100% |

### 3.4 æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ç¼–å· | æŒ‘æˆ˜é¢†åŸŸ | å…·ä½“æè¿° | è§£å†³æ–¹æ¡ˆ |
|----------|----------|----------|----------|
| 1 | **è¶…é«˜å¹¶å‘å¤„ç†** | ä¿ƒé”€æ´»åŠ¨æœŸé—´æ ¸ä¿è¯·æ±‚å³°å€¼è¾¾20ä¸‡QPSï¼Œéœ€åœ¨100mså†…è¿”å›å†³ç­– | å¤šçº§ç¼“å­˜+æœ¬åœ°è®¡ç®—ï¼ŒRedis Clusterå­˜å‚¨çƒ­æ•°æ®ï¼Œæ ¸ä¿å†³ç­–æœ¬åœ°ç¼“å­˜ |
| 2 | **å®æ—¶ç‰¹å¾è®¡ç®—** | å•ç¬”æ ¸ä¿éœ€å®æ—¶è®¡ç®—500+é£é™©ç‰¹å¾ï¼ŒåŒ…æ‹¬è®¾å¤‡æŒ‡çº¹ã€è¡Œä¸ºåºåˆ—ã€å›¾è°±å…³è”ç­‰ | Flinkæµå¤„ç†+ç‰¹å¾é¢„è®¡ç®—ï¼ŒSchemaå®šä¹‰ç‰¹å¾ä¾èµ–å…³ç³»å›¾ |
| 3 | **æ¨¡å‹å®æ—¶æ›´æ–°** | é£æ§æ¨¡å‹éœ€æ¯æ—¥æ›´æ–°ï¼Œæ›´æ–°è¿‡ç¨‹ä¸èƒ½å½±å“åœ¨çº¿æœåŠ¡ | è“ç»¿éƒ¨ç½²+æ¨¡å‹ç‰ˆæœ¬ç®¡ç†ï¼ŒSchemaå®šä¹‰æ¨¡å‹æ¥å£å¥‘çº¦ |
| 4 | **å¯è§£é‡Šæ€§è¦æ±‚** | ç›‘ç®¡è¦æ±‚æ ¸ä¿æ‹’ä¿å¿…é¡»æœ‰æ˜ç¡®ä¾æ®ï¼Œéœ€æ”¯æŒå†³ç­–è§£é‡Š | SchemaåµŒå…¥è§„åˆ™å…ƒæ•°æ®ï¼Œè‡ªåŠ¨ç”Ÿæˆå†³ç­–è§£é‡Š |
| 5 | **æ•°æ®å®‰å…¨åˆè§„** | æ¶‰åŠå¥åº·å‘ŠçŸ¥ç­‰æ•æ„Ÿä¿¡æ¯ï¼Œéœ€æ»¡è¶³ã€Šä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ã€‹ | æ•°æ®è„±æ•+å·®åˆ†éšç§ï¼ŒSchemaæ ‡è®°æ•æ„Ÿç­‰çº§ |

### 3.5 Schemaå®šä¹‰

**æ™ºèƒ½æ ¸ä¿å†³ç­–Schema**ï¼š

```dsl
schema IntelligentUnderwriting {
  // æŠ•ä¿è¯·æ±‚
  application: UnderwritingApplication {
    application_id: String @value("APP20250121000001")
    product_code: String @value("PA2025ACC001")
    channel: String @value("WECHAT_MINI")
    application_time: DateTime @value("2025-01-21T14:30:25.123Z")
    
    // æŠ•ä¿äººä¿¡æ¯
    applicant: ApplicantInfo {
      name_hash: String @value("HASH-abc123...") @sensitive
      id_hash: String @value("HASH-def456...") @sensitive
      phone_hash: String @value("HASH-ghi789...") @sensitive
      age: Int @value(28)
      gender: Enum @value("MALE")
      occupation_category: Int @value(2)
      city: String @value("ä¸Šæµ·å¸‚")
    }
    
    // æŠ•ä¿è®¡åˆ’
    coverage_plan: CoveragePlan {
      sum_assured: Decimal @value(1000000.00)
      coverage_period: Int @value(1)  // å¹´
      premium: Decimal @value(365.00)
      deductible: Decimal @value(10000.00)
    }
    
    // å¥åº·å‘ŠçŸ¥
    health_declaration: HealthDeclaration {
      has_chronic_disease: Boolean @value(false)
      has_surgery_history: Boolean @value(false)
      has_family_history: Boolean @value(false)
      bmi: Decimal @value(22.5)
    }
  }

  // è®¾å¤‡ä¸ç¯å¢ƒä¿¡æ¯
  device_context: DeviceContext {
    device_id: String @value("DEV-a1b2c3d4")
    device_type: Enum @value("ANDROID")
    os_version: String @value("13.0")
    app_version: String @value("3.5.0")
    device_fingerprint: String @value("FP-xyz789...")
    
    // å®‰å…¨æŒ‡æ ‡
    security_indicators: SecurityIndicators {
      is_emulator: Boolean @value(false)
      is_rooted: Boolean @value(false)
      is_proxy: Boolean @value(false)
      is_vpn: Boolean @value(false)
      risk_score: Decimal @value(12.0)
    }
    
    // è¡Œä¸ºç‰¹å¾
    behavior_features: BehaviorFeatures {
      input_speed_wpm: Decimal @value(45.5)
      field_change_count: Int @value(3)
      hesitation_time_ms: Int @value(2500)
      form_completion_time_sec: Int @value(180)
      is_paste_used: Boolean @value(false)
    }
  }

  // å†å²è¡Œä¸º
  historical_behavior: HistoricalBehavior {
    // æœ¬ç”¨æˆ·å†å²
    user_history: UserHistory {
      previous_applications_30d: Int @value(0)
      previous_policies: Int @value(2)
      claim_count_12m: Int @value(0)
      total_premium_12m: Decimal @value(1250.00)
      payment_history: Enum @value("GOOD")
    }
    
    // è®¾å¤‡å†å²
    device_history: DeviceHistory {
      unique_users_30d: Int @value(1)
      application_count_30d: Int @value(2)
      claim_count_30d: Int @value(0)
      is_shared_device: Boolean @value(false)
    }
    
    // IPå†å²
    ip_history: IPHistory {
      ip: String @value("123.45.67.89") @sensitive
      unique_users_24h: Int @value(5)
      application_count_24h: Int @value(12)
      is_high_risk_ip: Boolean @value(false)
    }
  }

  // å›¾è°±ç‰¹å¾
  graph_features: GraphFeatures {
    // å…³è”ç”¨æˆ·
    connected_users: ConnectedUsers {
      same_device_users: Int @value(0)
      same_ip_users_24h: Int @value(4)
      same_phone_prefix_users: Int @value(1)
    }
    
    // é»‘äº§å…³è”
    fraud_association: FraudAssociation {
      blacklisted_connections: Int @value(0)
      greylisted_connections: Int @value(1)
      fraud_community_score: Decimal @value(15.0)
    }
  }

  // å¤–éƒ¨æ•°æ®
  external_data: ExternalData {
    // å¾ä¿¡æ•°æ®
    credit_data: CreditData @sensitive {
      credit_score: Int @value(750)
      overdue_count_24m: Int @value(0)
      inquiry_count_3m: Int @value(1)
    }
    
    // å¸æ³•æ•°æ®
    judicial_data: JudicialData {
      lawsuit_count: Int @value(0)
      execution_count: Int @value(0)
      is_dishonest: Boolean @value(false)
    }
    
    // åæ¬ºè¯ˆè”ç›Ÿ
    antifraud_alliance: AntifraudAlliance {
      fraud_flag: Boolean @value(false)
      risk_tag: Optional[String]
      confidence: Decimal @value(0.0)
    }
  }

  // é£é™©è¯„åˆ†
  risk_assessment: RiskAssessment {
    // ç»¼åˆè¯„åˆ†
    composite_score: Decimal @value(25.5)
    risk_level: Enum @value("LOW")
    
    // åˆ†é¡¹è¯„åˆ†
    sub_scores: SubScores {
      identity_risk: Decimal @value(10.0)
      device_risk: Decimal @value(12.0)
      behavior_risk: Decimal @value(15.0)
      credit_risk: Decimal @value(5.0)
      association_risk: Decimal @value(20.0)
    }
    
    // æ¨¡å‹è¯„åˆ†
    model_scores: ModelScores {
      xgb_score: Decimal @value(0.25)
      dnn_score: Decimal @value(0.18)
      graph_score: Decimal @value(0.22)
      ensemble_score: Decimal @value(0.22)
    }
  }

  // æ ¸ä¿å†³ç­–
  underwriting_decision: UnderwritingDecision {
    decision: Enum @value("ACCEPT")
    decision_code: String @value("UW000")
    confidence: Decimal @value(0.95)
    
    // è§¦å‘è§„åˆ™
    triggered_rules: List[TriggeredRule] {
      rule1: TriggeredRule {
        rule_id: String @value("UW001")
        rule_name: String @value("æ ‡å‡†ä½“è§„åˆ™")
        rule_type: Enum @value("AUTO")
        score_contribution: Decimal @value(-10.0)
        explanation: String @value("æŠ•ä¿äººå¹´é¾„ã€èŒä¸šã€å¥åº·çŠ¶å†µç¬¦åˆæ ‡å‡†ä½“è¦æ±‚")
      }
    }
    
    // å®šä»·è°ƒæ•´
    pricing_adjustment: PricingAdjustment {
      base_premium: Decimal @value(365.00)
      risk_adjustment_rate: Decimal @value(1.0)
      final_premium: Decimal @value(365.00)
      adjustment_reason: Optional[String]
    }
    
    // å†³ç­–è§£é‡Š
    decision_explanation: DecisionExplanation {
      summary: String @value("æŠ•ä¿äººé£é™©è¯„åˆ†ä½ï¼Œè‡ªåŠ¨æ‰¿ä¿")
      key_factors: List[String] @value(["æ— å†å²ç†èµ”è®°å½•", "è®¾å¤‡ç¯å¢ƒå®‰å…¨", "è¡Œä¸ºç‰¹å¾æ­£å¸¸"])
      recommendations: List[String] @value([])
    }
  }

  // æ€§èƒ½æŒ‡æ ‡
  performance_metrics: PerformanceMetrics {
    total_latency_ms: Int @value(45)
    feature_calculation_ms: Int @value(15)
    model_inference_ms: Int @value(12)
    rule_evaluation_ms: Int @value(8)
    decision_generation_ms: Int @value(10)
  }
} @standard("äº’è”ç½‘ä¿é™©ç›‘ç®¡åŠæ³•") @data_classification("SENSITIVE")
```

---

### 3.6 ä»£ç å®ç°

**äº’è”ç½‘ä¿é™©æ™ºèƒ½æ ¸ä¿å¼•æ“å®Œæ•´å®ç°**ï¼š

```python
"""
äº’è”ç½‘ä¿é™©æ™ºèƒ½æ ¸ä¿å¼•æ“ - åŸºäºDSL Schemaçš„å®æ—¶é£æ§ç³»ç»Ÿ
æ”¯æŒé«˜å¹¶å‘æ ¸ä¿ã€AIé£é™©è¯†åˆ«ã€åŠ¨æ€è§„åˆ™ç®¡ç†
"""

import asyncio
import json
import logging
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple
import hashlib
import numpy as np

import redis.asyncio as redis
from kafka import KafkaProducer
import tensorflow as tf

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("IntelligentUnderwriting")


class UnderwritingDecision(Enum):
    """æ ¸ä¿å†³ç­–æšä¸¾"""
    ACCEPT = "æ¥å—"
    RATED_UP = "åŠ è´¹"
    EXCLUSION = "é™¤å¤–"
    MANUAL_REVIEW = "äººå·¥å®¡æ ¸"
    DECLINE = "æ‹’ä¿"
    POSTPONE = "å»¶æœŸ"


class RiskLevel(Enum):
    """é£é™©ç­‰çº§æšä¸¾"""
    VERY_LOW = "æä½"
    LOW = "ä½"
    MEDIUM = "ä¸­"
    HIGH = "é«˜"
    VERY_HIGH = "æé«˜"


@dataclass
class ApplicantInfo:
    """æŠ•ä¿äººä¿¡æ¯"""
    name_hash: str
    id_hash: str
    phone_hash: str
    age: int
    gender: str
    occupation_category: int
    city: str


@dataclass
class CoveragePlan:
    """æŠ•ä¿è®¡åˆ’"""
    sum_assured: Decimal
    coverage_period: int
    premium: Decimal
    deductible: Decimal


@dataclass
class SecurityIndicators:
    """å®‰å…¨æŒ‡æ ‡"""
    is_emulator: bool
    is_rooted: bool
    is_proxy: bool
    is_vpn: bool
    risk_score: Decimal


@dataclass
class BehaviorFeatures:
    """è¡Œä¸ºç‰¹å¾"""
    input_speed_wpm: Decimal
    field_change_count: int
    hesitation_time_ms: int
    form_completion_time_sec: int
    is_paste_used: bool


@dataclass
class RiskAssessment:
    """é£é™©è¯„ä¼°"""
    composite_score: Decimal
    risk_level: RiskLevel
    identity_risk: Decimal
    device_risk: Decimal
    behavior_risk: Decimal
    credit_risk: Decimal
    association_risk: Decimal


@dataclass
class UnderwritingResult:
    """æ ¸ä¿ç»“æœ"""
    application_id: str
    decision: UnderwritingDecision
    decision_code: str
    confidence: Decimal
    risk_score: Decimal
    risk_level: RiskLevel
    final_premium: Decimal
    triggered_rules: List[Dict]
    explanation: str
    latency_ms: int


class FeatureCalculationEngine:
    """ç‰¹å¾è®¡ç®—å¼•æ“"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.feature_cache = {}
    
    async def calculate_features(self, application: Dict) -> Dict[str, Any]:
        """è®¡ç®—æ ¸ä¿ç‰¹å¾"""
        features = {}
        
        # å¹¶è¡Œè®¡ç®—å„ç±»ç‰¹å¾
        await asyncio.gather(
            self._calc_identity_features(application, features),
            self._calc_device_features(application, features),
            self._calc_behavior_features(application, features),
            self._calc_historical_features(application, features),
            self._calc_graph_features(application, features),
            self._calc_external_features(application, features)
        )
        
        return features
    
    async def _calc_identity_features(self, app: Dict, features: Dict):
        """è®¡ç®—èº«ä»½ç‰¹å¾"""
        applicant = app.get("applicant", {})
        
        features["age"] = applicant.get("age", 0)
        features["age_risk"] = self._calc_age_risk(applicant.get("age", 30))
        features["occupation_risk"] = applicant.get("occupation_category", 1) * 10
        features["city_tier"] = self._get_city_tier(applicant.get("city", ""))
    
    async def _calc_device_features(self, app: Dict, features: Dict):
        """è®¡ç®—è®¾å¤‡ç‰¹å¾"""
        device = app.get("device_context", {})
        security = device.get("security_indicators", {})
        
        features["device_risk_score"] = security.get("risk_score", 0)
        features["is_emulator"] = 1 if security.get("is_emulator") else 0
        features["is_rooted"] = 1 if security.get("is_rooted") else 0
        features["is_proxy"] = 1 if security.get("is_proxy") else 0
        features["is_vpn"] = 1 if security.get("is_vpn") else 0
    
    async def _calc_behavior_features(self, app: Dict, features: Dict):
        """è®¡ç®—è¡Œä¸ºç‰¹å¾"""
        behavior = app.get("device_context", {}).get("behavior_features", {})
        
        features["input_speed"] = float(behavior.get("input_speed_wpm", 40))
        features["field_changes"] = behavior.get("field_change_count", 0)
        features["hesitation_time"] = behavior.get("hesitation_time_ms", 0)
        features["completion_time"] = behavior.get("form_completion_time_sec", 120)
        features["is_paste_used"] = 1 if behavior.get("is_paste_used") else 0
        
        # å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
        features["behavior_anomaly"] = self._detect_behavior_anomaly(behavior)
    
    async def _calc_historical_features(self, app: Dict, features: Dict):
        """è®¡ç®—å†å²ç‰¹å¾"""
        history = app.get("historical_behavior", {})
        user_hist = history.get("user_history", {})
        device_hist = history.get("device_history", {})
        ip_hist = history.get("ip_history", {})
        
        features["prev_applications_30d"] = user_hist.get("previous_applications_30d", 0)
        features["prev_policies"] = user_hist.get("previous_policies", 0)
        features["claim_count_12m"] = user_hist.get("claim_count_12m", 0)
        features["device_users_30d"] = device_hist.get("unique_users_30d", 0)
        features["ip_users_24h"] = ip_hist.get("unique_users_24h", 0)
    
    async def _calc_graph_features(self, app: Dict, features: Dict):
        """è®¡ç®—å›¾è°±ç‰¹å¾"""
        graph = app.get("graph_features", {})
        fraud_assoc = graph.get("fraud_association", {})
        
        features["fraud_community_score"] = fraud_assoc.get("fraud_community_score", 0)
        features["blacklisted_connections"] = fraud_assoc.get("blacklisted_connections", 0)
        features["greylisted_connections"] = fraud_assoc.get("greylisted_connections", 0)
    
    async def _calc_external_features(self, app: Dict, features: Dict):
        """è®¡ç®—å¤–éƒ¨ç‰¹å¾"""
        external = app.get("external_data", {})
        credit = external.get("credit_data", {})
        judicial = external.get("judicial_data", {})
        
        features["credit_score"] = credit.get("credit_score", 600)
        features["credit_normalized"] = (credit.get("credit_score", 600) - 350) / 5
        features["overdue_count"] = credit.get("overdue_count_24m", 0)
        features["lawsuit_count"] = judicial.get("lawsuit_count", 0)
        features["is_dishonest"] = 1 if judicial.get("is_dishonest") else 0
    
    def _calc_age_risk(self, age: int) -> float:
        """è®¡ç®—å¹´é¾„é£é™©"""
        if age < 18 or age > 65:
            return 100
        elif age > 55:
            return 50
        elif age > 45:
            return 30
        return 10
    
    def _get_city_tier(self, city: str) -> int:
        """è·å–åŸå¸‚ç­‰çº§"""
        tier1 = ["åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³"]
        tier2 = ["æ­å·", "å—äº¬", "æˆéƒ½", "æ­¦æ±‰", "è¥¿å®‰"]
        
        if city in tier1:
            return 1
        elif city in tier2:
            return 2
        return 3
    
    def _detect_behavior_anomaly(self, behavior: Dict) -> float:
        """æ£€æµ‹è¡Œä¸ºå¼‚å¸¸"""
        anomaly_score = 0
        
        # å¡«å†™è¿‡å¿«ï¼ˆå¯èƒ½ä½¿ç”¨è„šæœ¬ï¼‰
        if behavior.get("form_completion_time_sec", 120) < 30:
            anomaly_score += 30
        
        # è¾“å…¥é€Ÿåº¦å¼‚å¸¸
        if behavior.get("input_speed_wpm", 40) > 100:
            anomaly_score += 20
        
        # é¢‘ç¹åˆ‡æ¢å­—æ®µ
        if behavior.get("field_change_count", 0) > 10:
            anomaly_score += 15
        
        return min(anomaly_score, 100)


class RiskScoringEngine:
    """é£é™©è¯„åˆ†å¼•æ“"""
    
    def __init__(self):
        self.models = self._load_models()
    
    def _load_models(self) -> Dict:
        """åŠ è½½æ¨¡å‹"""
        return {
            "xgb": None,  # xgboost.Booster()
            "dnn": None,  # tf.keras.models.load_model()
            "graph": None
        }
    
    def calculate_risk(self, features: Dict) -> RiskAssessment:
        """è®¡ç®—é£é™©è¯„åˆ†"""
        # åˆ†é¡¹é£é™©è¯„åˆ†
        identity_risk = self._calc_identity_risk(features)
        device_risk = self._calc_device_risk(features)
        behavior_risk = self._calc_behavior_risk(features)
        credit_risk = self._calc_credit_risk(features)
        association_risk = self._calc_association_risk(features)
        
        # ç»¼åˆè¯„åˆ†ï¼ˆåŠ æƒå¹³å‡ï¼‰
        composite = (
            identity_risk * Decimal('0.15') +
            device_risk * Decimal('0.20') +
            behavior_risk * Decimal('0.25') +
            credit_risk * Decimal('0.25') +
            association_risk * Decimal('0.15')
        )
        
        # ç¡®å®šé£é™©ç­‰çº§
        if composite < Decimal('20'):
            level = RiskLevel.VERY_LOW
        elif composite < Decimal('40'):
            level = RiskLevel.LOW
        elif composite < Decimal('60'):
            level = RiskLevel.MEDIUM
        elif composite < Decimal('80'):
            level = RiskLevel.HIGH
        else:
            level = RiskLevel.VERY_HIGH
        
        return RiskAssessment(
            composite_score=composite,
            risk_level=level,
            identity_risk=identity_risk,
            device_risk=device_risk,
            behavior_risk=behavior_risk,
            credit_risk=credit_risk,
            association_risk=association_risk
        )
    
    def _calc_identity_risk(self, features: Dict) -> Decimal:
        """è®¡ç®—èº«ä»½é£é™©"""
        score = Decimal('0')
        score += Decimal(str(features.get("age_risk", 0)))
        score += Decimal(str(features.get("occupation_risk", 0)))
        return min(score, Decimal('100'))
    
    def _calc_device_risk(self, features: Dict) -> Decimal:
        """è®¡ç®—è®¾å¤‡é£é™©"""
        score = Decimal(str(features.get("device_risk_score", 0)))
        if features.get("is_emulator"):
            score += Decimal('50')
        if features.get("is_proxy"):
            score += Decimal('30')
        return min(score, Decimal('100'))
    
    def _calc_behavior_risk(self, features: Dict) -> Decimal:
        """è®¡ç®—è¡Œä¸ºé£é™©"""
        return Decimal(str(features.get("behavior_anomaly", 0)))
    
    def _calc_credit_risk(self, features: Dict) -> Decimal:
        """è®¡ç®—ä¿¡ç”¨é£é™©"""
        score = Decimal('100') - Decimal(str(features.get("credit_normalized", 50)))
        score += Decimal(str(features.get("overdue_count", 0))) * Decimal('20')
        if features.get("is_dishonest"):
            score += Decimal('100')
        return min(score, Decimal('100'))
    
    def _calc_association_risk(self, features: Dict) -> Decimal:
        """è®¡ç®—å…³è”é£é™©"""
        score = Decimal(str(features.get("fraud_community_score", 0)))
        score += Decimal(str(features.get("blacklisted_connections", 0))) * Decimal('30')
        score += Decimal(str(features.get("ip_users_24h", 0))) * Decimal('5')
        return min(score, Decimal('100'))


class DynamicRuleEngine:
    """åŠ¨æ€è§„åˆ™å¼•æ“"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.rules = []
        self.rule_version = "1.0.0"
    
    async def load_rules(self):
        """åŠ è½½è§„åˆ™"""
        # ä»RedisåŠ è½½è§„åˆ™
        rules_data = await self.redis.get("underwriting:rules")
        if rules_data:
            self.rules = json.loads(rules_data)
        else:
            self.rules = self._default_rules()
    
    def _default_rules(self) -> List[Dict]:
        """é»˜è®¤è§„åˆ™"""
        return [
            {
                "rule_id": "R001",
                "name": "æé«˜é£é™©æ‹¦æˆª",
                "condition": "risk_score >= 80",
                "action": "DECLINE",
                "priority": 100,
                "explanation": "é£é™©è¯„åˆ†è¿‡é«˜ï¼Œç³»ç»Ÿè‡ªåŠ¨æ‹’ä¿"
            },
            {
                "rule_id": "R002",
                "name": "æ¨¡æ‹Ÿå™¨æ£€æµ‹",
                "condition": "is_emulator == 1",
                "action": "DECLINE",
                "priority": 95,
                "explanation": "æ£€æµ‹åˆ°æ¨¡æ‹Ÿå™¨ç¯å¢ƒï¼Œå­˜åœ¨æ¬ºè¯ˆé£é™©"
            },
            {
                "rule_id": "R003",
                "name": "å¤±ä¿¡äººå‘˜",
                "condition": "is_dishonest == 1",
                "action": "DECLINE",
                "priority": 95,
                "explanation": "æŠ•ä¿äººå­˜åœ¨å¤±ä¿¡è®°å½•"
            },
            {
                "rule_id": "R004",
                "name": "é«˜é£é™©èŒä¸š",
                "condition": "occupation_category >= 5",
                "action": "DECLINE",
                "priority": 90,
                "explanation": "èŒä¸šé£é™©ç­‰çº§è¶…å‡ºæ‰¿ä¿èŒƒå›´"
            },
            {
                "rule_id": "R005",
                "name": "åŠ è´¹æ‰¿ä¿",
                "condition": "risk_score >= 40 and risk_score < 60",
                "action": "RATED_UP",
                "loading": 1.3,
                "priority": 70,
                "explanation": "é£é™©è¯„åˆ†ä¸­ç­‰ï¼Œéœ€åŠ è´¹æ‰¿ä¿"
            },
            {
                "rule_id": "R006",
                "name": "äººå·¥å®¡æ ¸",
                "condition": "risk_score >= 60 and risk_score < 80",
                "action": "MANUAL_REVIEW",
                "priority": 80,
                "explanation": "é£é™©è¯„åˆ†è¾ƒé«˜ï¼Œéœ€äººå·¥å®¡æ ¸"
            },
            {
                "rule_id": "R007",
                "name": "æ ‡å‡†ä½“",
                "condition": "risk_score < 20",
                "action": "ACCEPT",
                "priority": 10,
                "explanation": "é£é™©è¯„åˆ†ä½ï¼Œæ ‡å‡†ä½“æ‰¿ä¿"
            }
        ]
    
    def evaluate(self, features: Dict, risk_assessment: RiskAssessment) -> Tuple[UnderwritingDecision, List[Dict]]:
        """è¯„ä¼°è§„åˆ™"""
        triggered_rules = []
        decision = UnderwritingDecision.ACCEPT
        
        # å‡†å¤‡è§„åˆ™æ‰§è¡Œä¸Šä¸‹æ–‡
        context = {
            **features,
            "risk_score": float(risk_assessment.composite_score),
            "risk_level": risk_assessment.risk_level.name
        }
        
        for rule in sorted(self.rules, key=lambda r: r["priority"], reverse=True):
            try:
                if eval(rule["condition"], context):
                    triggered_rules.append({
                        "rule_id": rule["rule_id"],
                        "rule_name": rule["name"],
                        "explanation": rule["explanation"]
                    })
                    
                    action = rule["action"]
                    if action == "DECLINE":
                        return UnderwritingDecision.DECLINE, triggered_rules
                    elif action == "MANUAL_REVIEW":
                        decision = UnderwritingDecision.MANUAL_REVIEW
                    elif action == "RATED_UP":
                        if decision == UnderwritingDecision.ACCEPT:
                            decision = UnderwritingDecision.RATED_UP
                    elif action == "POSTPONE":
                        if decision in [UnderwritingDecision.ACCEPT]:
                            decision = UnderwritingDecision.POSTPONE
                            
            except Exception as e:
                logger.error(f"è§„åˆ™ {rule['rule_id']} æ‰§è¡Œå¤±è´¥: {e}")
        
        return decision, triggered_rules
    
    async def update_rules(self, new_rules: List[Dict], version: str):
        """æ›´æ–°è§„åˆ™"""
        await self.redis.setex("underwriting:rules", 86400, json.dumps(new_rules))
        await self.redis.setex("underwriting:rules:version", 86400, version)
        self.rules = new_rules
        self.rule_version = version
        logger.info(f"è§„åˆ™å·²æ›´æ–°è‡³ç‰ˆæœ¬ {version}")


class IntelligentUnderwritingEngine:
    """æ™ºèƒ½æ ¸ä¿å¼•æ“ä¸»ç±»"""
    
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.feature_engine: Optional[FeatureCalculationEngine] = None
        self.risk_engine = RiskScoringEngine()
        self.rule_engine: Optional[DynamicRuleEngine] = None
        
        # ç»Ÿè®¡
        self.stats = {
            "total_requests": 0,
            "accept_count": 0,
            "rated_up_count": 0,
            "manual_review_count": 0,
            "decline_count": 0,
            "avg_latency_ms": 0
        }
    
    async def initialize(self):
        """åˆå§‹åŒ–å¼•æ“"""
        self.redis_client = redis.Redis(
            host='localhost', port=6379, db=2, decode_responses=True
        )
        self.feature_engine = FeatureCalculationEngine(self.redis_client)
        self.rule_engine = DynamicRuleEngine(self.redis_client)
        await self.rule_engine.load_rules()
        logger.info("æ™ºèƒ½æ ¸ä¿å¼•æ“åˆå§‹åŒ–å®Œæˆ")
    
    async def underwrite(self, application: Dict) -> UnderwritingResult:
        """æ‰§è¡Œæ™ºèƒ½æ ¸ä¿"""
        start_time = time.time()
        application_id = application.get("application_id", str(uuid.uuid4()))
        
        try:
            # 1. ç‰¹å¾è®¡ç®—
            features = await self.feature_engine.calculate_features(application)
            
            # 2. é£é™©è¯„åˆ†
            risk_assessment = self.risk_engine.calculate_risk(features)
            
            # 3. è§„åˆ™è¯„ä¼°
            decision, triggered_rules = self.rule_engine.evaluate(features, risk_assessment)
            
            # 4. å®šä»·è°ƒæ•´
            base_premium = Decimal(str(application.get("coverage_plan", {}).get("premium", 0)))
            final_premium = base_premium
            
            if decision == UnderwritingDecision.RATED_UP:
                for rule in triggered_rules:
                    if rule.get("action") == "RATED_UP":
                        loading = Decimal(str(rule.get("loading", 1.0)))
                        final_premium = base_premium * loading
                        break
            
            # 5. æ„å»ºç»“æœ
            latency_ms = int((time.time() - start_time) * 1000)
            
            result = UnderwritingResult(
                application_id=application_id,
                decision=decision,
                decision_code=self._get_decision_code(decision),
                confidence=Decimal('0.95') if decision != UnderwritingDecision.MANUAL_REVIEW else Decimal('0.7'),
                risk_score=risk_assessment.composite_score,
                risk_level=risk_assessment.risk_level,
                final_premium=final_premium.quantize(Decimal('0.01')),
                triggered_rules=triggered_rules,
                explanation=self._generate_explanation(decision, triggered_rules, risk_assessment),
                latency_ms=latency_ms
            )
            
            # 6. æ›´æ–°ç»Ÿè®¡
            await self._update_stats(decision, latency_ms)
            
            # 7. è®°å½•å†³ç­–æ—¥å¿—
            await self._log_decision(result, features)
            
            logger.info(f"æ ¸ä¿å®Œæˆ: application_id={application_id}, "
                       f"decision={decision.value}, risk_score={risk_assessment.composite_score}, "
                       f"latency={latency_ms}ms")
            
            return result
            
        except Exception as e:
            logger.error(f"æ ¸ä¿å¼‚å¸¸: {e}")
            # å¼‚å¸¸æ—¶è½¬äººå·¥å®¡æ ¸
            return UnderwritingResult(
                application_id=application_id,
                decision=UnderwritingDecision.MANUAL_REVIEW,
                decision_code="UW999",
                confidence=Decimal('0.5'),
                risk_score=Decimal('50'),
                risk_level=RiskLevel.MEDIUM,
                final_premium=Decimal('0'),
                triggered_rules=[{"rule_id": "SYSTEM", "rule_name": "ç³»ç»Ÿå¼‚å¸¸", "explanation": str(e)}],
                explanation=f"ç³»ç»Ÿå¼‚å¸¸ï¼Œè½¬äººå·¥å®¡æ ¸: {str(e)}",
                latency_ms=int((time.time() - start_time) * 1000)
            )
    
    def _get_decision_code(self, decision: UnderwritingDecision) -> str:
        """è·å–å†³ç­–ä»£ç """
        codes = {
            UnderwritingDecision.ACCEPT: "UW000",
            UnderwritingDecision.RATED_UP: "UW100",
            UnderwritingDecision.EXCLUSION: "UW200",
            UnderwritingDecision.MANUAL_REVIEW: "UW300",
            UnderwritingDecision.DECLINE: "UW400",
            UnderwritingDecision.POSTPONE: "UW500"
        }
        return codes.get(decision, "UW999")
    
    def _generate_explanation(self, decision: UnderwritingDecision, 
                              rules: List[Dict], risk: RiskAssessment) -> str:
        """ç”Ÿæˆå†³ç­–è§£é‡Š"""
        if decision == UnderwritingDecision.ACCEPT:
            return f"é£é™©è¯„åˆ†{risk.composite_score}ï¼Œå±äº{risk.risk_level.value}é£é™©ï¼Œæ ‡å‡†ä½“æ‰¿ä¿"
        elif decision == UnderwritingDecision.DECLINE:
            return f"è§¦å‘è§„åˆ™ï¼š{rules[0]['explanation']}" if rules else "é£é™©è¯„åˆ†è¿‡é«˜"
        elif decision == UnderwritingDecision.RATED_UP:
            return f"é£é™©è¯„åˆ†{risk.composite_score}ï¼Œéœ€åŠ è´¹æ‰¿ä¿"
        elif decision == UnderwritingDecision.MANUAL_REVIEW:
            return f"é£é™©è¯„åˆ†{risk.composite_score}ï¼Œéœ€äººå·¥è¿›ä¸€æ­¥å®¡æ ¸"
        return ""
    
    async def _update_stats(self, decision: UnderwritingDecision, latency: int):
        """æ›´æ–°ç»Ÿè®¡"""
        self.stats["total_requests"] += 1
        
        if decision == UnderwritingDecision.ACCEPT:
            self.stats["accept_count"] += 1
        elif decision == UnderwritingDecision.RATED_UP:
            self.stats["rated_up_count"] += 1
        elif decision == UnderwritingDecision.MANUAL_REVIEW:
            self.stats["manual_review_count"] += 1
        elif decision == UnderwritingDecision.DECLINE:
            self.stats["decline_count"] += 1
        
        # æ›´æ–°å¹³å‡å»¶è¿Ÿ
        n = self.stats["total_requests"]
        self.stats["avg_latency_ms"] = (self.stats["avg_latency_ms"] * (n - 1) + latency) / n
    
    async def _log_decision(self, result: UnderwritingResult, features: Dict):
        """è®°å½•å†³ç­–æ—¥å¿—"""
        log_data = {
            "application_id": result.application_id,
            "decision": result.decision.value,
            "risk_score": float(result.risk_score),
            "risk_level": result.risk_level.value,
            "features": features,
            "timestamp": datetime.now().isoformat()
        }
        
        key = f"uw_log:{result.application_id}"
        await self.redis_client.setex(key, 86400 * 30, json.dumps(log_data))
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡"""
        total = self.stats["total_requests"]
        if total == 0:
            return self.stats
        
        return {
            **self.stats,
            "accept_rate": round(self.stats["accept_count"] / total * 100, 2),
            "auto_underwriting_rate": round(
                (self.stats["accept_count"] + self.stats["rated_up_count"] + self.stats["decline_count"]) / total * 100, 2
            ),
            "manual_review_rate": round(self.stats["manual_review_count"] / total * 100, 2)
        }


# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºæ™ºèƒ½æ ¸ä¿å¼•æ“"""
    engine = IntelligentUnderwritingEngine()
    await engine.initialize()
    
    # æ„é€ æŠ•ä¿ç”³è¯·
    application = {
        "application_id": "APP20250121000001",
        "product_code": "PA2025ACC001",
        "channel": "WECHAT_MINI",
        "applicant": {
            "name_hash": "HASH-abc123",
            "id_hash": "HASH-def456",
            "phone_hash": "HASH-ghi789",
            "age": 28,
            "gender": "MALE",
            "occupation_category": 2,
            "city": "ä¸Šæµ·å¸‚"
        },
        "coverage_plan": {
            "sum_assured": 1000000,
            "coverage_period": 1,
            "premium": 365.00,
            "deductible": 10000
        },
        "device_context": {
            "security_indicators": {
                "is_emulator": False,
                "is_rooted": False,
                "is_proxy": False,
                "is_vpn": False,
                "risk_score": 12.0
            },
            "behavior_features": {
                "input_speed_wpm": 45.5,
                "field_change_count": 3,
                "hesitation_time_ms": 2500,
                "form_completion_time_sec": 180,
                "is_paste_used": False
            }
        },
        "historical_behavior": {
            "user_history": {
                "previous_applications_30d": 0,
                "previous_policies": 2,
                "claim_count_12m": 0
            },
            "device_history": {
                "unique_users_30d": 1,
                "unique_users_24h": 5
            },
            "ip_history": {
                "unique_users_24h": 5,
                "is_high_risk_ip": False
            }
        },
        "graph_features": {
            "fraud_association": {
                "blacklisted_connections": 0,
                "greylisted_connections": 1,
                "fraud_community_score": 15.0
            }
        },
        "external_data": {
            "credit_data": {
                "credit_score": 750,
                "overdue_count_24m": 0
            },
            "judicial_data": {
                "lawsuit_count": 0,
                "is_dishonest": False
            }
        }
    }
    
    # æ‰§è¡Œæ ¸ä¿
    result = await engine.underwrite(application)
    print(f"æ ¸ä¿ç»“æœ:")
    print(f"  å†³ç­–: {result.decision.value}")
    print(f"  é£é™©è¯„åˆ†: {result.risk_score}")
    print(f"  é£é™©ç­‰çº§: {result.risk_level.value}")
    print(f"  æœ€ç»ˆä¿è´¹: {result.final_premium}")
    print(f"  å†³ç­–è§£é‡Š: {result.explanation}")
    print(f"  å¤„ç†è€—æ—¶: {result.latency_ms}ms")
    print(f"\nå¼•æ“ç»Ÿè®¡: {json.dumps(engine.get_stats(), ensure_ascii=False, indent=2)}")


if __name__ == "__main__":
    asyncio.run(main())
```


### 3.7 æ•ˆæœè¯„ä¼°

#### 3.7.1 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ç±»åˆ« | æŒ‡æ ‡é¡¹ | å®æ–½å‰ | å®æ–½å | æå‡å¹…åº¦ |
|----------|--------|--------|--------|----------|
| **æ ¸ä¿æ—¶æ•ˆ** | å¹³å‡æ ¸ä¿å“åº”æ—¶é—´ | 3,500ms | 42ms | **æå‡98.8%** |
| | P99å“åº”æ—¶é—´ | 15,000ms | 85ms | **æå‡99.4%** |
| | å³°å€¼ååé‡ | 2,000TPS | 55,000TPS | **æå‡26.5å€** |
| | æ ¸ä¿é˜Ÿåˆ—ç§¯å‹ | é«˜å³°æœŸ>10,000å• | 0å• | **å®Œå…¨æ¶ˆé™¤** |
| **é£æ§æ•ˆæœ** | é€†é€‰æ‹©è¯†åˆ«ç‡ | 35% | 92% | **æå‡57%** |
| | æ¬ºè¯ˆæ‹¦æˆªç‡ | 12% | 87% | **æå‡75%** |
| | è¯¯æ€ç‡ | 18% | 2.5% | **é™ä½86%** |
| | ç»¼åˆæˆæœ¬ç‡(COR) | 105% | 96% | **é™ä½9%** |
| **è‡ªåŠ¨åŒ–ç‡** | è‡ªåŠ¨æ ¸ä¿é€šè¿‡ç‡ | 15% | 82% | **æå‡67%** |
| | äººå·¥æ ¸ä¿å æ¯” | 85% | 18% | **é™ä½67%** |
| | è§„åˆ™è°ƒæ•´æ—¶æ•ˆ | 2å‘¨ | 1å°æ—¶ | **ç¼©çŸ­99.7%** |
| **ä¸šåŠ¡æŒ‡æ ‡** | å®¢æˆ·æµå¤±ç‡ | 40% | 8% | **é™ä½80%** |
| | æŠ•ä¿è½¬åŒ–ç‡ | 55% | 82% | **æå‡49%** |
| | å®¢æˆ·æ»¡æ„åº¦ | 72% | 91% | **æå‡26%** |
| | æŠ•è¯‰ç‡ | 1.2% | 0.2% | **é™ä½83%** |

#### 3.7.2 ä¸šåŠ¡ä»·å€¼è¯„ä¼°

| ä»·å€¼ç»´åº¦ | å…·ä½“æ”¶ç›Š | é‡åŒ–æŒ‡æ ‡ | ROIè®¡ç®— |
|----------|----------|----------|---------|
| **æ ¸ä¿æ•ˆç‡æå‡** | è‡ªåŠ¨åŒ–ç‡æå‡å¸¦æ¥çš„äººåŠ›æˆæœ¬èŠ‚çº¦ | å¹´åº¦èŠ‚çº¦ï¼šÂ¥1,800ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥5,400ä¸‡ |
| **æ¬ºè¯ˆæŸå¤±å‡å°‘** | æ¬ºè¯ˆè¯†åˆ«ç‡æå‡å¸¦æ¥çš„èµ”ä»˜å‡å°‘ | å¹´åº¦å‡å°‘ï¼šÂ¥2,500ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥7,500ä¸‡ |
| **å®¢æˆ·è½¬åŒ–æå‡** | æ ¸ä¿æ—¶æ•ˆæå‡å¸¦æ¥çš„æŠ•ä¿è½¬åŒ–ç‡å¢é•¿ | å¹´åº¦å¢æ”¶ï¼šÂ¥8,000ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥2.4äº¿ |
| **CORä¼˜åŒ–** | é£æ§èƒ½åŠ›æå‡å¸¦æ¥çš„æ‰¿ä¿åˆ©æ¶¦æ”¹å–„ | å¹´åº¦å¢æ”¶ï¼šÂ¥6,000ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥1.8äº¿ |
| **è·å®¢æˆæœ¬èŠ‚çº¦** | æµå¤±ç‡é™ä½å¸¦æ¥çš„è·å®¢æˆæœ¬èŠ‚çº¦ | å¹´åº¦èŠ‚çº¦ï¼šÂ¥3,200ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥9,600ä¸‡ |

**æ€»æŠ•èµ„å›æŠ¥ç‡ï¼ˆROIï¼‰**ï¼š
- é¡¹ç›®æ€»æŠ•èµ„ï¼šÂ¥3,500ä¸‡ï¼ˆå«å¹³å°å»ºè®¾ã€æ¨¡å‹å¼€å‘ã€æ•°æ®é‡‡è´­ï¼‰
- é¦–å¹´æ”¶ç›Šï¼šÂ¥2.15äº¿
- 3å¹´ç´¯è®¡æ”¶ç›Šï¼šÂ¥6.41äº¿
- **3å¹´ROI = 1,732%**
- **æŠ•èµ„å›æ”¶æœŸ = 2ä¸ªæœˆ**

#### 3.7.3 ç»éªŒæ•™è®­

**æˆåŠŸç»éªŒ**ï¼š

1. **å®æ—¶ç‰¹å¾ä½“ç³»**ï¼šæ„å»ºäº†500+ç»´å®æ—¶ç‰¹å¾ï¼Œæ¶µç›–è®¾å¤‡ã€è¡Œä¸ºã€å›¾è°±ã€å¤–éƒ¨æ•°æ®ç­‰ç»´åº¦ã€‚ç‰¹å¾Schemaæ ‡å‡†åŒ–ä½¿æ¨¡å‹è¿­ä»£å‘¨æœŸä»3å‘¨ç¼©çŸ­è‡³3å¤©ï¼Œæ”¯æŒå¿«é€Ÿå“åº”é»‘äº§å˜åŒ–ã€‚

2. **ç«¯åˆ°ç«¯å»¶è¿Ÿä¼˜åŒ–**ï¼šé€šè¿‡ç‰¹å¾é¢„è®¡ç®—ã€æœ¬åœ°ç¼“å­˜ã€å¼‚æ­¥å¤„ç†ç­‰æ‰‹æ®µï¼Œå°†æ ¸ä¿å»¶è¿Ÿä»3.5ç§’é™è‡³42æ¯«ç§’ã€‚å®¢æˆ·ä½“éªŒå¤§å¹…æ”¹å–„ï¼ŒæŠ•ä¿æµå¤±ç‡ä»40%é™è‡³8%ã€‚

3. **å¯¹æŠ—å­¦ä¹ æœºåˆ¶**ï¼šå»ºç«‹"ç›‘æµ‹-åˆ†æ-å“åº”-éªŒè¯"é—­ç¯ï¼Œæ¯æ—¥åˆ†ææ‹’ä¿æ¡ˆä¾‹ï¼Œæ¯å‘¨æ›´æ–°é£æ§è§„åˆ™ï¼Œæ¯æœˆé‡è®­ç»ƒæ¨¡å‹ã€‚æ–°å‹æ¬ºè¯ˆæ¨¡å¼è¯†åˆ«æ—¶é—´ä»30å¤©ç¼©çŸ­è‡³3å¤©ã€‚

**æ•™è®­ä¸æ”¹è¿›**ï¼š

1. **å†·å¯åŠ¨å›°å¢ƒ**ï¼šæ–°æ¸ é“ä¸Šçº¿åˆæœŸç¼ºä¹å†å²æ•°æ®ï¼Œè¯¯æ€ç‡åé«˜ã€‚æ”¹è¿›ï¼šé‡‡ç”¨è¿ç§»å­¦ä¹ ï¼Œåˆ©ç”¨å…¶ä»–æ¸ é“æ•°æ®é¢„è®­ç»ƒæ¨¡å‹ï¼Œæ–°æ¸ é“å†·å¯åŠ¨æœŸä»2å‘¨ç¼©çŸ­è‡³3å¤©ã€‚

2. **æ¨¡å‹å¯è§£é‡Šæ€§**ï¼šåˆæœŸMLæ¨¡å‹"é»‘ç›’"ç‰¹æ€§å¯¼è‡´ä¸šåŠ¡æ–¹ä¸ä¿¡ä»»ã€‚æ”¹è¿›ï¼šå¼•å…¥SHAPå€¼è§£é‡Šï¼Œä¸ºæ¯ç¬”å†³ç­–ç”Ÿæˆå¯è§†åŒ–è§£é‡Šï¼Œä¸šåŠ¡æ¥å—åº¦ä»60%æå‡è‡³95%ã€‚

3. **è·¨å…¬å¸åä½œ**ï¼šåæ¬ºè¯ˆè”ç›Ÿæ•°æ®å…±äº«å­˜åœ¨æ³•å¾‹é¡¾è™‘ã€‚æ”¹è¿›ï¼šé‡‡ç”¨è”é‚¦å­¦ä¹ ï¼ŒåŸå§‹æ•°æ®ä¸å‡ºåŸŸï¼Œä»…å…±äº«æ¨¡å‹å‚æ•°ï¼Œåœ¨ä¿æŠ¤éšç§çš„åŒæ—¶æå‡è¯†åˆ«èƒ½åŠ›ã€‚

---

## 4. æ¡ˆä¾‹3ï¼šä¿é™©ç†èµ”æ™ºèƒ½åæ¬ºè¯ˆå¹³å°

### 4.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šä¸­å›½å¹³å®‰XXè´¢äº§é™©åˆ†å…¬å¸ï¼ˆåŒ–åï¼šå®‰ç››è´¢é™©ï¼‰  
**ä¼ä¸šè§„æ¨¡**ï¼šå¹´åº¦ä¿è´¹æ”¶å…¥è¶…è¿‡500äº¿å…ƒï¼Œå¹´ç†èµ”æ¡ˆä»¶è¶…è¿‡300ä¸‡ä»¶ï¼Œç†èµ”é‡‘é¢è¶…è¿‡Â¥300äº¿  
**ç†èµ”ç°çŠ¶**ï¼šä¼ ç»Ÿç†èµ”å®¡æ ¸ä¸»è¦ä¾èµ–äººå·¥ç»éªŒï¼Œæ¬ºè¯ˆè¯†åˆ«èƒ½åŠ›å¼±ï¼Œå¹´åº¦æ¬ºè¯ˆæŸå¤±ä¼°è®¡è¶…è¿‡Â¥15äº¿

å®‰ç››è´¢é™©ä½œä¸ºå›½å†…é¢†å…ˆçš„è´¢äº§ä¿é™©å…¬å¸ï¼Œå…¶ç†èµ”ä¸šåŠ¡è¦†ç›–è½¦é™©ã€è´¢äº§é™©ã€è´£ä»»é™©ç­‰å¤šä¸ªé™©ç§ã€‚éšç€ç†èµ”é‡æŒç»­å¢é•¿ï¼Œä¼ ç»Ÿçš„"äººç›¯äºº"å®¡æ ¸æ¨¡å¼å·²æ— æ³•æœ‰æ•ˆè¯†åˆ«æ—¥ç›Šå¤æ‚çš„ä¿é™©æ¬ºè¯ˆè¡Œä¸ºã€‚è™šå‡äº‹æ•…ã€éª—ä¿å›¢ä¼™ã€å†…å¤–å‹¾ç»“ç­‰æ¬ºè¯ˆæ‰‹æ®µå±‚å‡ºä¸ç©·ï¼Œæ€¥éœ€æ„å»ºæ™ºèƒ½åŒ–çš„ç†èµ”åæ¬ºè¯ˆä½“ç³»ã€‚

### 4.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹é¢†åŸŸ | å…·ä½“é—®é¢˜æè¿° | ä¸šåŠ¡å½±å“ |
|------|----------|--------------|----------|
| 1 | **æ¬ºè¯ˆæŸå¤±å·¨å¤§** | å¹´åº¦æ¬ºè¯ˆæŸå¤±ä¼°è®¡Â¥15äº¿ï¼Œè½¦é™©æ¬ºè¯ˆç‡çº¦15%ï¼Œè´¢äº§é™©æ¬ºè¯ˆç‡çº¦8% | ç›´æ¥ç»æµæŸå¤±ï¼Œä¿è´¹ä¸Šæ¶¨å‹åŠ› |
| 2 | **è¯†åˆ«èƒ½åŠ›å¼±** | ä¾èµ–äººå·¥ç»éªŒè¯†åˆ«æ¬ºè¯ˆï¼Œå¤æ‚æ¬ºè¯ˆæ¡ˆä»¶å‘ç°ç‡ä½ï¼Œå›¢ä¼™æ¬ºè¯ˆéš¾ä»¥è¯†åˆ« | å¤§é‡æ¬ºè¯ˆæ¡ˆä»¶æ¼ç½‘ |
| 3 | **å®¡æ ¸æ•ˆç‡ä½** | ç†èµ”æ¡ˆä»¶å¹³å‡å®¡æ ¸æ—¶æ•ˆ5å¤©ï¼Œäººå·¥è°ƒæŸ¥æˆæœ¬é«˜ï¼Œå°é¢æ¡ˆä»¶å®¡æ ¸ä¸ç»æµ | è¿è¥æˆæœ¬å¢åŠ ï¼Œå®¢æˆ·ä½“éªŒå·® |
| 4 | **æ•°æ®æœªæ‰“é€š** | ç†èµ”æ•°æ®ä¸æ‰¿ä¿æ•°æ®ã€å¤–éƒ¨æ•°æ®ï¼ˆäº¤è­¦ã€åŒ»é™¢ã€ç»´ä¿®å‚ï¼‰æœªæ‰“é€š | ä¿¡æ¯å­¤å²›ï¼Œæ— æ³•äº¤å‰éªŒè¯ |
| 5 | **è°ƒæŸ¥æˆæœ¬é«˜** | å§”æ‰˜ç¬¬ä¸‰æ–¹è°ƒæŸ¥å…¬å¸æˆæœ¬é«˜ï¼Œå¹³å‡è°ƒæŸ¥è´¹ç”¨Â¥3,000/æ¡ˆï¼ŒæŠ•å…¥äº§å‡ºæ¯”ä½ | è°ƒæŸ¥æˆæœ¬å±…é«˜ä¸ä¸‹ |

### 4.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ç»´åº¦ | å…·ä½“ç›®æ ‡ | é¢„æœŸæŒ‡æ ‡ |
|------|----------|----------|----------|
| 1 | **æ¬ºè¯ˆè¯†åˆ«** | å»ºç«‹AIé©±åŠ¨çš„ç†èµ”åæ¬ºè¯ˆæ¨¡å‹ï¼Œç²¾å‡†è¯†åˆ«å„ç±»æ¬ºè¯ˆæ¡ˆä»¶ | æ¬ºè¯ˆè¯†åˆ«ç‡>85%ï¼Œè¯¯æŠ¥ç‡<5% |
| 2 | **å®¡æ ¸ææ•ˆ** | å®ç°ç†èµ”æ¡ˆä»¶æ™ºèƒ½åˆ†æµï¼Œç®€å•æ¡ˆä»¶è‡ªåŠ¨å®¡æ ¸ | è‡ªåŠ¨åŒ–å®¡æ ¸ç‡>70%ï¼Œæ—¶æ•ˆæå‡3å€ |
| 3 | **æˆæœ¬é™ä½** | ç²¾å‡†å®šä½é«˜é£é™©æ¡ˆä»¶ï¼Œå‡å°‘æ— æ•ˆè°ƒæŸ¥ | è°ƒæŸ¥æˆæœ¬é™ä½40% |
| 4 | **å›¢ä¼™æ‰“å‡»** | æ„å»ºç†èµ”çŸ¥è¯†å›¾è°±ï¼Œè¯†åˆ«éª—ä¿å›¢ä¼™ | å›¢ä¼™å‘ç°ç‡>90% |
| 5 | **æ•°æ®æ•´åˆ** | æ‰“é€šå†…å¤–éƒ¨æ•°æ®æºï¼Œæ„å»ºç»Ÿä¸€ç†èµ”è§†å›¾ | æ•°æ®è¦†ç›–ç‡>95% |

### 4.4 æŠ€æœ¯æŒ‘æˆ˜

| æŒ‘æˆ˜ç¼–å· | æŒ‘æˆ˜é¢†åŸŸ | å…·ä½“æè¿° | è§£å†³æ–¹æ¡ˆ |
|----------|----------|----------|----------|
| 1 | **å¤šæ¨¡æ€æ•°æ®å¤„ç†** | ç†èµ”æ•°æ®åŒ…æ‹¬ç»“æ„åŒ–æ•°æ®ï¼ˆä¿å•ã€å®šæŸï¼‰ã€åŠç»“æ„åŒ–æ•°æ®ï¼ˆæŸ¥å‹˜æŠ¥å‘Šï¼‰ã€éç»“æ„åŒ–æ•°æ®ï¼ˆç…§ç‰‡ã€è§†é¢‘ï¼‰ | åŸºäºSchemaç»Ÿä¸€æ•°æ®æ¨¡å‹ï¼ŒOCR+NLPæå–å…³é”®ä¿¡æ¯ï¼Œå¤šæ¨¡æ€ç‰¹å¾èåˆ |
| 2 | **å›¢ä¼™æ¬ºè¯ˆè¯†åˆ«** | éª—ä¿å›¢ä¼™ç»„ç»‡ä¸¥å¯†ï¼Œå•æ¡ˆä»¶çœ‹ä¼¼æ­£å¸¸ï¼Œéœ€ä»å…³è”å…³ç³»ä¸­å‘ç°å¼‚å¸¸æ¨¡å¼ | æ„å»ºç†èµ”çŸ¥è¯†å›¾è°±ï¼ŒGraph Neural Networkè¯†åˆ«å›¢ä¼™æ¨¡å¼ |
| 3 | **æ­£è´Ÿæ ·æœ¬å¤±è¡¡** | æ¬ºè¯ˆæ¡ˆä»¶å æ¯”<5%ï¼Œä¸¥é‡æ ·æœ¬å¤±è¡¡ï¼Œä¼ ç»Ÿæ¨¡å‹æ•ˆæœå·® | SMOTEè¿‡é‡‡æ ·+ä»£ä»·æ•æ„Ÿå­¦ä¹ ï¼Œç»“åˆä¸»åŠ¨å­¦ä¹ æŒç»­æ ‡æ³¨ |
| 4 | **å®æ—¶æ€§è¦æ±‚** | ç†èµ”å®¡æ ¸éœ€åœ¨å®šæŸåå³æ—¶ç»™å‡ºæ¬ºè¯ˆé£é™©æç¤º | æµå¼è®¡ç®—+é¢„è®­ç»ƒæ¨¡å‹ï¼Œç§’çº§é£é™©è¯„åˆ† |
| 5 | **å¯è§£é‡Šæ€§è¦æ±‚** | æ‹’èµ”æ¡ˆä»¶éœ€æœ‰æ˜ç¡®è¯æ®æ”¯æŒï¼Œéœ€æä¾›å¯è§£é‡Šçš„æ¬ºè¯ˆä¾æ® | æ³¨æ„åŠ›æœºåˆ¶å¯è§†åŒ–+è§„åˆ™å¼•æ“ï¼Œç”Ÿæˆæ¬ºè¯ˆè¯æ®é“¾ |

### 4.5 Schemaå®šä¹‰

**ç†èµ”åæ¬ºè¯ˆæ¡ˆä»¶Schema**ï¼š

```dsl
schema ClaimsFraudDetection {
  // æ¡ˆä»¶åŸºç¡€ä¿¡æ¯
  claim_basic: ClaimBasicInfo {
    claim_no: String @value("CLM20250121000001")
    policy_no: String @value("POL2025000001")
    report_no: String @value("RPT2025012100001")
    
    // é™©ç§ä¿¡æ¯
    insurance_type: Enum @value("AUTO")
    product_code: String @value("PAUTO2025")
    coverage_type: String @value("VEHICLE_DAMAGE")
    
    // æ—¶é—´ä¿¡æ¯
    accident_date: DateTime @value("2025-01-20T15:30:00Z")
    report_date: DateTime @value("2025-01-20T16:45:00Z")
    claim_date: DateTime @value("2025-01-21T09:00:00Z")
    
    // å‡ºé™©ä¿¡æ¯
    accident_location: Location {
      province: String @value("å¹¿ä¸œçœ")
      city: String @value("æ·±åœ³å¸‚")
      district: String @value("å—å±±åŒº")
      address: String @value("æ·±å—å¤§é“XXè·¯æ®µ")
      longitude: Decimal @value(113.9433)
      latitude: Decimal @value(22.5233)
    }
    
    accident_description: String @value("ä¸¤è½¦è¿½å°¾ï¼Œæœ¬è½¦è½¦å¤´å—æŸ")
    accident_type: Enum @value("REAR_END")
    weather_condition: String @value("æ™´")
    is_night: Boolean @value(false)
    is_weekend: Boolean @value(true)
    
    // æŸå¤±ä¿¡æ¯
    estimated_loss: Decimal @value(15000.00)
    claim_amount: Decimal @value(12000.00)
    deductible: Decimal @value(1000.00)
    salvage_value: Decimal @value(0)
  }

  // å½“äº‹äººä¿¡æ¯
  parties: PartiesInfo {
    // è¢«ä¿é™©äºº
    insured: InsuredInfo {
      name_hash: String @value("HASH-insured001") @sensitive
      id_hash: String @value("HASH-id001") @sensitive
      phone_hash: String @value("HASH-phone001") @sensitive
      age: Int @value(32)
      gender: Enum @value("MALE")
      driver_license_no: String @value("HASH-license001") @sensitive
      license_issue_date: Date @value("2015-03-15")
      driving_experience_years: Int @value(10)
    }
    
    // é©¾é©¶å‘˜
    driver: DriverInfo {
      is_insured: Boolean @value(true)
      name_hash: String @value("HASH-driver001") @sensitive
      id_hash: String @value("HASH-id001") @sensitive
      license_type: String @value("C1")
      license_status: String @value("VALID")
    }
    
    // å¯¹æ–¹å½“äº‹äººï¼ˆå¦‚æœ‰ï¼‰
    third_party: Optional[ThirdPartyInfo] {
      name_hash: String @value("HASH-tp001") @sensitive
      vehicle_plate: String @value("ç²¤B-XXXXX")
      insurance_company: String @value("å¹³å®‰è´¢é™©")
      has_compulsory_insurance: Boolean @value(true)
    }
  }

  // è½¦è¾†ä¿¡æ¯
  vehicle_info: VehicleInfo {
    vehicle_plate: String @value("ç²¤A-XXXXX")
    vin: String @value("LSVXXXXXXXXXXXXXX")
    engine_no: String @value("ENGINE001")
    brand_model: String @value("å¤§ä¼—-å¸•è¨ç‰¹")
    vehicle_type: String @value("è½¿è½¦")
    purchase_date: Date @value("2022-06-15")
    vehicle_age_months: Int @value(31)
    mileage_km: Int @value(45000)
    is_commercial_use: Boolean @value(false)
    
    // å†å²ç†èµ”
    claim_history: ClaimHistory {
      total_claims: Int @value(2)
      total_claim_amount: Decimal @value(8000.00)
      last_claim_date: Optional[Date] @value("2024-08-10")
      last_claim_amount: Decimal @value(3500.00)
      days_since_last_claim: Int @value(164)
    }
  }

  // ç»´ä¿®ä¿¡æ¯
  repair_info: RepairInfo {
    repair_shop: RepairShop {
      shop_code: String @value("RS001")
      shop_name: String @value("XXæ±½è½¦ç»´ä¿®ä¸­å¿ƒ")
      shop_rating: Decimal @value(4.2)
      is_authorized: Boolean @value(true)
      cooperation_years: Int @value(3)
      monthly_claims_avg: Int @value(45)
      fraud_flag_count: Int @value(0)
    }
    
    damage_parts: List[DamagePart] {
      part1: DamagePart {
        part_code: String @value("BUMPER_FRONT")
        part_name: String @value("å‰ä¿é™©æ ")
        damage_type: String @value("REPLACE")
        part_price: Decimal @value(2800.00)
        labor_cost: Decimal @value(500.00)
        paint_cost: Decimal @value(800.00)
      }
      part2: DamagePart {
        part_code: String @value("HEADLIGHT_LEFT")
        part_name: String @value("å·¦å‰å¤§ç¯")
        damage_type: String @value("REPLACE")
        part_price: Decimal @value(3500.00)
        labor_cost: Decimal @value(300.00)
      }
    }
    
    total_repair_estimate: Decimal @value(15000.00)
    repair_days: Int @value(5)
  }

  // æŸ¥å‹˜ä¿¡æ¯
  survey_info: SurveyInfo {
    surveyor_id: String @value("SUR001")
    surveyor_name: String @value("ç‹æŸ¥å‹˜")
    survey_date: DateTime @value("2025-01-21T10:30:00Z")
    survey_method: Enum @value("ON_SITE")
    
    // æŸ¥å‹˜å‘ç°
    findings: SurveyFindings {
      damage_consistent_with_description: Boolean @value(true)
      old_damage_found: Boolean @value(false)
      suspicious_damage_found: Boolean @value(false)
      vehicle_condition_matches: Boolean @value(true)
      driver_matches_id: Boolean @value(true)
    }
    
    // å½±åƒèµ„æ–™
    photos: List[Photo] {
      photo_count: Int @value(12)
      has_overview: Boolean @value(true)
      has_damage_detail: Boolean @value(true)
      has_vin_photo: Boolean @value(true)
      has_license_photo: Boolean @value(true)
      photo_quality_score: Decimal @value(85.5)
    }
  }

  // å¤–éƒ¨æ•°æ®
  external_data: ExternalData {
    // äº¤è­¦æ•°æ®
    traffic_police_data: TrafficPoliceData {
      accident_no: Optional[String]
      has_accident_record: Boolean @value(false)
      is_drunk_driving: Boolean @value(false)
      is_fleeing: Boolean @value(false)
      violation_count: Int @value(0)
    }
    
    // ç»´ä¿®è®°å½•
    repair_records: List[RepairRecord] {
      has_external_repair_history: Boolean @value(false)
      external_repair_count_12m: Int @value(0)
    }
    
    // å¾ä¿¡æ•°æ®
    credit_data: CreditData @sensitive {
      credit_score: Int @value(720)
      is_overdue: Boolean @value(false)
    }
  }

  // å†å²è¡Œä¸º
  historical_patterns: HistoricalPatterns {
    // è¢«ä¿é™©äººçš„è¡Œä¸ºæ¨¡å¼
    insured_patterns: InsuredPatterns {
      claim_frequency_12m: Int @value(2)
      claim_frequency_score: Decimal @value(35.0)
      avg_claim_interval_days: Decimal @value(82.0)
      is_regular_pattern: Boolean @value(false)
      usual_repair_shops: List[String] @value(["RS001", "RS003"])
      shop_concentration_score: Decimal @value(65.0)
    }
    
    // åŒç±»æ¡ˆä»¶åŸºå‡†
    benchmark: Benchmark {
      similar_claims_avg_amount: Decimal @value(12500.00)
      amount_deviation_rate: Decimal @value(-0.04)
      similar_claims_avg_parts: Int @value(2)
      parts_deviation: Int @value(0)
    }
  }

  // å›¾è°±ç‰¹å¾
  graph_features: GraphFeatures {
    // å…³è”ç½‘ç»œ
    connections: Connections {
      same_insured_claims_6m: Int @value(1)
      same_driver_claims_6m: Int @value(1)
      same_vehicle_plate_claims_6m: Int @value(1)
      same_repair_shop_claims_6m: Int @value(8)
      same_location_accidents_6m: Int @value(3)
    }
    
    // ç¤¾åŒºæ£€æµ‹
    community_risk: CommunityRisk {
      community_id: String @value("COMM-001")
      community_size: Int @value(15)
      community_fraud_rate: Decimal @value(0.12)
      is_high_risk_community: Boolean @value(false)
    }
    
    // å›¢ä¼™å…³è”
    gang_association: GangAssociation {
      gang_id: Optional[String]
      is_gang_member: Boolean @value(false)
      gang_confidence: Decimal @value(0.0)
      known_associates: List[String] @value([])
    }
  }

  // æ¬ºè¯ˆæ£€æµ‹
  fraud_detection: FraudDetection {
    // æ¨¡å‹è¯„åˆ†
    model_scores: ModelScores {
      gbdt_score: Decimal @value(0.15)
      dnn_score: Decimal @value(0.22)
      graph_score: Decimal @value(0.08)
      ensemble_score: Decimal @value(0.16)
    }
    
    // é£é™©ç­‰çº§
    risk_level: RiskLevel @value("LOW")
    risk_score: Decimal @value(16.0)
    
    // è§¦å‘è§„åˆ™
    triggered_rules: List[TriggeredRule] {
      // ä½é£é™©æ¡ˆä»¶æ— è§¦å‘è§„åˆ™
    }
    
    // æ¬ºè¯ˆç±»å‹
    fraud_type: Optional[String]
    fraud_indicators: List[String] @value([])
    
    // å»ºè®®å¤„ç½®
    recommendation: Recommendation {
      action: Enum @value("AUTO_APPROVE")
      priority: Enum @value("NORMAL")
      suggested_reserve: Decimal @value(12000.00)
      investigation_budget: Decimal @value(0)
      estimated_fraud_amount: Decimal @value(0)
    }
    
    // å†³ç­–è§£é‡Š
    explanation: Explanation {
      summary: String @value("æ¡ˆä»¶é£é™©ä½ï¼Œå»ºè®®è‡ªåŠ¨èµ”ä»˜")
      key_factors: List[String] @value([
        "ç†èµ”é¢‘ç‡æ­£å¸¸ï¼ˆè¿‘12ä¸ªæœˆ2æ¬¡ï¼‰",
        "å‡ºé™©åœ°ç‚¹æ— å¼‚å¸¸",
        "ç»´ä¿®å‚åˆä½œè®°å½•è‰¯å¥½",
        "æŸ¥å‹˜ç…§ç‰‡å®Œæ•´æ¸…æ™°"
      ])
      similar_cases: List[String] @value(["CLM2024XXXX001", "CLM2024XXXX002"])
    }
  }

  // å¤„ç†ç»“æœ
  processing_result: ProcessingResult {
    status: Enum @value("COMPLETED")
    final_decision: Enum @value("APPROVED")
    approved_amount: Decimal @value(12000.00)
    processing_time_hours: Decimal @value(4.5)
    payment_date: Date @value("2025-01-21")
  }
} @standard("ä¿é™©ç†èµ”åæ¬ºè¯ˆæ•°æ®è§„èŒƒ") @data_classification("SENSITIVE")
```

---

### 4.6 ä»£ç å®ç°

**ä¿é™©ç†èµ”æ™ºèƒ½åæ¬ºè¯ˆå¹³å°å®Œæ•´å®ç°**ï¼š

```python
"""
ä¿é™©ç†èµ”æ™ºèƒ½åæ¬ºè¯ˆå¹³å° - åŸºäºDSL Schemaçš„å¤šæ¨¡æ€é£æ§ç³»ç»Ÿ
æ”¯æŒæ¡ˆä»¶æ™ºèƒ½å®¡æ ¸ã€å›¢ä¼™è¯†åˆ«ã€æ¬ºè¯ˆæ£€æµ‹ã€çŸ¥è¯†å›¾è°±åˆ†æ
"""

import asyncio
import json
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Optional, Any, Set, Tuple
import hashlib
import networkx as nx
import numpy as np

import redis.asyncio as redis
import asyncpg
from neo4j import AsyncGraphDatabase

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("ClaimsFraudPlatform")


class ClaimStatus(Enum):
    """ç†èµ”çŠ¶æ€"""
    PENDING = "å¾…å¤„ç†"
    UNDER_REVIEW = "å®¡æ ¸ä¸­"
    INVESTIGATING = "è°ƒæŸ¥ä¸­"
    APPROVED = "å·²å®¡æ‰¹"
    REJECTED = "å·²æ‹’èµ”"
    COMPLETED = "å·²å®Œæˆ"


class RiskLevel(Enum):
    """é£é™©ç­‰çº§"""
    VERY_LOW = "æä½"
    LOW = "ä½"
    MEDIUM = "ä¸­"
    HIGH = "é«˜"
    VERY_HIGH = "æé«˜"


class FraudAction(Enum):
    """å¤„ç½®åŠ¨ä½œ"""
    AUTO_APPROVE = "è‡ªåŠ¨èµ”ä»˜"
    FAST_TRACK = "å¿«é€Ÿé€šé“"
    STANDARD_REVIEW = "æ ‡å‡†å®¡æ ¸"
    ENHANCED_REVIEW = "åŠ å¼ºå®¡æ ¸"
    INVESTIGATE = "è°ƒæŸ¥"
    EXPERT_REVIEW = "ä¸“å®¶ä¼šå®¡"
    REJECT = "æ‹’èµ”"


@dataclass
class Location:
    """ä½ç½®ä¿¡æ¯"""
    province: str
    city: str
    district: str
    address: str
    longitude: Decimal
    latitude: Decimal


@dataclass
class DamagePart:
    """æŸåéƒ¨ä»¶"""
    part_code: str
    part_name: str
    damage_type: str
    part_price: Decimal
    labor_cost: Decimal
    paint_cost: Decimal = Decimal('0')


@dataclass
class RepairShop:
    """ç»´ä¿®å‚"""
    shop_code: str
    shop_name: str
    shop_rating: Decimal
    is_authorized: bool
    cooperation_years: int
    monthly_claims_avg: int
    fraud_flag_count: int


@dataclass
class ClaimCase:
    """ç†èµ”æ¡ˆä»¶å®ä½“"""
    claim_no: str
    policy_no: str
    insurance_type: str
    accident_date: datetime
    report_date: datetime
    claim_date: datetime
    accident_location: Location
    accident_description: str
    
    # æŸå¤±ä¿¡æ¯
    estimated_loss: Decimal
    claim_amount: Decimal
    deductible: Decimal
    
    # å½“äº‹äºº
    insured_id_hash: str
    driver_id_hash: str
    driver_license_no: str
    driving_experience_years: int
    
    # è½¦è¾†
    vehicle_plate: str
    vin: str
    vehicle_age_months: int
    mileage_km: int
    
    # ç»´ä¿®
    repair_shop: RepairShop
    damage_parts: List[DamagePart]
    
    # çŠ¶æ€
    status: ClaimStatus = ClaimStatus.PENDING
    risk_level: RiskLevel = RiskLevel.LOW
    risk_score: Decimal = Decimal('0')
    fraud_probability: Decimal = Decimal('0')
    recommended_action: FraudAction = FraudAction.STANDARD_REVIEW
    created_at: datetime = field(default_factory=datetime.now)


class KnowledgeGraphBuilder:
    """çŸ¥è¯†å›¾è°±æ„å»ºå™¨"""
    
    def __init__(self, neo4j_uri: str, user: str, password: str):
        self.driver = AsyncGraphDatabase.driver(neo4j_uri, auth=(user, password))
    
    async def build_claim_graph(self, claim: ClaimCase):
        """æ„å»ºæ¡ˆä»¶å›¾è°±"""
        async with self.driver.session() as session:
            # åˆ›å»ºæ¡ˆä»¶èŠ‚ç‚¹
            await session.run("""
                MERGE (c:Claim {claim_no: $claim_no})
                SET c.claim_amount = $claim_amount,
                    c.accident_date = $accident_date,
                    c.risk_score = $risk_score
            """, claim_no=claim.claim_no, claim_amount=float(claim.claim_amount),
                 accident_date=claim.accident_date.isoformat(),
                 risk_score=float(claim.risk_score))
            
            # åˆ›å»ºè¢«ä¿é™©äººèŠ‚ç‚¹
            await session.run("""
                MERGE (i:Insured {id_hash: $insured_id})
                MERGE (c:Claim {claim_no: $claim_no})
                MERGE (i)-[:INSURED_IN]->(c)
            """, insured_id=claim.insured_id_hash, claim_no=claim.claim_no)
            
            # åˆ›å»ºé©¾é©¶å‘˜èŠ‚ç‚¹
            await session.run("""
                MERGE (d:Driver {license_no: $license_no})
                SET d.experience_years = $exp_years
                MERGE (c:Claim {claim_no: $claim_no})
                MERGE (d)-[:DROVE_IN]->(c)
            """, license_no=claim.driver_license_no,
                 exp_years=claim.driving_experience_years,
                 claim_no=claim.claim_no)
            
            # åˆ›å»ºè½¦è¾†èŠ‚ç‚¹
            await session.run("""
                MERGE (v:Vehicle {vin: $vin})
                SET v.plate = $plate,
                    v.age_months = $age
                MERGE (c:Claim {claim_no: $claim_no})
                MERGE (v)-[:INVOLVED_IN]->(c)
            """, vin=claim.vin, plate=claim.vehicle_plate,
                 age=claim.vehicle_age_months, claim_no=claim.claim_no)
            
            # åˆ›å»ºç»´ä¿®å‚èŠ‚ç‚¹
            await session.run("""
                MERGE (r:RepairShop {code: $shop_code})
                SET r.name = $shop_name,
                    r.fraud_flags = $fraud_flags
                MERGE (c:Claim {claim_no: $claim_no})
                MERGE (c)-[:REPAIRED_AT]->(r)
            """, shop_code=claim.repair_shop.shop_code,
                 shop_name=claim.repair_shop.shop_name,
                 fraud_flags=claim.repair_shop.fraud_flag_count,
                 claim_no=claim.claim_no)
            
            # åˆ›å»ºåœ°ç‚¹èŠ‚ç‚¹
            await session.run("""
                MERGE (l:Location {address: $address})
                SET l.city = $city,
                    l.longitude = $lon,
                    l.latitude = $lat
                MERGE (c:Claim {claim_no: $claim_no})
                MERGE (c)-[:OCCURRED_AT]->(l)
            """, address=claim.accident_location.address,
                 city=claim.accident_location.city,
                 lon=float(claim.accident_location.longitude),
                 lat=float(claim.accident_location.latitude),
                 claim_no=claim.claim_no)
    
    async def detect_communities(self, claim_no: str) -> List[Dict]:
        """æ£€æµ‹ç¤¾åŒº"""
        async with self.driver.session() as session:
            result = await session.run("""
                MATCH (c:Claim {claim_no: $claim_no})-[:INSURED_IN|DROVE_IN|INVOLVED_IN|REPAIRED_AT|OCCURRED_AT]-(n)
                WITH n
                MATCH (n)-[:INSURED_IN|DROVE_IN|INVOLVED_IN|REPAIRED_AT|OCCURRED_AT]-(c2:Claim)
                WITH c2, count(*) as connections
                WHERE connections >= 2
                RETURN c2.claim_no as related_claim, connections
                ORDER BY connections DESC
                LIMIT 10
            """, claim_no=claim_no)
            
            communities = []
            async for record in result:
                communities.append({
                    "related_claim": record["related_claim"],
                    "connection_strength": record["connections"]
                })
            return communities
    
    async def find_gang_patterns(self, claim_no: str) -> Optional[Dict]:
        """æŸ¥æ‰¾å›¢ä¼™æ¨¡å¼"""
        async with self.driver.session() as session:
            # æŸ¥æ‰¾é—­ç¯æ¬ºè¯ˆæ¨¡å¼
            result = await session.run("""
                MATCH (c:Claim {claim_no: $claim_no})-[:REPAIRED_AT]->(r:RepairShop)
                MATCH (r)<-[:REPAIRED_AT]-(c2:Claim)
                MATCH (c2)-[:INSURED_IN]->(i:Insured)
                MATCH (i)-[:INSURED_IN]->(c3:Claim)
                MATCH (c3)-[:OCCURRED_AT]->(l:Location)
                MATCH (l)<-[:OCCURRED_AT]-(c)
                WHERE c2.claim_no <> $claim_no AND c3.claim_no <> $claim_no
                RETURN count(*) as cycle_count
            """, claim_no=claim_no)
            
            record = await result.single()
            if record and record["cycle_count"] > 0:
                return {
                    "gang_pattern": "é—­ç¯æ¬ºè¯ˆ",
                    "confidence": min(record["cycle_count"] * 0.2, 1.0),
                    "description": "å‘ç°ç»´ä¿®å‚-è¢«ä¿é™©äºº-å‡ºé™©åœ°ç‚¹é—­ç¯å…³è”"
                }
            return None


class FeatureExtractor:
    """ç‰¹å¾æå–å™¨"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
    
    async def extract_features(self, claim: ClaimCase) -> Dict[str, float]:
        """æå–æ¡ˆä»¶ç‰¹å¾"""
        features = {}
        
        # æ—¶é—´ç‰¹å¾
        report_delay = (claim.report_date - claim.accident_date).total_seconds() / 3600
        features["report_delay_hours"] = report_delay
        features["is_night_accident"] = 1 if claim.accident_date.hour < 6 or claim.accident_date.hour > 22 else 0
        features["is_weekend"] = 1 if claim.accident_date.weekday() >= 5 else 0
        
        # æŸå¤±ç‰¹å¾
        features["claim_amount"] = float(claim.claim_amount)
        features["loss_claim_ratio"] = float(claim.estimated_loss / claim.claim_amount) if claim.claim_amount > 0 else 1
        
        # é©¾é©¶å‘˜ç‰¹å¾
        features["driving_experience"] = claim.driving_experience_years
        features["is_new_driver"] = 1 if claim.driving_experience_years < 2 else 0
        
        # è½¦è¾†ç‰¹å¾
        features["vehicle_age_months"] = claim.vehicle_age_months
        features["mileage"] = claim.mileage_km
        features["mileage_per_month"] = claim.mileage_km / max(claim.vehicle_age_months, 1)
        
        # ç»´ä¿®å‚ç‰¹å¾
        features["shop_rating"] = float(claim.repair_shop.shop_rating)
        features["shop_fraud_flags"] = claim.repair_shop.fraud_flag_count
        features["is_authorized_shop"] = 1 if claim.repair_shop.is_authorized else 0
        
        # æŸåéƒ¨ä»¶ç‰¹å¾
        features["damage_parts_count"] = len(claim.damage_parts)
        features["total_parts_cost"] = sum(
            p.part_price + p.labor_cost + p.paint_cost for p in claim.damage_parts
        )
        features["has_expensive_parts"] = 1 if any(
            p.part_price > 5000 for p in claim.damage_parts
        ) else 0
        
        # å†å²ç‰¹å¾
        historical = await self._get_historical_features(claim)
        features.update(historical)
        
        return features
    
    async def _get_historical_features(self, claim: ClaimCase) -> Dict[str, float]:
        """è·å–å†å²ç‰¹å¾"""
        features = {}
        
        # æŸ¥è¯¢å†å²ç†èµ”
        key = f"claims_history:{claim.insured_id_hash}"
        history_data = await self.redis.get(key)
        
        if history_data:
            history = json.loads(history_data)
            features["historical_claims_12m"] = history.get("claims_12m", 0)
            features["historical_amount_12m"] = history.get("amount_12m", 0)
            features["days_since_last_claim"] = history.get("days_since_last", 365)
        else:
            features["historical_claims_12m"] = 0
            features["historical_amount_12m"] = 0
            features["days_since_last_claim"] = 365
        
        return features


class FraudDetectionModel:
    """æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹"""
    
    def __init__(self):
        self.models = self._load_models()
    
    def _load_models(self) -> Dict:
        """åŠ è½½æ¨¡å‹"""
        return {
            "gbdt": None,  # lgb.Booster()
            "dnn": None,   # tf.keras.models.load_model()
            "graph": None  # GraphSAGE model
        }
    
    def predict(self, features: Dict[str, float]) -> Dict[str, float]:
        """é¢„æµ‹æ¬ºè¯ˆæ¦‚ç‡"""
        # GBDTé¢„æµ‹
        gbdt_score = self._gbdt_predict(features)
        
        # DNNé¢„æµ‹
        dnn_score = self._dnn_predict(features)
        
        # å›¾æ¨¡å‹é¢„æµ‹
        graph_score = self._graph_predict(features)
        
        # é›†æˆè¯„åˆ†
        ensemble = 0.5 * gbdt_score + 0.3 * dnn_score + 0.2 * graph_score
        
        return {
            "gbdt_score": gbdt_score,
            "dnn_score": dnn_score,
            "graph_score": graph_score,
            "ensemble_score": ensemble
        }
    
    def _gbdt_predict(self, features: Dict[str, float]) -> float:
        """GBDTé¢„æµ‹"""
        # æ¨¡æ‹Ÿé¢„æµ‹é€»è¾‘
        score = 0.1
        
        # é«˜é£é™©ç‰¹å¾
        if features.get("shop_fraud_flags", 0) > 0:
            score += 0.3
        if features.get("historical_claims_12m", 0) > 3:
            score += 0.2
        if features.get("is_new_driver", 0) == 1 and features.get("claim_amount", 0) > 10000:
            score += 0.15
        if features.get("report_delay_hours", 0) > 48:
            score += 0.1
        
        return min(score, 1.0)
    
    def _dnn_predict(self, features: Dict[str, float]) -> float:
        """DNNé¢„æµ‹"""
        # æ¨¡æ‹Ÿé¢„æµ‹
        return 0.15
    
    def _graph_predict(self, features: Dict[str, float]) -> float:
        """å›¾æ¨¡å‹é¢„æµ‹"""
        # æ¨¡æ‹Ÿé¢„æµ‹
        return 0.08


class RuleEngine:
    """è§„åˆ™å¼•æ“"""
    
    def __init__(self):
        self.rules = self._load_rules()
    
    def _load_rules(self) -> List[Dict]:
        """åŠ è½½è§„åˆ™"""
        return [
            {
                "rule_id": "FR001",
                "name": "é«˜é£é™©ç»´ä¿®å‚",
                "condition": lambda f: f.get("shop_fraud_flags", 0) >= 3,
                "score": 40,
                "action": FraudAction.INVESTIGATE,
                "explanation": "ç»´ä¿®å‚å­˜åœ¨å¤šèµ·æ¬ºè¯ˆå«Œç–‘è®°å½•"
            },
            {
                "rule_id": "FR002",
                "name": "é«˜é¢‘ç†èµ”",
                "condition": lambda f: f.get("historical_claims_12m", 0) >= 5,
                "score": 35,
                "action": FraudAction.ENHANCED_REVIEW,
                "explanation": "è¿‘12ä¸ªæœˆç†èµ”æ¬¡æ•°è¶…è¿‡5æ¬¡"
            },
            {
                "rule_id": "FR003",
                "name": "æ–°é©¾é©¶å‘˜é«˜é¢ç†èµ”",
                "condition": lambda f: f.get("is_new_driver", 0) == 1 and f.get("claim_amount", 0) > 20000,
                "score": 30,
                "action": FraudAction.INVESTIGATE,
                "explanation": "é©¾é¾„ä¸è¶³2å¹´ï¼Œç†èµ”é‡‘é¢è¶…è¿‡2ä¸‡å…ƒ"
            },
            {
                "rule_id": "FR004",
                "name": "å»¶è¿ŸæŠ¥æ¡ˆ",
                "condition": lambda f: f.get("report_delay_hours", 0) > 72,
                "score": 25,
                "action": FraudAction.ENHANCED_REVIEW,
                "explanation": "å‡ºé™©åè¶…è¿‡72å°æ—¶æŠ¥æ¡ˆ"
            },
            {
                "rule_id": "FR005",
                "name": "å¼‚å¸¸æŸå¤±æ¯”ä¾‹",
                "condition": lambda f: f.get("loss_claim_ratio", 1) > 1.2,
                "score": 20,
                "action": FraudAction.STANDARD_REVIEW,
                "explanation": "å®šæŸé‡‘é¢è¶…è¿‡ç´¢èµ”é‡‘é¢20%"
            }
        ]
    
    def evaluate(self, features: Dict[str, float]) -> Tuple[List[Dict], int, FraudAction]:
        """è¯„ä¼°è§„åˆ™"""
        triggered = []
        total_score = 0
        max_action_priority = 0
        final_action = FraudAction.AUTO_APPROVE
        
        action_priority = {
            FraudAction.AUTO_APPROVE: 1,
            FraudAction.FAST_TRACK: 2,
            FraudAction.STANDARD_REVIEW: 3,
            FraudAction.ENHANCED_REVIEW: 4,
            FraudAction.INVESTIGATE: 5,
            FraudAction.EXPERT_REVIEW: 6,
            FraudAction.REJECT: 7
        }
        
        for rule in self.rules:
            try:
                if rule["condition"](features):
                    triggered.append({
                        "rule_id": rule["rule_id"],
                        "rule_name": rule["name"],
                        "explanation": rule["explanation"]
                    })
                    total_score += rule["score"]
                    
                    action = rule["action"]
                    priority = action_priority.get(action, 0)
                    if priority > max_action_priority:
                        max_action_priority = priority
                        final_action = action
            except Exception as e:
                logger.error(f"è§„åˆ™ {rule['rule_id']} æ‰§è¡Œå¤±è´¥: {e}")
        
        return triggered, total_score, final_action


class ClaimsFraudPlatform:
    """ç†èµ”åæ¬ºè¯ˆå¹³å°ä¸»ç±»"""
    
    def __init__(self):
        self.redis_client: Optional[redis.Redis] = None
        self.db_pool: Optional[asyncpg.Pool] = None
        self.graph_builder: Optional[KnowledgeGraphBuilder] = None
        self.feature_extractor: Optional[FeatureExtractor] = None
        self.fraud_model = FraudDetectionModel()
        self.rule_engine = RuleEngine()
        
        # ç»Ÿè®¡
        self.stats = {
            "total_claims": 0,
            "auto_approved": 0,
            "investigated": 0,
            "rejected": 0,
            "fraud_detected": 0,
            "avg_processing_time": 0
        }
    
    async def initialize(self):
        """åˆå§‹åŒ–å¹³å°"""
        self.redis_client = redis.Redis(
            host='localhost', port=6379, db=3, decode_responses=True
        )
        self.db_pool = await asyncpg.create_pool(
            host='localhost', port=5432,
            user='admin', password='admin',
            database='claims_fraud'
        )
        self.graph_builder = KnowledgeGraphBuilder(
            "bolt://localhost:7687", "neo4j", "password"
        )
        self.feature_extractor = FeatureExtractor(self.redis_client)
        logger.info("ç†èµ”åæ¬ºè¯ˆå¹³å°åˆå§‹åŒ–å®Œæˆ")
    
    async def process_claim(self, claim_data: Dict) -> Dict:
        """å¤„ç†ç†èµ”æ¡ˆä»¶"""
        start_time = time.time()
        
        try:
            # 1. æ„å»ºæ¡ˆä»¶å®ä½“
            claim = self._build_claim_entity(claim_data)
            
            # 2. ç‰¹å¾æå–
            features = await self.feature_extractor.extract_features(claim)
            
            # 3. æ¨¡å‹é¢„æµ‹
            model_scores = self.fraud_model.predict(features)
            
            # 4. è§„åˆ™è¯„ä¼°
            triggered_rules, rule_score, action = self.rule_engine.evaluate(features)
            
            # 5. çŸ¥è¯†å›¾è°±åˆ†æ
            await self.graph_builder.build_claim_graph(claim)
            communities = await self.graph_builder.detect_communities(claim.claim_no)
            gang_pattern = await self.graph_builder.find_gang_patterns(claim.claim_no)
            
            # 6. ç»¼åˆè¯„åˆ†
            graph_bonus = 0.1 if gang_pattern else 0
            final_score = model_scores["ensemble_score"] * 100 + rule_score + graph_bonus * 100
            final_score = min(final_score, 100)
            
            # 7. ç¡®å®šé£é™©ç­‰çº§
            risk_level = self._determine_risk_level(final_score)
            
            # 8. è°ƒæ•´å¤„ç½®å»ºè®®
            if gang_pattern:
                action = FraudAction.INVESTIGATE
            
            # 9. æ„å»ºç»“æœ
            processing_time = time.time() - start_time
            
            result = {
                "claim_no": claim.claim_no,
                "risk_score": round(final_score, 2),
                "risk_level": risk_level.value,
                "fraud_probability": round(model_scores["ensemble_score"], 4),
                "recommended_action": action.value,
                "model_scores": model_scores,
                "triggered_rules": triggered_rules,
                "community_info": {
                    "related_claims": len(communities),
                    "top_connections": communities[:3]
                },
                "gang_analysis": gang_pattern,
                "explanation": self._generate_explanation(final_score, triggered_rules, gang_pattern),
                "processing_time_ms": int(processing_time * 1000)
            }
            
            # 10. æ›´æ–°ç»Ÿè®¡
            await self._update_stats(action, processing_time)
            
            # 11. å­˜å‚¨ç»“æœ
            await self._store_result(claim, result)
            
            logger.info(f"æ¡ˆä»¶å¤„ç†å®Œæˆ: claim_no={claim.claim_no}, "
                       f"risk_score={final_score}, action={action.value}")
            
            return result
            
        except Exception as e:
            logger.error(f"æ¡ˆä»¶å¤„ç†å¤±è´¥: {e}")
            return {"error": str(e), "claim_no": claim_data.get("claim_no")}
    
    def _build_claim_entity(self, data: Dict) -> ClaimCase:
        """æ„å»ºæ¡ˆä»¶å®ä½“"""
        location_data = data.get("accident_location", {})
        location = Location(
            province=location_data.get("province", ""),
            city=location_data.get("city", ""),
            district=location_data.get("district", ""),
            address=location_data.get("address", ""),
            longitude=Decimal(str(location_data.get("longitude", 0))),
            latitude=Decimal(str(location_data.get("latitude", 0)))
        )
        
        repair_data = data.get("repair_info", {}).get("repair_shop", {})
        repair_shop = RepairShop(
            shop_code=repair_data.get("shop_code", ""),
            shop_name=repair_data.get("shop_name", ""),
            shop_rating=Decimal(str(repair_data.get("shop_rating", 0))),
            is_authorized=repair_data.get("is_authorized", False),
            cooperation_years=repair_data.get("cooperation_years", 0),
            monthly_claims_avg=repair_data.get("monthly_claims_avg", 0),
            fraud_flag_count=repair_data.get("fraud_flag_count", 0)
        )
        
        damage_parts = []
        for part_data in data.get("repair_info", {}).get("damage_parts", []):
            damage_parts.append(DamagePart(
                part_code=part_data.get("part_code", ""),
                part_name=part_data.get("part_name", ""),
                damage_type=part_data.get("damage_type", ""),
                part_price=Decimal(str(part_data.get("part_price", 0))),
                labor_cost=Decimal(str(part_data.get("labor_cost", 0))),
                paint_cost=Decimal(str(part_data.get("paint_cost", 0)))
            ))
        
        return ClaimCase(
            claim_no=data.get("claim_no", ""),
            policy_no=data.get("policy_no", ""),
            insurance_type=data.get("insurance_type", ""),
            accident_date=datetime.fromisoformat(data.get("accident_date", "")),
            report_date=datetime.fromisoformat(data.get("report_date", "")),
            claim_date=datetime.fromisoformat(data.get("claim_date", "")),
            accident_location=location,
            accident_description=data.get("accident_description", ""),
            estimated_loss=Decimal(str(data.get("estimated_loss", 0))),
            claim_amount=Decimal(str(data.get("claim_amount", 0))),
            deductible=Decimal(str(data.get("deductible", 0))),
            insured_id_hash=data.get("parties", {}).get("insured", {}).get("id_hash", ""),
            driver_id_hash=data.get("parties", {}).get("driver", {}).get("id_hash", ""),
            driver_license_no=data.get("parties", {}).get("driver", {}).get("license_no", ""),
            driving_experience_years=data.get("parties", {}).get("insured", {}).get("driving_experience_years", 0),
            vehicle_plate=data.get("vehicle_info", {}).get("vehicle_plate", ""),
            vin=data.get("vehicle_info", {}).get("vin", ""),
            vehicle_age_months=data.get("vehicle_info", {}).get("vehicle_age_months", 0),
            mileage_km=data.get("vehicle_info", {}).get("mileage_km", 0),
            repair_shop=repair_shop,
            damage_parts=damage_parts
        )
    
    def _determine_risk_level(self, score: float) -> RiskLevel:
        """ç¡®å®šé£é™©ç­‰çº§"""
        if score < 20:
            return RiskLevel.VERY_LOW
        elif score < 40:
            return RiskLevel.LOW
        elif score < 60:
            return RiskLevel.MEDIUM
        elif score < 80:
            return RiskLevel.HIGH
        return RiskLevel.VERY_HIGH
    
    def _generate_explanation(self, score: float, rules: List[Dict], gang: Optional[Dict]) -> str:
        """ç”Ÿæˆè§£é‡Š"""
        if gang:
            return f"å‘ç°ç–‘ä¼¼å›¢ä¼™æ¬ºè¯ˆæ¨¡å¼: {gang['description']}"
        
        if score >= 60:
            rule_names = [r["rule_name"] for r in rules[:3]]
            return f"è§¦å‘æ¬ºè¯ˆè§„åˆ™: {', '.join(rule_names)}"
        elif score >= 40:
            return "å­˜åœ¨ä¸€å®šé£é™©å› ç´ ï¼Œå»ºè®®åŠ å¼ºå®¡æ ¸"
        elif score >= 20:
            return "é£é™©å¯æ§ï¼Œå¯æŒ‰æ ‡å‡†æµç¨‹å¤„ç†"
        return "æœªå‘ç°æ˜æ˜¾é£é™©ï¼Œå»ºè®®è‡ªåŠ¨èµ”ä»˜"
    
    async def _update_stats(self, action: FraudAction, processing_time: float):
        """æ›´æ–°ç»Ÿè®¡"""
        self.stats["total_claims"] += 1
        
        if action in [FraudAction.AUTO_APPROVE, FraudAction.FAST_TRACK]:
            self.stats["auto_approved"] += 1
        elif action in [FraudAction.INVESTIGATE, FraudAction.EXPERT_REVIEW]:
            self.stats["investigated"] += 1
        elif action == FraudAction.REJECT:
            self.stats["rejected"] += 1
        
        if action in [FraudAction.INVESTIGATE, FraudAction.EXPERT_REVIEW, FraudAction.REJECT]:
            self.stats["fraud_detected"] += 1
        
        # æ›´æ–°å¹³å‡å¤„ç†æ—¶é—´
        n = self.stats["total_claims"]
        self.stats["avg_processing_time"] = (
            (self.stats["avg_processing_time"] * (n - 1) + processing_time) / n
        )
    
    async def _store_result(self, claim: ClaimCase, result: Dict):
        """å­˜å‚¨ç»“æœ"""
        key = f"claim_result:{claim.claim_no}"
        await self.redis_client.setex(key, 86400 * 30, json.dumps(result))
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡"""
        total = self.stats["total_claims"]
        if total == 0:
            return self.stats
        
        return {
            **self.stats,
            "auto_approval_rate": round(self.stats["auto_approved"] / total * 100, 2),
            "investigation_rate": round(self.stats["investigated"] / total * 100, 2),
            "fraud_detection_rate": round(self.stats["fraud_detected"] / total * 100, 2),
            "avg_processing_time_ms": round(self.stats["avg_processing_time"] * 1000, 2)
        }


# ä½¿ç”¨ç¤ºä¾‹
async def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºç†èµ”åæ¬ºè¯ˆå¹³å°"""
    platform = ClaimsFraudPlatform()
    await platform.initialize()
    
    # æ„é€ ç†èµ”æ¡ˆä»¶
    claim_data = {
        "claim_no": "CLM20250121000001",
        "policy_no": "POL2025000001",
        "insurance_type": "AUTO",
        "accident_date": "2025-01-20T15:30:00",
        "report_date": "2025-01-20T16:45:00",
        "claim_date": "2025-01-21T09:00:00",
        "accident_location": {
            "province": "å¹¿ä¸œçœ",
            "city": "æ·±åœ³å¸‚",
            "district": "å—å±±åŒº",
            "address": "æ·±å—å¤§é“XXè·¯æ®µ",
            "longitude": 113.9433,
            "latitude": 22.5233
        },
        "accident_description": "ä¸¤è½¦è¿½å°¾ï¼Œæœ¬è½¦è½¦å¤´å—æŸ",
        "estimated_loss": 15000,
        "claim_amount": 12000,
        "deductible": 1000,
        "parties": {
            "insured": {
                "id_hash": "HASH-insured001",
                "driving_experience_years": 10
            },
            "driver": {
                "id_hash": "HASH-driver001",
                "license_no": "HASH-license001"
            }
        },
        "vehicle_info": {
            "vehicle_plate": "ç²¤A-XXXXX",
            "vin": "LSVXXXXXXXXXXXXXX",
            "vehicle_age_months": 31,
            "mileage_km": 45000
        },
        "repair_info": {
            "repair_shop": {
                "shop_code": "RS001",
                "shop_name": "XXæ±½è½¦ç»´ä¿®ä¸­å¿ƒ",
                "shop_rating": 4.2,
                "is_authorized": True,
                "cooperation_years": 3,
                "monthly_claims_avg": 45,
                "fraud_flag_count": 0
            },
            "damage_parts": [
                {
                    "part_code": "BUMPER_FRONT",
                    "part_name": "å‰ä¿é™©æ ",
                    "damage_type": "REPLACE",
                    "part_price": 2800,
                    "labor_cost": 500,
                    "paint_cost": 800
                },
                {
                    "part_code": "HEADLIGHT_LEFT",
                    "part_name": "å·¦å‰å¤§ç¯",
                    "damage_type": "REPLACE",
                    "part_price": 3500,
                    "labor_cost": 300
                }
            ]
        }
    }
    
    # å¤„ç†æ¡ˆä»¶
    result = await platform.process_claim(claim_data)
    print(f"æ¡ˆä»¶å¤„ç†ç»“æœ:")
    print(f"  é£é™©è¯„åˆ†: {result.get('risk_score')}")
    print(f"  é£é™©ç­‰çº§: {result.get('risk_level')}")
    print(f"  æ¬ºè¯ˆæ¦‚ç‡: {result.get('fraud_probability')}")
    print(f"  å»ºè®®å¤„ç½®: {result.get('recommended_action')}")
    print(f"  å¤„ç†è€—æ—¶: {result.get('processing_time_ms')}ms")
    print(f"  å†³ç­–è§£é‡Š: {result.get('explanation')}")
    
    print(f"\nå¹³å°ç»Ÿè®¡: {json.dumps(platform.get_stats(), ensure_ascii=False, indent=2)}")


if __name__ == "__main__":
    asyncio.run(main())
```


### 4.7 æ•ˆæœè¯„ä¼°

#### 4.7.1 æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ç±»åˆ« | æŒ‡æ ‡é¡¹ | å»ºè®¾å‰ | å»ºè®¾å | æå‡å¹…åº¦ |
|----------|--------|--------|--------|----------|
| **æ¬ºè¯ˆè¯†åˆ«** | æ¬ºè¯ˆæ¡ˆä»¶è¯†åˆ«ç‡ | 35% | 89% | **æå‡54%** |
| | å›¢ä¼™æ¬ºè¯ˆå‘ç°ç‡ | 15% | 82% | **æå‡67%** |
| | è¯¯æŠ¥ç‡ | 25% | 4.5% | **é™ä½82%** |
| | æ¬ºè¯ˆæŸå¤±ç‡ | 5.2% | 1.8% | **é™ä½65%** |
| **å®¡æ ¸æ•ˆç‡** | æ¡ˆä»¶å¤„ç†æ—¶æ•ˆ | 5å¤© | 8å°æ—¶ | **ç¼©çŸ­93%** |
| | è‡ªåŠ¨å®¡æ ¸å æ¯” | 20% | 75% | **æå‡55%** |
| | äººå·¥å®¡æ ¸å·¥ä½œé‡ | 100% | 25% | **é™ä½75%** |
| | è°ƒæŸ¥æ¡ˆä»¶ç²¾å‡†åº¦ | 40% | 85% | **æå‡45%** |
| **æˆæœ¬èŠ‚çº¦** | è°ƒæŸ¥æˆæœ¬ | Â¥3,000/æ¡ˆ | Â¥1,200/æ¡ˆ | **é™ä½60%** |
| | å®¡æ ¸äººåŠ›æˆæœ¬ | åŸºå‡† | -45% | **é™ä½45%** |
| | å•æ¡ˆå¤„ç†æˆæœ¬ | Â¥450 | Â¥180 | **é™ä½60%** |
| **ç³»ç»Ÿèƒ½åŠ›** | æ—¥å¤„ç†æ¡ˆä»¶é‡ | 5,000ä»¶ | 25,000ä»¶ | **æå‡5å€** |
| | å³°å€¼å¤„ç†èƒ½åŠ› | 8,000ä»¶/æ—¥ | 50,000ä»¶/æ—¥ | **æå‡5.25å€** |
| | å›¾è°±æŸ¥è¯¢å“åº” | 3ç§’ | 200ms | **æå‡93%** |
| **ä¸šåŠ¡ä»·å€¼** | å¹´åº¦æ¬ºè¯ˆæŸå¤± | Â¥15äº¿ | Â¥5.2äº¿ | **å‡å°‘65%** |
| | æŒ½å›æŸå¤±é‡‘é¢ | åŸºå‡† | +Â¥9.8äº¿/å¹´ | **æ–°å¢** |

#### 4.7.2 ä¸šåŠ¡ä»·å€¼è¯„ä¼°

| ä»·å€¼ç»´åº¦ | å…·ä½“æ”¶ç›Š | é‡åŒ–æŒ‡æ ‡ | ROIè®¡ç®— |
|----------|----------|----------|---------|
| **æ¬ºè¯ˆæŸå¤±æŒ½å›** | æ¬ºè¯ˆè¯†åˆ«ç‡æå‡å¸¦æ¥çš„èµ”ä»˜å‡å°‘ | å¹´åº¦æŒ½å›ï¼šÂ¥9.8äº¿ | 3å¹´ç´¯è®¡ï¼šÂ¥29.4äº¿ |
| **è°ƒæŸ¥æˆæœ¬èŠ‚çº¦** | ç²¾å‡†è°ƒæŸ¥å‡å°‘æ— æ•ˆè°ƒæŸ¥æŠ•å…¥ | å¹´åº¦èŠ‚çº¦ï¼šÂ¥6,500ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥1.95äº¿ |
| **è¿è¥æ•ˆç‡æå‡** | è‡ªåŠ¨åŒ–å®¡æ ¸å¸¦æ¥çš„äººåŠ›æˆæœ¬èŠ‚çº¦ | å¹´åº¦èŠ‚çº¦ï¼šÂ¥4,200ä¸‡ | 3å¹´ç´¯è®¡ï¼šÂ¥1.26äº¿ |
| **å®¢æˆ·ä½“éªŒæå‡** | å®¡æ ¸æ—¶æ•ˆæå‡å¸¦æ¥çš„å®¢æˆ·æ»¡æ„åº¦å¢é•¿ | NPSæå‡15åˆ† | å“ç‰Œä»·å€¼æå‡Â¥8äº¿ |
| **åˆè§„ä»·å€¼** | æ»¡è¶³ç›‘ç®¡åæ¬ºè¯ˆè¦æ±‚ï¼Œé¿å…åˆè§„é£é™© | ç›‘ç®¡è¯„ä»·ä¼˜ç§€ | é¿å…æ½œåœ¨ç½šæ¬¾Â¥5,000ä¸‡ |

**æ€»æŠ•èµ„å›æŠ¥ç‡ï¼ˆROIï¼‰**ï¼š
- é¡¹ç›®æ€»æŠ•èµ„ï¼šÂ¥1.2äº¿ï¼ˆå«å¹³å°å»ºè®¾ã€æ¨¡å‹å¼€å‘ã€çŸ¥è¯†å›¾è°±æ„å»ºã€æ•°æ®é‡‡è´­ï¼‰
- é¦–å¹´æ”¶ç›Šï¼šÂ¥15.7äº¿
- 3å¹´ç´¯è®¡æ”¶ç›Šï¼šÂ¥41.11äº¿
- **3å¹´ROI = 3,426%**
- **æŠ•èµ„å›æ”¶æœŸ = 1ä¸ªæœˆ**

#### 4.7.3 ç»éªŒæ•™è®­

**æˆåŠŸç»éªŒ**ï¼š

1. **çŸ¥è¯†å›¾è°±ä»·å€¼å·¨å¤§**ï¼šæ„å»ºçš„ç†èµ”çŸ¥è¯†å›¾è°±åŒ…å«500ä¸‡+èŠ‚ç‚¹ã€2,000ä¸‡+å…³ç³»ï¼ŒæˆåŠŸè¯†åˆ«å‡º120+ä¸ªéª—ä¿å›¢ä¼™ï¼Œæ¶‰åŠæ¡ˆä»¶è¶…è¿‡3,000ä»¶ï¼Œé¢„è®¡æŒ½å›æŸå¤±Â¥4.5äº¿ã€‚å›¾è°±åˆ†æä½¿å›¢ä¼™æ¬ºè¯ˆå‘ç°ç‡ä»15%æå‡è‡³82%ã€‚

2. **å¤šæ¨¡å‹èåˆç­–ç•¥**ï¼šé‡‡ç”¨GBDT+DNN+å›¾ç¥ç»ç½‘ç»œçš„ä¸‰æ¨¡å‹èåˆï¼Œå„æ¨¡å‹æ•æ‰ä¸åŒç±»å‹çš„æ¬ºè¯ˆæ¨¡å¼ã€‚èåˆæ¨¡å‹AUCè¾¾åˆ°0.94ï¼Œæ˜¾è‘—ä¼˜äºå•ä¸€æ¨¡å‹ï¼ˆAUC 0.82-0.87ï¼‰ã€‚

3. **ä¸»åŠ¨å­¦ä¹ æœºåˆ¶**ï¼šå»ºç«‹"æ¨¡å‹é¢„æµ‹-äººå·¥æ ‡æ³¨-æ¨¡å‹æ›´æ–°"é—­ç¯ï¼Œæ¯æ—¥ä»é¢„æµ‹æ¡ˆä»¶ä¸­æŠ½æ ·äººå·¥å¤æ ¸ï¼ŒæŒç»­ä¸°å¯Œè®­ç»ƒæ ·æœ¬ã€‚3ä¸ªæœˆå†…è®­ç»ƒæ ·æœ¬é‡ä»10ä¸‡å¢è‡³50ä¸‡ï¼Œæ¨¡å‹æ•ˆæœæå‡12%ã€‚

**æ•™è®­ä¸æ”¹è¿›**ï¼š

1. **æ•°æ®è´¨é‡ç“¶é¢ˆ**ï¼šåˆæœŸå¤–éƒ¨æ•°æ®ï¼ˆäº¤è­¦ã€åŒ»é™¢ï¼‰æ¥å…¥å›°éš¾ï¼Œæ•°æ®è´¨é‡å·®ï¼Œå½±å“æ¨¡å‹æ•ˆæœã€‚æ”¹è¿›ï¼šå»ºç«‹æ•°æ®è´¨é‡SLAï¼Œä¸æ•°æ®æä¾›æ–¹ç­¾ç½²è´¨é‡åè®®ï¼Œæ•°æ®é—®é¢˜å“åº”æ—¶æ•ˆ<24å°æ—¶ã€‚

2. **æ¨¡å‹å¯è§£é‡Šæ€§æŒ‘æˆ˜**ï¼šä¸šåŠ¡äººå‘˜å¯¹"é»‘ç›’"æ¨¡å‹å†³ç­–å­˜ç–‘ï¼Œå½±å“è½åœ°æ¨å¹¿ã€‚æ”¹è¿›ï¼šå¼•å…¥SHAPå€¼è§£é‡Šå’Œè§„åˆ™å½’å› ï¼Œä¸ºæ¯ç¬”é«˜é£é™©æ¡ˆä»¶ç”Ÿæˆ"æ¬ºè¯ˆè¯æ®é“¾"ï¼ŒåŒ…æ‹¬æ¶‰åŠçš„å®ä½“ã€å…³ç³»ã€è§„åˆ™ï¼Œä¸šåŠ¡æ¥å—åº¦ä»50%æå‡è‡³95%ã€‚

3. **æ­£è´Ÿæ ·æœ¬æåº¦å¤±è¡¡**ï¼šæ¬ºè¯ˆæ ·æœ¬å æ¯”<1%ï¼ŒåˆæœŸæ¨¡å‹å€¾å‘äºé¢„æµ‹æ­£å¸¸ã€‚æ”¹è¿›ï¼šé‡‡ç”¨SMOTE+ADASYNæ··åˆé‡‡æ ·ï¼Œç»“åˆä»£ä»·æ•æ„Ÿå­¦ä¹ ï¼ˆæ¬ºè¯ˆæ ·æœ¬æƒé‡10å€ï¼‰ï¼Œæ¨¡å‹å¬å›ç‡ä»45%æå‡è‡³89%ã€‚

**è¡Œä¸šè´¡çŒ®**ï¼š

è¯¥å¹³å°å·²ä¸è¡Œä¸šåæ¬ºè¯ˆè”ç›Ÿå¯¹æ¥ï¼Œå…±äº«æ¬ºè¯ˆæƒ…æŠ¥å’Œå›¢ä¼™ç‰¹å¾ï¼Œç´¯è®¡è¾“å‡ºæ¬ºè¯ˆçº¿ç´¢è¶…è¿‡2,000æ¡ï¼ŒååŠ©åŒä¸šè¯†åˆ«æ¬ºè¯ˆæ¡ˆä»¶è¶…è¿‡5,000ä»¶ï¼Œä¸ºè¡Œä¸šåæ¬ºè¯ˆåä½œæ ‘ç«‹äº†æ ‡æ†ã€‚å…¶çŸ¥è¯†å›¾è°±Schemaæ ‡å‡†å·²è¢«ä¸­å›½ä¿é™©è¡Œä¸šåä¼šé‡‡çº³ï¼Œæ­£åœ¨å…¨è¡Œä¸šæ¨å¹¿ã€‚

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æœ€åæ›´æ–°**ï¼š2025-01-21

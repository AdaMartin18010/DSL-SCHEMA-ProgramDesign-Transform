# å†œä¸šç‰©è”ç½‘Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
- [2. ä¼ä¸šèƒŒæ™¯](#2-ä¼ä¸šèƒŒæ™¯)
- [3. ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡](#3-ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡)
- [4. æŠ€æœ¯æŒ‘æˆ˜](#4-æŠ€æœ¯æŒ‘æˆ˜)
- [5. è§£å†³æ–¹æ¡ˆæ¶æ„](#5-è§£å†³æ–¹æ¡ˆæ¶æ„)
- [6. å®Œæ•´å®ç°ä»£ç ](#6-å®Œæ•´å®ç°ä»£ç )
- [7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ](#7-æ•ˆæœè¯„ä¼°ä¸roiåˆ†æ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å†œä¸šç‰©è”ç½‘(IoT)Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®Œæ•´å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†ã€è®¾å¤‡ç®¡ç†ã€è¿œç¨‹æ§åˆ¶ã€è¾¹ç¼˜è®¡ç®—ç­‰æ ¸å¿ƒIoTåœºæ™¯ã€‚

---

## 2. ä¼ä¸šèƒŒæ™¯

### 2.1 ä¼ä¸šæ¦‚å†µ

**ä¼ä¸šåç§°**ï¼šæ™ºè”å†œä¸šç‰©è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸ï¼ˆè™šæ„æ¡ˆä¾‹ä¼ä¸šï¼‰

**ä¼ä¸šè§„æ¨¡**ï¼š
- éƒ¨ç½²ä¼ æ„Ÿå™¨èŠ‚ç‚¹ï¼š50,000+
- è¦†ç›–å†œåœºï¼š150+å®¶
- æ—¥å¤„ç†æ•°æ®é‡ï¼š2TB
- å¹´è¥ä¸šé¢ï¼š1.5äº¿å…ƒäººæ°‘å¸

---

## 3. ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡

### 3.1 äº”å¤§ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å…·ä½“è¡¨ç° | å½±å“ç¨‹åº¦ |
|------|------|----------|----------|
| 1 | **è®¾å¤‡ç®¡ç†å¤æ‚** | å¤šå‚å•†è®¾å¤‡åè®®ä¸ä¸€ | é«˜ |
| 2 | **ç½‘ç»œè¦†ç›–å›°éš¾** | å†œç”°ç½‘ç»œä¿¡å·ä¸ç¨³å®š | é«˜ |
| 3 | **æ•°æ®ä¸¢å¤±é£é™©** | ç½‘ç»œä¸­æ–­å¯¼è‡´æ•°æ®ä¸¢å¤± | é«˜ |
| 4 | **å®æ—¶æ€§å·®** | æ§åˆ¶æŒ‡ä»¤å»¶è¿Ÿé«˜ | ä¸­ |
| 5 | **è¿ç»´æˆæœ¬é«˜** | ç°åœºç»´æŠ¤é¢‘ç¹ | ä¸­ |

### 3.2 äº”å¤§ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å…·ä½“æŒ‡æ ‡ | å®ŒæˆæœŸé™ |
|------|------|----------|----------|
| 1 | **ç»Ÿä¸€è®¾å¤‡ç®¡ç†** | æ”¯æŒ50+ç§è®¾å¤‡åè®® | 9ä¸ªæœˆ |
| 2 | **æ•°æ®å®Œæ•´æ€§** | æ•°æ®ä¸¢å¤±ç‡<0.1% | 6ä¸ªæœˆ |
| 3 | **å®æ—¶æ§åˆ¶** | æ§åˆ¶å»¶è¿Ÿ<2ç§’ | 6ä¸ªæœˆ |
| 4 | **è¿œç¨‹è¿ç»´** | 80%é—®é¢˜è¿œç¨‹è§£å†³ | 12ä¸ªæœˆ |
| 5 | **è¾¹ç¼˜æ™ºèƒ½** | 50%è®¡ç®—æœ¬åœ°å®Œæˆ | 12ä¸ªæœˆ |

---

## 4. æŠ€æœ¯æŒ‘æˆ˜

1. **åè®®å…¼å®¹æ€§**ï¼šModbusã€LoRaWANã€NB-IoTç­‰å¤šç§é€šä¿¡åè®®
2. **è¾¹ç¼˜è®¡ç®—**ï¼šç½‘ç»œä¸ç¨³å®šæƒ…å†µä¸‹çš„æ•°æ®å¤„ç†èƒ½åŠ›
3. **å®æ—¶æ•°æ®å¤„ç†**ï¼šé«˜é¢‘ä¼ æ„Ÿå™¨æ•°æ®çš„å®æ—¶åˆ†æ
4. **è®¾å¤‡å®‰å…¨**ï¼šç‰©è”ç½‘è®¾å¤‡çš„å®‰å…¨è®¤è¯å’ŒåŠ å¯†
5. **èƒ½è€—ç®¡ç†**ï¼šä½åŠŸè€—è®¾è®¡å’Œç”µæ± å¯¿å‘½ä¼˜åŒ–

---

## 5. è§£å†³æ–¹æ¡ˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    äº‘å¹³å°å±‚                                  â”‚
â”‚  è®¾å¤‡ç®¡ç†  æ•°æ®å­˜å‚¨  è§„åˆ™å¼•æ“  å¯è§†åŒ–                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ç½‘ç»œå±‚                                    â”‚
â”‚  4G/5G  LoRaWAN  NB-IoT  WiFi  å«æ˜Ÿ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    è¾¹ç¼˜å±‚                                    â”‚
â”‚  è¾¹ç¼˜ç½‘å…³  åè®®è½¬æ¢  æœ¬åœ°å­˜å‚¨  è¾¹ç¼˜è®¡ç®—                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ„ŸçŸ¥å±‚                                    â”‚
â”‚  åœŸå£¤ä¼ æ„Ÿå™¨  æ°”è±¡ç«™  æ‘„åƒå¤´  æ§åˆ¶å™¨  æ‰§è¡Œå™¨                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å†œä¸šç‰©è”ç½‘Schemaå®è·µæ¡ˆä¾‹
ä¼ä¸šï¼šæ™ºè”å†œä¸šç‰©è”ç½‘ç§‘æŠ€æœ‰é™å…¬å¸
"""

import json
import uuid
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
from collections import deque
import threading
import random
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class DeviceType(Enum):
    """è®¾å¤‡ç±»å‹"""
    SOIL_SENSOR = "soil_sensor"
    WEATHER_STATION = "weather_station"
    CAMERA = "camera"
    IRRIGATION_CONTROLLER = "irrigation_controller"
    GATEWAY = "gateway"


class DeviceStatus(Enum):
    """è®¾å¤‡çŠ¶æ€"""
    ONLINE = "online"
    OFFLINE = "offline"
    SLEEPING = "sleeping"
    ERROR = "error"
    MAINTENANCE = "maintenance"


class ProtocolType(Enum):
    """é€šä¿¡åè®®"""
    MODBUS_RTU = "modbus_rtu"
    MODBUS_TCP = "modbus_tcp"
    LORAWAN = "lorawan"
    MQTT = "mqtt"
    HTTP = "http"
    COAP = "coap"
    NB_IOT = "nb_iot"


@dataclass
class SensorReading:
    """ä¼ æ„Ÿå™¨è¯»æ•°"""
    sensor_id: str
    timestamp: datetime
    metric_name: str
    value: float
    unit: str
    quality: str = "good"  # good, suspect, bad
    
    def to_dict(self) -> Dict:
        return {
            "sensor_id": self.sensor_id,
            "timestamp": self.timestamp.isoformat(),
            "metric_name": self.metric_name,
            "value": self.value,
            "unit": self.unit,
            "quality": self.quality
        }


@dataclass
class IoTDevice:
    """ç‰©è”ç½‘è®¾å¤‡"""
    device_id: str
    device_name: str
    device_type: DeviceType
    protocol: ProtocolType
    status: DeviceStatus = DeviceStatus.OFFLINE
    firmware_version: str = "1.0.0"
    last_seen: Optional[datetime] = None
    battery_level: Optional[float] = None  # %
    signal_strength: Optional[float] = None  # dBm
    location: Dict[str, float] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_online(self) -> bool:
        if not self.last_seen:
            return False
        return (datetime.now() - self.last_seen).seconds < 300  # 5åˆ†é’Ÿå†…æœ‰å¿ƒè·³
    
    def update_status(self):
        self.status = DeviceStatus.ONLINE if self.is_online() else DeviceStatus.OFFLINE
    
    def to_dict(self) -> Dict:
        return {
            "device_id": self.device_id,
            "device_name": self.device_name,
            "device_type": self.device_type.value,
            "protocol": self.protocol.value,
            "status": self.status.value,
            "firmware_version": self.firmware_version,
            "last_seen": self.last_seen.isoformat() if self.last_seen else None,
            "battery_level": self.battery_level,
            "signal_strength": self.signal_strength,
            "location": self.location
        }


@dataclass
class ControlCommand:
    """æ§åˆ¶å‘½ä»¤"""
    command_id: str
    device_id: str
    command_type: str
    parameters: Dict[str, Any]
    issued_at: datetime
    executed_at: Optional[datetime] = None
    status: str = "pending"  # pending, executing, completed, failed
    response: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return {
            "command_id": self.command_id,
            "device_id": self.device_id,
            "command_type": self.command_type,
            "parameters": self.parameters,
            "issued_at": self.issued_at.isoformat(),
            "executed_at": self.executed_at.isoformat() if self.executed_at else None,
            "status": self.status,
            "response": self.response
        }


class ProtocolAdapter:
    """åè®®é€‚é…å™¨"""
    
    def __init__(self):
        self.parsers: Dict[ProtocolType, Callable] = {
            ProtocolType.MODBUS_RTU: self._parse_modbus,
            ProtocolType.MQTT: self._parse_mqtt,
            ProtocolType.LORAWAN: self._parse_lorawan,
            ProtocolType.HTTP: self._parse_http
        }
    
    def parse_message(self, protocol: ProtocolType, raw_data: bytes) -> Optional[Dict]:
        """è§£æåŸå§‹æ•°æ®"""
        parser = self.parsers.get(protocol)
        if parser:
            return parser(raw_data)
        return None
    
    def _parse_modbus(self, data: bytes) -> Dict:
        """è§£æModbusæ•°æ®ï¼ˆç®€åŒ–ï¼‰"""
        # æ¨¡æ‹ŸModbusè§£æ
        return {
            "register_address": 0,
            "value": int.from_bytes(data[:2], 'big') if len(data) >= 2 else 0
        }
    
    def _parse_mqtt(self, data: bytes) -> Dict:
        """è§£æMQTTæ•°æ®"""
        try:
            return json.loads(data.decode('utf-8'))
        except:
            return {"raw": data.hex()}
    
    def _parse_lorawan(self, data: bytes) -> Dict:
        """è§£æLoRaWANæ•°æ®"""
        # ç®€åŒ–çš„LoRaWANè§£æ
        return {
            "payload": data.hex(),
            "port": 1,
            "rssi": -80
        }
    
    def _parse_http(self, data: bytes) -> Dict:
        """è§£æHTTPæ•°æ®"""
        try:
            return json.loads(data.decode('utf-8'))
        except:
            return {"raw": data.decode('utf-8', errors='ignore')}


class EdgeGateway:
    """è¾¹ç¼˜ç½‘å…³"""
    
    def __init__(self, gateway_id: str):
        self.gateway_id = gateway_id
        self.devices: Dict[str, IoTDevice] = {}
        self.data_buffer: deque = deque(maxlen=10000)
        self.command_queue: List[ControlCommand] = []
        self.local_storage: Dict[str, List[Dict]] = {}
        self.adapter = ProtocolAdapter()
        self.running = False
        self.edge_rules: List[Callable] = []
        
    def register_device(self, device: IoTDevice):
        """æ³¨å†Œè®¾å¤‡"""
        self.devices[device.device_id] = device
        self.local_storage[device.device_id] = []
        logger.info(f"Device {device.device_id} registered to gateway {self.gateway_id}")
    
    def process_sensor_data(self, device_id: str, raw_data: bytes, protocol: ProtocolType):
        """å¤„ç†ä¼ æ„Ÿå™¨æ•°æ®"""
        device = self.devices.get(device_id)
        if not device:
            return
        
        # æ›´æ–°è®¾å¤‡çŠ¶æ€
        device.last_seen = datetime.now()
        device.update_status()
        
        # è§£ææ•°æ®
        parsed = self.adapter.parse_message(protocol, raw_data)
        if not parsed:
            return
        
        # åˆ›å»ºè¯»æ•°è®°å½•
        reading = {
            "device_id": device_id,
            "gateway_id": self.gateway_id,
            "timestamp": datetime.now().isoformat(),
            "protocol": protocol.value,
            "data": parsed
        }
        
        # æœ¬åœ°å­˜å‚¨
        self.local_storage[device_id].append(reading)
        
        # è¾¹ç¼˜è®¡ç®—ï¼šæ‰§è¡Œæœ¬åœ°è§„åˆ™
        self._execute_edge_rules(device_id, reading)
        
        # åŠ å…¥ä¸Šä¼ ç¼“å†²åŒº
        self.data_buffer.append(reading)
        
        return reading
    
    def _execute_edge_rules(self, device_id: str, reading: Dict):
        """æ‰§è¡Œè¾¹ç¼˜è®¡ç®—è§„åˆ™"""
        for rule in self.edge_rules:
            try:
                rule(device_id, reading)
            except Exception as e:
                logger.error(f"Edge rule error: {e}")
    
    def add_edge_rule(self, rule: Callable):
        """æ·»åŠ è¾¹ç¼˜è§„åˆ™"""
        self.edge_rules.append(rule)
    
    def queue_command(self, command: ControlCommand):
        """é˜Ÿåˆ—æ§åˆ¶å‘½ä»¤"""
        self.command_queue.append(command)
        logger.info(f"Command queued: {command.command_id}")
    
    def execute_command(self, command_id: str) -> bool:
        """æ‰§è¡Œæ§åˆ¶å‘½ä»¤"""
        command = next((c for c in self.command_queue if c.command_id == command_id), None)
        if not command:
            return False
        
        device = self.devices.get(command.device_id)
        if not device or device.status != DeviceStatus.ONLINE:
            command.status = "failed"
            command.response = "Device offline"
            return False
        
        # æ¨¡æ‹Ÿå‘½ä»¤æ‰§è¡Œ
        command.status = "executing"
        time.sleep(0.1)  # æ¨¡æ‹Ÿæ‰§è¡Œå»¶è¿Ÿ
        command.status = "completed"
        command.executed_at = datetime.now()
        command.response = "Success"
        
        logger.info(f"Command executed: {command_id}")
        return True
    
    def sync_to_cloud(self) -> List[Dict]:
        """åŒæ­¥æ•°æ®åˆ°äº‘ç«¯"""
        data_to_sync = list(self.data_buffer)
        self.data_buffer.clear()
        return data_to_sync
    
    def get_device_stats(self) -> Dict:
        """è·å–è®¾å¤‡ç»Ÿè®¡"""
        online_count = sum(1 for d in self.devices.values() if d.status == DeviceStatus.ONLINE)
        return {
            "gateway_id": self.gateway_id,
            "total_devices": len(self.devices),
            "online_devices": online_count,
            "offline_devices": len(self.devices) - online_count,
            "buffer_size": len(self.data_buffer),
            "pending_commands": len(self.command_queue)
        }


class IoTPlatform:
    """ç‰©è”ç½‘å¹³å°"""
    
    def __init__(self):
        self.gateways: Dict[str, EdgeGateway] = {}
        self.devices: Dict[str, IoTDevice] = {}
        self.data_store: Dict[str, List[Dict]] = {}
        self.rules: List[Dict] = []
        self.command_history: List[ControlCommand] = []
    
    def register_gateway(self, gateway: EdgeGateway):
        """æ³¨å†Œç½‘å…³"""
        self.gateways[gateway.gateway_id] = gateway
        logger.info(f"Gateway registered: {gateway.gateway_id}")
    
    def get_all_devices(self) -> List[IoTDevice]:
        """è·å–æ‰€æœ‰è®¾å¤‡"""
        devices = []
        for gateway in self.gateways.values():
            devices.extend(gateway.devices.values())
        return devices
    
    def create_rule(self, rule_name: str, condition: Dict, action: Dict):
        """åˆ›å»ºè§„åˆ™"""
        rule = {
            "rule_id": str(uuid.uuid4()),
            "name": rule_name,
            "condition": condition,
            "action": action,
            "enabled": True
        }
        self.rules.append(rule)
        return rule
    
    def process_data_stream(self, gateway_id: str, readings: List[Dict]):
        """å¤„ç†æ•°æ®æµ"""
        for reading in readings:
            device_id = reading.get("device_id")
            if device_id not in self.data_store:
                self.data_store[device_id] = []
            self.data_store[device_id].append(reading)
            
            # è¯„ä¼°è§„åˆ™
            self._evaluate_rules(reading)
    
    def _evaluate_rules(self, reading: Dict):
        """è¯„ä¼°è§„åˆ™"""
        for rule in self.rules:
            if not rule["enabled"]:
                continue
            
            condition = rule["condition"]
            if self._check_condition(reading, condition):
                self._execute_action(rule["action"], reading)
    
    def _check_condition(self, reading: Dict, condition: Dict) -> bool:
        """æ£€æŸ¥æ¡ä»¶"""
        metric = condition.get("metric")
        operator = condition.get("operator")
        threshold = condition.get("threshold")
        
        data = reading.get("data", {})
        value = data.get(metric) if isinstance(data, dict) else None
        
        if value is None:
            return False
        
        if operator == ">":
            return value > threshold
        elif operator == "<":
            return value < threshold
        elif operator == "==":
            return value == threshold
        
        return False
    
    def _execute_action(self, action: Dict, reading: Dict):
        """æ‰§è¡ŒåŠ¨ä½œ"""
        action_type = action.get("type")
        if action_type == "send_command":
            device_id = action.get("device_id")
            command_type = action.get("command_type")
            parameters = action.get("parameters", {})
            
            command = ControlCommand(
                command_id=str(uuid.uuid4()),
                device_id=device_id,
                command_type=command_type,
                parameters=parameters,
                issued_at=datetime.now()
            )
            
            # æ‰¾åˆ°å¯¹åº”çš„ç½‘å…³
            for gateway in self.gateways.values():
                if device_id in gateway.devices:
                    gateway.queue_command(command)
                    self.command_history.append(command)
                    break
        
        elif action_type == "alert":
            logger.warning(f"Rule triggered alert: {action.get('message')}")
    
    def get_analytics(self, device_id: str, metric: str, hours: int = 24) -> Dict:
        """è·å–è®¾å¤‡åˆ†ææ•°æ®"""
        data = self.data_store.get(device_id, [])
        
        # è¿‡æ»¤æ—¶é—´èŒƒå›´
        cutoff_time = datetime.now() - timedelta(hours=hours)
        recent_data = [
            d for d in data 
            if datetime.fromisoformat(d["timestamp"]) > cutoff_time
        ]
        
        # æå–æŒ‡æ ‡å€¼
        values = []
        for d in recent_data:
            d_data = d.get("data", {})
            if isinstance(d_data, dict) and metric in d_data:
                values.append(d_data[metric])
        
        if not values:
            return {"error": "No data available"}
        
        return {
            "device_id": device_id,
            "metric": metric,
            "period_hours": hours,
            "count": len(values),
            "min": min(values),
            "max": max(values),
            "avg": sum(values) / len(values),
            "latest": values[-1] if values else None
        }
    
    def generate_platform_report(self) -> Dict:
        """ç”Ÿæˆå¹³å°æŠ¥å‘Š"""
        total_devices = len(self.get_all_devices())
        online_devices = sum(1 for d in self.get_all_devices() if d.status == DeviceStatus.ONLINE)
        
        return {
            "report_time": datetime.now().isoformat(),
            "gateways": len(self.gateways),
            "total_devices": total_devices,
            "online_devices": online_devices,
            "online_rate": round(online_devices / total_devices * 100, 2) if total_devices else 0,
            "active_rules": len([r for r in self.rules if r["enabled"]]),
            "total_data_points": sum(len(d) for d in self.data_store.values()),
            "commands_executed": len(self.command_history)
        }


def create_demo_iot_system():
    """åˆ›å»ºæ¼”ç¤ºIoTç³»ç»Ÿ"""
    platform = IoTPlatform()
    
    # åˆ›å»ºç½‘å…³
    gateway1 = EdgeGateway("GW-001")
    gateway2 = EdgeGateway("GW-002")
    
    # åˆ›å»ºè®¾å¤‡
    devices = [
        IoTDevice("SOIL-001", "1å·åœŸå£¤ä¼ æ„Ÿå™¨", DeviceType.SOIL_SENSOR, ProtocolType.LORAWAN),
        IoTDevice("SOIL-002", "2å·åœŸå£¤ä¼ æ„Ÿå™¨", DeviceType.SOIL_SENSOR, ProtocolType.LORAWAN),
        IoTDevice("WEATHER-001", "æ°”è±¡ç«™1", DeviceType.WEATHER_STATION, ProtocolType.MQTT),
        IoTDevice("IRR-001", "çŒæº‰æ§åˆ¶å™¨", DeviceType.IRRIGATION_CONTROLLER, ProtocolType.MQTT),
        IoTDevice("SOIL-003", "3å·åœŸå£¤ä¼ æ„Ÿå™¨", DeviceType.SOIL_SENSOR, ProtocolType.NB_IOT),
        IoTDevice("CAM-001", "ç›‘æ§æ‘„åƒå¤´", DeviceType.CAMERA, ProtocolType.HTTP),
    ]
    
    # æ³¨å†Œè®¾å¤‡åˆ°ç½‘å…³
    for i, device in enumerate(devices):
        if i < 3:
            gateway1.register_device(device)
        else:
            gateway2.register_device(device)
    
    # æ·»åŠ è¾¹ç¼˜è§„åˆ™ï¼šåœŸå£¤æ¹¿åº¦ä½æ—¶è‡ªåŠ¨çŒæº‰
    def auto_irrigation_rule(device_id: str, reading: Dict):
        data = reading.get("data", {})
        if isinstance(data, dict) and data.get("moisture", 100) < 40:
            logger.info(f"Edge rule: Low moisture detected on {device_id}, triggering irrigation")
    
    gateway1.add_edge_rule(auto_irrigation_rule)
    
    # æ³¨å†Œç½‘å…³åˆ°å¹³å°
    platform.register_gateway(gateway1)
    platform.register_gateway(gateway2)
    
    # åˆ›å»ºå¹³å°è§„åˆ™
    platform.create_rule(
        rule_name="é«˜æ¸©é¢„è­¦",
        condition={"metric": "temperature", "operator": ">", "threshold": 35},
        action={"type": "alert", "message": "æ¸©åº¦è¿‡é«˜ï¼Œè¯·æ³¨æ„é®é˜³"}
    )
    
    # æ¨¡æ‹Ÿæ•°æ®æ”¶é›†
    for gateway in [gateway1, gateway2]:
        for device_id in gateway.devices:
            for _ in range(10):
                # æ¨¡æ‹Ÿä¼ æ„Ÿå™¨æ•°æ®
                raw_data = json.dumps({
                    "moisture": random.uniform(30, 80),
                    "temperature": random.uniform(20, 38),
                    "battery": random.uniform(20, 100)
                }).encode()
                
                protocol = gateway.devices[device_id].protocol
                gateway.process_sensor_data(device_id, raw_data, protocol)
    
    return platform


def main():
    """ä¸»å‡½æ•°"""
    print("=" * 80)
    print("å†œä¸šç‰©è”ç½‘Schemaå®è·µæ¡ˆä¾‹ - æ™ºè”å†œä¸šIoT")
    print("=" * 80)
    
    # åˆ›å»ºç³»ç»Ÿ
    print("\nã€æ­¥éª¤1ã€‘åˆ›å»ºIoTç³»ç»Ÿ...")
    platform = create_demo_iot_system()
    print(f"  ç½‘å…³æ•°é‡: {len(platform.gateways)}")
    print(f"  è®¾å¤‡æ€»æ•°: {len(platform.get_all_devices())}")
    
    # åŒæ­¥æ•°æ®åˆ°äº‘ç«¯
    print("\nã€æ­¥éª¤2ã€‘åŒæ­¥æ•°æ®åˆ°äº‘ç«¯...")
    total_synced = 0
    for gateway in platform.gateways.values():
        data = gateway.sync_to_cloud()
        platform.process_data_stream(gateway.gateway_id, data)
        total_synced += len(data)
    print(f"  åŒæ­¥æ•°æ®ç‚¹: {total_synced}")
    
    # è®¾å¤‡ç»Ÿè®¡
    print("\nã€æ­¥éª¤3ã€‘è®¾å¤‡çŠ¶æ€ç»Ÿè®¡...")
    for gw_id, gateway in platform.gateways.items():
        stats = gateway.get_device_stats()
        print(f"  ç½‘å…³ {gw_id}:")
        print(f"    è®¾å¤‡æ•°: {stats['total_devices']}, åœ¨çº¿: {stats['online_devices']}")
    
    # æ•°æ®åˆ†æ
    print("\nã€æ­¥éª¤4ã€‘ä¼ æ„Ÿå™¨æ•°æ®åˆ†æ...")
    analytics = platform.get_analytics("SOIL-001", "moisture", hours=24)
    if "error" not in analytics:
        print(f"  è®¾å¤‡ SOIL-001 åœŸå£¤æ¹¿åº¦:")
        print(f"    å¹³å‡å€¼: {analytics['avg']:.1f}%")
        print(f"    èŒƒå›´: {analytics['min']:.1f}% - {analytics['max']:.1f}%")
    
    # å¹³å°æŠ¥å‘Š
    print("\nã€æ­¥éª¤5ã€‘ç”Ÿæˆå¹³å°æŠ¥å‘Š...")
    report = platform.generate_platform_report()
    print(f"  åœ¨çº¿ç‡: {report['online_rate']}%")
    print(f"  æ´»è·ƒè§„åˆ™: {report['active_rules']}")
    print(f"  æ€»æ•°æ®ç‚¹: {report['total_data_points']}")
    
    print("\n" + "=" * 80)
    print("å†œä¸šç‰©è”ç½‘Schemaå®è·µæ¡ˆä¾‹æ‰§è¡Œå®Œæˆ")
    print("=" * 80)


if __name__ == "__main__":
    main()
```

---

## 7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ

### 7.1 å…³é”®ç»©æ•ˆæŒ‡æ ‡

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æ”¹å–„ |
|------|--------|--------|------|
| è®¾å¤‡åœ¨çº¿ç‡ | 75% | 98% | +31% |
| æ•°æ®å®Œæ•´æ€§ | 85% | 99.9% | +18% |
| å“åº”å»¶è¿Ÿ | 8ç§’ | 1.2ç§’ | -85% |
| ç°åœºç»´æŠ¤æ¬¡æ•° | æ¯æœˆ20æ¬¡ | æ¯æœˆ4æ¬¡ | -80% |

### 7.2 ROIåˆ†æ

**æŠ•èµ„**ï¼šÂ¥120ä¸‡  
**å¹´æ”¶ç›Š**ï¼šÂ¥200ä¸‡  
**ROI**ï¼š167%ï¼ˆ3å¹´ï¼‰

---

**åˆ›å»ºæ—¶é—´**ï¼š2026-02-15  
**ç‰ˆæœ¬**ï¼š1.0.0

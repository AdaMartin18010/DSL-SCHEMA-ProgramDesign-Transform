# é£Ÿå“æº¯æºSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
- [2. ä¼ä¸šèƒŒæ™¯](#2-ä¼ä¸šèƒŒæ™¯)
- [3. ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡](#3-ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡)
- [4. æŠ€æœ¯æŒ‘æˆ˜](#4-æŠ€æœ¯æŒ‘æˆ˜)
- [5. è§£å†³æ–¹æ¡ˆæ¶æ„](#5-è§£å†³æ–¹æ¡ˆæ¶æ„)
- [6. å®Œæ•´å®ç°ä»£ç ](#6-å®Œæ•´å®ç°ä»£ç )
- [7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ](#7-æ•ˆæœè¯„ä¼°ä¸roiåˆ†æ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›é£Ÿå“æº¯æºSchemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®Œæ•´å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ä»å†œç”°åˆ°é¤æ¡Œçš„å…¨é“¾æ¡æº¯æºç®¡ç†ï¼ŒåŒ…æ‹¬ç§æ¤ã€åŠ å·¥ã€ä»“å‚¨ã€ç‰©æµã€é”€å”®ç­‰ç¯èŠ‚çš„æ•°æ®è¿½è¸ªã€‚

---

## 2. ä¼ä¸šèƒŒæ™¯

### 2.1 ä¼ä¸šæ¦‚å†µ

**ä¼ä¸šåç§°**ï¼šé£Ÿå®‰é“¾æº¯æºç§‘æŠ€æœ‰é™å…¬å¸ï¼ˆè™šæ„æ¡ˆä¾‹ä¼ä¸šï¼‰

**ä¼ä¸šè§„æ¨¡**ï¼š
- æœåŠ¡é£Ÿå“ä¼ä¸šï¼š300+å®¶
- æº¯æºäº§å“ç§ç±»ï¼š500+ç§
- å¹´æº¯æºæ•°æ®é‡ï¼š10äº¿æ¡
- å¹´è¥ä¸šé¢ï¼š1.2äº¿å…ƒäººæ°‘å¸

---

## 3. ä¸šåŠ¡ç—›ç‚¹ä¸ç›®æ ‡

### 3.1 äº”å¤§ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å…·ä½“è¡¨ç° | å½±å“ç¨‹åº¦ |
|------|------|----------|----------|
| 1 | **ä¿¡æ¯ä¸é€æ˜** | æ¶ˆè´¹è€…æ— æ³•äº†è§£é£Ÿå“æ¥æº | é«˜ |
| 2 | **æ•°æ®æ˜“ç¯¡æ”¹** | ä¼ ç»Ÿçº¸è´¨è®°å½•å¯éšæ„ä¿®æ”¹ | é«˜ |
| 3 | **å¬å›æ•ˆç‡ä½** | é—®é¢˜é£Ÿå“å¬å›èŒƒå›´éš¾ç¡®å®š | é«˜ |
| 4 | **ç›‘ç®¡å›°éš¾** | ç›‘ç®¡éƒ¨é—¨éš¾ä»¥å®æ—¶æŒæ¡ | ä¸­ |
| 5 | **å“ç‰Œä¿¡ä»»åº¦** | é£Ÿå“å®‰å…¨äº‹ä»¶é¢‘å‘å½±å“ä¿¡ä»» | ä¸­ |

### 3.2 äº”å¤§ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å…·ä½“æŒ‡æ ‡ | å®ŒæˆæœŸé™ |
|------|------|----------|----------|
| 1 | **å…¨ç¨‹å¯è¿½æº¯** | è¦†ç›–100%äº§å“ | 12ä¸ªæœˆ |
| 2 | **æ•°æ®é˜²ç¯¡æ”¹** | åŒºå—é“¾å­˜è¯ï¼Œä¸å¯ç¯¡æ”¹ | 9ä¸ªæœˆ |
| 3 | **ç§’çº§æŸ¥è¯¢** | æº¯æºæŸ¥è¯¢<3ç§’ | 6ä¸ªæœˆ |
| 4 | **ç²¾å‡†å¬å›** | å¬å›èŒƒå›´ç¼©å°90% | 12ä¸ªæœˆ |
| 5 | **æ¶ˆè´¹è€…ä¿¡ä»»** | å“ç‰Œä¿¡ä»»åº¦æå‡50% | 24ä¸ªæœˆ |

---

## 4. æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šç¯èŠ‚æ•°æ®æ•´åˆ**ï¼šç§æ¤ã€åŠ å·¥ã€ç‰©æµç­‰å¤šç¯èŠ‚æ•°æ®æ ¼å¼ä¸ä¸€
2. **åŒºå—é“¾æ€§èƒ½**ï¼šé«˜é¢‘æ•°æ®ä¸Šé“¾çš„æ€§èƒ½ç“¶é¢ˆ
3. **äºŒç»´ç å®‰å…¨**ï¼šé˜²ä¼ªé˜²å¤åˆ¶æŠ€æœ¯
4. **æ•°æ®éšç§ä¿æŠ¤**ï¼šå•†ä¸šæœºå¯†ä¸æ¶ˆè´¹è€…çŸ¥æƒ…æƒå¹³è¡¡
5. **è·¨å¢ƒæº¯æº**ï¼šè¿›å‡ºå£é£Ÿå“çš„å›½é™…æ ‡å‡†å¯¹æ¥

---

## 5. è§£å†³æ–¹æ¡ˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚                                    â”‚
â”‚  æ¶ˆè´¹è€…æŸ¥è¯¢  ä¼ä¸šåå°  ç›‘ç®¡å¹³å°  æ•°æ®åˆ†æ                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æœåŠ¡å±‚                                    â”‚
â”‚  æº¯æºæœåŠ¡  åŒºå—é“¾æœåŠ¡  äºŒç»´ç æœåŠ¡  å‘Šè­¦æœåŠ¡                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ•°æ®å±‚                                    â”‚
â”‚  æº¯æºæ•°æ®åº“  åŒºå—é“¾  æ–‡ä»¶å­˜å‚¨  ç¼“å­˜                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    æ¥å…¥å±‚                                    â”‚
â”‚  ç§æ¤ç«¯  åŠ å·¥ç«¯  ä»“å‚¨ç«¯  ç‰©æµç«¯  é”€å”®ç«¯                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
é£Ÿå“æº¯æºSchemaå®è·µæ¡ˆä¾‹
ä¼ä¸šï¼šé£Ÿå®‰é“¾æº¯æºç§‘æŠ€æœ‰é™å…¬å¸
"""

import json
import uuid
import hashlib
from datetime import datetime, date
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import random
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TraceabilityStage(Enum):
    """æº¯æºç¯èŠ‚"""
    PLANTING = "ç§æ¤"
    HARVESTING = "é‡‡æ”¶"
    PROCESSING = "åŠ å·¥"
    PACKAGING = "åŒ…è£…"
    STORAGE = "ä»“å‚¨"
    TRANSPORT = "è¿è¾“"
    DISTRIBUTION = "åˆ†é”€"
    RETAIL = "é›¶å”®"


class ProductCategory(Enum):
    """äº§å“ç±»åˆ«"""
    VEGETABLES = "è”¬èœ"
    FRUITS = "æ°´æœ"
    GRAINS = "ç²®æ²¹"
    MEAT = "è‚‰ç±»"
    DAIRY = "ä¹³åˆ¶å“"
    AQUATIC = "æ°´äº§"
    PROCESSED = "åŠ å·¥é£Ÿå“"


@dataclass
class Producer:
    """ç”Ÿäº§è€…"""
    producer_id: str
    name: str
    type: str  # å†œæˆ·ã€åˆä½œç¤¾ã€ä¼ä¸š
    address: str
    contact: str
    license_number: str
    certification: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict:
        return {
            "producer_id": self.producer_id,
            "name": self.name,
            "type": self.type,
            "address": self.address,
            "contact": self.contact,
            "license_number": self.license_number,
            "certification": self.certification
        }


@dataclass
class TraceabilityEvent:
    """æº¯æºäº‹ä»¶"""
    event_id: str
    product_id: str
    stage: TraceabilityStage
    timestamp: datetime
    location: str
    operator: str
    operation: str
    details: Dict[str, Any] = field(default_factory=dict)
    attachments: List[str] = field(default_factory=list)
    blockchain_tx: Optional[str] = None
    
    def calculate_hash(self) -> str:
        """è®¡ç®—äº‹ä»¶å“ˆå¸Œ"""
        data = f"{self.event_id}:{self.product_id}:{self.timestamp}:{self.operation}"
        return hashlib.sha256(data.encode()).hexdigest()
    
    def to_dict(self) -> Dict:
        return {
            "event_id": self.event_id,
            "product_id": self.product_id,
            "stage": self.stage.value,
            "timestamp": self.timestamp.isoformat(),
            "location": self.location,
            "operator": self.operator,
            "operation": self.operation,
            "details": self.details,
            "attachments": self.attachments,
            "blockchain_tx": self.blockchain_tx,
            "hash": self.calculate_hash()
        }


@dataclass
class Product:
    """äº§å“"""
    product_id: str
    trace_code: str  # è¿½æº¯ç 
    name: str
    category: ProductCategory
    batch_number: str
    production_date: date
    shelf_life_days: int
    producer: Producer
    specifications: str = ""
    storage_conditions: str = ""
    qr_code: str = ""
    
    def generate_qr_code(self) -> str:
        """ç”ŸæˆäºŒç»´ç å†…å®¹"""
        return f"https://trace.example.com/{self.trace_code}"
    
    def __post_init__(self):
        if not self.qr_code:
            self.qr_code = self.generate_qr_code()
    
    def to_dict(self) -> Dict:
        return {
            "product_id": self.product_id,
            "trace_code": self.trace_code,
            "name": self.name,
            "category": self.category.value,
            "batch_number": self.batch_number,
            "production_date": self.production_date.isoformat(),
            "shelf_life_days": self.shelf_life_days,
            "producer": self.producer.to_dict(),
            "specifications": self.specifications,
            "storage_conditions": self.storage_conditions,
            "qr_code": self.qr_code
        }


@dataclass
class QualityTest:
    """è´¨é‡æ£€æµ‹"""
    test_id: str
    product_id: str
    test_type: str
    test_date: date
    test_items: List[Dict]
    overall_result: str  # åˆæ ¼/ä¸åˆæ ¼
    tester: str
    certificate_url: str = ""
    
    def to_dict(self) -> Dict:
        return {
            "test_id": self.test_id,
            "product_id": self.product_id,
            "test_type": self.test_type,
            "test_date": self.test_date.isoformat(),
            "test_items": self.test_items,
            "overall_result": self.overall_result,
            "tester": self.tester,
            "certificate_url": self.certificate_url
        }


class BlockchainLedger:
    """åŒºå—é“¾è´¦æœ¬ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    
    def __init__(self):
        self.blocks: List[Dict] = []
        self.pending_transactions: List[Dict] = []
        self._create_genesis_block()
    
    def _create_genesis_block(self):
        """åˆ›å»ºåˆ›ä¸–åŒºå—"""
        genesis = {
            "index": 0,
            "timestamp": datetime.now().isoformat(),
            "data": "Genesis Block",
            "previous_hash": "0" * 64,
            "hash": self._calculate_hash(0, "0" * 64, "Genesis Block")
        }
        self.blocks.append(genesis)
    
    def _calculate_hash(self, index: int, previous_hash: str, data: str) -> str:
        """è®¡ç®—åŒºå—å“ˆå¸Œ"""
        block_string = f"{index}{previous_hash}{data}{datetime.now().isoformat()}"
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def add_transaction(self, event: TraceabilityEvent):
        """æ·»åŠ äº¤æ˜“"""
        transaction = {
            "event_id": event.event_id,
            "product_id": event.product_id,
            "hash": event.calculate_hash(),
            "timestamp": datetime.now().isoformat()
        }
        self.pending_transactions.append(transaction)
        
        # ç®€åŒ–ï¼šæ¯ä¸ªäº¤æ˜“ç›´æ¥æ‰“åŒ…æˆåŒºå—
        return self._mine_block(transaction)
    
    def _mine_block(self, transaction: Dict) -> str:
        """æ‰“åŒ…åŒºå—ï¼ˆç®€åŒ–æŒ–çŸ¿ï¼‰"""
        previous_block = self.blocks[-1]
        new_block = {
            "index": len(self.blocks),
            "timestamp": datetime.now().isoformat(),
            "data": transaction,
            "previous_hash": previous_block["hash"],
            "hash": self._calculate_hash(len(self.blocks), previous_block["hash"], json.dumps(transaction))
        }
        self.blocks.append(new_block)
        return new_block["hash"]
    
    def verify_chain(self) -> bool:
        """éªŒè¯åŒºå—é“¾å®Œæ•´æ€§"""
        for i in range(1, len(self.blocks)):
            current = self.blocks[i]
            previous = self.blocks[i - 1]
            
            if current["previous_hash"] != previous["hash"]:
                return False
            
            if current["hash"] != self._calculate_hash(
                current["index"], current["previous_hash"], 
                json.dumps(current["data"])
            ):
                return False
        
        return True


class TraceabilitySystem:
    """æº¯æºç³»ç»Ÿ"""
    
    def __init__(self):
        self.products: Dict[str, Product] = {}
        self.events: Dict[str, List[TraceabilityEvent]] = {}
        self.quality_tests: Dict[str, List[QualityTest]] = {}
        self.blockchain = BlockchainLedger()
        self.producers: Dict[str, Producer] = {}
    
    def register_producer(self, producer: Producer):
        """æ³¨å†Œç”Ÿäº§è€…"""
        self.producers[producer.producer_id] = producer
        logger.info(f"Registered producer: {producer.name}")
    
    def register_product(self, product: Product):
        """æ³¨å†Œäº§å“"""
        self.products[product.product_id] = product
        self.events[product.product_id] = []
        self.quality_tests[product.product_id] = []
        
        # è®°å½•ä¸Šé“¾
        genesis_event = TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=product.product_id,
            stage=TraceabilityStage.PLANTING,
            timestamp=datetime.now(),
            location=product.producer.address,
            operator=product.producer.name,
            operation="äº§å“æ³¨å†Œ"
        )
        tx_hash = self.blockchain.add_transaction(genesis_event)
        genesis_event.blockchain_tx = tx_hash
        self.events[product.product_id].append(genesis_event)
        
        logger.info(f"Registered product: {product.name} ({product.trace_code})")
        return product
    
    def record_event(self, event: TraceabilityEvent):
        """è®°å½•æº¯æºäº‹ä»¶"""
        if event.product_id not in self.events:
            raise ValueError(f"Product {event.product_id} not found")
        
        # ä¸Šé“¾å­˜è¯
        tx_hash = self.blockchain.add_transaction(event)
        event.blockchain_tx = tx_hash
        
        self.events[event.product_id].append(event)
        logger.info(f"Recorded event: {event.operation} for {event.product_id}")
        return event
    
    def add_quality_test(self, test: QualityTest):
        """æ·»åŠ è´¨æ£€è®°å½•"""
        if test.product_id not in self.quality_tests:
            raise ValueError(f"Product {test.product_id} not found")
        
        self.quality_tests[test.product_id].append(test)
        
        # è®°å½•è´¨æ£€äº‹ä»¶
        event = TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=test.product_id,
            stage=TraceabilityStage.PROCESSING,
            timestamp=datetime.combine(test.test_date, datetime.min.time()),
            location="æ£€æµ‹ä¸­å¿ƒ",
            operator=test.tester,
            operation=f"è´¨é‡æ£€æµ‹:{test.test_type}",
            details={"result": test.overall_result, "test_id": test.test_id}
        )
        self.record_event(event)
        
        logger.info(f"Added quality test: {test.test_id}")
    
    def trace_product(self, trace_code: str) -> Optional[Dict]:
        """è¿½æº¯äº§å“å…¨é“¾è·¯"""
        product = next((p for p in self.products.values() if p.trace_code == trace_code), None)
        if not product:
            return None
        
        events = self.events.get(product.product_id, [])
        tests = self.quality_tests.get(product.product_id, [])
        
        return {
            "product": product.to_dict(),
            "trace_history": [e.to_dict() for e in sorted(events, key=lambda x: x.timestamp)],
            "quality_tests": [t.to_dict() for t in tests],
            "total_events": len(events),
            "blockchain_verified": self.blockchain.verify_chain()
        }
    
    def quick_query(self, trace_code: str) -> Dict:
        """å¿«é€ŸæŸ¥è¯¢ï¼ˆä¾›æ¶ˆè´¹è€…æ‰«ç ï¼‰"""
        trace_result = self.trace_product(trace_code)
        if not trace_result:
            return {"error": "Product not found"}
        
        product = trace_result["product"]
        events = trace_result["trace_history"]
        
        # æå–å…³é”®ä¿¡æ¯
        stages = list(set(e["stage"] for e in events))
        latest_event = events[-1] if events else None
        
        return {
            "product_name": product["name"],
            "producer": product["producer"]["name"],
            "production_date": product["production_date"],
            "trace_stages": stages,
            "stage_count": len(stages),
            "blockchain_verified": trace_result["blockchain_verified"],
            "latest_status": latest_event["operation"] if latest_event else "Unknown"
        }
    
    def recall_products(self, batch_number: str, reason: str) -> List[str]:
        """å¬å›äº§å“"""
        affected_products = [
            p.product_id for p in self.products.values() 
            if p.batch_number == batch_number
        ]
        
        for product_id in affected_products:
            event = TraceabilityEvent(
                event_id=str(uuid.uuid4()),
                product_id=product_id,
                stage=TraceabilityStage.RETAIL,
                timestamp=datetime.now(),
                location="å¬å›ä¸­å¿ƒ",
                operator="ç³»ç»Ÿ",
                operation="äº§å“å¬å›",
                details={"reason": reason, "batch": batch_number}
            )
            self.record_event(event)
        
        logger.info(f"Recalled {len(affected_products)} products from batch {batch_number}")
        return affected_products
    
    def get_statistics(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            "total_products": len(self.products),
            "total_events": sum(len(e) for e in self.events.values()),
            "total_tests": sum(len(t) for t in self.quality_tests.values()),
            "blockchain_blocks": len(self.blockchain.blocks),
            "chain_integrity": self.blockchain.verify_chain(),
            "producers": len(self.producers)
        }


def create_demo_traceability():
    """åˆ›å»ºæ¼”ç¤ºæº¯æºç³»ç»Ÿ"""
    system = TraceabilitySystem()
    
    # æ³¨å†Œç”Ÿäº§è€…
    producer = Producer(
        producer_id="PROD-001",
        name="ç»¿æºç”Ÿæ€å†œåœº",
        type="å†œä¸šåˆä½œç¤¾",
        address="æ±Ÿè‹çœå—äº¬å¸‚æº§æ°´åŒº",
        contact="025-12345678",
        license_number="SC12345678901234",
        certification=["æœ‰æœºè®¤è¯", "ç»¿è‰²é£Ÿå“"]
    )
    system.register_producer(producer)
    
    # æ³¨å†Œäº§å“
    product = Product(
        product_id="PROD-2025-001",
        trace_code="TR20250615001",
        name="æœ‰æœºå°ç•ªèŒ„",
        category=ProductCategory.VEGETABLES,
        batch_number="B20250615-A",
        production_date=date(2025, 6, 15),
        shelf_life_days=7,
        producer=producer,
        specifications="500g/ç›’",
        storage_conditions="0-4Â°Cå†·è—"
    )
    system.register_product(product)
    
    # è®°å½•æº¯æºäº‹ä»¶
    events = [
        TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=product.product_id,
            stage=TraceabilityStage.PLANTING,
            timestamp=datetime(2025, 3, 1, 8, 0),
            location="1å·å¤§æ£š",
            operator="ç‹å†œè‰ºå¸ˆ",
            operation="æ’­ç§å®šæ¤",
            details={"seed_batch": "S2025-001", "quantity": 500}
        ),
        TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=product.product_id,
            stage=TraceabilityStage.PLANTING,
            timestamp=datetime(2025, 3, 15, 10, 0),
            location="1å·å¤§æ£š",
            operator="ææŠ€æœ¯å‘˜",
            operation="æ–½è‚¥",
            details={"fertilizer": "æœ‰æœºè‚¥", "amount": "10kg"}
        ),
        TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=product.product_id,
            stage=TraceabilityStage.HARVESTING,
            timestamp=datetime(2025, 6, 15, 6, 0),
            location="1å·å¤§æ£š",
            operator="å¼ é‡‡æ”¶å‘˜",
            operation="æ‰‹å·¥é‡‡æ”¶",
            details={"harvest_weight": 1000, "quality_grade": "ä¸€çº§"}
        ),
        TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=product.product_id,
            stage=TraceabilityStage.PACKAGING,
            timestamp=datetime(2025, 6, 15, 14, 0),
            location="åŒ…è£…è½¦é—´",
            operator="åˆ˜åŒ…è£…å·¥",
            operation="åˆ†æ‹£åŒ…è£…",
            details={"package_type": "ç²¾å“ç›’", "weight": 500}
        ),
        TraceabilityEvent(
            event_id=str(uuid.uuid4()),
            product_id=product.product_id,
            stage=TraceabilityStage.TRANSPORT,
            timestamp=datetime(2025, 6, 15, 16, 0),
            location="ç‰©æµä¸­å¿ƒ",
            operator="é™ˆå¸æœº",
            operation="å†·é“¾è¿è¾“",
            details={"vehicle": "æ²ªA12345", "temperature": "4Â°C"}
        )
    ]
    
    for event in events:
        system.record_event(event)
    
    # æ·»åŠ è´¨æ£€è®°å½•
    test = QualityTest(
        test_id="QT-2025-001",
        product_id=product.product_id,
        test_type="å†œæ®‹æ£€æµ‹",
        test_date=date(2025, 6, 15),
        test_items=[
            {"item": "æ•Œæ•Œç•", "result": "æœªæ£€å‡º", "limit": "0.01mg/kg"},
            {"item": "ä¹æœ", "result": "æœªæ£€å‡º", "limit": "0.01mg/kg"},
            {"item": "æ°¯æ°°èŠé…¯", "result": "0.002mg/kg", "limit": "0.05mg/kg"}
        ],
        overall_result="åˆæ ¼",
        tester="è´¨æ£€å‘˜èµµæ˜",
        certificate_url="https://cert.example.com/QT-2025-001"
    )
    system.add_quality_test(test)
    
    return system, product.trace_code


def main():
    """ä¸»å‡½æ•°"""
    print("=" * 80)
    print("é£Ÿå“æº¯æºSchemaå®è·µæ¡ˆä¾‹ - é£Ÿå®‰é“¾æº¯æºç§‘æŠ€")
    print("=" * 80)
    
    # åˆ›å»ºç³»ç»Ÿ
    print("\nã€æ­¥éª¤1ã€‘åˆ›å»ºæº¯æºç³»ç»Ÿ...")
    system, trace_code = create_demo_traceability()
    print(f"  è¿½æº¯ç : {trace_code}")
    
    # å®Œæ•´è¿½æº¯
    print("\nã€æ­¥éª¤2ã€‘äº§å“å…¨é“¾è·¯è¿½æº¯...")
    trace_result = system.trace_product(trace_code)
    if trace_result:
        print(f"  äº§å“åç§°: {trace_result['product']['name']}")
        print(f"  ç”Ÿäº§è€…: {trace_result['product']['producer']['name']}")
        print(f"  æº¯æºäº‹ä»¶æ•°: {trace_result['total_events']}")
        print(f"  åŒºå—é“¾éªŒè¯: {'é€šè¿‡' if trace_result['blockchain_verified'] else 'å¤±è´¥'}")
        print("\n  è¿½æº¯å†ç¨‹:")
        for event in trace_result['trace_history']:
            print(f"    [{event['stage']}] {event['operation']} - {event['location']}")
    
    # å¿«é€ŸæŸ¥è¯¢ï¼ˆæ‰«ç æŸ¥è¯¢ï¼‰
    print("\nã€æ­¥éª¤3ã€‘æ¶ˆè´¹è€…æ‰«ç æŸ¥è¯¢...")
    quick_info = system.quick_query(trace_code)
    print(f"  äº§å“: {quick_info['product_name']}")
    print(f"  æº¯æºç¯èŠ‚: {quick_info['stage_count']} ä¸ª")
    print(f"  å½“å‰çŠ¶æ€: {quick_info['latest_status']}")
    
    # è´¨æ£€æŠ¥å‘Š
    print("\nã€æ­¥éª¤4ã€‘è´¨æ£€æŠ¥å‘Š...")
    if trace_result and trace_result['quality_tests']:
        test = trace_result['quality_tests'][0]
        print(f"  æ£€æµ‹ç±»å‹: {test['test_type']}")
        print(f"  æ£€æµ‹ç»“æœ: {test['overall_result']}")
        print(f"  æ£€æµ‹é¡¹:")
        for item in test['test_items']:
            print(f"    - {item['item']}: {item['result']} (é™å€¼: {item['limit']})")
    
    # ç³»ç»Ÿç»Ÿè®¡
    print("\nã€æ­¥éª¤5ã€‘ç³»ç»Ÿç»Ÿè®¡...")
    stats = system.get_statistics()
    print(f"  æ³¨å†Œäº§å“: {stats['total_products']}")
    print(f"  æº¯æºäº‹ä»¶: {stats['total_events']}")
    print(f"  è´¨æ£€è®°å½•: {stats['total_tests']}")
    print(f"  åŒºå—é“¾åŒºå—: {stats['blockchain_blocks']}")
    
    print("\n" + "=" * 80)
    print("é£Ÿå“æº¯æºSchemaå®è·µæ¡ˆä¾‹æ‰§è¡Œå®Œæˆ")
    print("=" * 80)


if __name__ == "__main__":
    main()
```

---

## 7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ

### 7.1 å…³é”®ç»©æ•ˆæŒ‡æ ‡

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æ”¹å–„ |
|------|--------|--------|------|
| æŸ¥è¯¢å“åº”æ—¶é—´ | 10ç§’ | 2ç§’ | -80% |
| å¬å›èŒƒå›´ | æ•´æ‰¹ | ç²¾å‡†åˆ°å•å“ | -90% |
| æ¶ˆè´¹è€…ä¿¡ä»»åº¦ | 60% | 90% | +50% |
| æ•°æ®å¯ä¿¡åº¦ | ä½ | 100%ï¼ˆåŒºå—é“¾ï¼‰ | è´¨å˜ |

### 7.2 ROIåˆ†æ

**æŠ•èµ„**ï¼šÂ¥150ä¸‡  
**å¹´æ”¶ç›Š**ï¼šÂ¥280ä¸‡  
**ROI**ï¼š187%ï¼ˆ3å¹´ï¼‰

---

**åˆ›å»ºæ—¶é—´**ï¼š2026-02-15  
**ç‰ˆæœ¬**ï¼š1.0.0

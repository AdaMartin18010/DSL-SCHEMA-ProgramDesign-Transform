# BPEL Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [BPEL Schemaå®è·µæ¡ˆä¾‹](#bpel-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šFlowWorksä¼ä¸šæµç¨‹è‡ªåŠ¨åŒ–å¹³å°](#2-æ¡ˆä¾‹1flowworksä¼ä¸šæµç¨‹è‡ªåŠ¨åŒ–å¹³å°)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 Schemaå®šä¹‰](#25-schemaå®šä¹‰)
    - [2.6 å®Œæ•´å®ç°ä»£ç ](#26-å®Œæ•´å®ç°ä»£ç )
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šæ”¯ä»˜æœåŠ¡ç¼–æ’](#3-æ¡ˆä¾‹2æ”¯ä»˜æœåŠ¡ç¼–æ’)
  - [4. æ¡ˆä¾‹3ï¼šå¹¶è¡ŒæœåŠ¡è°ƒç”¨](#4-æ¡ˆä¾‹3å¹¶è¡ŒæœåŠ¡è°ƒç”¨)
  - [5. æ¡ˆä¾‹4ï¼šBPMNåˆ°BPELè½¬æ¢](#5-æ¡ˆä¾‹4bpmnåˆ°bpelè½¬æ¢)
  - [6. æ¡ˆä¾‹5ï¼šBPELæ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ](#6-æ¡ˆä¾‹5bpelæ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›BPEL Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–è®¢å•å¤„ç†ã€æ”¯ä»˜ç¼–æ’ã€æœåŠ¡è°ƒç”¨ç­‰å·¥ä½œæµåœºæ™¯ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šFlowWorksä¼ä¸šæµç¨‹è‡ªåŠ¨åŒ–å¹³å°

### 2.1 ä¼ä¸šèƒŒæ™¯

**FlowWorks**æ˜¯å…¨çƒé¢†å…ˆçš„ä¿é™©ç§‘æŠ€å…¬å¸ï¼Œä¸º50+å›½å®¶çš„200+ä¿é™©å…¬å¸æä¾›æ ¸å¿ƒç³»ç»Ÿè§£å†³æ–¹æ¡ˆï¼Œå¹´å¤„ç†ä¿å•è¶…è¿‡5äº¿ä»½ï¼Œç†èµ”æ¡ˆä»¶2,000ä¸‡ä»¶ã€‚

- **æˆç«‹æ—¶é—´**ï¼š2005å¹´
- **å‘˜å·¥è§„æ¨¡**ï¼š4,500äºº
- **å®¢æˆ·æ•°é‡**ï¼š200+ä¿é™©å…¬å¸
- **å¹´äº¤æ˜“é‡**ï¼š5äº¿ä¿å•ï¼Œ2000ä¸‡ç†èµ”
- **åŸç³»ç»Ÿ**ï¼šåŸºäºä¼ ç»ŸBPELå¼•æ“ï¼Œæ‰©å±•æ€§å·®ï¼Œå“åº”æ—¶é—´é•¿

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **æµç¨‹å“åº”æ…¢** | ä¸¥é‡ | ä¿å•å¤„ç†å¹³å‡è€—æ—¶45åˆ†é’Ÿï¼Œå®¢æˆ·æµå¤±ç‡é«˜ |
| 2 | **ç³»ç»Ÿæ‰©å±•æ€§å·®** | é«˜ | æ–°ä¸šåŠ¡æµç¨‹å¼€å‘å‘¨æœŸ3ä¸ªæœˆï¼Œæ— æ³•å¿«é€Ÿå“åº”å¸‚åœº |
| 3 | **æ•…éšœæ¢å¤æ…¢** | é«˜ | æµç¨‹å¼‚å¸¸éœ€äººå·¥å¹²é¢„ï¼Œå¹³å‡æ¢å¤æ—¶é—´4å°æ—¶ |
| 4 | **ç›‘æ§èƒ½åŠ›ä¸è¶³** | ä¸­ | æ— æ³•å®æ—¶æŸ¥çœ‹æµç¨‹çŠ¶æ€ï¼Œé—®é¢˜å‘ç°æ»å |
| 5 | **å¤šç§Ÿæˆ·æ”¯æŒå¼±** | ä¸­ | å„ä¿é™©å…¬å¸éœ€æ±‚ä¸åŒï¼Œå®šåˆ¶åŒ–æˆæœ¬é«˜ |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | ä¿å•å¤„ç†æ—¶é—´ | 45åˆ†é’Ÿ | <5åˆ†é’Ÿ | 12ä¸ªæœˆ |
| 2 | æ–°æµç¨‹å¼€å‘å‘¨æœŸ | 3ä¸ªæœˆ | <2å‘¨ | 9ä¸ªæœˆ |
| 3 | æ•…éšœæ¢å¤æ—¶é—´ | 4å°æ—¶ | <10åˆ†é’Ÿ | 12ä¸ªæœˆ |
| 4 | æµç¨‹å¯è§æ€§ | 30% | 100% | 6ä¸ªæœˆ |
| 5 | ç³»ç»Ÿå¯ç”¨æ€§ | 99.5% | 99.99% | 12ä¸ªæœˆ |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **é«˜æ€§èƒ½è¦æ±‚**ï¼šå³°å€¼éœ€æ”¯æŒ100,000+å¹¶å‘æµç¨‹å®ä¾‹

2. **å¤æ‚äº‹åŠ¡ç®¡ç†**ï¼šä¿é™©æµç¨‹æ¶‰åŠå¤šä¸ªå¤–éƒ¨ç³»ç»Ÿï¼Œéœ€ä¿è¯æœ€ç»ˆä¸€è‡´æ€§

3. **å¤šç§Ÿæˆ·éš”ç¦»**ï¼šéœ€æ”¯æŒ200+ä¿é™©å…¬å¸çš„æ•°æ®éš”ç¦»å’Œèµ„æºåˆ†é…

4. **å¼¹æ€§æ‰©å±•**ï¼šä¸šåŠ¡é«˜å³°æœŸéœ€è‡ªåŠ¨æ‰©å±•ï¼Œä½å³°æœŸè‡ªåŠ¨ç¼©å‡

5. **å¤šäº‘éƒ¨ç½²**ï¼šéœ€åœ¨AWSã€Azureã€é˜¿é‡Œäº‘ç­‰å¤šäº‘ç¯å¢ƒéƒ¨ç½²

### 2.5 Schemaå®šä¹‰

**è®¢å•å¤„ç†æµç¨‹BPEL Schema**ï¼š

```dsl
schema OrderProcess {
  name: String @value("OrderProcess")
  target_namespace: String @value("http://example.com/order")

  partner_links: List[PartnerLink] {
    customer: PartnerLink {
      name: String @value("customer")
      partner_link_type: String @value("customerLT")
      my_role: String @value("orderService")
    }

    payment_service: PartnerLink {
      name: String @value("paymentService")
      partner_link_type: String @value("paymentLT")
      partner_role: String @value("paymentProvider")
    }

    shipping_service: PartnerLink {
      name: String @value("shippingService")
      partner_link_type: String @value("shippingLT")
      partner_role: String @value("shippingProvider")
    }
  }

  variables: List[Variable] {
    order_request: Variable {
      name: String @value("orderRequest")
      message_type: String @value("tns:OrderRequest")
    }

    payment_request: Variable {
      name: String @value("paymentRequest")
      message_type: String @value("tns:PaymentRequest")
    }

    shipping_request: Variable {
      name: String @value("shippingRequest")
      message_type: String @value("tns:ShippingRequest")
    }
  }

  activities: Sequence {
    receive: Receive {
      partner_link: String @value("customer")
      operation: String @value("createOrder")
      variable: String @value("orderRequest")
      create_instance: Boolean @value(true)
    }

    invoke_payment: Invoke {
      partner_link: String @value("paymentService")
      operation: String @value("processPayment")
      input_variable: String @value("paymentRequest")
    }

    invoke_shipping: Invoke {
      partner_link: String @value("shippingService")
      operation: String @value("shipOrder")
      input_variable: String @value("shippingRequest")
    }

    reply: Reply {
      partner_link: String @value("customer")
      operation: String @value("createOrder")
      variable: String @value("orderRequest")
    }
  }
} @standard("WS-BPEL_2.0")
```

### 2.6 å®Œæ•´å®ç°ä»£ç 

```python
"""
FlowWorksä¼ä¸šæµç¨‹è‡ªåŠ¨åŒ–å¹³å°
åŸºäºBPELçš„å·¥ä½œæµå¼•æ“å®ç°
æ”¯æŒæµç¨‹ç¼–æ’ã€äº‹åŠ¡ç®¡ç†ã€å¹¶è¡Œæ‰§è¡Œ
"""

import uuid
import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Optional, List, Dict, Any, Callable, Awaitable
from abc import ABC, abstractmethod
from collections import defaultdict
import json


class ProcessStatus(Enum):
    """æµç¨‹çŠ¶æ€"""
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    SUSPENDED = "SUSPENDED"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    COMPENSATING = "COMPENSATING"
    COMPENSATED = "COMPENSATED"


class ActivityStatus(Enum):
    """æ´»åŠ¨çŠ¶æ€"""
    READY = "READY"
    EXECUTING = "EXECUTING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


class ActivityType(Enum):
    """æ´»åŠ¨ç±»å‹"""
    RECEIVE = "receive"
    REPLY = "reply"
    INVOKE = "invoke"
    ASSIGN = "assign"
    SEQUENCE = "sequence"
    FLOW = "flow"
    IF = "if"
    WHILE = "while"
    PICK = "pick"
    SCOPE = "scope"
    THROW = "throw"
    CATCH = "catch"


@dataclass
class ProcessVariable:
    """æµç¨‹å˜é‡"""
    name: str
    value: Any
    type_hint: str = "string"
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "value": self.value,
            "type": self.type_hint
        }


@dataclass
class Activity:
    """BPELæ´»åŠ¨"""
    activity_id: str
    name: str
    activity_type: ActivityType
    status: ActivityStatus = ActivityStatus.READY
    input_data: Dict[str, Any] = field(default_factory=dict)
    output_data: Dict[str, Any] = field(default_factory=dict)
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    children: List['Activity'] = field(default_factory=list)
    condition: Optional[str] = None
    partner_link: Optional[str] = None
    operation: Optional[str] = None
    compensation_activity: Optional['Activity'] = None
    
    def get_duration_seconds(self) -> float:
        """è·å–æ‰§è¡Œæ—¶é•¿"""
        if self.start_time and self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        elif self.start_time:
            return (datetime.now() - self.start_time).total_seconds()
        return 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "activity_id": self.activity_id,
            "name": self.name,
            "type": self.activity_type.value,
            "status": self.status.value,
            "duration_seconds": self.get_duration_seconds(),
            "children": [c.to_dict() for c in self.children],
            "partner_link": self.partner_link,
            "operation": self.operation
        }


@dataclass
class ProcessInstance:
    """æµç¨‹å®ä¾‹"""
    instance_id: str
    process_name: str
    status: ProcessStatus = ProcessStatus.PENDING
    variables: Dict[str, ProcessVariable] = field(default_factory=dict)
    activities: List[Activity] = field(default_factory=list)
    current_activity: Optional[Activity] = None
    create_time: datetime = field(default_factory=datetime.now)
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    parent_instance_id: Optional[str] = None
    correlation_id: Optional[str] = None
    
    def get_variable(self, name: str) -> Optional[Any]:
        """è·å–å˜é‡å€¼"""
        var = self.variables.get(name)
        return var.value if var else None
    
    def set_variable(self, name: str, value: Any, type_hint: str = "string"):
        """è®¾ç½®å˜é‡å€¼"""
        self.variables[name] = ProcessVariable(name, value, type_hint)
    
    def get_duration_seconds(self) -> float:
        """è·å–æµç¨‹æ‰§è¡Œæ—¶é•¿"""
        if self.start_time and self.end_time:
            return (self.end_time - self.start_time).total_seconds()
        elif self.start_time:
            return (datetime.now() - self.start_time).total_seconds()
        return 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "instance_id": self.instance_id,
            "process_name": self.process_name,
            "status": self.status.value,
            "variables": {k: v.to_dict() for k, v in self.variables.items()},
            "activities": [a.to_dict() for a in self.activities],
            "create_time": self.create_time.isoformat(),
            "duration_seconds": self.get_duration_seconds()
        }


class PartnerLink:
    """åˆä½œä¼™ä¼´é“¾æ¥"""
    
    def __init__(self, name: str, partner_role: str = None):
        self.name = name
        self.partner_role = partner_role
        self.endpoint = None
    
    async def invoke(self, operation: str, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """è°ƒç”¨åˆä½œä¼™ä¼´æœåŠ¡"""
        # æ¨¡æ‹ŸæœåŠ¡è°ƒç”¨
        await asyncio.sleep(0.1)
        return {
            "operation": operation,
            "status": "SUCCESS",
            "output": f"Result of {operation}",
            "timestamp": datetime.now().isoformat()
        }


class BPELEngine:
    """BPELå¼•æ“"""
    
    def __init__(self):
        self.instances: Dict[str, ProcessInstance] = {}
        self.partner_links: Dict[str, PartnerLink] = {}
        self.process_definitions: Dict[str, Dict[str, Any]] = {}
        self.activity_handlers: Dict[ActivityType, Callable] = {}
        self.metrics = {
            "total_instances": 0,
            "completed_instances": 0,
            "failed_instances": 0,
            "total_activities": 0
        }
        self._register_handlers()
    
    def _register_handlers(self):
        """æ³¨å†Œæ´»åŠ¨å¤„ç†å™¨"""
        self.activity_handlers = {
            ActivityType.RECEIVE: self._handle_receive,
            ActivityType.INVOKE: self._handle_invoke,
            ActivityType.SEQUENCE: self._handle_sequence,
            ActivityType.FLOW: self._handle_flow,
            ActivityType.IF: self._handle_if,
            ActivityType.ASSIGN: self._handle_assign
        }
    
    def register_partner_link(self, name: str, partner: PartnerLink):
        """æ³¨å†Œåˆä½œä¼™ä¼´é“¾æ¥"""
        self.partner_links[name] = partner
    
    def create_instance(self, process_name: str, 
                       initial_variables: Dict[str, Any] = None,
                       correlation_id: str = None) -> ProcessInstance:
        """åˆ›å»ºæµç¨‹å®ä¾‹"""
        instance = ProcessInstance(
            instance_id=str(uuid.uuid4()),
            process_name=process_name,
            correlation_id=correlation_id
        )
        
        if initial_variables:
            for name, value in initial_variables.items():
                instance.set_variable(name, value)
        
        self.instances[instance.instance_id] = instance
        self.metrics["total_instances"] += 1
        
        return instance
    
    async def execute_process(self, instance_id: str, 
                             definition: Dict[str, Any]) -> ProcessInstance:
        """æ‰§è¡Œæµç¨‹"""
        instance = self.instances.get(instance_id)
        if not instance:
            raise ValueError(f"Instance {instance_id} not found")
        
        instance.status = ProcessStatus.RUNNING
        instance.start_time = datetime.now()
        
        try:
            # åˆ›å»ºæ ¹æ´»åŠ¨
            root_activity = self._create_activity_from_definition(definition)
            instance.activities.append(root_activity)
            
            # æ‰§è¡Œæ´»åŠ¨
            await self._execute_activity(instance, root_activity)
            
            instance.status = ProcessStatus.COMPLETED
            instance.end_time = datetime.now()
            self.metrics["completed_instances"] += 1
            
        except Exception as e:
            instance.status = ProcessStatus.FAILED
            instance.end_time = datetime.now()
            self.metrics["failed_instances"] += 1
            raise
        
        return instance
    
    def _create_activity_from_definition(self, definition: Dict[str, Any]) -> Activity:
        """ä»å®šä¹‰åˆ›å»ºæ´»åŠ¨"""
        activity_type = ActivityType(definition.get("type", "sequence"))
        
        activity = Activity(
            activity_id=str(uuid.uuid4()),
            name=definition.get("name", f"Activity_{activity_type.value}"),
            activity_type=activity_type,
            partner_link=definition.get("partner_link"),
            operation=definition.get("operation"),
            condition=definition.get("condition")
        )
        
        # åˆ›å»ºå­æ´»åŠ¨
        for child_def in definition.get("children", []):
            child = self._create_activity_from_definition(child_def)
            activity.children.append(child)
        
        return activity
    
    async def _execute_activity(self, instance: ProcessInstance, activity: Activity):
        """æ‰§è¡Œæ´»åŠ¨"""
        handler = self.activity_handlers.get(activity.activity_type)
        if handler:
            await handler(instance, activity)
        else:
            # é»˜è®¤å¤„ç†ï¼šç›´æ¥å®Œæˆ
            activity.status = ActivityStatus.COMPLETED
    
    async def _handle_receive(self, instance: ProcessInstance, activity: Activity):
        """å¤„ç†æ¥æ”¶æ´»åŠ¨"""
        activity.status = ActivityStatus.EXECUTING
        activity.start_time = datetime.now()
        
        # æ¨¡æ‹Ÿæ¥æ”¶æ¶ˆæ¯
        await asyncio.sleep(0.05)
        
        activity.status = ActivityStatus.COMPLETED
        activity.end_time = datetime.now()
        self.metrics["total_activities"] += 1
    
    async def _handle_invoke(self, instance: ProcessInstance, activity: Activity):
        """å¤„ç†è°ƒç”¨æ´»åŠ¨"""
        activity.status = ActivityStatus.EXECUTING
        activity.start_time = datetime.now()
        
        partner = self.partner_links.get(activity.partner_link)
        if partner:
            # å‡†å¤‡è¾“å…¥æ•°æ®
            input_data = {}
            if activity.partner_link and activity.operation:
                input_data = instance.get_variable(f"{activity.partner_link}_request") or {}
            
            # è°ƒç”¨æœåŠ¡
            result = await partner.invoke(activity.operation, input_data)
            activity.output_data = result
            
            # å­˜å‚¨ç»“æœåˆ°å˜é‡
            if activity.partner_link:
                instance.set_variable(
                    f"{activity.partner_link}_response",
                    result
                )
        
        activity.status = ActivityStatus.COMPLETED
        activity.end_time = datetime.now()
        self.metrics["total_activities"] += 1
    
    async def _handle_sequence(self, instance: ProcessInstance, activity: Activity):
        """å¤„ç†é¡ºåºæ´»åŠ¨"""
        activity.status = ActivityStatus.EXECUTING
        activity.start_time = datetime.now()
        
        for child in activity.children:
            await self._execute_activity(instance, child)
        
        activity.status = ActivityStatus.COMPLETED
        activity.end_time = datetime.now()
    
    async def _handle_flow(self, instance: ProcessInstance, activity: Activity):
        """å¤„ç†å¹¶è¡Œæ´»åŠ¨"""
        activity.status = ActivityStatus.EXECUTING
        activity.start_time = datetime.now()
        
        # å¹¶è¡Œæ‰§è¡Œå­æ´»åŠ¨
        tasks = [
            self._execute_activity(instance, child)
            for child in activity.children
        ]
        await asyncio.gather(*tasks)
        
        activity.status = ActivityStatus.COMPLETED
        activity.end_time = datetime.now()
    
    async def _handle_if(self, instance: ProcessInstance, activity: Activity):
        """å¤„ç†æ¡ä»¶æ´»åŠ¨"""
        activity.status = ActivityStatus.EXECUTING
        activity.start_time = datetime.now()
        
        # è¯„ä¼°æ¡ä»¶
        condition_result = True  # ç®€åŒ–å¤„ç†
        
        if condition_result and activity.children:
            await self._execute_activity(instance, activity.children[0])
        
        activity.status = ActivityStatus.COMPLETED
        activity.end_time = datetime.now()
    
    async def _handle_assign(self, instance: ProcessInstance, activity: Activity):
        """å¤„ç†èµ‹å€¼æ´»åŠ¨"""
        activity.status = ActivityStatus.EXECUTING
        activity.start_time = datetime.now()
        
        # æ‰§è¡Œå˜é‡èµ‹å€¼
        if activity.output_data:
            for name, value in activity.output_data.items():
                instance.set_variable(name, value)
        
        activity.status = ActivityStatus.COMPLETED
        activity.end_time = datetime.now()
        self.metrics["total_activities"] += 1
    
    def get_instance(self, instance_id: str) -> Optional[ProcessInstance]:
        """è·å–æµç¨‹å®ä¾‹"""
        return self.instances.get(instance_id)
    
    def get_metrics(self) -> Dict[str, Any]:
        """è·å–æŒ‡æ ‡"""
        total = self.metrics["total_instances"]
        return {
            **self.metrics,
            "completion_rate": (self.metrics["completed_instances"] / total * 100) if total > 0 else 0,
            "failure_rate": (self.metrics["failed_instances"] / total * 100) if total > 0 else 0
        }


class ProcessMonitor:
    """æµç¨‹ç›‘æ§å™¨"""
    
    def __init__(self, engine: BPELEngine):
        self.engine = engine
    
    def get_active_instances(self) -> List[ProcessInstance]:
        """è·å–æ´»åŠ¨å®ä¾‹"""
        return [
            inst for inst in self.engine.instances.values()
            if inst.status == ProcessStatus.RUNNING
        ]
    
    def get_instance_statistics(self) -> Dict[str, Any]:
        """è·å–å®ä¾‹ç»Ÿè®¡"""
        status_counts = defaultdict(int)
        for inst in self.engine.instances.values():
            status_counts[inst.status.value] += 1
        
        return {
            "total": len(self.engine.instances),
            "by_status": dict(status_counts),
            "average_duration": self._calculate_average_duration()
        }
    
    def _calculate_average_duration(self) -> float:
        """è®¡ç®—å¹³å‡æ‰§è¡Œæ—¶é•¿"""
        durations = [
            inst.get_duration_seconds()
            for inst in self.engine.instances.values()
            if inst.end_time
        ]
        return sum(durations) / len(durations) if durations else 0
    
    def get_bottleneck_activities(self, top_n: int = 5) -> List[Dict[str, Any]]:
        """è¯†åˆ«ç“¶é¢ˆæ´»åŠ¨"""
        activity_durations = defaultdict(list)
        
        for inst in self.engine.instances.values():
            for activity in inst.activities:
                if activity.end_time:
                    activity_durations[activity.name].append(activity.get_duration_seconds())
        
        avg_durations = [
            {
                "name": name,
                "average_duration": sum(durations) / len(durations),
                "execution_count": len(durations)
            }
            for name, durations in activity_durations.items()
        ]
        
        return sorted(avg_durations, key=lambda x: x["average_duration"], reverse=True)[:top_n]


async def main():
    """ä¸»å‡½æ•° - æ¼”ç¤º"""
    # åˆ›å»ºå¼•æ“
    engine = BPELEngine()
    
    # æ³¨å†Œåˆä½œä¼™ä¼´
    engine.register_partner_link("paymentService", PartnerLink("paymentService"))
    engine.register_partner_link("shippingService", PartnerLink("shippingService"))
    
    # å®šä¹‰æµç¨‹
    order_process_definition = {
        "name": "OrderProcess",
        "type": "sequence",
        "children": [
            {
                "name": "ReceiveOrder",
                "type": "receive"
            },
            {
                "name": "ProcessPayment",
                "type": "invoke",
                "partner_link": "paymentService",
                "operation": "processPayment"
            },
            {
                "name": "ParallelProcessing",
                "type": "flow",
                "children": [
                    {
                        "name": "UpdateInventory",
                        "type": "invoke",
                        "partner_link": "inventoryService",
                        "operation": "updateStock"
                    },
                    {
                        "name": "SendNotification",
                        "type": "invoke",
                        "partner_link": "notificationService",
                        "operation": "sendEmail"
                    }
                ]
            },
            {
                "name": "ShipOrder",
                "type": "invoke",
                "partner_link": "shippingService",
                "operation": "createShipment"
            }
        ]
    }
    
    # åˆ›å»ºå¹¶æ‰§è¡Œæµç¨‹å®ä¾‹
    instance = engine.create_instance(
        "OrderProcess",
        initial_variables={
            "orderId": "ORD-2025-001",
            "customerId": "CUST-001",
            "amount": 1000.00
        }
    )
    
    print(f"åˆ›å»ºæµç¨‹å®ä¾‹: {instance.instance_id}")
    
    # æ‰§è¡Œæµç¨‹
    await engine.execute_process(instance.instance_id, order_process_definition)
    
    # è·å–ç»“æœ
    completed_instance = engine.get_instance(instance.instance_id)
    print(f"\næµç¨‹æ‰§è¡Œå®Œæˆ:")
    print(f"  çŠ¶æ€: {completed_instance.status.value}")
    print(f"  æ‰§è¡Œæ—¶é•¿: {completed_instance.get_duration_seconds():.3f}ç§’")
    print(f"  æ´»åŠ¨æ•°é‡: {len(completed_instance.activities)}")
    
    # ç›‘æ§
    monitor = ProcessMonitor(engine)
    print(f"\n=== æµç¨‹ç»Ÿè®¡ ===")
    print(json.dumps(monitor.get_instance_statistics(), indent=2))
    
    print(f"\n=== ç“¶é¢ˆæ´»åŠ¨ ===")
    bottlenecks = monitor.get_bottleneck_activities()
    for b in bottlenecks:
        print(f"  {b['name']}: {b['average_duration']:.3f}ç§’ (æ‰§è¡Œ{b['execution_count']}æ¬¡)")


if __name__ == "__main__":
    asyncio.run(main())
```

### 2.7 æ•ˆæœè¯„ä¼°

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| ä¿å•å¤„ç†æ—¶é—´ | 45åˆ†é’Ÿ | 3.5åˆ†é’Ÿ | -92% |
| æ–°æµç¨‹å¼€å‘å‘¨æœŸ | 3ä¸ªæœˆ | 8å¤© | -91% |
| æ•…éšœæ¢å¤æ—¶é—´ | 4å°æ—¶ | 7åˆ†é’Ÿ | -97% |
| æµç¨‹å¯è§æ€§ | 30% | 100% | +70% |
| ç³»ç»Ÿå¯ç”¨æ€§ | 99.5% | 99.99% | +0.49% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼ˆ18ä¸ªæœˆé¡¹ç›®å‘¨æœŸï¼‰ï¼š
- å¼•æ“å¼€å‘ï¼š600ä¸‡ç¾å…ƒ
- åŸºç¡€è®¾æ–½ï¼š400ä¸‡ç¾å…ƒ
- è¿ç§»æˆæœ¬ï¼š200ä¸‡ç¾å…ƒ
- **æ€»æŠ•èµ„**ï¼š1,200ä¸‡ç¾å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- æ•ˆç‡æå‡ï¼š2,000ä¸‡ç¾å…ƒ
- å®¢æˆ·ç•™å­˜ï¼š800ä¸‡ç¾å…ƒ
- è¿ç»´æˆæœ¬èŠ‚çº¦ï¼š400ä¸‡ç¾å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š3,200ä¸‡ç¾å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š4.5ä¸ªæœˆ
- 3å¹´ROIï¼š700%

#### ç»éªŒæ•™è®­

**æˆåŠŸå› ç´ **ï¼š
1. **å¾®æœåŠ¡æ¶æ„**ï¼šæµç¨‹å¼•æ“æ‹†åˆ†ä¸ºç‹¬ç«‹æœåŠ¡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
2. **äº‹ä»¶é©±åŠ¨**ï¼šé‡‡ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œè§£è€¦æµç¨‹æ­¥éª¤
3. **å¯è§†åŒ–è®¾è®¡å™¨**ï¼šä¸šåŠ¡äººå‘˜å¯æ‹–æ‹½è®¾è®¡æµç¨‹ï¼Œå‡å°‘ITä¾èµ–

**æŒ‘æˆ˜ä¸åº”å¯¹**ï¼š
1. **äº‹åŠ¡ä¸€è‡´æ€§**ï¼šé‡‡ç”¨Sagaæ¨¡å¼ï¼Œä¿è¯æœ€ç»ˆä¸€è‡´æ€§
2. **é—ç•™ç³»ç»Ÿå…¼å®¹**ï¼šæä¾›é€‚é…å™¨ï¼Œä¿æŠ¤ç°æœ‰æŠ•èµ„
3. **æ€§èƒ½è°ƒä¼˜**ï¼šå»ºç«‹æ€§èƒ½åŸºçº¿ï¼ŒæŒç»­ä¼˜åŒ–

---

## 3. æ¡ˆä¾‹2ï¼šæ”¯ä»˜æœåŠ¡ç¼–æ’

è¯¦è§ `04_Transformation.md` ç¬¬3ç« ã€‚

## 4. æ¡ˆä¾‹3ï¼šå¹¶è¡ŒæœåŠ¡è°ƒç”¨

è¯¦è§ `04_Transformation.md` ç¬¬4ç« ã€‚

## 5. æ¡ˆä¾‹4ï¼šBPMNåˆ°BPELè½¬æ¢

è¯¦è§ `04_Transformation.md` ç¬¬2ç« ã€‚

## 6. æ¡ˆä¾‹5ï¼šBPELæ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ

è¯¦è§ `04_Transformation.md` ç¬¬6ç« ã€‚

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

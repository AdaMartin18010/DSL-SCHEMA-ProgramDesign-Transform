# WebSocket Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [WebSocket Schemaå®è·µæ¡ˆä¾‹](#websocket-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹ï¼šå®æ—¶åä½œå¹³å°WebSocketæ¶æ„](#2-æ¡ˆä¾‹å®æ—¶åä½œå¹³å°websocketæ¶æ„)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›WebSocket Schemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–å®æ—¶é€šä¿¡ã€æ¶ˆæ¯æ¨é€ã€åœ¨çº¿åä½œã€æ¸¸æˆåŒæ­¥ç­‰çœŸå®åœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **å®æ—¶åä½œå¹³å°WebSocketæ¶æ„**ï¼šæ–‡æ¡£åä½œã€ç™½æ¿åŒæ­¥ã€å³æ—¶é€šè®¯
2. **åœ¨çº¿å®¢æœç³»ç»Ÿ**ï¼šå®æ—¶æ¶ˆæ¯ã€çŠ¶æ€åŒæ­¥ã€å¤šåª’ä½“é€šä¿¡
3. **å®æ—¶æ•°æ®ç›‘æ§å¹³å°**ï¼šè‚¡ç¥¨è¡Œæƒ…ã€IoTæ•°æ®ã€å‘Šè­¦æ¨é€
4. **å¤šäººåœ¨çº¿æ¸¸æˆ**ï¼šçŠ¶æ€åŒæ­¥ã€ä½ç½®å¹¿æ’­ã€æˆ¿é—´ç®¡ç†

---

## 2. æ¡ˆä¾‹ï¼šå®æ—¶åä½œå¹³å°WebSocketæ¶æ„

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šäº‘åä½œç§‘æŠ€æœ‰é™å…¬å¸

**ä¼ä¸šè§„æ¨¡**ï¼š
- ä¸»è¥ä¸šåŠ¡ï¼šä¼ä¸šåœ¨çº¿åä½œæ–‡æ¡£å¹³å°
- æ³¨å†Œç”¨æˆ·ï¼š800ä¸‡+
- ä¼ä¸šå®¢æˆ·ï¼š5ä¸‡+å®¶ä¼ä¸š
- æ—¥æ´»ç”¨æˆ·ï¼š120ä¸‡+
- åŒæ—¶åœ¨çº¿æ–‡æ¡£ï¼š200ä¸‡+
- å¹´è¥æ”¶ï¼š3.5äº¿å…ƒäººæ°‘å¸

**äº§å“åŠŸèƒ½**ï¼š
- åœ¨çº¿æ–‡æ¡£ï¼šWordã€Excelã€PPTå¤šäººå®æ—¶åä½œ
- å³æ—¶é€šè®¯ï¼šå›¢é˜ŸèŠå¤©ã€@æåŠã€æ¶ˆæ¯æé†’
- é¡¹ç›®ç®¡ç†ï¼šçœ‹æ¿ã€ç”˜ç‰¹å›¾ã€ä»»åŠ¡åˆ†é…
- è§†é¢‘ä¼šè®®ï¼šéŸ³è§†é¢‘ä¼šè®®ã€å±å¹•å…±äº«

**ç°æœ‰æŠ€æœ¯æ¶æ„**ï¼š
- Webå‰ç«¯ï¼šReact + TypeScript
- ç§»åŠ¨ç«¯ï¼šReact Native
- åç«¯ï¼šNode.js + Redis + MongoDB
- æ–‡æ¡£æœåŠ¡ï¼šè‡ªç ”OTç®—æ³•å¼•æ“
- æ¶ˆæ¯é˜Ÿåˆ—ï¼šRabbitMQ

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **åä½œå»¶è¿Ÿä¸¥é‡**ï¼šå¤šäººç¼–è¾‘æ–‡æ¡£æ—¶ï¼Œæ“ä½œåŒæ­¥å»¶è¿Ÿ2-3ç§’ï¼Œç”¨æˆ·æ„ŸçŸ¥æ˜æ˜¾ï¼Œç¼–è¾‘å†²çªé¢‘ç¹ï¼Œç”¨æˆ·ä½“éªŒå·®ï¼Œå®¢æˆ·æµå¤±ç‡é«˜ã€‚

2. **æ¶ˆæ¯æ¨é€ä¸å¯é **ï¼šä½¿ç”¨HTTPè½®è¯¢è·å–æ¶ˆæ¯ï¼Œå»¶è¿Ÿ5-10ç§’ï¼Œæ¶ˆæ¯åˆ°è¾¾ç‡ä½ï¼Œç”¨æˆ·é”™è¿‡é‡è¦é€šçŸ¥ï¼Œå›¢é˜Ÿåä½œæ•ˆç‡ä½ã€‚

3. **åœ¨çº¿çŠ¶æ€ä¸å‡†ç¡®**ï¼šç”¨æˆ·åœ¨çº¿çŠ¶æ€ä¾èµ–å¿ƒè·³æ£€æµ‹ï¼ŒçŠ¶æ€æ›´æ–°å»¶è¿Ÿ30ç§’ï¼Œ"æ­£åœ¨ç¼–è¾‘"çŠ¶æ€ä¸å‡†ç¡®ï¼Œåä½œä½“éªŒå·®ã€‚

4. **ç³»ç»Ÿæ‰©å±•å›°éš¾**ï¼šè½®è¯¢äº§ç”Ÿå¤§é‡æ— æ•ˆè¯·æ±‚ï¼ŒæœåŠ¡å™¨CPUå ç”¨80%ï¼Œé«˜å³°æœŸæœåŠ¡ä¸ç¨³å®šï¼Œæ‰©å®¹æˆæœ¬é«˜ã€‚

5. **å¤šç«¯åŒæ­¥å¤æ‚**ï¼šWebã€Appã€æ¡Œé¢ç«¯æ•°æ®åŒæ­¥å›°éš¾ï¼ŒåŒä¸€ç”¨æˆ·å¤šç«¯ç™»å½•çŠ¶æ€ä¸ä¸€è‡´ï¼Œæ•°æ®å†²çªé¢‘å‘ã€‚

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **å®ç°æ¯«ç§’çº§å®æ—¶åä½œ**ï¼šWebSocketé•¿è¿æ¥å®ç°æ“ä½œåŒæ­¥ï¼Œåä½œå»¶è¿Ÿä»2-3ç§’é™è‡³100msä»¥å†…ï¼Œç¼–è¾‘ä½“éªŒå¦‚æœ¬åœ°èˆ¬æµç•…ã€‚

2. **ç¡®ä¿æ¶ˆæ¯å®æ—¶å¯é æ¨é€**ï¼šWebSocketæ¨é€æ¶ˆæ¯ï¼Œåˆ°è¾¾å»¶è¿Ÿ<100msï¼Œåˆ°è¾¾ç‡99.9%ï¼Œç”¨æˆ·ä¸å†é”™è¿‡é‡è¦é€šçŸ¥ã€‚

3. **ç²¾å‡†å®æ—¶åœ¨çº¿çŠ¶æ€**ï¼šå®æ—¶åŒæ­¥ç”¨æˆ·å…‰æ ‡ä½ç½®ã€é€‰åŒºã€åœ¨çº¿çŠ¶æ€ï¼Œ"æ­£åœ¨ç¼–è¾‘"æŒ‡ç¤ºå‡†ç¡®ï¼Œåä½œä½“éªŒè‡ªç„¶ã€‚

4. **å¤§å¹…é™ä½æœåŠ¡å™¨è´Ÿè½½**ï¼šé•¿è¿æ¥æ›¿ä»£è½®è¯¢ï¼Œæ— æ•ˆè¯·æ±‚å‡å°‘90%ï¼ŒæœåŠ¡å™¨CPUé™è‡³30%ï¼Œæ”¯æŒ10å€ç”¨æˆ·å¢é•¿ã€‚

5. **å®ç°å¤šç«¯æ•°æ®ä¸€è‡´æ€§**ï¼šWebSocketç»Ÿä¸€åŒæ­¥é€šé“ï¼Œå¤šç«¯æ•°æ®å®æ—¶ä¸€è‡´ï¼Œå†²çªè‡ªåŠ¨è§£å†³ï¼Œç”¨æˆ·ä½“éªŒç»Ÿä¸€ã€‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **æµ·é‡è¿æ¥ç®¡ç†**ï¼š120ä¸‡æ—¥æ´»ï¼Œå³°å€¼åŒæ—¶åœ¨çº¿50ä¸‡è¿æ¥ï¼Œéœ€è¦é«˜æ€§èƒ½è¿æ¥ç®¡ç†å’Œè´Ÿè½½å‡è¡¡ã€‚

2. **æ¶ˆæ¯å¯é æŠ•é€’**ï¼šå¼±ç½‘ç¯å¢ƒä¸‹æ¶ˆæ¯ä¸ä¸¢å¤±ï¼Œéœ€è¦æ¶ˆæ¯ç¡®è®¤ã€é‡ä¼ ã€å»é‡æœºåˆ¶ã€‚

3. **åˆ†å¸ƒå¼æ¶æ„è®¾è®¡**ï¼šå¤šèŠ‚ç‚¹éƒ¨ç½²ä¸‹ï¼Œéœ€è¦æ¶ˆæ¯å¹¿æ’­ã€æˆ¿é—´ç®¡ç†ã€çŠ¶æ€åŒæ­¥ã€‚

4. **æ•°æ®ä¸€è‡´æ€§ä¿éšœ**ï¼šOTç®—æ³•ä¸WebSocketç»“åˆï¼Œç¡®ä¿å¤šäººç¼–è¾‘å†²çªæ­£ç¡®è§£å†³ã€‚

5. **å®‰å…¨æ€§ä¿éšœ**ï¼šWebSocketè¿æ¥éœ€è¦è®¤è¯ã€åŠ å¯†ï¼Œé˜²æ­¢æœªæˆæƒè®¿é—®å’Œæ•°æ®çªƒå–ã€‚

### 2.5 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨Schemaå®šä¹‰WebSocketå®æ—¶åä½œå¹³å°**ï¼š

- **æ¶ˆæ¯Schema**ï¼šå®šä¹‰æ¶ˆæ¯ç±»å‹ã€æ ¼å¼ã€åºåˆ—åŒ–æ–¹å¼
- **äº‹ä»¶Schema**ï¼šå®šä¹‰ç”¨æˆ·æ“ä½œã€æ–‡æ¡£å˜æ›´ã€çŠ¶æ€æ›´æ–°äº‹ä»¶
- **æˆ¿é—´Schema**ï¼šå®šä¹‰æ–‡æ¡£æˆ¿é—´ã€æˆå‘˜ç®¡ç†ã€æƒé™æ§åˆ¶
- **åè®®Schema**ï¼šå®šä¹‰æ¡æ‰‹ã€å¿ƒè·³ã€é‡è¿ã€ACKæœºåˆ¶
- **OTæ“ä½œSchema**ï¼šå®šä¹‰æ“ä½œç±»å‹ã€å˜æ¢ç®—æ³•ã€ç‰ˆæœ¬ç®¡ç†

### 2.6 å®Œæ•´ä»£ç å®ç°

**WebSocketå®æ—¶åä½œå¹³å°Schemaå®ç°**ï¼š

```python
#!/usr/bin/env python3
"""
WebSocketå®æ—¶åä½œå¹³å°Schemaå®ç°
WebSocket Real-time Collaboration Platform Schema Implementation
"""

from typing import Dict, List, Optional, Set, Callable, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
import json
import uuid
import asyncio
from collections import defaultdict


class MessageType(str, Enum):
    """æ¶ˆæ¯ç±»å‹"""
    # è¿æ¥ç®¡ç†
    CONNECT = "connect"
    DISCONNECT = "disconnect"
    PING = "ping"
    PONG = "pong"
    AUTH = "auth"
    AUTH_SUCCESS = "auth_success"
    AUTH_FAILED = "auth_failed"
    
    # æ–‡æ¡£åä½œ
    JOIN_DOCUMENT = "join_document"
    LEAVE_DOCUMENT = "leave_document"
    DOCUMENT_JOINED = "document_joined"
    OPERATION = "operation"
    OPERATION_ACK = "operation_ack"
    CURSOR_UPDATE = "cursor_update"
    SELECTION_UPDATE = "selection_update"
    
    # å³æ—¶é€šè®¯
    CHAT_MESSAGE = "chat_message"
    CHAT_ACK = "chat_ack"
    TYPING = "typing"
    MENTION = "mention"
    
    # çŠ¶æ€åŒæ­¥
    USER_ONLINE = "user_online"
    USER_OFFLINE = "user_offline"
    PRESENCE_UPDATE = "presence_update"
    
    # ç³»ç»Ÿæ¶ˆæ¯
    ERROR = "error"
    BROADCAST = "broadcast"
    NOTIFICATION = "notification"


class OperationType(str, Enum):
    """OTæ“ä½œç±»å‹"""
    INSERT = "insert"
    DELETE = "delete"
    RETAIN = "retain"
    FORMAT = "format"


class PresenceStatus(str, Enum):
    """åœ¨çº¿çŠ¶æ€"""
    ONLINE = "online"
    AWAY = "away"
    BUSY = "busy"
    OFFLINE = "offline"
    EDITING = "editing"


@dataclass
class WebSocketMessage:
    """WebSocketæ¶ˆæ¯åŸºç±»"""
    message_id: str
    message_type: MessageType
    timestamp: datetime = field(default_factory=datetime.now)
    sender_id: Optional[str] = None
    recipient_id: Optional[str] = None
    payload: Dict[str, Any] = field(default_factory=dict)
    
    def to_json(self) -> str:
        """åºåˆ—åŒ–ä¸ºJSON"""
        data = {
            'message_id': self.message_id,
            'message_type': self.message_type.value,
            'timestamp': self.timestamp.isoformat(),
            'sender_id': self.sender_id,
            'recipient_id': self.recipient_id,
            'payload': self.payload
        }
        return json.dumps(data, ensure_ascii=False)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'WebSocketMessage':
        """ä»JSONååºåˆ—åŒ–"""
        data = json.loads(json_str)
        return cls(
            message_id=data['message_id'],
            message_type=MessageType(data['message_type']),
            timestamp=datetime.fromisoformat(data['timestamp']),
            sender_id=data.get('sender_id'),
            recipient_id=data.get('recipient_id'),
            payload=data.get('payload', {})
        )


@dataclass
class OTOperation:
    """OTæ“ä½œ"""
    operation_id: str
    document_id: str
    user_id: str
    operation_type: OperationType
    position: int
    content: Optional[str] = None
    attributes: Optional[Dict] = None
    revision: int = 0
    parent_revision: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        return {
            'operation_id': self.operation_id,
            'document_id': self.document_id,
            'user_id': self.user_id,
            'operation_type': self.operation_type.value,
            'position': self.position,
            'content': self.content,
            'attributes': self.attributes,
            'revision': self.revision,
            'parent_revision': self.parent_revision,
            'timestamp': self.timestamp.isoformat()
        }


@dataclass
class CursorPosition:
    """å…‰æ ‡ä½ç½®"""
    user_id: str
    document_id: str
    line: int
    column: int
    color: str
    username: str
    last_update: datetime = field(default_factory=datetime.now)


@dataclass
class ChatMessage:
    """èŠå¤©æ¶ˆæ¯"""
    message_id: str
    room_id: str
    sender_id: str
    sender_name: str
    content: str
    message_type: str = "text"
    mentioned_users: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        return {
            'message_id': self.message_id,
            'room_id': self.room_id,
            'sender_id': self.sender_id,
            'sender_name': self.sender_name,
            'content': self.content,
            'message_type': self.message_type,
            'mentioned_users': self.mentioned_users,
            'timestamp': self.timestamp.isoformat()
        }


@dataclass
class PresenceInfo:
    """åœ¨çº¿çŠ¶æ€ä¿¡æ¯"""
    user_id: str
    status: PresenceStatus
    current_document: Optional[str] = None
    client_info: Optional[Dict] = None
    last_active: datetime = field(default_factory=datetime.now)


class DocumentRoom:
    """æ–‡æ¡£æˆ¿é—´"""
    def __init__(self, document_id: str):
        self.document_id = document_id
        self.members: Dict[str, 'WebSocketClient'] = {}
        self.operations: List[OTOperation] = []
        self.cursors: Dict[str, CursorPosition] = {}
        self.current_revision: int = 0
        self.created_at: datetime = datetime.now()
    
    def add_member(self, client: 'WebSocketClient'):
        """æ·»åŠ æˆå‘˜"""
        self.members[client.client_id] = client
    
    def remove_member(self, client_id: str):
        """ç§»é™¤æˆå‘˜"""
        if client_id in self.members:
            del self.members[client_id]
        if client_id in self.cursors:
            del self.cursors[client_id]
    
    def broadcast(self, message: WebSocketMessage, exclude: Optional[str] = None):
        """å¹¿æ’­æ¶ˆæ¯"""
        for client_id, client in self.members.items():
            if client_id != exclude:
                asyncio.create_task(client.send(message))
    
    def apply_operation(self, operation: OTOperation) -> OTOperation:
        """åº”ç”¨OTæ“ä½œ"""
        operation.revision = self.current_revision + 1
        self.operations.append(operation)
        self.current_revision = operation.revision
        return operation
    
    def get_members_count(self) -> int:
        """è·å–æˆå‘˜æ•°"""
        return len(self.members)
    
    def get_active_users(self) -> List[Dict]:
        """è·å–æ´»è·ƒç”¨æˆ·åˆ—è¡¨"""
        return [
            {
                'user_id': client.user_id,
                'username': client.username,
                'cursor': self.cursors.get(client.client_id).to_dict() if client.client_id in self.cursors else None
            }
            for client in self.members.values()
        ]


@dataclass
class WebSocketClient:
    """WebSocketå®¢æˆ·ç«¯"""
    client_id: str
    user_id: Optional[str] = None
    username: Optional[str] = None
    socket: Any = None
    connected_at: datetime = field(default_factory=datetime.now)
    last_ping: datetime = field(default_factory=datetime.now)
    is_authenticated: bool = False
    current_room: Optional[str] = None
    
    async def send(self, message: WebSocketMessage):
        """å‘é€æ¶ˆæ¯"""
        if self.socket:
            try:
                await self.socket.send(message.to_json())
            except Exception as e:
                print(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
    
    async def close(self):
        """å…³é—­è¿æ¥"""
        if self.socket:
            await self.socket.close()


class WebSocketServer:
    """WebSocketæœåŠ¡å™¨"""
    def __init__(self):
        self.clients: Dict[str, WebSocketClient] = {}
        self.rooms: Dict[str, DocumentRoom] = {}
        self.user_presence: Dict[str, PresenceInfo] = {}
        self.message_handlers: Dict[MessageType, Callable] = {}
        self.setup_handlers()
    
    def setup_handlers(self):
        """è®¾ç½®æ¶ˆæ¯å¤„ç†å™¨"""
        self.message_handlers = {
            MessageType.AUTH: self.handle_auth,
            MessageType.JOIN_DOCUMENT: self.handle_join_document,
            MessageType.LEAVE_DOCUMENT: self.handle_leave_document,
            MessageType.OPERATION: self.handle_operation,
            MessageType.CURSOR_UPDATE: self.handle_cursor_update,
            MessageType.CHAT_MESSAGE: self.handle_chat_message,
            MessageType.PING: self.handle_ping,
        }
    
    async def connect(self, client: WebSocketClient):
        """å®¢æˆ·ç«¯è¿æ¥"""
        self.clients[client.client_id] = client
        print(f"å®¢æˆ·ç«¯è¿æ¥: {client.client_id}")
        
        # å‘é€è¿æ¥æˆåŠŸæ¶ˆæ¯
        msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.CONNECT,
            payload={'client_id': client.client_id}
        )
        await client.send(msg)
    
    async def disconnect(self, client_id: str):
        """å®¢æˆ·ç«¯æ–­å¼€"""
        client = self.clients.get(client_id)
        if client:
            # ç¦»å¼€å½“å‰æˆ¿é—´
            if client.current_room:
                await self.handle_leave_document(client, WebSocketMessage(
                    message_id=str(uuid.uuid4()),
                    message_type=MessageType.LEAVE_DOCUMENT,
                    payload={'document_id': client.current_room}
                ))
            
            del self.clients[client_id]
            print(f"å®¢æˆ·ç«¯æ–­å¼€: {client_id}")
    
    async def handle_message(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†æ¶ˆæ¯"""
        handler = self.message_handlers.get(message.message_type)
        if handler:
            await handler(client, message)
        else:
            await self.send_error(client, f"æœªçŸ¥æ¶ˆæ¯ç±»å‹: {message.message_type}")
    
    async def handle_auth(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†è®¤è¯"""
        token = message.payload.get('token')
        user_id = message.payload.get('user_id')
        username = message.payload.get('username')
        
        # æ¨¡æ‹Ÿè®¤è¯
        if token and user_id:
            client.user_id = user_id
            client.username = username
            client.is_authenticated = True
            
            # æ›´æ–°åœ¨çº¿çŠ¶æ€
            self.user_presence[user_id] = PresenceInfo(
                user_id=user_id,
                status=PresenceStatus.ONLINE
            )
            
            msg = WebSocketMessage(
                message_id=str(uuid.uuid4()),
                message_type=MessageType.AUTH_SUCCESS,
                sender_id=user_id,
                payload={'user_id': user_id, 'username': username}
            )
            await client.send(msg)
        else:
            msg = WebSocketMessage(
                message_id=str(uuid.uuid4()),
                message_type=MessageType.AUTH_FAILED,
                payload={'error': 'è®¤è¯å¤±è´¥'}
            )
            await client.send(msg)
    
    async def handle_join_document(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†åŠ å…¥æ–‡æ¡£"""
        document_id = message.payload.get('document_id')
        
        if not document_id:
            await self.send_error(client, "ç¼ºå°‘document_id")
            return
        
        # åˆ›å»ºæˆ–è·å–æˆ¿é—´
        if document_id not in self.rooms:
            self.rooms[document_id] = DocumentRoom(document_id)
        
        room = self.rooms[document_id]
        
        # ç¦»å¼€ä¹‹å‰çš„æˆ¿é—´
        if client.current_room and client.current_room != document_id:
            await self.handle_leave_document(client, WebSocketMessage(
                message_id=str(uuid.uuid4()),
                message_type=MessageType.LEAVE_DOCUMENT,
                payload={'document_id': client.current_room}
            ))
        
        # åŠ å…¥æ–°æˆ¿é—´
        room.add_member(client)
        client.current_room = document_id
        
        # æ›´æ–°ç”¨æˆ·çŠ¶æ€
        if client.user_id and client.user_id in self.user_presence:
            self.user_presence[client.user_id].current_document = document_id
            self.user_presence[client.user_id].status = PresenceStatus.EDITING
        
        # å‘é€åŠ å…¥æˆåŠŸæ¶ˆæ¯
        joined_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.DOCUMENT_JOINED,
            sender_id=client.user_id,
            payload={
                'document_id': document_id,
                'members_count': room.get_members_count(),
                'active_users': room.get_active_users(),
                'current_revision': room.current_revision
            }
        )
        await client.send(joined_msg)
        
        # å¹¿æ’­æ–°æˆå‘˜åŠ å…¥
        broadcast_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.USER_ONLINE,
            sender_id=client.user_id,
            payload={
                'document_id': document_id,
                'user_id': client.user_id,
                'username': client.username
            }
        )
        room.broadcast(broadcast_msg, exclude=client.client_id)
    
    async def handle_leave_document(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†ç¦»å¼€æ–‡æ¡£"""
        document_id = message.payload.get('document_id') or client.current_room
        
        if document_id and document_id in self.rooms:
            room = self.rooms[document_id]
            room.remove_member(client.client_id)
            
            # å¹¿æ’­æˆå‘˜ç¦»å¼€
            broadcast_msg = WebSocketMessage(
                message_id=str(uuid.uuid4()),
                message_type=MessageType.USER_OFFLINE,
                sender_id=client.user_id,
                payload={
                    'document_id': document_id,
                    'user_id': client.user_id
                }
            )
            room.broadcast(broadcast_msg)
            
            # æ¸…ç†ç©ºæˆ¿é—´
            if room.get_members_count() == 0:
                del self.rooms[document_id]
        
        client.current_room = None
    
    async def handle_operation(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†OTæ“ä½œ"""
        document_id = client.current_room
        
        if not document_id or document_id not in self.rooms:
            await self.send_error(client, "æœªåŠ å…¥æ–‡æ¡£")
            return
        
        room = self.rooms[document_id]
        
        # åˆ›å»ºOTæ“ä½œ
        operation = OTOperation(
            operation_id=str(uuid.uuid4()),
            document_id=document_id,
            user_id=client.user_id or 'anonymous',
            operation_type=OperationType(message.payload.get('operation_type', 'retain')),
            position=message.payload.get('position', 0),
            content=message.payload.get('content'),
            attributes=message.payload.get('attributes'),
            parent_revision=message.payload.get('parent_revision', room.current_revision)
        )
        
        # åº”ç”¨æ“ä½œ
        room.apply_operation(operation)
        
        # å‘é€ACK
        ack_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.OPERATION_ACK,
            sender_id=client.user_id,
            payload={
                'operation_id': operation.operation_id,
                'revision': operation.revision
            }
        )
        await client.send(ack_msg)
        
        # å¹¿æ’­ç»™å…¶ä»–æˆå‘˜
        broadcast_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.OPERATION,
            sender_id=client.user_id,
            payload=operation.to_dict()
        )
        room.broadcast(broadcast_msg, exclude=client.client_id)
    
    async def handle_cursor_update(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†å…‰æ ‡æ›´æ–°"""
        document_id = client.current_room
        
        if not document_id or document_id not in self.rooms:
            return
        
        room = self.rooms[document_id]
        
        # æ›´æ–°å…‰æ ‡ä½ç½®
        cursor = CursorPosition(
            user_id=client.user_id or 'anonymous',
            document_id=document_id,
            line=message.payload.get('line', 0),
            column=message.payload.get('column', 0),
            color=message.payload.get('color', '#000000'),
            username=client.username or 'Anonymous'
        )
        room.cursors[client.client_id] = cursor
        
        # å¹¿æ’­å…‰æ ‡ä½ç½®
        broadcast_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.CURSOR_UPDATE,
            sender_id=client.user_id,
            payload={
                'user_id': client.user_id,
                'username': client.username,
                'line': cursor.line,
                'column': cursor.column,
                'color': cursor.color
            }
        )
        room.broadcast(broadcast_msg, exclude=client.client_id)
    
    async def handle_chat_message(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†èŠå¤©æ¶ˆæ¯"""
        document_id = client.current_room
        
        if not document_id or document_id not in self.rooms:
            await self.send_error(client, "æœªåŠ å…¥æ–‡æ¡£")
            return
        
        room = self.rooms[document_id]
        
        # åˆ›å»ºèŠå¤©æ¶ˆæ¯
        chat_msg = ChatMessage(
            message_id=str(uuid.uuid4()),
            room_id=document_id,
            sender_id=client.user_id or 'anonymous',
            sender_name=client.username or 'Anonymous',
            content=message.payload.get('content', ''),
            mentioned_users=message.payload.get('mentioned_users', [])
        )
        
        # å‘é€ACK
        ack_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.CHAT_ACK,
            sender_id=client.user_id,
            payload={'message_id': chat_msg.message_id}
        )
        await client.send(ack_msg)
        
        # å¹¿æ’­æ¶ˆæ¯
        broadcast_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.CHAT_MESSAGE,
            sender_id=client.user_id,
            payload=chat_msg.to_dict()
        )
        room.broadcast(broadcast_msg)
    
    async def handle_ping(self, client: WebSocketClient, message: WebSocketMessage):
        """å¤„ç†å¿ƒè·³"""
        client.last_ping = datetime.now()
        
        pong_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.PONG,
            timestamp=datetime.now()
        )
        await client.send(pong_msg)
    
    async def send_error(self, client: WebSocketClient, error_message: str):
        """å‘é€é”™è¯¯æ¶ˆæ¯"""
        error_msg = WebSocketMessage(
            message_id=str(uuid.uuid4()),
            message_type=MessageType.ERROR,
            payload={'error': error_message}
        )
        await client.send(error_msg)
    
    def get_stats(self) -> Dict:
        """è·å–æœåŠ¡å™¨ç»Ÿè®¡"""
        return {
            'total_connections': len(self.clients),
            'total_rooms': len(self.rooms),
            'online_users': len(self.user_presence),
            'total_operations': sum(len(room.operations) for room in self.rooms.values()),
            'room_details': [
                {
                    'document_id': room.document_id,
                    'members': room.get_members_count(),
                    'operations': len(room.operations)
                }
                for room in self.rooms.values()
            ]
        }


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    print("=" * 70)
    print("WebSocketå®æ—¶åä½œå¹³å°Schemaå®ç°")
    print("=" * 70)
    
    # åˆ›å»ºæœåŠ¡å™¨å®ä¾‹
    server = WebSocketServer()
    
    print("\n1. æ¶ˆæ¯ç±»å‹å®šä¹‰")
    print("-" * 70)
    for msg_type in MessageType:
        print(f"  {msg_type.name}: {msg_type.value}")
    
    print("\n2. OTæ“ä½œç±»å‹")
    print("-" * 70)
    for op_type in OperationType:
        print(f"  {op_type.name}: {op_type.value}")
    
    print("\n3. åœ¨çº¿çŠ¶æ€")
    print("-" * 70)
    for status in PresenceStatus:
        print(f"  {status.name}: {status.value}")
    
    print("\n4. ç¤ºä¾‹æ¶ˆæ¯æ ¼å¼")
    print("-" * 70)
    
    # ç¤ºä¾‹æ¶ˆæ¯
    examples = [
        WebSocketMessage(
            message_id="msg-001",
            message_type=MessageType.AUTH,
            sender_id="user-001",
            payload={'token': 'xxx', 'user_id': 'user-001'}
        ),
        WebSocketMessage(
            message_id="msg-002",
            message_type=MessageType.JOIN_DOCUMENT,
            sender_id="user-001",
            payload={'document_id': 'doc-001'}
        ),
        WebSocketMessage(
            message_id="msg-003",
            message_type=MessageType.OPERATION,
            sender_id="user-001",
            payload={
                'operation_type': 'insert',
                'position': 10,
                'content': 'Hello',
                'parent_revision': 5
            }
        ),
        WebSocketMessage(
            message_id="msg-004",
            message_type=MessageType.CURSOR_UPDATE,
            sender_id="user-001",
            payload={'line': 3, 'column': 15, 'color': '#FF0000'}
        )
    ]
    
    for msg in examples:
        print(f"\n{msg.message_type.value}:")
        print(json.dumps(json.loads(msg.to_json()), indent=2, ensure_ascii=False))
    
    print("\n5. OTæ“ä½œç¤ºä¾‹")
    print("-" * 70)
    
    op = OTOperation(
        operation_id="op-001",
        document_id="doc-001",
        user_id="user-001",
        operation_type=OperationType.INSERT,
        position=10,
        content="Hello World",
        revision=6
    )
    print(json.dumps(op.to_dict(), indent=2, ensure_ascii=False))
    
    print("\n6. æ€§èƒ½å¯¹æ¯”ï¼ˆWebSocket vs HTTPè½®è¯¢ï¼‰")
    print("-" * 70)
    print(f"{'æŒ‡æ ‡':<25} {'HTTPè½®è¯¢':<15} {'WebSocket':<15} {'æå‡':<10}")
    print("-" * 65)
    comparisons = [
        ("æ¶ˆæ¯å»¶è¿Ÿ", "5-10ç§’", "<100ms", "-98%"),
        ("æœåŠ¡å™¨CPUå ç”¨", "80%", "30%", "-63%"),
        ("å¸¦å®½æ¶ˆè€—", "é«˜", "ä½", "-90%"),
        ("å¹¶å‘è¿æ¥æ•°", "æœ‰é™", "50ä¸‡+", "+âˆ"),
        ("å®æ—¶æ€§", "å·®", "æå¥½", "è´¨çš„é£è·ƒ"),
        ("æ¶ˆæ¯åˆ°è¾¾ç‡", "95%", "99.9%", "+5%"),
    ]
    for metric, polling, websocket, improvement in comparisons:
        print(f"{metric:<25} {polling:<15} {websocket:<15} {improvement:<10}")
    
    print("\n" + "=" * 70)
    print("WebSocketåè®®ä¼˜åŠ¿")
    print("=" * 70)
    print("""
1. å…¨åŒå·¥é€šä¿¡: å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨å¯åŒæ—¶å‘é€æ¶ˆæ¯ï¼Œæ— éœ€ç­‰å¾…
2. ä½å»¶è¿Ÿ: é•¿è¿æ¥é¿å…TCPæ¡æ‰‹å¼€é”€ï¼Œå»¶è¿Ÿé™è‡³æ¯«ç§’çº§
3. é«˜æ•ˆ: å¤´éƒ¨å¼€é”€å°ï¼Œæ”¯æŒäºŒè¿›åˆ¶ä¼ è¾“ï¼Œå¸¦å®½åˆ©ç”¨ç‡é«˜
4. å®æ—¶æ€§: æœåŠ¡å™¨å¯ä¸»åŠ¨æ¨é€æ¶ˆæ¯ï¼ŒçœŸæ­£çš„å®æ—¶é€šä¿¡
5. æ ‡å‡†åŒ–: RFC 6455æ ‡å‡†ï¼Œæµè§ˆå™¨åŸç”Ÿæ”¯æŒï¼Œç”Ÿæ€æˆç†Ÿ
    """)
```

### 2.7 æ•ˆæœè¯„ä¼°

**å…³é”®ç»©æ•ˆæŒ‡æ ‡ï¼ˆKPIï¼‰å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›åï¼ˆ6ä¸ªæœˆï¼‰ | æå‡å¹…åº¦ |
|------|--------|----------------|----------|
| åä½œå»¶è¿Ÿ | 2-3ç§’ | 80ms | -97% |
| æ¶ˆæ¯æ¨é€å»¶è¿Ÿ | 5-10ç§’ | 50ms | -99% |
| æ¶ˆæ¯åˆ°è¾¾ç‡ | 95% | 99.9% | +4.9pp |
| æœåŠ¡å™¨CPUå ç”¨ | 80% | 28% | -65% |
| åŒæ—¶åœ¨çº¿è¿æ¥ | 10ä¸‡ | 50ä¸‡ | +400% |
| ç”¨æˆ·æ»¡æ„åº¦ | 3.2/5 | 4.7/5 | +47% |
| å®¢æˆ·æµå¤±ç‡ | 8%/æœˆ | 2%/æœˆ | -75% |

**æŠ•èµ„å›æŠ¥åˆ†æï¼ˆROIï¼‰**ï¼š

| æŠ•èµ„/æ”¶ç›Šé¡¹ç›® | é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰ | è¯´æ˜ |
|--------------|-------------|------|
| **æ€»æŠ•èµ„** | **320** | |
| WebSocketæœåŠ¡å™¨ | 120 | Socket.IO/è‡ªç ” |
| æ¶æ„æ”¹é€  | 100 | å­˜é‡ç³»ç»Ÿæ”¹é€  |
| åŸºç¡€è®¾æ–½ | 60 | è´Ÿè½½å‡è¡¡ã€æ¶ˆæ¯é˜Ÿåˆ— |
| æµ‹è¯•ä¼˜åŒ– | 40 | æ€§èƒ½æµ‹è¯•ã€ç¨³å®šæ€§ä¼˜åŒ– |
| **å¹´åº¦æ”¶ç›Š** | **1,380** | |
| æœåŠ¡å™¨æˆæœ¬èŠ‚çº¦ | 480 | å‡å°‘æœåŠ¡å™¨æ•°é‡ |
| å®¢æˆ·ç•™å­˜æå‡ | 520 | æµå¤±ç‡é™ä½å¸¦æ¥æ”¶å…¥ |
| å®¢æˆ·æ»¡æ„åº¦ | 280 | NPSæå‡è½¬åŒ– |
| è¿ç»´æˆæœ¬é™ä½ | 100 | è‡ªåŠ¨åŒ–è¿ç»´ |
| **é¦–å¹´å‡€æ”¶ç›Š** | **1,060** | |
| **æŠ•èµ„å›æŠ¥ç‡ï¼ˆROIï¼‰** | **331.3%** | é¦–å¹´ |
| **æŠ•èµ„å›æ”¶æœŸ** | **2.8ä¸ªæœˆ** | |

**ä¸šåŠ¡ä»·å€¼**ï¼š

1. **åä½œä½“éªŒè´¨çš„é£è·ƒ**ï¼šç¼–è¾‘å»¶è¿Ÿä»2-3ç§’é™è‡³80msï¼Œç”¨æˆ·æ„Ÿè§‰å¦‚åŒæœ¬åœ°ç¼–è¾‘ï¼Œå®¢æˆ·æ»¡æ„åº¦ä»3.2æå‡è‡³4.7ï¼Œå®¢æˆ·æµå¤±ç‡é™ä½75%ã€‚

2. **æ¶ˆæ¯å®æ—¶å¯é **ï¼šæ¶ˆæ¯æ¨é€å»¶è¿Ÿä»5-10ç§’é™è‡³50msï¼Œåˆ°è¾¾ç‡æå‡è‡³99.9%ï¼Œç”¨æˆ·ä¸å†é”™è¿‡é‡è¦é€šçŸ¥ï¼Œå›¢é˜Ÿåä½œæ•ˆç‡æå‡40%ã€‚

3. **ç³»ç»Ÿå®¹é‡å¤§å¹…æå‡**ï¼šæœåŠ¡å™¨CPUå ç”¨ä»80%é™è‡³28%ï¼ŒåŒæ—¶åœ¨çº¿è¿æ¥ä»10ä¸‡æå‡è‡³50ä¸‡ï¼Œæ”¯æŒä¸šåŠ¡å¿«é€Ÿå¢é•¿ã€‚

4. **è¿ç»´æˆæœ¬æ˜¾è‘—é™ä½**ï¼šå¸¦å®½æ¶ˆè€—å‡å°‘90%ï¼ŒæœåŠ¡å™¨éœ€æ±‚å‡å°‘60%ï¼Œå¹´åº¦æœåŠ¡å™¨æˆæœ¬èŠ‚çº¦480ä¸‡å…ƒã€‚

5. **äº§å“ç«äº‰åŠ›å¢å¼º**ï¼šå®æ—¶åä½œæˆä¸ºäº§å“æ ¸å¿ƒå–ç‚¹ï¼Œä¼ä¸šå®¢æˆ·ç­¾çº¦ç‡æå‡35%ï¼ŒARRå¢é•¿50%ã€‚

**æˆåŠŸç»éªŒ**ï¼š

1. **å¿ƒè·³æœºåˆ¶åˆ°ä½**ï¼šåˆç†è®¾ç½®å¿ƒè·³é—´éš”ï¼Œæ—¢ä¿æŒè¿æ¥åˆä¸è¿‡åº¦æ¶ˆè€—èµ„æºã€‚
2. **é‡è¿ç­–ç•¥å®Œå–„**ï¼šå¼±ç½‘ç¯å¢ƒä¸‹è‡ªåŠ¨é‡è¿ï¼Œæ¶ˆæ¯ä¸ä¸¢å¤±ï¼Œç”¨æˆ·ä½“éªŒè¿ç»­ã€‚
3. **æ¶ˆæ¯ACKæœºåˆ¶**ï¼šé‡è¦æ¶ˆæ¯è¦æ±‚ACKç¡®è®¤ï¼Œç¡®ä¿æ¶ˆæ¯å¯é æŠ•é€’ã€‚
4. ** roomsåˆç†è®¾è®¡**ï¼šæ–‡æ¡£ç²’åº¦æˆ¿é—´ç®¡ç†ï¼Œå¹¿æ’­èŒƒå›´å¯æ§ï¼Œæ€§èƒ½ä¼˜åŒ–ã€‚

---

**å‚è€ƒæ¡ˆä¾‹**ï¼š

- [Google Docså®æ—¶åä½œ](https://www.google.com/docs/about/)
- [Figma WebSocketæ¶æ„](https://www.figma.com/blog/)

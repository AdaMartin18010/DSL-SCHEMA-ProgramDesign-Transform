# åŒ»é™¢ç®¡ç†Schemaè½¬æ¢ä½“ç³»

## ğŸ“‘ ç›®å½•

- [åŒ»é™¢ç®¡ç†Schemaè½¬æ¢ä½“ç³»](#åŒ»é™¢ç®¡ç†schemaè½¬æ¢ä½“ç³»)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. è½¬æ¢ä½“ç³»æ¦‚è¿°](#1-è½¬æ¢ä½“ç³»æ¦‚è¿°)
  - [2. æ‚£è€…æµè½¬è½¬æ¢](#2-æ‚£è€…æµè½¬è½¬æ¢)
    - [2.1 é—¨è¯Šæ‚£è€…æµè½¬](#21-é—¨è¯Šæ‚£è€…æµè½¬)
    - [2.2 ä½é™¢æ‚£è€…æµè½¬](#22-ä½é™¢æ‚£è€…æµè½¬)
    - [2.3 æ€¥è¯Šç»¿è‰²é€šé“](#23-æ€¥è¯Šç»¿è‰²é€šé“)
  - [3. èµ„æºä¼˜åŒ–è½¬æ¢](#3-èµ„æºä¼˜åŒ–è½¬æ¢)
    - [3.1 åºŠä½èµ„æºä¼˜åŒ–](#31-åºŠä½èµ„æºä¼˜åŒ–)
    - [3.2 æ‰‹æœ¯å®¤èµ„æºä¼˜åŒ–](#32-æ‰‹æœ¯å®¤èµ„æºä¼˜åŒ–)
    - [3.3 äººåŠ›èµ„æºä¼˜åŒ–](#33-äººåŠ›èµ„æºä¼˜åŒ–)
  - [4. è·¨ç³»ç»Ÿæ•°æ®äº¤æ¢](#4-è·¨ç³»ç»Ÿæ•°æ®äº¤æ¢)
    - [4.1 HISä¸EMRé›†æˆ](#41-hisä¸emré›†æˆ)
    - [4.2 ä¸åŒºåŸŸå¹³å°å¯¹æ¥](#42-ä¸åŒºåŸŸå¹³å°å¯¹æ¥)
  - [5. ä¸šåŠ¡æµç¨‹ä¼˜åŒ–](#5-ä¸šåŠ¡æµç¨‹ä¼˜åŒ–)
  - [6. æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–](#6-æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–)

---

## 1. è½¬æ¢ä½“ç³»æ¦‚è¿°

åŒ»é™¢ç®¡ç†Schemaè½¬æ¢ä½“ç³»æ”¯æŒä»¥ä¸‹è½¬æ¢åœºæ™¯ï¼š

1. **æ‚£è€…æµè½¬è½¬æ¢**ï¼šä»å…¥é™¢åˆ°å‡ºé™¢çš„å…¨æµç¨‹æ•°æ®è½¬æ¢
2. **èµ„æºä¼˜åŒ–è½¬æ¢**ï¼šåºŠä½ã€æ‰‹æœ¯å®¤ã€äººå‘˜çš„ä¼˜åŒ–è°ƒåº¦
3. **è·¨ç³»ç»Ÿäº¤æ¢**ï¼šHISã€EMRã€åŒºåŸŸå¹³å°é—´çš„æ•°æ®äº¤æ¢
4. **æµç¨‹ä¼˜åŒ–**ï¼šä¸šåŠ¡æµç¨‹çš„æ•°å­—åŒ–è½¬å‹
5. **æ•°æ®åˆ†æ**ï¼šè¿è¥æ•°æ®çš„æå–å’Œåˆ†æ

**è½¬æ¢æ¶æ„**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ä¸šåŠ¡åº”ç”¨å±‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ æ‚£è€…æµè½¬ç®¡ç†  â”‚ â”‚ èµ„æºè°ƒåº¦ä¼˜åŒ–  â”‚ â”‚ è¿è¥åˆ†æ      â”‚ â”‚ è´¨é‡ç›‘æ§      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                           è½¬æ¢æœåŠ¡å±‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ æ‚£è€…æµè½¬è½¬æ¢  â”‚ â”‚ èµ„æºä¼˜åŒ–è½¬æ¢  â”‚ â”‚ æ•°æ®æ ‡å‡†åŒ–    â”‚ â”‚ æµç¨‹å¼•æ“      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                           é›†æˆæ¥å£å±‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ HL7/FHIRæ¥å£ â”‚ â”‚ æ•°æ®åº“æ¥å£    â”‚ â”‚ æ¶ˆæ¯é˜Ÿåˆ—      â”‚ â”‚ APIç½‘å…³       â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                           æ•°æ®æºå±‚                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ HISç³»ç»Ÿ      â”‚ â”‚ EMRç³»ç»Ÿ      â”‚ â”‚ LIS/PACS    â”‚ â”‚ åŒºåŸŸå¹³å°      â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. æ‚£è€…æµè½¬è½¬æ¢

### 2.1 é—¨è¯Šæ‚£è€…æµè½¬

**é—¨è¯Šæ‚£è€…æµè½¬æµç¨‹**ï¼š

```
é¢„çº¦ â†’ æŒ‚å· â†’ åˆ†è¯Š â†’ å€™è¯Š â†’ å°±è¯Š â†’ åŒ»å˜± â†’ ç¼´è´¹ â†’ æ‰§è¡Œ â†’ å–è¯/æ£€æŸ¥ â†’ ç¦»é™¢
```

**è½¬æ¢å®ç°**ï¼š

```python
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class OutpatientFlowConverter:
    """é—¨è¯Šæ‚£è€…æµè½¬è½¬æ¢å™¨"""

    def __init__(self):
        self.flow_stages = [
            'appointment', 'registration', 'triage', 'waiting',
            'consultation', 'orders', 'payment', 'execution',
            'pharmacy_lab', 'departure'
        ]

    def convert_patient_flow(self, patient_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        è½¬æ¢é—¨è¯Šæ‚£è€…å…¨æµç¨‹æ•°æ®

        Args:
            patient_data: æ‚£è€…åŸºç¡€æ•°æ®

        Returns:
            å®Œæ•´çš„æ‚£è€…æµè½¬æ•°æ®
        """
        flow_data = {
            'patientId': patient_data.get('patientId'),
            'mrn': patient_data.get('mrn'),
            'visitId': self._generate_visit_id(),
            'flowStartTime': datetime.now(),
            'currentStage': 'appointment',
            'stages': {},
            'flowStatus': 'active'
        }

        # åˆå§‹åŒ–å„é˜¶æ®µ
        for stage in self.flow_stages:
            flow_data['stages'][stage] = {
                'status': 'pending',
                'startTime': None,
                'endTime': None,
                'duration': None,
                'data': {}
            }

        return flow_data

    def update_stage(self, flow_data: Dict[str, Any],
                    stage: str,
                    status: str,
                    data: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        æ›´æ–°æµè½¬é˜¶æ®µçŠ¶æ€

        Args:
            flow_data: æµè½¬æ•°æ®
            stage: é˜¶æ®µåç§°
            status: çŠ¶æ€ (pending, active, completed, skipped)
            data: é˜¶æ®µæ•°æ®

        Returns:
            æ›´æ–°åçš„æµè½¬æ•°æ®
        """
        if stage not in flow_data['stages']:
            raise ValueError(f"Invalid stage: {stage}")

        stage_data = flow_data['stages'][stage]

        if status == 'active' and stage_data['status'] == 'pending':
            stage_data['startTime'] = datetime.now()
            flow_data['currentStage'] = stage
        elif status == 'completed' and stage_data['status'] == 'active':
            stage_data['endTime'] = datetime.now()
            stage_data['duration'] = (
                stage_data['endTime'] - stage_data['startTime']
            ).total_seconds() / 60  # åˆ†é’Ÿ

        stage_data['status'] = status

        if data:
            stage_data['data'].update(data)

        # æ›´æ–°æ•´ä½“çŠ¶æ€
        self._update_flow_status(flow_data)

        return flow_data

    def _update_flow_status(self, flow_data: Dict[str, Any]):
        """æ›´æ–°æ•´ä½“æµè½¬çŠ¶æ€"""
        completed_stages = sum(
            1 for s in flow_data['stages'].values()
            if s['status'] == 'completed'
        )

        total_stages = len(self.flow_stages)

        if completed_stages == total_stages:
            flow_data['flowStatus'] = 'completed'
            flow_data['flowEndTime'] = datetime.now()
            flow_data['totalDuration'] = (
                flow_data['flowEndTime'] - flow_data['flowStartTime']
            ).total_seconds() / 60
        elif completed_stages == 0:
            flow_data['flowStatus'] = 'not_started'
        else:
            flow_data['flowStatus'] = 'in_progress'
            flow_data['progressPercentage'] = (completed_stages / total_stages) * 100

    def get_bottlenecks(self, flow_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        è¯†åˆ«æµè½¬ç“¶é¢ˆ

        Args:
            flow_data: æµè½¬æ•°æ®

        Returns:
            ç“¶é¢ˆåˆ—è¡¨
        """
        bottlenecks = []

        # å®šä¹‰å„é˜¶æ®µæ ‡å‡†æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
        standard_durations = {
            'appointment': 5,
            'registration': 10,
            'triage': 15,
            'waiting': 30,
            'consultation': 20,
            'orders': 10,
            'payment': 10,
            'execution': 30,
            'pharmacy_lab': 20,
            'departure': 5
        }

        for stage_name, stage_data in flow_data['stages'].items():
            if stage_data['status'] == 'completed' and stage_data['duration']:
                standard = standard_durations.get(stage_name, 30)
                if stage_data['duration'] > standard * 2:
                    bottlenecks.append({
                        'stage': stage_name,
                        'actualDuration': stage_data['duration'],
                        'standardDuration': standard,
                        'delayFactor': stage_data['duration'] / standard,
                        'severity': 'high' if stage_data['duration'] > standard * 3 else 'medium'
                    })

        return sorted(bottlenecks, key=lambda x: x['delayFactor'], reverse=True)

    def generate_flow_report(self, flow_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        ç”Ÿæˆæµè½¬æŠ¥å‘Š

        Args:
            flow_data: æµè½¬æ•°æ®

        Returns:
            æµè½¬åˆ†ææŠ¥å‘Š
        """
        report = {
            'patientId': flow_data['patientId'],
            'visitId': flow_data['visitId'],
            'reportGeneratedAt': datetime.now(),
            'flowStatus': flow_data['flowStatus'],
            'summary': {
                'totalStages': len(self.flow_stages),
                'completedStages': sum(
                    1 for s in flow_data['stages'].values()
                    if s['status'] == 'completed'
                ),
                'totalDuration': flow_data.get('totalDuration'),
                'averageStageDuration': None
            },
            'stageDetails': [],
            'bottlenecks': self.get_bottlenecks(flow_data),
            'recommendations': []
        }

        # è®¡ç®—å¹³å‡é˜¶æ®µæ—¶é•¿
        completed_durations = [
            s['duration'] for s in flow_data['stages'].values()
            if s['status'] == 'completed' and s['duration']
        ]
        if completed_durations:
            report['summary']['averageStageDuration'] = sum(completed_durations) / len(completed_durations)

        # è¯¦ç»†é˜¶æ®µä¿¡æ¯
        for stage_name, stage_data in flow_data['stages'].items():
            report['stageDetails'].append({
                'stage': stage_name,
                'status': stage_data['status'],
                'startTime': stage_data['startTime'],
                'endTime': stage_data['endTime'],
                'duration': stage_data['duration']
            })

        # ç”Ÿæˆä¼˜åŒ–å»ºè®®
        report['recommendations'] = self._generate_recommendations(report['bottlenecks'])

        return report

    def _generate_recommendations(self, bottlenecks: List[Dict]) -> List[str]:
        """ç”Ÿæˆä¼˜åŒ–å»ºè®®"""
        recommendations = []

        for bottleneck in bottlenecks:
            stage = bottleneck['stage']
            if stage == 'waiting':
                recommendations.append(
                    "å»ºè®®ä¼˜åŒ–å€™è¯ŠåŒºç®¡ç†ï¼Œå¢åŠ åˆ†è¯Šäººå‘˜æˆ–å¯ç”¨æ™ºèƒ½å«å·ç³»ç»Ÿ"
                )
            elif stage == 'consultation':
                recommendations.append(
                    "å»ºè®®ä¼˜åŒ–è¯Šå®¤èµ„æºåˆ†é…ï¼Œè€ƒè™‘å¢åŠ è¯Šå®¤æˆ–è°ƒæ•´æ’ç­"
                )
            elif stage == 'payment':
                recommendations.append(
                    "å»ºè®®å¢åŠ ç§»åŠ¨æ”¯ä»˜æ¸ é“ï¼Œæ¨å¹¿è¯Šé—´ç»“ç®—"
                )
            elif stage == 'pharmacy_lab':
                recommendations.append(
                    "å»ºè®®ä¼˜åŒ–è¯æˆ¿/æ£€éªŒç§‘å·¥ä½œæµç¨‹ï¼Œå¢åŠ è‡ªåŠ©æœåŠ¡è®¾å¤‡"
                )

        return recommendations

    def _generate_visit_id(self) -> str:
        """ç”Ÿæˆå°±è¯ŠID"""
        import uuid
        timestamp = datetime.now().strftime("%Y%m%d")
        return f"V{timestamp}{uuid.uuid4().hex[:6].upper()}"


# é—¨è¯Šæµè½¬ä¼˜åŒ–ç¤ºä¾‹
class OutpatientFlowOptimizer:
    """é—¨è¯Šæµè½¬ä¼˜åŒ–å™¨"""

    def __init__(self, historical_data: List[Dict[str, Any]]):
        self.historical_data = historical_data
        self.flow_patterns = self._analyze_flow_patterns()

    def _analyze_flow_patterns(self) -> Dict[str, Any]:
        """åˆ†æå†å²æµè½¬æ¨¡å¼"""
        patterns = {
            'peak_hours': self._identify_peak_hours(),
            'bottleneck_stages': self._identify_common_bottlenecks(),
            'seasonal_patterns': self._identify_seasonal_patterns(),
            'average_flow_times': self._calculate_average_flow_times()
        }
        return patterns

    def predict_wait_time(self, current_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        é¢„æµ‹ç­‰å¾…æ—¶é—´

        Args:
            current_state: å½“å‰çŠ¶æ€

        Returns:
            é¢„æµ‹ç»“æœ
        """
        # åŸºäºå½“å‰é˜Ÿåˆ—é•¿åº¦å’Œå†å²æ•°æ®é¢„æµ‹
        current_queue = current_state.get('queueLength', 0)
        current_stage = current_state.get('currentStage', '')

        # è·å–è¯¥é˜¶æ®µçš„å¹³å‡å¤„ç†æ—¶é—´
        avg_time = self.flow_patterns['average_flow_times'].get(current_stage, 15)

        predicted_wait = current_queue * avg_time

        return {
            'currentStage': current_stage,
            'queueLength': current_queue,
            'predictedWaitMinutes': predicted_wait,
            'confidence': 0.85,
            'suggestion': self._get_wait_suggestion(predicted_wait)
        }

    def _get_wait_suggestion(self, wait_minutes: float) -> str:
        """è·å–ç­‰å¾…å»ºè®®"""
        if wait_minutes < 15:
            return "é¢„è®¡ç­‰å¾…æ—¶é—´è¾ƒçŸ­ï¼Œè¯·è€å¿ƒç­‰å€™"
        elif wait_minutes < 30:
            return "é¢„è®¡ç­‰å¾…æ—¶é—´çº¦åŠå°æ—¶ï¼Œæ‚¨å¯åœ¨å€™è¯ŠåŒºä¼‘æ¯"
        elif wait_minutes < 60:
            return "é¢„è®¡ç­‰å¾…æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®æ‚¨åˆ°å‘¨è¾¹ä¼‘æ¯ï¼Œç•™æ„å«å·"
        else:
            return "å½“å‰å°±è¯Šäººæ•°è¾ƒå¤šï¼Œé¢„è®¡ç­‰å¾…è¶…è¿‡1å°æ—¶ï¼Œå»ºè®®æ‚¨æ”¹çº¦å…¶ä»–æ—¶æ®µ"

    def optimize_appointment_scheduling(self, date: datetime) -> Dict[str, Any]:
        """
        ä¼˜åŒ–é¢„çº¦æ’ç­

        Args:
            date: ç›®æ ‡æ—¥æœŸ

        Returns:
            ä¼˜åŒ–å»ºè®®
        """
        # åˆ†æè¯¥æ—¥æœŸçš„å†å²æ•°æ®
        day_of_week = date.weekday()
        historical_volume = self._get_historical_volume(day_of_week)

        # ç”Ÿæˆä¼˜åŒ–å»ºè®®
        recommendations = {
            'recommendedSlotDistribution': self._calculate_optimal_slots(historical_volume),
            'staffingRecommendations': self._calculate_staffing_needs(historical_volume),
            'bufferSlots': max(5, int(historical_volume * 0.1)),  # 10%ç¼“å†²
            'expectedPeakHours': self.flow_patterns['peak_hours']
        }

        return recommendations

    def _calculate_optimal_slots(self, expected_volume: int) -> Dict[str, int]:
        """è®¡ç®—æœ€ä¼˜å·æºåˆ†é…"""
        # åŸºç¡€åˆ†é… + åŠ¨æ€è°ƒæ•´
        base_distribution = {
            'morning': int(expected_volume * 0.5),
            'afternoon': int(expected_volume * 0.4),
            'evening': int(expected_volume * 0.1)
        }
        return base_distribution

    def _calculate_staffing_needs(self, expected_volume: int) -> Dict[str, int]:
        """è®¡ç®—äººå‘˜éœ€æ±‚"""
        # æ ¹æ®é¢„æœŸæ‚£è€…é‡è®¡ç®—å„å²—ä½äººå‘˜éœ€æ±‚
        return {
            'doctors': max(5, int(expected_volume / 20)),  # æ¯ä½åŒ»ç”Ÿ20ä¸ªæ‚£è€…
            'nurses': max(3, int(expected_volume / 30)),
            'registration_staff': max(2, int(expected_volume / 50)),
            'pharmacy_staff': max(2, int(expected_volume / 40))
        }
```

### 2.2 ä½é™¢æ‚£è€…æµè½¬

**ä½é™¢æ‚£è€…æµè½¬æµç¨‹**ï¼š

```
å…¥é™¢ç”³è¯· â†’ åºŠä½åˆ†é… â†’ å…¥é™¢ç™»è®° â†’ åŒ»å˜±ç®¡ç† â†’ ä¸´åºŠæŠ¤ç† â†’ å‡ºé™¢è¯„ä¼° â†’ å‡ºé™¢ç»“ç®— â†’ å‡ºé™¢éšè®¿
```

```python
class InpatientFlowConverter:
    """ä½é™¢æ‚£è€…æµè½¬è½¬æ¢å™¨"""

    def __init__(self):
        self.admission_stages = [
            'admission_request', 'bed_assignment', 'admission_registration',
            'initial_assessment', 'care_planning', 'daily_care', 'discharge_planning',
            'discharge_assessment', 'discharge_process', 'follow_up'
        ]

    def convert_admission(self, admission_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        è½¬æ¢å…¥é™¢æµç¨‹

        Args:
            admission_request: å…¥é™¢ç”³è¯·æ•°æ®

        Returns:
            å…¥é™¢æµè½¬æ•°æ®
        """
        admission_data = {
            'admissionId': self._generate_admission_id(),
            'patientId': admission_request.get('patientId'),
            'mrn': admission_request.get('mrn'),
            'requestTime': datetime.now(),
            'expectedAdmissionDate': admission_request.get('expectedDate'),
            'admissionType': admission_request.get('type', 'elective'),
            'admissionSource': admission_request.get('source', 'outpatient'),
            'referringPhysician': admission_request.get('referringPhysician'),
            'admittingDepartment': admission_request.get('department'),
            'requestedBedType': admission_request.get('bedType', 'standard'),
            'diagnosis': admission_request.get('diagnosis'),
            'specialNeeds': admission_request.get('specialNeeds', []),
            'stages': {},
            'currentStage': 'admission_request',
            'status': 'active',
            'lengthOfStay': {
                'expected': admission_request.get('expectedLOS', 5),
                'actual': None
            },
            'bed': None,
            'careTeam': [],
            'dailyCharges': [],
            'totalCharges': 0
        }

        # åˆå§‹åŒ–å„é˜¶æ®µ
        for stage in self.admission_stages:
            admission_data['stages'][stage] = {
                'status': 'pending',
                'startTime': None,
                'endTime': None,
                'duration': None,
                'data': {}
            }

        # å…¥é™¢ç”³è¯·é˜¶æ®µå®Œæˆ
        admission_data['stages']['admission_request']['status'] = 'completed'
        admission_data['stages']['admission_request']['startTime'] = datetime.now()
        admission_data['stages']['admission_request']['endTime'] = datetime.now()

        return admission_data

    def assign_bed(self, admission_data: Dict[str, Any],
                   bed_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        åˆ†é…åºŠä½

        Args:
            admission_data: å…¥é™¢æ•°æ®
            bed_info: åºŠä½ä¿¡æ¯

        Returns:
            æ›´æ–°åçš„å…¥é™¢æ•°æ®
        """
        # æ›´æ–°åºŠä½ä¿¡æ¯
        admission_data['bed'] = {
            'bedId': bed_info.get('bedId'),
            'bedNumber': bed_info.get('bedNumber'),
            'ward': bed_info.get('ward'),
            'room': bed_info.get('room'),
            'bedType': bed_info.get('bedType'),
            'assignedAt': datetime.now(),
            'assignedBy': bed_info.get('assignedBy')
        }

        # æ›´æ–°é˜¶æ®µçŠ¶æ€
        self._complete_stage(admission_data, 'bed_assignment')
        self._start_stage(admission_data, 'admission_registration')

        return admission_data

    def complete_admission(self, admission_data: Dict[str, Any],
                          registration_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        å®Œæˆå…¥é™¢ç™»è®°

        Args:
            admission_data: å…¥é™¢æ•°æ®
            registration_data: ç™»è®°æ•°æ®

        Returns:
            æ›´æ–°åçš„å…¥é™¢æ•°æ®
        """
        # æ›´æ–°å…¥é™¢ä¿¡æ¯
        admission_data['actualAdmissionDate'] = datetime.now()
        admission_data['admissionRegistration'] = registration_data

        # å®Œæˆå…¥é™¢ç™»è®°é˜¶æ®µ
        self._complete_stage(admission_data, 'admission_registration')
        self._start_stage(admission_data, 'initial_assessment')

        return admission_data

    def plan_discharge(self, admission_data: Dict[str, Any],
                      discharge_plan: Dict[str, Any]) -> Dict[str, Any]:
        """
        åˆ¶å®šå‡ºé™¢è®¡åˆ’

        Args:
            admission_data: å…¥é™¢æ•°æ®
            discharge_plan: å‡ºé™¢è®¡åˆ’

        Returns:
            æ›´æ–°åçš„å…¥é™¢æ•°æ®
        """
        admission_data['dischargePlan'] = {
            'plannedDate': discharge_plan.get('plannedDate'),
            'disposition': discharge_plan.get('disposition', 'home'),
            'followUpRequired': discharge_plan.get('followUpRequired', False),
            'followUpAppointments': discharge_plan.get('followUpAppointments', []),
            'medications': discharge_plan.get('medications', []),
            'instructions': discharge_plan.get('instructions', ''),
            'homeCareNeeds': discharge_plan.get('homeCareNeeds', []),
            'equipmentNeeds': discharge_plan.get('equipmentNeeds', []),
            'createdAt': datetime.now(),
            'createdBy': discharge_plan.get('createdBy')
        }

        # å¼€å§‹å‡ºé™¢è®¡åˆ’é˜¶æ®µ
        self._start_stage(admission_data, 'discharge_planning')

        return admission_data

    def complete_discharge(self, admission_data: Dict[str, Any],
                          discharge_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        å®Œæˆå‡ºé™¢

        Args:
            admission_data: å…¥é™¢æ•°æ®
            discharge_data: å‡ºé™¢æ•°æ®

        Returns:
            æ›´æ–°åçš„å…¥é™¢æ•°æ®
        """
        # è®¡ç®—ä½é™¢æ—¶é•¿
        admission_date = admission_data.get('actualAdmissionDate')
        discharge_date = datetime.now()

        if admission_date:
            los_days = (discharge_date - admission_date).days
            los_hours = (discharge_date - admission_date).total_seconds() / 3600
            admission_data['lengthOfStay']['actual'] = {
                'days': los_days,
                'hours': los_hours
            }

        # æ›´æ–°å‡ºé™¢ä¿¡æ¯
        admission_data['discharge'] = {
            'dischargeDate': discharge_date,
            'dischargeDisposition': discharge_data.get('disposition'),
            'dischargeDiagnosis': discharge_data.get('diagnosis'),
            'dischargeCondition': discharge_data.get('condition'),
            'medications': discharge_data.get('medications', []),
            'followUpInstructions': discharge_data.get('followUpInstructions'),
            'dischargedBy': discharge_data.get('dischargedBy')
        }

        # å®Œæˆç›¸å…³é˜¶æ®µ
        self._complete_stage(admission_data, 'daily_care')
        self._complete_stage(admission_data, 'discharge_planning')
        self._complete_stage(admission_data, 'discharge_assessment')
        self._complete_stage(admission_data, 'discharge_process')

        admission_data['status'] = 'discharged'

        return admission_data

    def _complete_stage(self, admission_data: Dict[str, Any], stage: str):
        """å®Œæˆé˜¶æ®µ"""
        if stage in admission_data['stages']:
            stage_data = admission_data['stages'][stage]
            stage_data['status'] = 'completed'
            stage_data['endTime'] = datetime.now()
            if stage_data['startTime']:
                stage_data['duration'] = (
                    stage_data['endTime'] - stage_data['startTime']
                ).total_seconds() / 3600  # å°æ—¶

    def _start_stage(self, admission_data: Dict[str, Any], stage: str):
        """å¼€å§‹é˜¶æ®µ"""
        if stage in admission_data['stages']:
            stage_data = admission_data['stages'][stage]
            stage_data['status'] = 'active'
            stage_data['startTime'] = datetime.now()
            admission_data['currentStage'] = stage

    def _generate_admission_id(self) -> str:
        """ç”Ÿæˆå…¥é™¢ID"""
        import uuid
        timestamp = datetime.now().strftime("%Y%m%d")
        return f"ADM{timestamp}{uuid.uuid4().hex[:6].upper()}"
```

### 2.3 æ€¥è¯Šç»¿è‰²é€šé“

**æ€¥è¯Šç»¿è‰²é€šé“Schema**ï¼š

```dsl
schema EmergencyGreenChannel {
  resourceType: String @value("EmergencyGreenChannel") @required

  // æ‚£è€…ä¿¡æ¯
  patient: EmergencyPatient {
    patientId: String
    isUnknown: Boolean @default(false)
    tempId: String  // æ— åæ°ä¸´æ—¶ID
    estimatedAge: AgeRange
    estimatedGender: Enum { male, female, unknown }
    arrivedBy: Enum { ambulance, walk_in, transfer, police }
    ambulanceInfo: AmbulanceInfo {
      ambulanceId: String
      emsProvider: String
      cccReport: String
      vitalSignsEnRoute: List<VitalSign>
      interventions: List<String>
      eta: DateTime
    }
  }

  // åˆ†è¯Šä¿¡æ¯
  triage: EmergencyTriage {
    triageId: String @required
    triageTime: DateTime @required
    triageNurse: Practitioner @required

    // äº”çº§åˆ†è¯Š
    acuityLevel: Enum { resuscitation, emergent, urgent, less_urgent, non_urgent } @required
    chiefComplaint: String @required
    presentingProblem: String @required

    // ç”Ÿå‘½ä½“å¾
    vitalSigns: VitalSigns {
      temperature: Quantity
      heartRate: Quantity
      respiratoryRate: Quantity
      bloodPressure: BloodPressure
      spo2: Quantity
      painScore: Integer @min(0) @max(10)
      consciousness: Enum { alert, verbal, pain, unresponsive }
      glucose: Quantity
    }

    // ç»¿è‰²é€šé“æŒ‡å¾
    greenChannelIndicators: List<GreenChannelIndicator> {
      indicatorType: Enum {
        stemi, stroke, trauma, severe_trauma,
        pregnancy_emergency, pediatric_emergency,
        severe_sepsis, acute_respiratory_failure
      }
      activationTime: DateTime
      activatedBy: Practitioner
      targetResponseTime: Integer  // åˆ†é’Ÿ
    }

    // ç›®æ ‡å“åº”æ—¶é—´
    targetTime: TargetResponseTime {
      physicianAssessment: Integer  // STEMI: 10åˆ†é’Ÿ
      ecg: Integer                  // STEMI: 10åˆ†é’Ÿ
      labResults: Integer           // 60åˆ†é’Ÿ
      imaging: Integer              // 30åˆ†é’Ÿ
      intervention: Integer         // STEMI: 90åˆ†é’Ÿ (D2B)
    }
  }

  // ç»¿è‰²é€šé“æ‰§è¡Œ
  execution: GreenChannelExecution {
    status: Enum { activated, in_progress, completed, cancelled }
    activatedAt: DateTime
    activatedBy: Practitioner

    // æ—¶é—´èŠ‚ç‚¹
    milestones: List<Milestone> {
      milestoneType: Enum {
        door_time, triage_complete, physician_assessment,
        ecg_complete, lab_drawn, lab_reported,
        imaging_ordered, imaging_complete, imaging_reported,
        specialist_consult, intervention_start, intervention_complete,
        icu_admission, or_admission, ward_admission, discharge
      }
      scheduledTime: DateTime
      actualTime: DateTime
      variance: Integer  // åˆ†é’Ÿ
      responsiblePerson: Practitioner
    }

    // è´¨é‡æ§åˆ¶
    qualityMetrics: QualityMetrics {
      doorToDoctor: Duration
      doorToEcg: Duration
      doorToNeedle: Duration  // æº¶æ “
      doorToBalloon: Duration  // PCI
      doorToCT: Duration  // å’ä¸­
      doorToDrug: Duration  // å’ä¸­æº¶æ “
    }

    // å›¢é˜Ÿæ¿€æ´»
    teamActivation: TeamActivation {
      teamType: Enum { code_stroke, code_stemi, trauma_team, sepsis_team }
      activatedAt: DateTime
      teamMembers: List<Practitioner>
      teamLeader: Practitioner
      responseTime: Duration
    }
  }

  // æ‚£è€…å»å‘
  disposition: EmergencyDisposition {
    dispositionType: Enum {
      discharge, admit_ward, admit_icu, admit_or,
      transfer, expired, left_ama, eloped
    }
    dispositionTime: DateTime
    dispositionLocation: Location

    // ä½é™¢ä¿¡æ¯
    admission: EmergencyAdmission {
      admissionId: String
      admittingService: String
      admittingPhysician: Practitioner
      bedAssigned: Bed
    }

    // è½¬é™¢ä¿¡æ¯
    transfer: EmergencyTransfer {
      transferReason: String
      receivingFacility: String
      transportMode: Enum { ambulance, helicopter, fixed_wing }
      handoffComplete: Boolean
    }
  }
}
```

---

## 3. èµ„æºä¼˜åŒ–è½¬æ¢

### 3.1 åºŠä½èµ„æºä¼˜åŒ–

**åºŠä½ä¼˜åŒ–ç®—æ³•**ï¼š

```python
import numpy as np
from typing import List, Dict, Tuple
from datetime import datetime, timedelta

class BedResourceOptimizer:
    """åºŠä½èµ„æºä¼˜åŒ–å™¨"""

    def __init__(self, bed_inventory: List[Dict], historical_occupancy: List[Dict]):
        self.bed_inventory = bed_inventory
        self.historical_occupancy = historical_occupancy
        self.optimization_model = self._build_optimization_model()

    def optimize_bed_allocation(self, forecast_demand: Dict[str, int],
                               constraints: Dict[str, Any]) -> Dict[str, Any]:
        """
        ä¼˜åŒ–åºŠä½åˆ†é…

        Args:
            forecast_demand: é¢„æµ‹éœ€æ±‚ {ward_type: predicted_demand}
            constraints: çº¦æŸæ¡ä»¶

        Returns:
            ä¼˜åŒ–æ–¹æ¡ˆ
        """
        # åˆ†æå½“å‰åºŠä½çŠ¶æ€
        current_status = self._analyze_current_status()

        # è®¡ç®—åºŠä½ç¼ºå£
        bed_gaps = self._calculate_bed_gaps(forecast_demand, current_status)

        # ç”Ÿæˆä¼˜åŒ–ç­–ç•¥
        optimization_plan = {
            'currentUtilization': current_status['utilization'],
            'forecastDemand': forecast_demand,
            'bedGaps': bed_gaps,
            'recommendations': self._generate_bed_recommendations(bed_gaps),
            'flexibleBedPlan': self._create_flexible_bed_plan(forecast_demand),
            'staffingRecommendations': self._calculate_staffing_needs(forecast_demand),
            'expectedOutcomes': {
                'projectedUtilization': None,
                'projectedWaitTime': None,
                'projectedTurnAwayRate': None
            }
        }

        return optimization_plan

    def _analyze_current_status(self) -> Dict[str, Any]:
        """åˆ†æå½“å‰åºŠä½çŠ¶æ€"""
        total_beds = len(self.bed_inventory)
        occupied_beds = sum(1 for b in self.bed_inventory if b.get('status') == 'occupied')
        available_beds = total_beds - occupied_beds

        return {
            'totalBeds': total_beds,
            'occupiedBeds': occupied_beds,
            'availableBeds': available_beds,
            'utilization': occupied_beds / total_beds if total_beds > 0 else 0,
            'byWard': self._group_by_ward()
        }

    def _group_by_ward(self) -> Dict[str, Dict[str, int]]:
        """æŒ‰ç—…åŒºåˆ†ç»„ç»Ÿè®¡"""
        ward_stats = {}
        for bed in self.bed_inventory:
            ward = bed.get('ward', 'unknown')
            if ward not in ward_stats:
                ward_stats[ward] = {'total': 0, 'occupied': 0, 'available': 0}

            ward_stats[ward]['total'] += 1
            if bed.get('status') == 'occupied':
                ward_stats[ward]['occupied'] += 1
            else:
                ward_stats[ward]['available'] += 1

        return ward_stats

    def _calculate_bed_gaps(self, forecast_demand: Dict[str, int],
                           current_status: Dict[str, Any]) -> Dict[str, int]:
        """è®¡ç®—åºŠä½ç¼ºå£"""
        gaps = {}
        for ward_type, demand in forecast_demand.items():
            current_available = current_status['byWard'].get(ward_type, {}).get('available', 0)
            gap = demand - current_available
            gaps[ward_type] = max(0, gap)
        return gaps

    def _generate_bed_recommendations(self, bed_gaps: Dict[str, int]) -> List[Dict[str, Any]]:
        """ç”ŸæˆåºŠä½ä¼˜åŒ–å»ºè®®"""
        recommendations = []

        for ward_type, gap in bed_gaps.items():
            if gap > 0:
                recommendations.append({
                    'type': 'capacity_expansion',
                    'wardType': ward_type,
                    'recommendedBeds': gap,
                    'priority': 'high' if gap > 5 else 'medium',
                    'timeline': 'immediate' if gap > 10 else 'short_term',
                    'estimatedCost': gap * 50000  // æ¯åºŠä½5ä¸‡å…ƒä¼°ç®—
                })

        # æ·»åŠ æ•ˆç‡æå‡å»ºè®®
        recommendations.append({
            'type': 'efficiency_improvement',
            'description': 'ä¼˜åŒ–å‡ºé™¢æµç¨‹ï¼Œç¼©çŸ­å¹³å‡ä½é™¢æ—¥',
            'potentialBedDays': 50,
            'implementationEffort': 'medium'
        })

        recommendations.append({
            'type': 'flexible_beds',
            'description': 'å»ºç«‹å¼¹æ€§åºŠä½æ± ï¼Œåº”å¯¹éœ€æ±‚æ³¢åŠ¨',
            'flexibleBedCount': 10,
            'targetWards': ['general', 'observation']
        })

        return recommendations

    def _create_flexible_bed_plan(self, forecast_demand: Dict[str, int]) -> Dict[str, Any]:
        """åˆ›å»ºå¼¹æ€§åºŠä½è®¡åˆ’"""
        return {
            'flexibleBedPool': {
                'totalBeds': 10,
                'allocationStrategy': 'dynamic',
                'triggerThreshold': 0.9,  // åˆ©ç”¨ç‡è¶…90%æ—¶æ¿€æ´»
                'releaseThreshold': 0.7   // åˆ©ç”¨ç‡ä½äº70%æ—¶é‡Šæ”¾
            },
            'surgeCapacity': {
                'maxSurgeBeds': 20,
                'activationCriteria': 'disaster_or_epidemic',
                'staffingPlan': 'on_call_activation'
            }
        }

    def predict_discharge_readiness(self, current_inpatients: List[Dict]) -> List[Dict]:
        """
        é¢„æµ‹å‡ºé™¢å‡†å¤‡åº¦

        Args:
            current_inpatients: å½“å‰ä½é™¢æ‚£è€…åˆ—è¡¨

        Returns:
            å‡ºé™¢é¢„æµ‹åˆ—è¡¨
        """
        predictions = []

        for patient in current_inpatients:
            # åŸºäºä¸´åºŠæŒ‡æ ‡é¢„æµ‹å‡ºé™¢æ—¶é—´
            predicted_los = self._predict_length_of_stay(patient)
            days_remaining = predicted_los - patient.get('currentLOS', 0)

            predictions.append({
                'patientId': patient.get('patientId'),
                'admissionId': patient.get('admissionId'),
                'currentLOS': patient.get('currentLOS'),
                'predictedTotalLOS': predicted_los,
                'predictedDischargeDate': datetime.now() + timedelta(days=days_remaining),
                'dischargeReadiness': self._assess_discharge_readiness(patient),
                'dischargeBarriers': self._identify_discharge_barriers(patient),
                'confidence': 0.8
            })

        return sorted(predictions, key=lambda x: x['predictedDischargeDate'])

    def _predict_length_of_stay(self, patient: Dict) -> float:
        """é¢„æµ‹ä½é™¢æ—¶é•¿"""
        # åŸºäºè¯Šæ–­ã€å¹´é¾„ã€åˆå¹¶ç—‡ç­‰å› ç´ é¢„æµ‹
        base_los = self._get_typical_los_for_diagnosis(patient.get('primaryDiagnosis'))

        # è°ƒæ•´å› ç´ 
        age_factor = 1.0
        if patient.get('age', 50) > 75:
            age_factor = 1.3
        elif patient.get('age', 50) < 18:
            age_factor = 0.9

        comorbidity_factor = 1 + (len(patient.get('comorbidities', [])) * 0.1)

        return base_los * age_factor * comorbidity_factor

    def _get_typical_los_for_diagnosis(self, diagnosis: str) -> float:
        """è·å–è¯Šæ–­çš„å…¸å‹ä½é™¢æ—¶é•¿"""
        typical_los = {
            'pneumonia': 5.5,
            'heart_failure': 4.2,
            'copd': 4.8,
            'mi': 3.5,
            'stroke': 6.2,
            'fracture': 4.0,
            'appendectomy': 2.5,
            'cholecystectomy': 3.0
        }
        return typical_los.get(diagnosis.lower(), 4.0)

    def _assess_discharge_readiness(self, patient: Dict) -> str:
        """è¯„ä¼°å‡ºé™¢å‡†å¤‡åº¦"""
        # åŸºäºä¸´åºŠæŒ‡æ ‡è¯„ä¼°
        clinical_stability = patient.get('clinicalStability', 'unstable')
        discharge_plan_complete = patient.get('dischargePlanComplete', False)

        if clinical_stability == 'stable' and discharge_plan_complete:
            return 'ready'
        elif clinical_stability == 'stable':
            return 'likely_ready_24h'
        else:
            return 'not_ready'

    def _identify_discharge_barriers(self, patient: Dict) -> List[str]:
        """è¯†åˆ«å‡ºé™¢éšœç¢"""
        barriers = []

        if not patient.get('dischargeDisposition'):
            barriers.append('æœªç¡®å®šå‡ºé™¢å»å‘')

        if patient.get('pendingTests', []):
            barriers.append('æœ‰æœªå®Œæˆæ£€æŸ¥')

        if patient.get('needsHomeCare') and not patient.get('homeCareArranged'):
            barriers.append('å®¶åº­æŠ¤ç†æœªå®‰æ’')

        if patient.get('needsEquipment') and not patient.get('equipmentArranged'):
            barriers.append('å‡ºé™¢è®¾å¤‡æœªå®‰æ’')

        return barriers
```

### 3.2 æ‰‹æœ¯å®¤èµ„æºä¼˜åŒ–

```python
class ORResourceOptimizer:
    """æ‰‹æœ¯å®¤èµ„æºä¼˜åŒ–å™¨"""

    def __init__(self, or_rooms: List[Dict], surgery_schedules: List[Dict]):
        self.or_rooms = or_rooms
        self.surgery_schedules = surgery_schedules

    def optimize_or_schedule(self, surgery_requests: List[Dict],
                            date_range: Tuple[datetime, datetime]) -> Dict[str, Any]:
        """
        ä¼˜åŒ–æ‰‹æœ¯å®¤æ’ç¨‹

        Args:
            surgery_requests: æ‰‹æœ¯ç”³è¯·åˆ—è¡¨
            date_range: æ—¥æœŸèŒƒå›´

        Returns:
            ä¼˜åŒ–åçš„æ’ç¨‹æ–¹æ¡ˆ
        """
        # æŒ‰ä¼˜å…ˆçº§å’Œç´§æ€¥ç¨‹åº¦æ’åº
        sorted_requests = self._prioritize_surgeries(surgery_requests)

        # åˆ†é…æ‰‹æœ¯å®¤å’Œæ—¶é—´
        schedule = self._assign_or_slots(sorted_requests, date_range)

        # è®¡ç®—æ•ˆç‡æŒ‡æ ‡
        efficiency_metrics = self._calculate_efficiency(schedule)

        return {
            'schedule': schedule,
            'efficiencyMetrics': efficiency_metrics,
            'unscheduledCases': self._identify_unscheduled(sorted_requests, schedule),
            'optimizationSuggestions': self._generate_or_suggestions(efficiency_metrics)
        }

    def _prioritize_surgeries(self, requests: List[Dict]) -> List[Dict]:
        """æ‰‹æœ¯ä¼˜å…ˆçº§æ’åº"""
        priority_order = {
            'emergent': 1,
            'urgent': 2,
            'elective': 3
        }

        return sorted(requests, key=lambda x: (
            priority_order.get(x.get('priority', 'elective'), 3),
            x.get('requestedDate', datetime.max)
        ))

    def _assign_or_slots(self, requests: List[Dict],
                        date_range: Tuple[datetime, datetime]) -> List[Dict]:
        """åˆ†é…æ‰‹æœ¯å®¤æ—¶æ®µ"""
        schedule = []
        or_availability = self._initialize_or_availability(date_range)

        for request in requests:
            assigned = False

            # æŸ¥æ‰¾å¯ç”¨æ—¶æ®µ
            for date in self._date_range(date_range[0], date_range[1]):
                if assigned:
                    break

                for or_room in self.or_rooms:
                    if self._can_accommodate(or_room, request, or_availability, date):
                        slot = self._create_slot(or_room, request, date)
                        schedule.append(slot)
                        self._update_availability(or_availability, slot)
                        assigned = True
                        break

            if not assigned:
                request['unscheduled'] = True

        return schedule

    def _calculate_efficiency(self, schedule: List[Dict]) -> Dict[str, float]:
        """è®¡ç®—æ•ˆç‡æŒ‡æ ‡"""
        total_scheduled_time = sum(
            s.get('estimatedDuration', 0) + s.get('turnover', 30)
            for s in schedule
        )

        available_time = len(self.or_rooms) * 8 * 60  // 8å°æ—¶/å¤©

        return {
            'roomUtilization': total_scheduled_time / available_time if available_time > 0 else 0,
            'firstCaseOnTime': 0.85,  // é¦–å°å‡†æ—¶ç‡
            'turnoverTime': 28,  // å¹³å‡å‘¨è½¬æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
            'addOnRate': 0.15,  // åŠ å°ç‡
            'cancellationRate': 0.05  // å–æ¶ˆç‡
        }

    def predict_surgery_duration(self, surgery_type: str,
                                 patient_factors: Dict) -> Dict[str, float]:
        """
        é¢„æµ‹æ‰‹æœ¯æ—¶é•¿

        Args:
            surgery_type: æ‰‹æœ¯ç±»å‹
            patient_factors: æ‚£è€…å› ç´ 

        Returns:
            æ—¶é•¿é¢„æµ‹
        """
        # åŸºäºå†å²æ•°æ®å’Œæ‚£è€…å› ç´ é¢„æµ‹
        base_duration = self._get_base_duration(surgery_type)

        # è°ƒæ•´å› ç´ 
        bmi_factor = 1.0
        if patient_factors.get('bmi', 25) > 35:
            bmi_factor = 1.2

        age_factor = 1.0
        if patient_factors.get('age', 50) > 75:
            age_factor = 1.1

        asa_factor = 1.0 + (patient_factors.get('asa', 2) - 2) * 0.1

        adjusted_duration = base_duration * bmi_factor * age_factor * asa_factor

        return {
            'predictedDuration': adjusted_duration,
            'confidenceInterval': (adjusted_duration * 0.8, adjusted_duration * 1.2),
            'confidence': 0.85
        }
```

### 3.3 äººåŠ›èµ„æºä¼˜åŒ–

```python
class StaffingOptimizer:
    """äººåŠ›èµ„æºä¼˜åŒ–å™¨"""

    def __init__(self, staff_pool: List[Dict], demand_forecast: Dict):
        self.staff_pool = staff_pool
        self.demand_forecast = demand_forecast

    def optimize_staffing(self, department: str,
                         date: datetime) -> Dict[str, Any]:
        """
        ä¼˜åŒ–æ’ç­äººå‘˜é…ç½®

        Args:
            department: ç§‘å®¤
            date: æ—¥æœŸ

        Returns:
            ä¼˜åŒ–æ–¹æ¡ˆ
        """
        # é¢„æµ‹éœ€æ±‚é‡
        predicted_demand = self.demand_forecast.get(department, {}).get(date, {})

        # è®¡ç®—äººå‘˜éœ€æ±‚
        staffing_requirements = self._calculate_requirements(
            department, predicted_demand
        )

        # åŒ¹é…å¯ç”¨äººå‘˜
        available_staff = self._get_available_staff(department, date)

        # ç”Ÿæˆæ’ç­æ–¹æ¡ˆ
        schedule = self._generate_optimal_schedule(
            staffing_requirements, available_staff
        )

        return {
            'date': date,
            'department': department,
            'predictedDemand': predicted_demand,
            'staffingRequirements': staffing_requirements,
            'proposedSchedule': schedule,
            'coverageAnalysis': self._analyze_coverage(schedule, staffing_requirements),
            'costEstimate': self._estimate_cost(schedule)
        }

    def _calculate_requirements(self, department: str,
                               predicted_demand: Dict) -> Dict[str, int]:
        """è®¡ç®—äººå‘˜éœ€æ±‚"""
        # åŸºäºæ‚£è€…é‡å’Œå¤æ‚åº¦è®¡ç®—
        patient_count = predicted_demand.get('patientCount', 0)
        acuity_level = predicted_demand.get('averageAcuity', 1)

        # æŠ¤å£«é…æ¯”è®¡ç®—ï¼ˆåŸºäºæ‚£è€…ä¸¥é‡ç¨‹åº¦å’Œæ•°é‡ï¼‰
        if department in ['ICU', 'CCU']:
            nurse_ratio = 1  // 1:1æˆ–1:2
            nurses_needed = max(4, int(patient_count * 0.6))
        elif department in ['ER']:
            nurse_ratio = 4
            nurses_needed = max(6, int(patient_count / nurse_ratio))
        else:
            nurse_ratio = 6
            nurses_needed = max(3, int(patient_count / nurse_ratio * acuity_level))

        return {
            'nurses': nurses_needed,
            'doctors': max(2, int(nurses_needed / 3)),
            'technicians': max(1, int(nurses_needed / 4)),
            'supportStaff': max(1, int(nurses_needed / 5))
        }
```

---

## 4. è·¨ç³»ç»Ÿæ•°æ®äº¤æ¢

### 4.1 HISä¸EMRé›†æˆ

**HIS-EMRé›†æˆæ¶æ„**ï¼š

```python
class HISEMRIntegration:
    """HISä¸EMRç³»ç»Ÿé›†æˆ"""

    def __init__(self, his_connector, emr_connector):
        self.his = his_connector
        self.emr = emr_connector
        self.sync_mapping = self._load_sync_mapping()

    def sync_patient_data(self, patient_id: str, sync_type: str = 'bidirectional') -> bool:
        """
        åŒæ­¥æ‚£è€…æ•°æ®

        Args:
            patient_id: æ‚£è€…ID
            sync_type: åŒæ­¥ç±»å‹ (his_to_emr, emr_to_his, bidirectional)

        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        try:
            if sync_type in ['his_to_emr', 'bidirectional']:
                # ä»HISè·å–æ‚£è€…åŸºç¡€ä¿¡æ¯
                his_patient = self.his.get_patient(patient_id)
                # è½¬æ¢å¹¶æ›´æ–°åˆ°EMR
                emr_patient = self._convert_his_to_emr_patient(his_patient)
                self.emr.update_patient(emr_patient)

            if sync_type in ['emr_to_his', 'bidirectional']:
                # ä»EMRè·å–ä¸´åºŠä¿¡æ¯
                emr_clinical = self.emr.get_clinical_data(patient_id)
                # æ›´æ–°åˆ°HIS
                his_updates = self._convert_emr_to_his_clinical(emr_clinical)
                self.his.update_patient_clinical(patient_id, his_updates)

            return True
        except Exception as e:
            logger.error(f"Patient sync failed: {e}")
            return False

    def sync_admission_data(self, admission_id: str) -> bool:
        """åŒæ­¥å…¥é™¢æ•°æ®"""
        try:
            # ä»HISè·å–å…¥é™¢ä¿¡æ¯
            his_admission = self.his.get_admission(admission_id)

            # è½¬æ¢å¹¶åˆ›å»ºEMRå…¥é™¢è®°å½•
            emr_encounter = self._convert_his_admission_to_emr(his_admission)
            self.emr.create_encounter(emr_encounter)

            # åŒæ­¥åºŠä½ä¿¡æ¯
            bed_info = his_admission.get('bed')
            if bed_info:
                self.emr.update_patient_location(
                    his_admission['patientId'],
                    bed_info
                )

            return True
        except Exception as e:
            logger.error(f"Admission sync failed: {e}")
            return False

    def sync_financial_data(self, encounter_id: str) -> bool:
        """åŒæ­¥è´¢åŠ¡æ•°æ®"""
        try:
            # ä»HISè·å–æ”¶è´¹ä¿¡æ¯
            charges = self.his.get_encounter_charges(encounter_id)

            # è½¬æ¢å¹¶æ›´æ–°åˆ°EMRï¼ˆç”¨äºä¸´åºŠæˆæœ¬åˆ†æï¼‰
            emr_charges = self._convert_his_charges_to_emr(charges)
            self.emr.add_encounter_charges(encounter_id, emr_charges)

            return True
        except Exception as e:
            logger.error(f"Financial sync failed: {e}")
            return False

    def _convert_his_to_emr_patient(self, his_patient: Dict) -> Dict:
        """è½¬æ¢HISæ‚£è€…æ•°æ®åˆ°EMRæ ¼å¼"""
        return {
            'resourceType': 'Patient',
            'id': his_patient.get('patientId'),
            'identifier': [{
                'system': 'http://hospital.org/mrn',
                'value': his_patient.get('mrn')
            }],
            'name': [{
                'family': his_patient.get('lastName'),
                'given': [his_patient.get('firstName')]
            }],
            'gender': his_patient.get('gender'),
            'birthDate': his_patient.get('birthDate'),
            'address': self._convert_address(his_patient.get('address')),
            'telecom': self._convert_telecom(his_patient.get('contact'))
        }
```

### 4.2 ä¸åŒºåŸŸå¹³å°å¯¹æ¥

```python
class RegionalPlatformIntegration:
    """åŒºåŸŸå«ç”Ÿä¿¡æ¯å¹³å°é›†æˆ"""

    def __init__(self, platform_config: Dict[str, str]):
        self.platform_url = platform_config.get('url')
        self.api_key = platform_config.get('api_key')
        self.headers = {
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        }

    def upload_patient_summary(self, patient_id: str) -> bool:
        """
        ä¸Šä¼ æ‚£è€…ç—…å†æ‘˜è¦åˆ°åŒºåŸŸå¹³å°

        Args:
            patient_id: æ‚£è€…ID

        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        try:
            # è·å–æ‚£è€…æ‘˜è¦
            summary = self._generate_patient_summary(patient_id)

            # è½¬æ¢ä¸ºåŒºåŸŸå¹³å°æ ‡å‡†æ ¼å¼
            platform_format = self._convert_to_platform_format(summary)

            # ä¸Šä¼ 
            response = requests.post(
                f"{self.platform_url}/api/v1/patient/summary",
                headers=self.headers,
                json=platform_format
            )

            return response.status_code == 200
        except Exception as e:
            logger.error(f"Upload to regional platform failed: {e}")
            return False

    def query_regional_records(self, patient_id: str,
                               id_type: str = 'id_card') -> List[Dict]:
        """
        æŸ¥è¯¢æ‚£è€…åœ¨åŒºåŸŸå¹³å°çš„è®°å½•

        Args:
            patient_id: æ‚£è€…æ ‡è¯†
            id_type: æ ‡è¯†ç±»å‹

        Returns:
            åŒºåŸŸåŒ»ç–—è®°å½•åˆ—è¡¨
        """
        try:
            response = requests.get(
                f"{self.platform_url}/api/v1/patient/records",
                headers=self.headers,
                params={
                    'patientId': patient_id,
                    'idType': id_type
                }
            )

            if response.status_code == 200:
                records = response.json()
                # è½¬æ¢ä¸ºæœ¬åœ°æ ¼å¼
                return [self._convert_from_platform_format(r) for r in records]

            return []
        except Exception as e:
            logger.error(f"Query regional records failed: {e}")
            return []
```

---

## 5. ä¸šåŠ¡æµç¨‹ä¼˜åŒ–

**ä¸šåŠ¡æµç¨‹ä¼˜åŒ–æ¡†æ¶**ï¼š

```python
class BusinessProcessOptimizer:
    """ä¸šåŠ¡æµç¨‹ä¼˜åŒ–å™¨"""

    def analyze_process(self, process_name: str,
                       process_data: List[Dict]) -> Dict[str, Any]:
        """
        åˆ†æä¸šåŠ¡æµç¨‹

        Args:
            process_name: æµç¨‹åç§°
            process_data: æµç¨‹æ‰§è¡Œæ•°æ®

        Returns:
            åˆ†ææŠ¥å‘Š
        """
        analysis = {
            'processName': process_name,
            'analysisDate': datetime.now(),
            'totalExecutions': len(process_data),
            'averageDuration': self._calculate_average_duration(process_data),
            'bottlenecks': self._identify_bottlenecks(process_data),
            'variability': self._calculate_variability(process_data),
            'defects': self._identify_defects(process_data),
            'recommendations': []
        }

        # ç”Ÿæˆä¼˜åŒ–å»ºè®®
        analysis['recommendations'] = self._generate_recommendations(analysis)

        return analysis

    def optimize_registration_process(self) -> Dict[str, Any]:
        """ä¼˜åŒ–æŒ‚å·æµç¨‹"""
        return {
            'currentSteps': 8,
            'optimizedSteps': 4,
            'improvements': [
                'å¼•å…¥è‡ªåŠ©æŒ‚å·æœºï¼Œå‡å°‘æ’é˜Ÿ',
                'æ¨å¹¿ç§»åŠ¨æ”¯ä»˜ï¼Œå‡å°‘ç°é‡‘çª—å£',
                'å®æ–½é¢„çº¦ä¼˜å…ˆåˆ¶ï¼Œé”™å³°å°±è¯Š',
                'è¯Šé—´ç»“ç®—ï¼Œå‡å°‘äºŒæ¬¡æ’é˜Ÿ'
            ],
            'expectedBenefits': {
                'waitTimeReduction': '40%',
                'patientSatisfactionIncrease': '25%',
                'staffEfficiencyImprovement': '30%'
            }
        }
```

---

## 6. æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–

**ç³»ç»Ÿæ€§èƒ½ç›‘æ§**ï¼š

```python
class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""

    def __init__(self):
        self.metrics = {}

    def record_metric(self, metric_name: str, value: float,
                     tags: Dict[str, str] = None):
        """è®°å½•æŒ‡æ ‡"""
        if metric_name not in self.metrics:
            self.metrics[metric_name] = []

        self.metrics[metric_name].append({
            'timestamp': datetime.now(),
            'value': value,
            'tags': tags or {}
        })

    def get_performance_dashboard(self) -> Dict[str, Any]:
        """è·å–æ€§èƒ½ä»ªè¡¨æ¿æ•°æ®"""
        return {
            'systemMetrics': {
                'responseTime': self._get_avg_response_time(),
                'throughput': self._get_throughput(),
                'errorRate': self._get_error_rate(),
                'availability': self._get_availability()
            },
            'businessMetrics': {
                'patientFlow': self._get_patient_flow_metrics(),
                'resourceUtilization': self._get_resource_utilization(),
                'serviceLevel': self._get_service_level_metrics()
            }
        }
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡

**åˆ›å»ºæ—¶é—´**ï¼š2025-02-15
**æœ€åæ›´æ–°**ï¼š2025-02-15

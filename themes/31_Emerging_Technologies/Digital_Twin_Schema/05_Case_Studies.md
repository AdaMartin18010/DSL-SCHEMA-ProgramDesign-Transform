# æ•°å­—å­ªç”ŸSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [æ•°å­—å­ªç”ŸSchemaå®è·µæ¡ˆä¾‹](#æ•°å­—å­ªç”Ÿschemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šæ™ºèƒ½åˆ¶é€ æ•°å­—å­ªç”Ÿ](#2-æ¡ˆä¾‹1æ™ºèƒ½åˆ¶é€ æ•°å­—å­ªç”Ÿ)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 å®Œæ•´ä»£ç å®ç°](#25-å®Œæ•´ä»£ç å®ç°)
    - [2.6 æ•ˆæœè¯„ä¼°ä¸ROI](#26-æ•ˆæœè¯„ä¼°ä¸roi)
  - [3. æ¡ˆä¾‹2ï¼šæ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿ](#3-æ¡ˆä¾‹2æ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿ)
    - [3.1 ä¼ä¸šèƒŒæ™¯](#31-ä¼ä¸šèƒŒæ™¯)
    - [3.2 ä¸šåŠ¡ç—›ç‚¹](#32-ä¸šåŠ¡ç—›ç‚¹)
    - [3.3 ä¸šåŠ¡ç›®æ ‡](#33-ä¸šåŠ¡ç›®æ ‡)
    - [3.4 æŠ€æœ¯æŒ‘æˆ˜](#34-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.5 å®Œæ•´ä»£ç å®ç°](#35-å®Œæ•´ä»£ç å®ç°)
    - [3.6 æ•ˆæœè¯„ä¼°ä¸ROI](#36-æ•ˆæœè¯„ä¼°ä¸roi)
  - [4. æ¡ˆä¾‹3ï¼šæ™ºèƒ½å»ºç­‘æ•°å­—å­ªç”Ÿ](#4-æ¡ˆä¾‹3æ™ºèƒ½å»ºç­‘æ•°å­—å­ªç”Ÿ)
  - [5. æ¡ˆä¾‹æ€»ç»“](#5-æ¡ˆä¾‹æ€»ç»“)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›**æ•°å­—å­ªç”ŸSchemaçš„å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼Œæ¶µç›–æ™ºèƒ½åˆ¶é€ ã€æ™ºæ…§åŸå¸‚ã€æ™ºèƒ½å»ºç­‘ç­‰é¢†åŸŸã€‚æ•°å­—å­ªç”ŸæŠ€æœ¯é€šè¿‡åˆ›å»ºç‰©ç†å®ä½“çš„è™šæ‹Ÿæ˜ å°„ï¼Œå®ç°å®æ—¶ç›‘æ§ã€é¢„æµ‹åˆ†æå’Œä¼˜åŒ–å†³ç­–ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

- æ™ºèƒ½åˆ¶é€ æ•°å­—å­ªç”Ÿ
- æ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿ
- æ™ºèƒ½å»ºç­‘æ•°å­—å­ªç”Ÿ

---

## 2. æ¡ˆä¾‹1ï¼šæ™ºèƒ½åˆ¶é€ æ•°å­—å­ªç”Ÿ

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå…¨çƒé¢†å…ˆçš„æ±½è½¦é›¶éƒ¨ä»¶åˆ¶é€ å•†ï¼ˆä»¥ä¸‹ç®€ç§°"AutoParts Inc."ï¼‰æˆç«‹äº1998å¹´ï¼Œæ€»éƒ¨ä½äºå¾·å›½æ–¯å›¾åŠ ç‰¹ï¼Œåœ¨å…¨çƒæ‹¥æœ‰28ä¸ªç”Ÿäº§åŸºåœ°ï¼Œå¹´è¥æ”¶è¶…è¿‡120äº¿æ¬§å…ƒã€‚å…¬å¸ä¸»è¦ç”Ÿäº§å‘åŠ¨æœºé›¶éƒ¨ä»¶ã€åº•ç›˜ç³»ç»Ÿå’Œç”µå­æ§åˆ¶å•å…ƒï¼Œä¸ºå®é©¬ã€å¥”é©°ã€å¥¥è¿ªç­‰é¡¶çº§æ±½è½¦å“ç‰Œæä¾›é…å¥—äº§å“ã€‚

å…¬å¸ä½äºä¸­å›½è‹å·çš„æ™ºèƒ½åˆ¶é€ å·¥å‚å åœ°é¢ç§¯50ä¸‡å¹³æ–¹ç±³ï¼Œæ‹¥æœ‰12æ¡è‡ªåŠ¨åŒ–ç”Ÿäº§çº¿ï¼Œ500+å°CNCæ•°æ§æœºåºŠï¼Œ100+å°å·¥ä¸šæœºå™¨äººã€‚å·¥å‚æ¯å¤©äº§ç”Ÿè¶…è¿‡50GBçš„ç”Ÿäº§æ•°æ®ï¼ŒåŒ…æ‹¬è®¾å¤‡ä¼ æ„Ÿå™¨æ•°æ®ã€è´¨é‡æ£€æµ‹æ•°æ®ã€ç¯å¢ƒç›‘æ§æ•°æ®ç­‰ã€‚éšç€å·¥ä¸š4.0æˆ˜ç•¥çš„æ¨è¿›ï¼Œå…¬å¸å†³å®šå»ºè®¾æ•°å­—å­ªç”Ÿå¹³å°ï¼Œå®ç°ç”Ÿäº§è¿‡ç¨‹çš„å…¨é¢æ•°å­—åŒ–æ˜ å°„ã€‚

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **è®¾å¤‡æ•…éšœå¯¼è‡´è®¡åˆ’å¤–åœæœº**ï¼šå…³é”®ç”Ÿäº§è®¾å¤‡ç¼ºä¹é¢„æµ‹æ€§ç»´æŠ¤èƒ½åŠ›ï¼Œå¹´å‡è®¡åˆ’å¤–åœæœºæ—¶é—´è¾¾åˆ°450å°æ—¶ï¼Œé€ æˆç›´æ¥ç»æµæŸå¤±çº¦2800ä¸‡å…ƒã€‚

2. **äº§å“è´¨é‡é—®é¢˜è¿½æº¯å›°éš¾**ï¼šå½“å‡ºç°è´¨é‡é—®é¢˜æ—¶ï¼Œéš¾ä»¥å¿«é€Ÿè¿½æº¯ç”Ÿäº§è¿‡ç¨‹ä¸­çš„å…³é”®å‚æ•°å’Œç¯å¢ƒæ¡ä»¶ï¼Œå¹³å‡è´¨é‡è°ƒæŸ¥æ—¶é—´éœ€è¦3-5å¤©ã€‚

3. **ç”Ÿäº§è¿‡ç¨‹é€æ˜åº¦ä¸è¶³**ï¼šç®¡ç†å±‚æ— æ³•å®æ—¶äº†è§£ç”Ÿäº§çº¿çŠ¶æ€ï¼Œå†³ç­–ä¾èµ–äº‹åæŠ¥å‘Šï¼Œå“åº”æ»åï¼Œå½±å“æ•´ä½“è¿è¥æ•ˆç‡ã€‚

4. **å·¥è‰ºä¼˜åŒ–ç¼ºä¹æ•°æ®æ”¯æ’‘**ï¼šå·¥è‰ºå‚æ•°ä¼˜åŒ–ä¸»è¦ä¾èµ–å·¥ç¨‹å¸ˆç»éªŒï¼Œç¼ºä¹æ•°æ®é©±åŠ¨çš„ç§‘å­¦æ–¹æ³•ï¼Œä¼˜åŒ–å‘¨æœŸé•¿ï¼Œæ•ˆæœéš¾ä»¥é‡åŒ–ã€‚

5. **è·¨å·¥å‚çŸ¥è¯†éš¾ä»¥å…±äº«**ï¼šå„å·¥å‚ç‹¬ç«‹è¿è¥ï¼Œæœ€ä½³å®è·µéš¾ä»¥å¿«é€Ÿå¤åˆ¶ï¼Œæ–°å·¥å‚äº§èƒ½çˆ¬å¡æ—¶é—´é•¿è¾¾12-18ä¸ªæœˆã€‚

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **å®ç°é¢„æµ‹æ€§ç»´æŠ¤**ï¼šæ„å»ºè®¾å¤‡æ•°å­—å­ªç”Ÿæ¨¡å‹ï¼Œæå‰7-14å¤©é¢„æµ‹è®¾å¤‡æ•…éšœï¼Œå°†è®¡åˆ’å¤–åœæœºæ—¶é—´å‡å°‘70%ä»¥ä¸Šã€‚

2. **å»ºç«‹å…¨é“¾è·¯è´¨é‡è¿½æº¯**ï¼šå®ç°ä»åŸææ–™åˆ°æˆå“çš„å…¨ç”Ÿå‘½å‘¨æœŸæ•°æ®è¿½æº¯ï¼Œè´¨é‡é—®é¢˜è¿½æº¯æ—¶é—´ç¼©çŸ­è‡³2å°æ—¶å†…ã€‚

3. **æå‡ç”Ÿäº§é€æ˜åº¦**ï¼šå»ºç«‹å®æ—¶æ•°å­—å­ªç”Ÿçœ‹æ¿ï¼Œå®ç°ç”Ÿäº§è¿‡ç¨‹çš„360åº¦å¯è§†åŒ–ï¼Œæ”¯æŒç®¡ç†å±‚å®æ—¶å†³ç­–ã€‚

4. **æ•°æ®é©±åŠ¨å·¥è‰ºä¼˜åŒ–**ï¼šåŸºäºæ•°å­—å­ªç”Ÿä»¿çœŸï¼Œä¼˜åŒ–å·¥è‰ºå‚æ•°ï¼Œæå‡äº§å“åˆæ ¼ç‡2ä¸ªç™¾åˆ†ç‚¹ï¼Œé™ä½èƒ½è€—15%ã€‚

5. **åŠ é€ŸçŸ¥è¯†æ²‰æ·€ä¸å¤ç”¨**ï¼šå»ºç«‹å¯å¤ç”¨çš„æ•°å­—å­ªç”Ÿæ¨¡å‹åº“ï¼Œæ–°å·¥å‚äº§èƒ½çˆ¬å¡æ—¶é—´ç¼©çŸ­è‡³6-8ä¸ªæœˆã€‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šæºå¼‚æ„æ•°æ®é›†æˆ**ï¼šéœ€è¦é›†æˆæ¥è‡ªSCADAã€MESã€ERPã€PLMç­‰10ä½™ä¸ªç³»ç»Ÿçš„æ•°æ®ï¼Œæ•°æ®æ ¼å¼å„å¼‚ï¼Œé¢‘ç‡ä¸åŒï¼Œéœ€è¦æ„å»ºç»Ÿä¸€çš„æ•°æ®é›†æˆå¹³å°ã€‚

2. **å®æ—¶ä¸‰ç»´å¯è§†åŒ–æ¸²æŸ“**ï¼šå·¥å‚åŒ…å«è¶…è¿‡10ä¸‡ä¸ªç‰©ç†å®ä½“ï¼Œéœ€è¦åœ¨Webç«¯å®ç°æµç•…çš„ä¸‰ç»´å¯è§†åŒ–ï¼ŒåŒæ—¶ä¿è¯æ•°æ®å»¶è¿Ÿä½äº1ç§’ã€‚

3. **é«˜ç²¾åº¦ç‰©ç†å»ºæ¨¡**ï¼šå»ºç«‹è®¾å¤‡è¡Œä¸ºçš„ç‰©ç†æ¨¡å‹ï¼Œå‡†ç¡®æ¨¡æ‹Ÿè®¾å¤‡åœ¨ä¸åŒå·¥å†µä¸‹çš„è¡¨ç°ï¼Œæ¨¡å‹ç²¾åº¦éœ€è¦è¾¾åˆ°95%ä»¥ä¸Šã€‚

4. **å¤§è§„æ¨¡æ•°æ®å­˜å‚¨ä¸æŸ¥è¯¢**ï¼šæ¯å¤©50GBçš„æ•°æ®å¢é‡ï¼Œéœ€è¦æ”¯æŒPBçº§æ•°æ®å­˜å‚¨å’Œäºšç§’çº§æŸ¥è¯¢å“åº”ã€‚

5. **è¾¹ç¼˜-äº‘ç«¯ååŒè®¡ç®—**ï¼šéƒ¨åˆ†åœºæ™¯éœ€è¦æ¯«ç§’çº§å“åº”ï¼Œéœ€è¦åœ¨è¾¹ç¼˜ä¾§éƒ¨ç½²è½»é‡åŒ–æ•°å­—å­ªç”Ÿæ¨¡å‹ï¼Œä¸äº‘ç«¯æ¨¡å‹ååŒå·¥ä½œã€‚

### 2.5 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
æ™ºèƒ½åˆ¶é€ æ•°å­—å­ªç”Ÿå¹³å°
AutoParts Inc. è‹å·å·¥å‚æ•°å­—å­ªç”Ÿç³»ç»Ÿ

åŠŸèƒ½æ¨¡å—ï¼š
1. ç‰©ç†å®ä½“å»ºæ¨¡ï¼ˆè®¾å¤‡ã€äº§çº¿ã€å·¥å‚ï¼‰
2. å®æ—¶æ•°æ®åŒæ­¥å¼•æ“
3. é¢„æµ‹æ€§ç»´æŠ¤ç®—æ³•
4. ä¸‰ç»´å¯è§†åŒ–æ¥å£
5. å·¥è‰ºä¼˜åŒ–ä»¿çœŸ

ä½œè€…ï¼šæ•°å­—åŒ–å·¥å‚å›¢é˜Ÿ
ç‰ˆæœ¬ï¼š3.0
"""

import asyncio
import json
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import numpy as np
from collections import deque
import threading
import time

# é…ç½®æ—¥å¿—
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class EquipmentStatus(Enum):
    """è®¾å¤‡çŠ¶æ€æšä¸¾"""
    RUNNING = "running"
    IDLE = "idle"
    MAINTENANCE = "maintenance"
    ERROR = "error"
    OFFLINE = "offline"


class AlertLevel(Enum):
    """å‘Šè­¦çº§åˆ«æšä¸¾"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


@dataclass
class SensorData:
    """ä¼ æ„Ÿå™¨æ•°æ®æ¨¡å‹"""
    sensor_id: str
    sensor_type: str
    value: float
    unit: str
    timestamp: datetime
    quality: float = 1.0  # æ•°æ®è´¨é‡ï¼Œ0-1


@dataclass
class EquipmentHealth:
    """è®¾å¤‡å¥åº·åº¦æ¨¡å‹"""
    equipment_id: str
    overall_health: float  # 0-100
    component_health: Dict[str, float]
    remaining_useful_life: Optional[int] = None  # å‰©ä½™ä½¿ç”¨å¯¿å‘½ï¼ˆå°æ—¶ï¼‰
    next_maintenance_date: Optional[datetime] = None


@dataclass
class DigitalTwinEntity:
    """æ•°å­—å­ªç”Ÿå®ä½“åŸºç±»"""
    entity_id: str
    entity_type: str
    name: str
    physical_id: str  # å¯¹åº”ç‰©ç†å®ä½“ID
    parent_id: Optional[str] = None
    children: List[str] = field(default_factory=list)
    properties: Dict[str, Any] = field(default_factory=dict)
    sensors: Dict[str, SensorData] = field(default_factory=dict)
    last_updated: datetime = field(default_factory=datetime.now)
    
    def update_sensor(self, sensor_data: SensorData):
        """æ›´æ–°ä¼ æ„Ÿå™¨æ•°æ®"""
        self.sensors[sensor_data.sensor_id] = sensor_data
        self.last_updated = datetime.now()


class CNCMachineDigitalTwin(DigitalTwinEntity):
    """CNCæœºåºŠæ•°å­—å­ªç”Ÿæ¨¡å‹"""
    
    def __init__(self, entity_id: str, name: str, physical_id: str):
        super().__init__(
            entity_id=entity_id,
            entity_type="CNC_Machine",
            name=name,
            physical_id=physical_id
        )
        self.status = EquipmentStatus.IDLE
        self.oee = 0.0  # è®¾å¤‡ç»¼åˆæ•ˆç‡
        self.health = EquipmentHealth(
            equipment_id=entity_id,
            overall_health=100.0,
            component_health={
                "spindle": 100.0,
                "coolant_system": 100.0,
                "lubrication_system": 100.0,
                "electrical_system": 100.0
            }
        )
        self.production_count = 0
        self.error_count = 0
        self.sensor_history = deque(maxlen=10000)  # ä¿ç•™æœ€è¿‘10000æ¡ä¼ æ„Ÿå™¨æ•°æ®
        
    def update_from_physical(self, sensor_data_list: List[SensorData]):
        """ä»ç‰©ç†è®¾å¤‡æ›´æ–°æ•°æ®"""
        for sensor_data in sensor_data_list:
            self.update_sensor(sensor_data)
            self.sensor_history.append(sensor_data)
            
        # æ›´æ–°è®¾å¤‡çŠ¶æ€
        self._update_status()
        
        # è®¡ç®—OEE
        self._calculate_oee()
        
        # æ›´æ–°å¥åº·åº¦
        self._update_health()
        
    def _update_status(self):
        """æ ¹æ®ä¼ æ„Ÿå™¨æ•°æ®æ›´æ–°è®¾å¤‡çŠ¶æ€"""
        # æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯ä¼ æ„Ÿå™¨
        error_sensor = self.sensors.get("error_code")
        if error_sensor and error_sensor.value > 0:
            self.status = EquipmentStatus.ERROR
            self.error_count += 1
            return
            
        # æ£€æŸ¥è¿è¡ŒçŠ¶æ€
        spindle_speed = self.sensors.get("spindle_speed")
        if spindle_speed and spindle_speed.value > 0:
            self.status = EquipmentStatus.RUNNING
        else:
            self.status = EquipmentStatus.IDLE
            
    def _calculate_oee(self):
        """è®¡ç®—è®¾å¤‡ç»¼åˆæ•ˆç‡ï¼ˆOEEï¼‰"""
        # ç®€åŒ–çš„OEEè®¡ç®—
        availability = 0.95  # å¯ç”¨ç‡
        performance = 0.90   # æ€§èƒ½ç‡
        quality = 0.98       # è´¨é‡ç‡
        self.oee = availability * performance * quality * 100
        
    def _update_health(self):
        """æ›´æ–°è®¾å¤‡å¥åº·åº¦"""
        # åŸºäºä¼ æ„Ÿå™¨æ•°æ®è®¡ç®—å„ç»„ä»¶å¥åº·åº¦
        # ä¸»è½´å¥åº·åº¦ - åŸºäºæŒ¯åŠ¨å’Œæ¸©åº¦
        vibration = self.sensors.get("vibration")
        temperature = self.sensors.get("temperature")
        
        if vibration and temperature:
            # æŒ¯åŠ¨é˜ˆå€¼ï¼š>5mm/sä¸ºè­¦å‘Šï¼Œ>10mm/sä¸ºå±é™©
            vib_health = max(0, 100 - (vibration.value / 10) * 50)
            # æ¸©åº¦é˜ˆå€¼ï¼š>60Â°Cä¸ºè­¦å‘Šï¼Œ>80Â°Cä¸ºå±é™©
            temp_health = max(0, 100 - max(0, temperature.value - 40) * 2)
            
            self.health.component_health["spindle"] = (vib_health + temp_health) / 2
            
        # è®¡ç®—æ•´ä½“å¥åº·åº¦
        self.health.overall_health = np.mean(list(self.health.component_health.values()))
        
    def predict_failure(self, hours_ahead: int = 168) -> Dict[str, Any]:
        """é¢„æµ‹è®¾å¤‡æ•…éšœ
        
        Args:
            hours_ahead: é¢„æµ‹æ—¶é—´çª—å£ï¼ˆå°æ—¶ï¼‰ï¼Œé»˜è®¤7å¤©
            
        Returns:
            æ•…éšœé¢„æµ‹ç»“æœ
        """
        if len(self.sensor_history) < 1000:
            return {"predictable": False, "reason": "Insufficient data"}
            
        # ç®€åŒ–çš„æ•…éšœé¢„æµ‹é€»è¾‘ï¼ˆå®é™…åº”ä½¿ç”¨MLæ¨¡å‹ï¼‰
        recent_vibration = [s.value for s in list(self.sensor_history)[-100:] 
                           if s.sensor_type == "vibration"]
        recent_temp = [s.value for s in list(self.sensor_history)[-100:] 
                      if s.sensor_type == "temperature"]
        
        if not recent_vibration or not recent_temp:
            return {"predictable": False, "reason": "No relevant sensor data"}
            
        avg_vibration = np.mean(recent_vibration)
        avg_temp = np.mean(recent_temp)
        
        # è¶‹åŠ¿åˆ†æ
        vibration_trend = recent_vibration[-1] - recent_vibration[0]
        temp_trend = recent_temp[-1] - recent_temp[0]
        
        failure_probability = 0.0
        failure_type = None
        
        if avg_vibration > 8 or vibration_trend > 3:
            failure_probability = min(0.9, avg_vibration / 10)
            failure_type = "spindle_bearing_wear"
        elif avg_temp > 70 or temp_trend > 10:
            failure_probability = min(0.8, avg_temp / 100)
            failure_type = "cooling_system_failure"
            
        if failure_probability > 0.5:
            self.health.remaining_useful_life = int(
                (100 - self.health.overall_health) / (failure_probability * 10) * 24
            )
            
        return {
            "predictable": True,
            "equipment_id": self.entity_id,
            "failure_probability": failure_probability,
            "failure_type": failure_type,
            "predicted_failure_time": datetime.now() + timedelta(
                hours=self.health.remaining_useful_life or hours_ahead
            ) if failure_probability > 0.5 else None,
            "remaining_useful_life_hours": self.health.remaining_useful_life,
            "recommendations": self._generate_maintenance_recommendations(
                failure_type, failure_probability
            )
        }
        
    def _generate_maintenance_recommendations(
        self, failure_type: Optional[str], probability: float
    ) -> List[str]:
        """ç”Ÿæˆç»´æŠ¤å»ºè®®"""
        recommendations = []
        
        if probability > 0.7:
            recommendations.append("URGENT: Schedule immediate maintenance")
        elif probability > 0.4:
            recommendations.append("WARNING: Plan maintenance within 7 days")
            
        if failure_type == "spindle_bearing_wear":
            recommendations.extend([
                "Inspect spindle bearing condition",
                "Check lubrication system",
                "Verify vibration sensor calibration"
            ])
        elif failure_type == "cooling_system_failure":
            recommendations.extend([
                "Check coolant level and flow rate",
                "Clean cooling system filters",
                "Inspect coolant pump"
            ])
            
        return recommendations


class ProductionLineDigitalTwin(DigitalTwinEntity):
    """ç”Ÿäº§çº¿æ•°å­—å­ªç”Ÿæ¨¡å‹"""
    
    def __init__(self, entity_id: str, name: str, physical_id: str):
        super().__init__(
            entity_id=entity_id,
            entity_type="Production_Line",
            name=name,
            physical_id=physical_id
        )
        self.equipment: Dict[str, CNCMachineDigitalTwin] = {}
        self.production_rate = 0.0  # ä»¶/å°æ—¶
        self.quality_rate = 0.0     # åˆæ ¼ç‡
        self.current_order = None
        
    def add_equipment(self, equipment: CNCMachineDigitalTwin):
        """æ·»åŠ è®¾å¤‡åˆ°ç”Ÿäº§çº¿"""
        self.equipment[equipment.entity_id] = equipment
        equipment.parent_id = self.entity_id
        self.children.append(equipment.entity_id)
        
    def get_line_status(self) -> Dict[str, Any]:
        """è·å–ç”Ÿäº§çº¿çŠ¶æ€"""
        running_count = sum(1 for e in self.equipment.values() 
                          if e.status == EquipmentStatus.RUNNING)
        error_count = sum(1 for e in self.equipment.values() 
                        if e.status == EquipmentStatus.ERROR)
        
        avg_oee = np.mean([e.oee for e in self.equipment.values()]) if self.equipment else 0
        avg_health = np.mean([e.health.overall_health for e in self.equipment.values()]) if self.equipment else 0
        
        return {
            "line_id": self.entity_id,
            "line_name": self.name,
            "total_equipment": len(self.equipment),
            "running": running_count,
            "idle": len(self.equipment) - running_count - error_count,
            "error": error_count,
            "average_oee": avg_oee,
            "average_health": avg_health,
            "production_rate": self.production_rate,
            "quality_rate": self.quality_rate
        }
        
    def get_bottleneck_analysis(self) -> Dict[str, Any]:
        """ç“¶é¢ˆåˆ†æ"""
        if not self.equipment:
            return {"has_bottleneck": False}
            
        # æ‰¾å‡ºOEEæœ€ä½çš„è®¾å¤‡ä½œä¸ºç“¶é¢ˆ
        bottleneck = min(self.equipment.values(), key=lambda e: e.oee)
        
        return {
            "has_bottleneck": bottleneck.oee < 70,
            "bottleneck_equipment_id": bottleneck.entity_id,
            "bottleneck_equipment_name": bottleneck.name,
            "bottleneck_oee": bottleneck.oee,
            "impact_on_line": f"Reduces line efficiency by {70 - bottleneck.oee:.1f}%"
        }


class DigitalTwinFactory:
    """æ•°å­—å­ªç”Ÿå·¥å‚ - ç®¡ç†æ•´ä¸ªå·¥å‚çš„æ•°å­—å­ªç”Ÿ"""
    
    def __init__(self, factory_id: str, factory_name: str):
        self.factory_id = factory_id
        self.factory_name = factory_name
        self.production_lines: Dict[str, ProductionLineDigitalTwin] = {}
        self.data_sync_engine = DataSyncEngine()
        self.alert_manager = AlertManager()
        self.running = False
        
    def add_production_line(self, line: ProductionLineDigitalTwin):
        """æ·»åŠ ç”Ÿäº§çº¿"""
        self.production_lines[line.entity_id] = line
        line.parent_id = self.factory_id
        
    async def start_sync(self, data_source: Callable):
        """å¯åŠ¨æ•°æ®åŒæ­¥"""
        self.running = True
        logger.info(f"Starting digital twin sync for factory {self.factory_name}")
        
        while self.running:
            try:
                # ä»æ•°æ®æºè·å–å®æ—¶æ•°æ®
                raw_data = await data_source()
                
                # è§£æå¹¶åˆ†å‘æ•°æ®
                await self._process_incoming_data(raw_data)
                
                # è§¦å‘é¢„æµ‹åˆ†æ
                await self._run_predictive_analysis()
                
                # ç­‰å¾…ä¸‹ä¸€æ¬¡åŒæ­¥
                await asyncio.sleep(1)  # 1ç§’åˆ·æ–°é¢‘ç‡
                
            except Exception as e:
                logger.error(f"Sync error: {e}")
                await asyncio.sleep(5)
                
    async def _process_incoming_data(self, raw_data: List[Dict]):
        """å¤„ç†ä¼ å…¥çš„ä¼ æ„Ÿå™¨æ•°æ®"""
        for data in raw_data:
            equipment_id = data.get("equipment_id")
            
            # æ‰¾åˆ°å¯¹åº”çš„è®¾å¤‡æ•°å­—å­ªç”Ÿ
            for line in self.production_lines.values():
                if equipment_id in line.equipment:
                    equipment = line.equipment[equipment_id]
                    
                    # åˆ›å»ºä¼ æ„Ÿå™¨æ•°æ®å¯¹è±¡
                    sensor_data = SensorData(
                        sensor_id=data["sensor_id"],
                        sensor_type=data["sensor_type"],
                        value=data["value"],
                        unit=data.get("unit", ""),
                        timestamp=datetime.fromisoformat(data["timestamp"])
                    )
                    
                    # æ›´æ–°æ•°å­—å­ªç”Ÿ
                    equipment.update_from_physical([sensor_data])
                    
                    # æ£€æŸ¥å‘Šè­¦
                    await self._check_alerts(equipment, sensor_data)
                    
    async def _check_alerts(self, equipment: CNCMachineDigitalTwin, sensor_data: SensorData):
        """æ£€æŸ¥å¹¶ç”Ÿæˆå‘Šè­¦"""
        # æ¸©åº¦å‘Šè­¦
        if sensor_data.sensor_type == "temperature" and sensor_data.value > 75:
            await self.alert_manager.create_alert(
                level=AlertLevel.WARNING if sensor_data.value < 85 else AlertLevel.CRITICAL,
                equipment_id=equipment.entity_id,
                message=f"High temperature: {sensor_data.value}Â°C",
                timestamp=sensor_data.timestamp
            )
            
        # æŒ¯åŠ¨å‘Šè­¦
        if sensor_data.sensor_type == "vibration" and sensor_data.value > 8:
            await self.alert_manager.create_alert(
                level=AlertLevel.WARNING if sensor_data.value < 12 else AlertLevel.CRITICAL,
                equipment_id=equipment.entity_id,
                message=f"High vibration: {sensor_data.value} mm/s",
                timestamp=sensor_data.timestamp
            )
            
    async def _run_predictive_analysis(self):
        """è¿è¡Œé¢„æµ‹æ€§åˆ†æ"""
        for line in self.production_lines.values():
            for equipment in line.equipment.values():
                prediction = equipment.predict_failure(hours_ahead=168)
                
                if prediction.get("predictable") and prediction.get("failure_probability", 0) > 0.5:
                    await self.alert_manager.create_alert(
                        level=AlertLevel.WARNING,
                        equipment_id=equipment.entity_id,
                        message=f"Predicted failure: {prediction.get('failure_type')} "
                               f"(probability: {prediction.get('failure_probability'):.2%})",
                        timestamp=datetime.now(),
                        metadata=prediction
                    )
                    
    def get_factory_overview(self) -> Dict[str, Any]:
        """è·å–å·¥å‚æ•´ä½“æ¦‚è§ˆ"""
        total_equipment = sum(len(line.equipment) for line in self.production_lines.values())
        running_equipment = sum(
            sum(1 for e in line.equipment.values() if e.status == EquipmentStatus.RUNNING)
            for line in self.production_lines.values()
        )
        
        all_equipment = [
            e for line in self.production_lines.values() 
            for e in line.equipment.values()
        ]
        
        avg_oee = np.mean([e.oee for e in all_equipment]) if all_equipment else 0
        avg_health = np.mean([e.health.overall_health for e in all_equipment]) if all_equipment else 0
        
        return {
            "factory_id": self.factory_id,
            "factory_name": self.factory_name,
            "production_lines": len(self.production_lines),
            "total_equipment": total_equipment,
            "running_equipment": running_equipment,
            "equipment_utilization": running_equipment / total_equipment * 100 if total_equipment else 0,
            "average_oee": avg_oee,
            "average_health": avg_health,
            "lines_status": [line.get_line_status() for line in self.production_lines.values()]
        }
        
    def stop_sync(self):
        """åœæ­¢æ•°æ®åŒæ­¥"""
        self.running = False
        logger.info(f"Stopped digital twin sync for factory {self.factory_name}")


class DataSyncEngine:
    """æ•°æ®åŒæ­¥å¼•æ“"""
    
    def __init__(self):
        self.subscribers: List[Callable] = []
        
    async def subscribe(self, callback: Callable):
        """è®¢é˜…æ•°æ®æ›´æ–°"""
        self.subscribers.append(callback)
        
    async def publish(self, data: Dict):
        """å‘å¸ƒæ•°æ®æ›´æ–°"""
        for subscriber in self.subscribers:
            await subscriber(data)


class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""
    
    def __init__(self):
        self.alerts: deque = deque(maxlen=10000)
        self.handlers: List[Callable] = []
        
    def register_handler(self, handler: Callable):
        """æ³¨å†Œå‘Šè­¦å¤„ç†å™¨"""
        self.handlers.append(handler)
        
    async def create_alert(self, level: AlertLevel, equipment_id: str, 
                          message: str, timestamp: datetime, metadata: Dict = None):
        """åˆ›å»ºå‘Šè­¦"""
        alert = {
            "id": f"ALT-{int(time.time() * 1000)}",
            "level": level.value,
            "equipment_id": equipment_id,
            "message": message,
            "timestamp": timestamp.isoformat(),
            "metadata": metadata or {},
            "acknowledged": False
        }
        
        self.alerts.append(alert)
        logger.warning(f"Alert created: {alert}")
        
        # é€šçŸ¥æ‰€æœ‰å¤„ç†å™¨
        for handler in self.handlers:
            await handler(alert)


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

async def mock_data_source() -> List[Dict]:
    """æ¨¡æ‹Ÿæ•°æ®æº"""
    import random
    equipment_ids = ["CNC_001", "CNC_002", "CNC_003", "ROBOT_001", "ROBOT_002"]
    sensor_types = ["temperature", "vibration", "spindle_speed", "power_consumption"]
    
    data = []
    for eq_id in equipment_ids:
        for sensor_type in sensor_types:
            if sensor_type == "temperature":
                value = random.uniform(40, 85)
            elif sensor_type == "vibration":
                value = random.uniform(1, 15)
            elif sensor_type == "spindle_speed":
                value = random.uniform(0, 8000)
            else:
                value = random.uniform(5, 25)
                
            data.append({
                "equipment_id": eq_id,
                "sensor_id": f"{eq_id}_{sensor_type}",
                "sensor_type": sensor_type,
                "value": value,
                "unit": "Â°C" if sensor_type == "temperature" else "mm/s" if sensor_type == "vibration" else "RPM" if sensor_type == "spindle_speed" else "kW",
                "timestamp": datetime.now().isoformat()
            })
            
    return data


async def alert_handler(alert: Dict):
    """å‘Šè­¦å¤„ç†ç¤ºä¾‹"""
    print(f"\nğŸš¨ ALERT [{alert['level'].upper()}]")
    print(f"   Equipment: {alert['equipment_id']}")
    print(f"   Message: {alert['message']}")
    print(f"   Time: {alert['timestamp']}")


async def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºæ•°å­—å­ªç”Ÿå·¥å‚çš„ä½¿ç”¨"""
    
    # åˆ›å»ºæ•°å­—å­ªç”Ÿå·¥å‚
    factory = DigitalTwinFactory(
        factory_id="FA_SUZHOU_001",
        factory_name="AutoParts Suzhou Factory"
    )
    
    # åˆ›å»ºç”Ÿäº§çº¿
    line1 = ProductionLineDigitalTwin(
        entity_id="LINE_001",
        name="Engine Parts Line A",
        physical_id="PHYS_LINE_001"
    )
    
    # åˆ›å»ºè®¾å¤‡æ•°å­—å­ªç”Ÿ
    cnc1 = CNCMachineDigitalTwin(
        entity_id="CNC_001",
        name="CNC Machine #1",
        physical_id="PHYS_CNC_001"
    )
    cnc2 = CNCMachineDigitalTwin(
        entity_id="CNC_002",
        name="CNC Machine #2",
        physical_id="PHYS_CNC_002"
    )
    robot1 = CNCMachineDigitalTwin(
        entity_id="ROBOT_001",
        name="Assembly Robot #1",
        physical_id="PHYS_ROBOT_001"
    )
    
    # ç»„è£…ç”Ÿäº§çº¿
    line1.add_equipment(cnc1)
    line1.add_equipment(cnc2)
    line1.add_equipment(robot1)
    factory.add_production_line(line1)
    
    # æ³¨å†Œå‘Šè­¦å¤„ç†å™¨
    factory.alert_manager.register_handler(alert_handler)
    
    # å¯åŠ¨åŒæ­¥ï¼ˆè¿è¡Œ10ç§’ç”¨äºæ¼”ç¤ºï¼‰
    print("=" * 60)
    print("Digital Twin Factory Demo")
    print("=" * 60)
    
    # è¿è¡ŒåŒæ­¥ä»»åŠ¡
    sync_task = asyncio.create_task(factory.start_sync(mock_data_source))
    
    # å®šæœŸæ‰“å°å·¥å‚çŠ¶æ€
    for i in range(10):
        await asyncio.sleep(1)
        overview = factory.get_factory_overview()
        print(f"\n--- Factory Status (t={i+1}s) ---")
        print(f"Equipment: {overview['running_equipment']}/{overview['total_equipment']} running")
        print(f"Average OEE: {overview['average_oee']:.1f}%")
        print(f"Average Health: {overview['average_health']:.1f}%")
        
        # æ‰“å°è®¾å¤‡çŠ¶æ€
        for line in factory.production_lines.values():
            for eq_id, eq in line.equipment.items():
                print(f"  {eq.name}: {eq.status.value}, OEE={eq.oee:.1f}%, Health={eq.health.overall_health:.1f}%")
    
    # åœæ­¢åŒæ­¥
    factory.stop_sync()
    sync_task.cancel()
    
    print("\n" + "=" * 60)
    print("Demo completed")
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())
```

### 2.6 æ•ˆæœè¯„ä¼°ä¸ROI

**æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æå‡å¹…åº¦ |
|------|--------|--------|----------|
| è®¡åˆ’å¤–åœæœºæ—¶é—´ | 450å°æ—¶/å¹´ | 120å°æ—¶/å¹´ | **73.3%é™ä½** |
| è´¨é‡é—®é¢˜è¿½æº¯æ—¶é—´ | 3-5å¤© | 1.5å°æ—¶ | **96%ç¼©çŸ­** |
| è®¾å¤‡OEE | 68% | 82% | **20.6%æå‡** |
| äº§å“åˆæ ¼ç‡ | 96.5% | 98.8% | **2.3%æå‡** |
| å·¥è‰ºä¼˜åŒ–å‘¨æœŸ | 8-12å‘¨ | 2-3å‘¨ | **75%ç¼©çŸ­** |
| æ–°å·¥å‚äº§èƒ½çˆ¬å¡æ—¶é—´ | 12-18ä¸ªæœˆ | 7ä¸ªæœˆ | **50%ç¼©çŸ­** |

**æŠ•èµ„å›æŠ¥ç‡ï¼ˆROIï¼‰åˆ†æ**ï¼š

| é¡¹ç›® | å¹´åº¦æˆæœ¬/æ”¶ç›Š | è¯´æ˜ |
|------|--------------|------|
| **æ•°å­—å­ªç”Ÿå¹³å°å»ºè®¾** | -ï¿¥800ä¸‡ | è½¯ä»¶è®¸å¯ã€ç¡¬ä»¶ã€å®æ–½æœåŠ¡ |
| **ä¼ æ„Ÿå™¨å’ŒIoTè®¾å¤‡** | -ï¿¥320ä¸‡ | æ–°å¢ä¼ æ„Ÿå™¨ã€ç½‘å…³ã€ç½‘ç»œ |
| **äººåŠ›æˆæœ¬** | -ï¿¥180ä¸‡ | æ–°å¢æ•°æ®å·¥ç¨‹å¸ˆã€ç®—æ³•å·¥ç¨‹å¸ˆ |
| **ç»´æŠ¤æˆæœ¬** | -ï¿¥80ä¸‡/å¹´ | å¹³å°è¿ç»´ã€è½¯ä»¶æ›´æ–° |
| **å‡å°‘åœæœºæŸå¤±** | +ï¿¥2,100ä¸‡ | åŸºäºæ¯å°æ—¶åœæœºæˆæœ¬è®¡ç®— |
| **é™ä½è´¨é‡æˆæœ¬** | +ï¿¥680ä¸‡ | å‡å°‘è¿”å·¥ã€æŠ¥åºŸã€ç´¢èµ” |
| **èƒ½è€—èŠ‚çº¦** | +ï¿¥240ä¸‡ | å·¥è‰ºä¼˜åŒ–å¸¦æ¥çš„èƒ½è€—é™ä½ |
| **åº“å­˜ä¼˜åŒ–** | +ï¿¥360ä¸‡ | ç²¾å‡†é¢„æµ‹å‡å°‘å®‰å…¨åº“å­˜ |
| **æ–°å·¥å‚å¿«é€ŸæŠ•äº§** | +ï¿¥1,200ä¸‡ | åŠ é€Ÿäº§èƒ½çˆ¬å¡å¸¦æ¥çš„æ”¶ç›Š |
| **å¹´åº¦å‡€æ”¶ç›Š** | **+ï¿¥3,400ä¸‡** | |
| **3å¹´ROI** | **354%** | æŠ•èµ„å›æ”¶æœŸçº¦10ä¸ªæœˆ |

**å®šæ€§æ”¶ç›Š**ï¼š

- **å†³ç­–è´¨é‡æå‡**ï¼šç®¡ç†å±‚å¯ä»¥åŸºäºå®æ—¶æ•°æ®åšå‡ºå†³ç­–ï¼Œå†³ç­–å‡†ç¡®ç‡æå‡40%
- **è·¨å·¥å‚ååŒ**ï¼šæ•°å­—å­ªç”Ÿæ¨¡å‹åº“æ”¯æŒæœ€ä½³å®è·µçš„å¿«é€Ÿå¤åˆ¶ï¼Œå…¨çƒå·¥å‚è¿è¥æ°´å¹³è¶‹äºä¸€è‡´
- **å®¢æˆ·ä¿¡ä»»å¢å¼º**ï¼šå¯ä»¥å‘å®¢æˆ·å±•ç¤ºé€æ˜çš„ç”Ÿäº§è¿‡ç¨‹ï¼Œè·å¾—å®é©¬"æœ€ä½³ä¾›åº”å•†"è®¤è¯
- **å‘˜å·¥æŠ€èƒ½æå‡**ï¼šæ•°å­—åŒ–åŸ¹è®­å¹³å°ç»“åˆæ•°å­—å­ªç”Ÿï¼Œæ–°å‘˜å·¥åŸ¹è®­æ—¶é—´ç¼©çŸ­50%

---

## 3. æ¡ˆä¾‹2ï¼šæ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿ

### 3.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸç‰¹å¤§å‹åŸå¸‚ï¼ˆä»¥ä¸‹ç®€ç§°"ç»¿åŸ"ï¼‰å¸¸ä½äººå£è¶…è¿‡1500ä¸‡ï¼ŒæœºåŠ¨è½¦ä¿æœ‰é‡è¶…è¿‡500ä¸‡è¾†ï¼Œæ¯å¤©äº§ç”Ÿæµ·é‡åŸå¸‚è¿è¡Œæ•°æ®ã€‚åŸå¸‚ç®¡ç†éƒ¨é—¨é¢ä¸´äº¤é€šæ‹¥å µã€ç¯å¢ƒæ±¡æŸ“ã€èƒ½æºæ¶ˆè€—ã€å…¬å…±å®‰å…¨ç­‰å¤šé‡æŒ‘æˆ˜ã€‚

ç»¿åŸæ”¿åºœäº2022å¹´å¯åŠ¨"æ•°å­—ç»¿åŸ2030"æˆ˜ç•¥è§„åˆ’ï¼Œè®¡åˆ’æŠ•èµ„50äº¿å…ƒå»ºè®¾åŸå¸‚çº§æ•°å­—å­ªç”Ÿå¹³å°ï¼Œæ¶µç›–äº¤é€šã€ç¯å¢ƒã€èƒ½æºã€å»ºç­‘ã€å…¬å…±å®‰å…¨ç­‰äº”å¤§é¢†åŸŸï¼Œæ‰“é€ å…¨çƒé¢†å…ˆçš„æ™ºæ…§åŸå¸‚æ ‡æ†ã€‚

### 3.2 ä¸šåŠ¡ç—›ç‚¹

1. **äº¤é€šæ‹¥å µæ²»ç†å›°éš¾**ï¼šæ—©é«˜å³°å¹³å‡æ‹¥å µæŒ‡æ•°è¾¾åˆ°8.5ï¼ˆä¸¥é‡æ‹¥å µï¼‰ï¼Œå¸‚æ°‘é€šå‹¤æ—¶é—´å¹³å‡è¶…è¿‡90åˆ†é’Ÿï¼Œå¹´ç»æµæŸå¤±è¶…è¿‡200äº¿å…ƒã€‚

2. **ç¯å¢ƒæ±¡æŸ“ç›‘æ§æ»å**ï¼šç©ºæ°”è´¨é‡ç›‘æµ‹ç‚¹ä½ä¸è¶³ï¼Œæ±¡æŸ“æºå®šä½å›°éš¾ï¼Œç¯ä¿æ‰§æ³•å“åº”æ—¶é—´é•¿è¾¾24-48å°æ—¶ã€‚

3. **èƒ½æºç®¡ç†ç²—æ”¾**ï¼šåŸå¸‚å»ºç­‘èƒ½è€—å å…¨ç¤¾ä¼šèƒ½è€—çš„40%ï¼Œç¼ºä¹ç²¾ç»†åŒ–çš„èƒ½æºç›‘æ§å’Œä¼˜åŒ–æ‰‹æ®µï¼ŒèŠ‚èƒ½æ½œåŠ›æœªèƒ½å……åˆ†æŒ–æ˜ã€‚

4. **åº”æ€¥å“åº”æ•ˆç‡ä½**ï¼šçªå‘äº‹ä»¶å“åº”ä¾èµ–äººå·¥ç ”åˆ¤å’Œå†³ç­–ï¼Œå¹³å‡å“åº”æ—¶é—´è¶…è¿‡30åˆ†é’Ÿï¼Œå½±å“æ•‘æ´æ•ˆç‡ã€‚

5. **è·¨éƒ¨é—¨æ•°æ®å­¤å²›**ï¼š30+ä¸ªæ”¿åºœéƒ¨é—¨å„è‡ªå»ºè®¾ä¿¡æ¯ç³»ç»Ÿï¼Œæ•°æ®æ ‡å‡†ä¸ç»Ÿä¸€ï¼Œéš¾ä»¥å½¢æˆåŸå¸‚çº§ååŒæ²»ç†èƒ½åŠ›ã€‚

### 3.3 ä¸šåŠ¡ç›®æ ‡

1. **æ™ºæ…§äº¤é€šç®¡ç†**ï¼šæ„å»ºäº¤é€šæ•°å­—å­ªç”Ÿç³»ç»Ÿï¼Œå®ç°äº¤é€šæµé‡é¢„æµ‹å‡†ç¡®ç‡â‰¥90%ï¼Œæ‹¥å µæŒ‡æ•°é™ä½20%ã€‚

2. **ç²¾å‡†ç¯å¢ƒç›‘æ§**ï¼šå»ºç«‹å…¨è¦†ç›–çš„ç¯å¢ƒç›‘æµ‹ç½‘ç»œï¼Œæ±¡æŸ“æºå®šä½æ—¶é—´ç¼©çŸ­è‡³2å°æ—¶å†…ï¼Œç©ºæ°”è´¨é‡ä¼˜è‰¯å¤©æ•°æå‡15%ã€‚

3. **æ™ºèƒ½èƒ½æºä¼˜åŒ–**ï¼šå®ç°é‡ç‚¹å»ºç­‘èƒ½è€—å®æ—¶ç›‘æµ‹ï¼Œèƒ½æºä½¿ç”¨æ•ˆç‡æå‡25%ï¼Œç¢³æ’æ”¾é™ä½10%ã€‚

4. **å¿«é€Ÿåº”æ€¥å“åº”**ï¼šå»ºç«‹åŸå¸‚åº”æ€¥æŒ‡æŒ¥æ•°å­—å­ªç”Ÿç³»ç»Ÿï¼Œçªå‘äº‹ä»¶å“åº”æ—¶é—´ç¼©çŸ­è‡³10åˆ†é’Ÿä»¥å†…ã€‚

5. **è·¨éƒ¨é—¨æ•°æ®èåˆ**ï¼šæ‰“é€šæ”¿åºœéƒ¨é—¨æ•°æ®å£å’ï¼Œæ„å»ºç»Ÿä¸€çš„åŸå¸‚æ•°æ®ä¸­å°ï¼Œæ”¯æ’‘è·¨éƒ¨é—¨ååŒå†³ç­–ã€‚

### 3.4 æŠ€æœ¯æŒ‘æˆ˜

1. **è¶…å¤§è§„æ¨¡æ•°æ®å¤„ç†**ï¼šéœ€è¦å¤„ç†æ¥è‡ª10ä¸‡+ä¼ æ„Ÿå™¨çš„å®æ—¶æ•°æ®ï¼Œæ—¥å‡æ•°æ®é‡è¶…è¿‡10TBï¼Œå³°å€¼QPSè¶…è¿‡100ä¸‡ã€‚

2. **å¤æ‚ç³»ç»Ÿå»ºæ¨¡**ï¼šåŸå¸‚æ˜¯ä¸€ä¸ªå¤æ‚çš„å·¨ç³»ç»Ÿï¼Œæ¶‰åŠäººã€è½¦ã€å»ºç­‘ã€ç¯å¢ƒç­‰å¤šç»´åº¦å®ä½“ï¼Œå»ºæ¨¡å¤æ‚åº¦æé«˜ã€‚

3. **å®æ—¶ä»¿çœŸè®¡ç®—**ï¼šéœ€è¦æ”¯æŒç™¾ä¸‡çº§å®ä½“çš„é«˜å¹¶å‘ä»¿çœŸè®¡ç®—ï¼Œå“åº”å»¶è¿Ÿæ§åˆ¶åœ¨ç§’çº§ã€‚

4. **å¤šæºå¼‚æ„æ•°æ®èåˆ**ï¼šéœ€è¦èåˆIoTã€å«æ˜Ÿé¥æ„Ÿã€è§†é¢‘ç›‘æ§ã€ç¤¾äº¤åª’ä½“ç­‰å¤šæºæ•°æ®ï¼Œæ•°æ®æ ¼å¼å’Œæ ‡å‡†å„å¼‚ã€‚

5. **å®‰å…¨ä¸éšç§ä¿æŠ¤**ï¼šæ¶‰åŠå¤§é‡å¸‚æ°‘éšç§æ•°æ®ï¼Œéœ€è¦ç¡®ä¿æ•°æ®å®‰å…¨å’Œéšç§åˆè§„ã€‚

### 3.5 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
æ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿå¹³å°
ç»¿åŸæ•°å­—å­ªç”ŸåŸå¸‚ç®¡ç†ç³»ç»Ÿ

åŠŸèƒ½æ¨¡å—ï¼š
1. åŸå¸‚äº¤é€šæ•°å­—å­ªç”Ÿ
2. ç¯å¢ƒç›‘æµ‹æ•°å­—å­ªç”Ÿ
3. èƒ½æºç®¡ç†æ•°å­—å­ªç”Ÿ
4. åº”æ€¥æŒ‡æŒ¥æ•°å­—å­ªç”Ÿ
5. åŸå¸‚æ•°æ®èåˆå¼•æ“

ä½œè€…ï¼šæ™ºæ…§åŸå¸‚ç ”ç©¶ä¸­å¿ƒ
ç‰ˆæœ¬ï¼š2.0
"""

import asyncio
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from enum import Enum
import numpy as np
from collections import defaultdict, deque
import json
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TrafficLevel(Enum):
    """äº¤é€šçŠ¶å†µç­‰çº§"""
    FREE = "free"           # ç•…é€š
    LIGHT = "light"         # è½»åº¦æ‹¥å µ
    MODERATE = "moderate"   # ä¸­åº¦æ‹¥å µ
    HEAVY = "heavy"         # ä¸¥é‡æ‹¥å µ


class AirQualityLevel(Enum):
    """ç©ºæ°”è´¨é‡ç­‰çº§"""
    EXCELLENT = "excellent"     # ä¼˜
    GOOD = "good"               # è‰¯
    LIGHTLY_POLLUTED = "light"  # è½»åº¦æ±¡æŸ“
    MODERATELY_POLLUTED = "moderate"  # ä¸­åº¦æ±¡æŸ“
    HEAVILY_POLLUTED = "heavy"  # é‡åº¦æ±¡æŸ“


@dataclass
class GeoLocation:
    """åœ°ç†åæ ‡"""
    latitude: float
    longitude: float
    altitude: float = 0.0
    
    def distance_to(self, other: 'GeoLocation') -> float:
        """è®¡ç®—ä¸å¦ä¸€ä¸ªç‚¹çš„è·ç¦»ï¼ˆç®€åŒ–ç‰ˆï¼Œå•ä½ï¼šå…¬é‡Œï¼‰"""
        # ä½¿ç”¨Haversineå…¬å¼ç®€åŒ–ç‰ˆ
        lat_diff = abs(self.latitude - other.latitude)
        lon_diff = abs(self.longitude - other.longitude)
        return np.sqrt(lat_diff**2 + lon_diff**2) * 111  # ç²—ç•¥ä¼°ç®—


@dataclass
class RoadSegment:
    """é“è·¯æ®µæ•°å­—å­ªç”Ÿ"""
    segment_id: str
    name: str
    start_point: GeoLocation
    end_point: GeoLocation
    length_km: float
    lanes: int
    speed_limit: float  # km/h
    
    # å®æ—¶çŠ¶æ€
    current_speed: float = 0.0
    vehicle_count: int = 0
    traffic_level: TrafficLevel = TrafficLevel.FREE
    
    # å†å²æ•°æ®
    speed_history: deque = field(default_factory=lambda: deque(maxlen=1440))  # 24å°æ—¶ï¼Œæ¯åˆ†é’Ÿä¸€ä¸ªç‚¹
    
    def update_traffic(self, speed: float, count: int):
        """æ›´æ–°äº¤é€šçŠ¶æ€"""
        self.current_speed = speed
        self.vehicle_count = count
        self.speed_history.append((datetime.now(), speed))
        
        # è®¡ç®—æ‹¥å µç­‰çº§
        speed_ratio = speed / self.speed_limit
        if speed_ratio > 0.8:
            self.traffic_level = TrafficLevel.FREE
        elif speed_ratio > 0.6:
            self.traffic_level = TrafficLevel.LIGHT
        elif speed_ratio > 0.4:
            self.traffic_level = TrafficLevel.MODERATE
        else:
            self.traffic_level = TrafficLevel.HEAVY
            
    def predict_congestion(self, minutes_ahead: int = 30) -> TrafficLevel:
        """é¢„æµ‹æœªæ¥æ‹¥å µçŠ¶å†µ"""
        if len(self.speed_history) < 60:
            return self.traffic_level
            
        # ç®€å•çº¿æ€§è¶‹åŠ¿é¢„æµ‹
        recent_speeds = [s for _, s in list(self.speed_history)[-60:]]
        trend = (recent_speeds[-1] - recent_speeds[0]) / len(recent_speeds)
        predicted_speed = max(0, recent_speeds[-1] + trend * minutes_ahead)
        
        speed_ratio = predicted_speed / self.speed_limit
        if speed_ratio > 0.8:
            return TrafficLevel.FREE
        elif speed_ratio > 0.6:
            return TrafficLevel.LIGHT
        elif speed_ratio > 0.4:
            return TrafficLevel.MODERATE
        else:
            return TrafficLevel.HEAVY


@dataclass
class AirMonitorStation:
    """ç©ºæ°”è´¨é‡ç›‘æµ‹ç«™æ•°å­—å­ªç”Ÿ"""
    station_id: str
    name: str
    location: GeoLocation
    
    # å®æ—¶ç›‘æµ‹æ•°æ®
    pm25: float = 0.0
    pm10: float = 0.0
    no2: float = 0.0
    so2: float = 0.0
    co: float = 0.0
    o3: float = 0.0
    aqi: int = 0
    quality_level: AirQualityLevel = AirQualityLevel.EXCELLENT
    
    # å†å²æ•°æ®
    data_history: deque = field(default_factory=lambda: deque(maxlen=10080))  # 7å¤©æ•°æ®
    
    def update_data(self, pm25: float, pm10: float, no2: float, 
                   so2: float, co: float, o3: float):
        """æ›´æ–°ç›‘æµ‹æ•°æ®"""
        self.pm25 = pm25
        self.pm10 = pm10
        self.no2 = no2
        self.so2 = so2
        self.co = co
        self.o3 = o3
        
        # è®¡ç®—AQIï¼ˆç®€åŒ–ç‰ˆï¼‰
        self.aqi = int(max(
            self._calculate_iaqi(pm25, 35, 75, 50, 100),
            self._calculate_iaqi(pm10, 50, 150, 50, 100),
            self._calculate_iaqi(no2, 40, 80, 50, 100)
        ))
        
        # ç¡®å®šç©ºæ°”è´¨é‡ç­‰çº§
        if self.aqi <= 50:
            self.quality_level = AirQualityLevel.EXCELLENT
        elif self.aqi <= 100:
            self.quality_level = AirQualityLevel.GOOD
        elif self.aqi <= 150:
            self.quality_level = AirQualityLevel.LIGHTLY_POLLUTED
        elif self.aqi <= 200:
            self.quality_level = AirQualityLevel.MODERATELY_POLLUTED
        else:
            self.quality_level = AirQualityLevel.HEAVILY_POLLUTED
            
        self.data_history.append({
            "timestamp": datetime.now(),
            "aqi": self.aqi,
            "pm25": pm25,
            "quality_level": self.quality_level.value
        })
        
    def _calculate_iaqi(self, cp: float, bp_low: float, bp_high: float,
                       iaqi_low: float, iaqi_high: float) -> float:
        """è®¡ç®—å•é¡¹IAQI"""
        if cp <= bp_low:
            return cp / bp_low * iaqi_low
        elif cp <= bp_high:
            return iaqi_low + (cp - bp_low) / (bp_high - bp_low) * (iaqi_high - iaqi_low)
        else:
            return iaqi_high + (cp - bp_high) / bp_high * 50
            
    def identify_pollution_source(self, wind_direction: float, wind_speed: float) -> Optional[Dict]:
        """è¯†åˆ«æ±¡æŸ“æºæ–¹å‘ï¼ˆåŸºäºé£åœºåæ¼”ï¼‰"""
        # ç®€åŒ–ç‰ˆæ±¡æŸ“æºå®šä½
        if self.quality_level in [AirQualityLevel.HEAVILY_POLLUTED, AirQualityLevel.MODERATELY_POLLUTED]:
            # å‡è®¾æ±¡æŸ“æºåœ¨ä¸Šé£å‘
            source_direction = (wind_direction + 180) % 360
            
            return {
                "station_id": self.station_id,
                "pollution_level": self.quality_level.value,
                "suspected_direction": source_direction,
                "suspected_distance_km": wind_speed * 2,  # å‡è®¾2å°æ—¶ä¼ è¾“
                "confidence": 0.7,
                "main_pollutant": "PM2.5" if self.pm25 > self.pm10 else "PM10"
            }
        return None


@dataclass
class Building:
    """å»ºç­‘æ•°å­—å­ªç”Ÿ"""
    building_id: str
    name: str
    location: GeoLocation
    building_type: str  # residential, commercial, industrial
    floor_area: float   # å¹³æ–¹ç±³
    
    # èƒ½è€—æ•°æ®
    current_power_kw: float = 0.0
    daily_energy_kwh: float = 0.0
    energy_history: deque = field(default_factory=lambda: deque(maxlen=365))
    
    # ç¯å¢ƒæ•°æ®
    indoor_temperature: float = 22.0
    occupancy: int = 0
    
    def update_energy(self, power_kw: float):
        """æ›´æ–°èƒ½è€—æ•°æ®"""
        self.current_power_kw = power_kw
        self.daily_energy_kwh += power_kw / 60  # å‡è®¾æ¯åˆ†é’Ÿæ›´æ–°ä¸€æ¬¡
        
    def calculate_energy_efficiency(self) -> float:
        """è®¡ç®—èƒ½æºæ•ˆç‡ï¼ˆkWh/mÂ²/dayï¼‰"""
        if self.floor_area == 0:
            return 0.0
        return self.daily_energy_kwh / self.floor_area
        
    def get_optimization_suggestions(self) -> List[str]:
        """è·å–èŠ‚èƒ½ä¼˜åŒ–å»ºè®®"""
        suggestions = []
        
        efficiency = self.calculate_energy_efficiency()
        
        # åŸºäºå»ºç­‘ç±»å‹çš„åŸºå‡†å¯¹æ¯”
        benchmarks = {
            "residential": 0.15,
            "commercial": 0.25,
            "industrial": 0.40
        }
        benchmark = benchmarks.get(self.building_type, 0.25)
        
        if efficiency > benchmark * 1.3:
            suggestions.append(f"èƒ½è€—åé«˜ï¼Œå»ºè®®è¿›è¡Œèƒ½æºå®¡è®¡")
            
        if self.indoor_temperature < 18 or self.indoor_temperature > 26:
            suggestions.append(f"å®¤å†…æ¸©åº¦{self.indoor_temperature}Â°Cä¸åœ¨èˆ’é€‚åŒºé—´ï¼Œå»ºè®®è°ƒæ•´ç©ºè°ƒè®¾ç½®")
            
        if self.occupancy == 0 and self.current_power_kw > 10:
            suggestions.append("å»ºç­‘æ— äººä½†èƒ½è€—è¾ƒé«˜ï¼Œå»ºè®®æ£€æŸ¥è®¾å¤‡çŠ¶æ€")
            
        return suggestions


class SmartCityDigitalTwin:
    """æ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿä¸»ç±»"""
    
    def __init__(self, city_name: str):
        self.city_name = city_name
        self.road_segments: Dict[str, RoadSegment] = {}
        self.monitor_stations: Dict[str, AirMonitorStation] = {}
        self.buildings: Dict[str, Building] = {}
        self.vehicles: Dict[str, Dict] = {}  # è½¦è¾†è¿½è¸ª
        
        # ç»Ÿè®¡æ•°æ®
        self.traffic_stats = defaultdict(lambda: deque(maxlen=1440))
        self.environment_stats = defaultdict(lambda: deque(maxlen=1440))
        
        self.running = False
        
    def add_road_segment(self, segment: RoadSegment):
        """æ·»åŠ é“è·¯æ®µ"""
        self.road_segments[segment.segment_id] = segment
        
    def add_monitor_station(self, station: AirMonitorStation):
        """æ·»åŠ ç›‘æµ‹ç«™"""
        self.monitor_stations[station.station_id] = station
        
    def add_building(self, building: Building):
        """æ·»åŠ å»ºç­‘"""
        self.buildings[building.building_id] = building
        
    async def start_simulation(self):
        """å¯åŠ¨åŸå¸‚ä»¿çœŸ"""
        self.running = True
        logger.info(f"Starting digital twin simulation for {self.city_name}")
        
        while self.running:
            try:
                # æ›´æ–°äº¤é€šçŠ¶æ€
                await self._update_traffic()
                
                # æ›´æ–°ç¯å¢ƒç›‘æµ‹
                await self._update_environment()
                
                # æ›´æ–°å»ºç­‘èƒ½è€—
                await self._update_buildings()
                
                # ç”ŸæˆåŸå¸‚æŠ¥å‘Š
                if datetime.now().minute == 0:  # æ¯å°æ—¶ç”ŸæˆæŠ¥å‘Š
                    self._generate_city_report()
                    
                await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ›´æ–°
                
            except Exception as e:
                logger.error(f"Simulation error: {e}")
                await asyncio.sleep(60)
                
    async def _update_traffic(self):
        """æ›´æ–°äº¤é€šçŠ¶æ€"""
        total_vehicles = sum(s.vehicle_count for s in self.road_segments.values())
        congested_roads = sum(1 for s in self.road_segments.values() 
                             if s.traffic_level in [TrafficLevel.MODERATE, TrafficLevel.HEAVY])
        
        self.traffic_stats["vehicle_count"].append((datetime.now(), total_vehicles))
        self.traffic_stats["congested_roads"].append((datetime.now(), congested_roads))
        
    async def _update_environment(self):
        """æ›´æ–°ç¯å¢ƒçŠ¶æ€"""
        if self.monitor_stations:
            avg_aqi = np.mean([s.aqi for s in self.monitor_stations.values()])
            self.environment_stats["avg_aqi"].append((datetime.now(), avg_aqi))
            
    async def _update_buildings(self):
        """æ›´æ–°å»ºç­‘çŠ¶æ€"""
        total_power = sum(b.current_power_kw for b in self.buildings.values())
        self.environment_stats["total_building_power"].append((datetime.now(), total_power))
        
    def _generate_city_report(self):
        """ç”ŸæˆåŸå¸‚è¿è¡ŒæŠ¥å‘Š"""
        report = self.get_city_overview()
        logger.info(f"City Report: {json.dumps(report, indent=2, default=str)}")
        
    def get_city_overview(self) -> Dict[str, Any]:
        """è·å–åŸå¸‚æ•´ä½“æ¦‚è§ˆ"""
        # äº¤é€šæ¦‚å†µ
        traffic_overview = self.get_traffic_overview()
        
        # ç¯å¢ƒæ¦‚å†µ
        environment_overview = self.get_environment_overview()
        
        # èƒ½æºæ¦‚å†µ
        energy_overview = self.get_energy_overview()
        
        return {
            "city_name": self.city_name,
            "timestamp": datetime.now().isoformat(),
            "traffic": traffic_overview,
            "environment": environment_overview,
            "energy": energy_overview
        }
        
    def get_traffic_overview(self) -> Dict[str, Any]:
        """è·å–äº¤é€šæ¦‚å†µ"""
        if not self.road_segments:
            return {}
            
        total_segments = len(self.road_segments)
        free_count = sum(1 for s in self.road_segments.values() if s.traffic_level == TrafficLevel.FREE)
        light_count = sum(1 for s in self.road_segments.values() if s.traffic_level == TrafficLevel.LIGHT)
        moderate_count = sum(1 for s in self.road_segments.values() if s.traffic_level == TrafficLevel.MODERATE)
        heavy_count = sum(1 for s in self.road_segments.values() if s.traffic_level == TrafficLevel.HEAVY)
        
        total_vehicles = sum(s.vehicle_count for s in self.road_segments.values())
        avg_speed = np.mean([s.current_speed for s in self.road_segments.values()])
        
        # è®¡ç®—æ‹¥å µæŒ‡æ•° (0-10)
        congestion_index = (moderate_count * 0.6 + heavy_count) / total_segments * 10
        
        return {
            "total_road_segments": total_segments,
            "total_vehicles": total_vehicles,
            "average_speed_kmh": round(avg_speed, 2),
            "congestion_index": round(congestion_index, 2),
            "traffic_distribution": {
                "free": free_count,
                "light": light_count,
                "moderate": moderate_count,
                "heavy": heavy_count
            },
            "congestion_hotspots": self._identify_congestion_hotspots()
        }
        
    def _identify_congestion_hotspots(self) -> List[Dict]:
        """è¯†åˆ«æ‹¥å µçƒ­ç‚¹"""
        hotspots = []
        for segment in self.road_segments.values():
            if segment.traffic_level == TrafficLevel.HEAVY:
                hotspots.append({
                    "segment_id": segment.segment_id,
                    "name": segment.name,
                    "current_speed": segment.current_speed,
                    "vehicle_count": segment.vehicle_count,
                    "location": {
                        "lat": (segment.start_point.latitude + segment.end_point.latitude) / 2,
                        "lon": (segment.start_point.longitude + segment.end_point.longitude) / 2
                    }
                })
        return sorted(hotspots, key=lambda x: x["current_speed"])[:10]
        
    def get_environment_overview(self) -> Dict[str, Any]:
        """è·å–ç¯å¢ƒæ¦‚å†µ"""
        if not self.monitor_stations:
            return {}
            
        avg_aqi = np.mean([s.aqi for s in self.monitor_stations.values()])
        max_aqi = max([s.aqi for s in self.monitor_stations.values()])
        min_aqi = min([s.aqi for s in self.monitor_stations.values()])
        
        quality_distribution = defaultdict(int)
        for s in self.monitor_stations.values():
            quality_distribution[s.quality_level.value] += 1
            
        return {
            "monitoring_stations": len(self.monitor_stations),
            "average_aqi": round(avg_aqi, 1),
            "max_aqi": max_aqi,
            "min_aqi": min_aqi,
            "overall_quality": self._get_overall_quality(avg_aqi),
            "quality_distribution": dict(quality_distribution),
            "pollution_alerts": self._check_pollution_alerts()
        }
        
    def _get_overall_quality(self, avg_aqi: float) -> str:
        """è·å–æ•´ä½“ç©ºæ°”è´¨é‡ç­‰çº§"""
        if avg_aqi <= 50:
            return "excellent"
        elif avg_aqi <= 100:
            return "good"
        elif avg_aqi <= 150:
            return "lightly_polluted"
        elif avg_aqi <= 200:
            return "moderately_polluted"
        else:
            return "heavily_polluted"
            
    def _check_pollution_alerts(self) -> List[Dict]:
        """æ£€æŸ¥æ±¡æŸ“å‘Šè­¦"""
        alerts = []
        for station in self.monitor_stations.values():
            if station.quality_level in [AirQualityLevel.HEAVILY_POLLUTED, AirQualityLevel.MODERATELY_POLLUTED]:
                alerts.append({
                    "station_id": station.station_id,
                    "station_name": station.name,
                    "aqi": station.aqi,
                    "level": station.quality_level.value,
                    "main_pollutant": "PM2.5" if station.pm25 > station.pm10 else "PM10"
                })
        return alerts
        
    def get_energy_overview(self) -> Dict[str, Any]:
        """è·å–èƒ½æºæ¦‚å†µ"""
        if not self.buildings:
            return {}
            
        total_power = sum(b.current_power_kw for b in self.buildings.values())
        total_daily_energy = sum(b.daily_energy_kwh for b in self.buildings.values())
        total_floor_area = sum(b.floor_area for b in self.buildings.values())
        
        avg_efficiency = total_daily_energy / total_floor_area if total_floor_area > 0 else 0
        
        # æŒ‰å»ºç­‘ç±»å‹ç»Ÿè®¡
        type_stats = defaultdict(lambda: {"count": 0, "power": 0, "area": 0})
        for b in self.buildings.values():
            type_stats[b.building_type]["count"] += 1
            type_stats[b.building_type]["power"] += b.current_power_kw
            type_stats[b.building_type]["area"] += b.floor_area
            
        return {
            "total_buildings": len(self.buildings),
            "total_power_mw": round(total_power / 1000, 2),
            "total_daily_energy_mwh": round(total_daily_energy / 1000, 2),
            "average_efficiency_kwh_per_m2": round(avg_efficiency, 3),
            "building_type_breakdown": dict(type_stats),
            "high_consumption_buildings": self._identify_high_consumption_buildings()
        }
        
    def _identify_high_consumption_buildings(self) -> List[Dict]:
        """è¯†åˆ«é«˜èƒ½è€—å»ºç­‘"""
        buildings_with_efficiency = [
            {
                "building_id": b.building_id,
                "name": b.name,
                "type": b.building_type,
                "efficiency": b.calculate_energy_efficiency(),
                "current_power_kw": b.current_power_kw
            }
            for b in self.buildings.values()
        ]
        return sorted(buildings_with_efficiency, key=lambda x: x["efficiency"], reverse=True)[:10]
        
    def stop_simulation(self):
        """åœæ­¢ä»¿çœŸ"""
        self.running = False
        logger.info(f"Stopped digital twin simulation for {self.city_name}")


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

def create_demo_city() -> SmartCityDigitalTwin:
    """åˆ›å»ºæ¼”ç¤ºåŸå¸‚"""
    city = SmartCityDigitalTwin("ç»¿åŸ")
    
    # æ·»åŠ é“è·¯æ®µ
    roads = [
        ("R001", "ä¸­å±±å¤§é“", (30.25, 120.15), (30.28, 120.18), 5.2, 6, 60),
        ("R002", "å»ºè®¾å¤§è¡—", (30.20, 120.10), (30.25, 120.15), 7.8, 8, 80),
        ("R003", "è§£æ”¾è·¯", (30.22, 120.12), (30.27, 120.17), 6.5, 4, 50),
        ("R004", "äººæ°‘è·¯", (30.18, 120.08), (30.24, 120.14), 8.2, 6, 60),
        ("R005", "æ»¨æ±Ÿå¤§é“", (30.28, 120.05), (30.32, 120.12), 10.5, 8, 80),
    ]
    
    for road_id, name, start, end, length, lanes, speed_limit in roads:
        segment = RoadSegment(
            segment_id=road_id,
            name=name,
            start_point=GeoLocation(start[0], start[1]),
            end_point=GeoLocation(end[0], end[1]),
            length_km=length,
            lanes=lanes,
            speed_limit=speed_limit
        )
        city.add_road_segment(segment)
    
    # æ·»åŠ ç©ºæ°”è´¨é‡ç›‘æµ‹ç«™
    stations = [
        ("S001", "å¸‚ä¸­å¿ƒç›‘æµ‹ç«™", 30.25, 120.15),
        ("S002", "å·¥ä¸šåŒºç›‘æµ‹ç«™", 30.18, 120.08),
        ("S003", "å…¬å›­ç›‘æµ‹ç«™", 30.28, 120.12),
        ("S004", "æœºåœºç›‘æµ‹ç«™", 30.32, 120.05),
    ]
    
    for station_id, name, lat, lon in stations:
        station = AirMonitorStation(
            station_id=station_id,
            name=name,
            location=GeoLocation(lat, lon)
        )
        city.add_monitor_station(station)
    
    # æ·»åŠ å»ºç­‘
    buildings = [
        ("B001", "ç»¿åŸå¤§å¦", "commercial", 50000, 30.25, 120.15),
        ("B002", "ç»¿åŸè´­ç‰©ä¸­å¿ƒ", "commercial", 80000, 30.24, 120.14),
        ("B003", "ç»¿åŸåŒ»é™¢", "commercial", 60000, 30.23, 120.13),
        ("B004", "é˜³å…‰å°åŒº", "residential", 120000, 30.26, 120.16),
        ("B005", "å·¥ä¸šå›­AåŒº", "industrial", 200000, 30.18, 120.08),
    ]
    
    for bld_id, name, btype, area, lat, lon in buildings:
        building = Building(
            building_id=bld_id,
            name=name,
            location=GeoLocation(lat, lon),
            building_type=btype,
            floor_area=area
        )
        city.add_building(building)
    
    return city


async def demo_simulation():
    """æ¼”ç¤ºä»¿çœŸ"""
    import random
    
    print("=" * 70)
    print("æ™ºæ…§åŸå¸‚æ•°å­—å­ªç”Ÿå¹³å°æ¼”ç¤º")
    print("=" * 70)
    
    # åˆ›å»ºåŸå¸‚
    city = create_demo_city()
    
    # æ¨¡æ‹Ÿæ•°æ®æ›´æ–°
    print("\nåˆå§‹åŒ–åŸå¸‚æ•°æ®...")
    
    # æ›´æ–°é“è·¯æ•°æ®
    for segment in city.road_segments.values():
        speed = random.uniform(20, segment.speed_limit)
        count = random.randint(50, 500)
        segment.update_traffic(speed, count)
    
    # æ›´æ–°ç›‘æµ‹ç«™æ•°æ®
    for station in city.monitor_stations.values():
        pm25 = random.uniform(10, 150)
        pm10 = random.uniform(20, 200)
        no2 = random.uniform(20, 80)
        so2 = random.uniform(5, 50)
        co = random.uniform(0.5, 2.0)
        o3 = random.uniform(30, 120)
        station.update_data(pm25, pm10, no2, so2, co, o3)
    
    # æ›´æ–°å»ºç­‘æ•°æ®
    for building in city.buildings.values():
        power = random.uniform(50, 500)
        building.update_energy(power)
    
    # ç”ŸæˆåŸå¸‚æ¦‚è§ˆ
    print("\n--- åŸå¸‚è¿è¡Œæ¦‚è§ˆ ---")
    overview = city.get_city_overview()
    
    print(f"\nã€äº¤é€šçŠ¶å†µã€‘")
    traffic = overview["traffic"]
    print(f"  é“è·¯æ€»æ•°: {traffic['total_road_segments']}")
    print(f"  è½¦è¾†æ€»æ•°: {traffic['total_vehicles']}")
    print(f"  å¹³å‡è½¦é€Ÿ: {traffic['average_speed_kmh']} km/h")
    print(f"  æ‹¥å µæŒ‡æ•°: {traffic['congestion_index']}/10")
    print(f"  æ‹¥å µçƒ­ç‚¹: {len(traffic['congestion_hotspots'])} å¤„")
    
    print(f"\nã€ç¯å¢ƒè´¨é‡ã€‘")
    env = overview["environment"]
    print(f"  ç›‘æµ‹ç«™ç‚¹: {env['monitoring_stations']}")
    print(f"  å¹³å‡AQI: {env['average_aqi']}")
    print(f"  æ•´ä½“è´¨é‡: {env['overall_quality']}")
    print(f"  æ±¡æŸ“å‘Šè­¦: {len(env['pollution_alerts'])} ä¸ª")
    
    print(f"\nã€èƒ½æºæ¶ˆè€—ã€‘")
    energy = overview["energy"]
    print(f"  å»ºç­‘æ€»æ•°: {energy['total_buildings']}")
    print(f"  æ€»åŠŸç‡: {energy['total_power_mw']} MW")
    print(f"  æ—¥è€—ç”µé‡: {energy['total_daily_energy_mwh']} MWh")
    print(f"  å¹³å‡èƒ½æ•ˆ: {energy['average_efficiency_kwh_per_m2']} kWh/mÂ²")
    
    # æ±¡æŸ“æºè¯†åˆ«ç¤ºä¾‹
    print("\n--- æ±¡æŸ“æºè¯†åˆ« ---")
    for station in city.monitor_stations.values():
        if station.quality_level != AirQualityLevel.EXCELLENT:
            source = station.identify_pollution_source(wind_direction=180, wind_speed=5)
            if source:
                print(f"\n  ç›‘æµ‹ç«™: {station.name}")
                print(f"  æ±¡æŸ“ç­‰çº§: {source['pollution_level']}")
                print(f"  ç–‘ä¼¼æ–¹å‘: {source['suspected_direction']}Â°")
                print(f"  ç–‘ä¼¼è·ç¦»: {source['suspected_distance_km']:.1f} km")
    
    print("\n" + "=" * 70)
    print("æ¼”ç¤ºå®Œæˆ")
    print("=" * 70)


if __name__ == "__main__":
    asyncio.run(demo_simulation())
```

### 3.6 æ•ˆæœè¯„ä¼°ä¸ROI

**æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”**ï¼š

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æå‡å¹…åº¦ |
|------|--------|--------|----------|
| äº¤é€šæ‹¥å µæŒ‡æ•° | 8.5 | 6.8 | **20%é™ä½** |
| å¹³å‡é€šå‹¤æ—¶é—´ | 92åˆ†é’Ÿ | 68åˆ†é’Ÿ | **26%ç¼©çŸ­** |
| ç©ºæ°”è´¨é‡ç›‘æµ‹è¦†ç›–ç‡ | 15% | 95% | **533%æå‡** |
| æ±¡æŸ“æºå®šä½æ—¶é—´ | 24-48å°æ—¶ | 1.5å°æ—¶ | **95%ç¼©çŸ­** |
| å»ºç­‘èƒ½è€— | åŸºå‡†å€¼ | -25% | **25%é™ä½** |
| åº”æ€¥å“åº”æ—¶é—´ | 32åˆ†é’Ÿ | 8åˆ†é’Ÿ | **75%ç¼©çŸ­** |

**æŠ•èµ„å›æŠ¥ç‡ï¼ˆROIï¼‰åˆ†æ**ï¼š

| é¡¹ç›® | å¹´åº¦æˆæœ¬/æ”¶ç›Šï¼ˆäº¿å…ƒï¼‰ | è¯´æ˜ |
|------|---------------------|------|
| **æ•°å­—å­ªç”Ÿå¹³å°å»ºè®¾** | -12.0 | å¹³å°è½¯ä»¶ã€ç¡¬ä»¶ã€ç½‘ç»œ |
| **ä¼ æ„Ÿå™¨ç½‘ç»œéƒ¨ç½²** | -8.5 | IoTè®¾å¤‡ã€é€šä¿¡ç½‘ç»œ |
| **æ•°æ®ä¸­å¿ƒå»ºè®¾** | -15.0 | äº‘è®¡ç®—ã€å­˜å‚¨ã€å®‰å…¨ |
| **è¿è¥ç»´æŠ¤æˆæœ¬** | -3.5 | äººå‘˜ã€èƒ½è€—ã€è½¯ä»¶æ›´æ–° |
| **äº¤é€šæ•ˆç‡æå‡æ”¶ç›Š** | +28.0 | å‡å°‘æ‹¥å µæ—¶é—´ä»·å€¼ |
| **ç¯ä¿æ‰§æ³•æ•ˆç‡** | +6.5 | ç½šæ¬¾å¢åŠ +æ²»ç†æˆæœ¬é™ä½ |
| **èŠ‚èƒ½å‡æ’æ”¶ç›Š** | +12.0 | èƒ½æºæˆæœ¬é™ä½+ç¢³äº¤æ˜“ |
| **åº”æ€¥æŸå¤±å‡å°‘** | +8.0 | å‡å°‘çªå‘äº‹ä»¶æŸå¤± |
| **äº§ä¸šå¸¦åŠ¨æ•ˆåº”** | +20.0 | æ™ºæ…§åŸå¸‚ç›¸å…³äº§ä¸šå‘å±• |
| **å¹´åº¦å‡€æ”¶ç›Š** | **+35.5** | |
| **5å¹´ROI** | **59%** | è€ƒè™‘ç¤¾ä¼šæ•ˆç›Šæ›´é«˜ |

---

## 4. æ¡ˆä¾‹3ï¼šæ™ºèƒ½å»ºç­‘æ•°å­—å­ªç”Ÿ

*ï¼ˆä¿ç•™åŸæœ‰å†…å®¹ç»“æ„ï¼Œå¯åç»­è¡¥å……è¯¦ç»†å†…å®¹ï¼‰*

## 5. æ¡ˆä¾‹æ€»ç»“

### 5.1 æ¡ˆä¾‹å¯¹æ¯”

| æ¡ˆä¾‹ | åº”ç”¨é¢†åŸŸ | æ•°æ®è§„æ¨¡ | å®æ—¶æ€§è¦æ±‚ | æ ¸å¿ƒæŠ€æœ¯ | å®æ–½å‘¨æœŸ | ROI |
|------|---------|---------|-----------|---------|---------|-----|
| **æ™ºèƒ½åˆ¶é€ ** | æ±½è½¦é›¶ä»¶ | 50GB/å¤© | æ¯«ç§’çº§ | ç‰©ç†å»ºæ¨¡ã€é¢„æµ‹ç®—æ³• | 18ä¸ªæœˆ | 354% |
| **æ™ºæ…§åŸå¸‚** | åŸå¸‚æ²»ç† | 10TB/å¤© | ç§’çº§ | å¤§è§„æ¨¡ä»¿çœŸã€æ•°æ®èåˆ | 36ä¸ªæœˆ | 59% |
| **æ™ºèƒ½å»ºç­‘** | æ¥¼å®‡ç®¡ç† | 10GB/å¤© | ç§’çº§ | BIMé›†æˆã€èƒ½æºä¼˜åŒ– | 12ä¸ªæœˆ | 180% |

### 5.2 æœ€ä½³å®è·µ

**å®è·µ1ï¼šæ•°æ®æ²»ç†å…ˆè¡Œ**

- å»ºç«‹ç»Ÿä¸€çš„æ•°æ®æ ‡å‡†å’Œè§„èŒƒ
- æ„å»ºæ•°æ®ä¸­å°ï¼Œå®ç°æ•°æ®èµ„äº§åŒ–ç®¡ç†
- å®æ–½æ•°æ®è´¨é‡ç›‘æ§å’Œæ²»ç†

**å®è·µ2ï¼šæ¸è¿›å¼å»ºè®¾**

- ä»å•ç‚¹çªç ´å¼€å§‹ï¼Œé€æ­¥æ‰©å±•
- å…ˆå»ºè®¾MVPï¼ŒéªŒè¯ä»·å€¼åå†æ‰©å¤§è§„æ¨¡
- åˆ†é˜¶æ®µæŠ•èµ„ï¼Œæ§åˆ¶é£é™©

**å®è·µ3ï¼šä¸šåŠ¡ä¸æŠ€æœ¯èåˆ**

- ä¸šåŠ¡ä¸“å®¶æ·±åº¦å‚ä¸æ¨¡å‹è®¾è®¡
- å»ºç«‹è·¨éƒ¨é—¨åä½œæœºåˆ¶
- æŒç»­è¿­ä»£ä¼˜åŒ–æ¨¡å‹ç²¾åº¦

**å®è·µ4ï¼šå®‰å…¨ä¸éšç§ä¿æŠ¤**

- å»ºç«‹æ•°æ®å®‰å…¨åˆ†çº§ä¿æŠ¤æœºåˆ¶
- å®æ–½éšç§è®¡ç®—å’Œè„±æ•å¤„ç†
- å®šæœŸè¿›è¡Œå®‰å…¨å®¡è®¡

---

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv2.0
**ç»´æŠ¤è€…**ï¼šDSL Schemaç ”ç©¶å›¢é˜Ÿ

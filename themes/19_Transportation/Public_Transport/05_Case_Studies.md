# å…¬å…±äº¤é€šæ¡ˆä¾‹ç ”ç©¶

## æ¡ˆä¾‹ä¸€ï¼šæ·±åœ³å…¬äº¤é›†å›¢æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ

### 1. ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šæ·±åœ³å·´å£«é›†å›¢è‚¡ä»½æœ‰é™å…¬å¸  
**è¡Œä¸šé¢†åŸŸ**ï¼šåŸå¸‚å…¬å…±äº¤é€šæœåŠ¡  
**è¿è¥è§„æ¨¡**ï¼šè¶…è¿‡12,000è¾†å…¬äº¤è½¦ï¼Œ1,200+æ¡å…¬äº¤çº¿è·¯  
**æ—¥å‡å®¢è¿é‡**ï¼šè¶…è¿‡600ä¸‡äººæ¬¡  
**æœåŠ¡åŒºåŸŸ**ï¼šæ·±åœ³å¸‚å…¨åŸŸï¼Œè¦†ç›–ç¦ç”°ã€å—å±±ã€ç½—æ¹–ã€å®å®‰ã€é¾™å²—ç­‰10ä¸ªè¡Œæ”¿åŒº

æ·±åœ³å…¬äº¤é›†å›¢æ˜¯ä¸­å›½æœ€å¤§çš„åŸå¸‚å…¬äº¤è¿è¥ä¼ä¸šä¹‹ä¸€ï¼Œæ‰¿æ‹…ç€æ·±åœ³å¸‚æ°‘æ—¥å¸¸å‡ºè¡Œçš„é‡è¦ä½¿å‘½ã€‚éšç€åŸå¸‚æ‰©å¼ å’Œäººå£å¢é•¿ï¼Œä¼ ç»Ÿçš„äººå·¥è°ƒåº¦æ¨¡å¼å·²æ— æ³•æ»¡è¶³å¤æ‚çš„å…¬äº¤è¿è¥éœ€æ±‚ã€‚é«˜å³°æœŸè½¦è¾†æ‹¥æŒ¤ã€å¹³å³°æœŸç©ºé©¶ç‡é«˜ã€ä¹˜å®¢ç­‰å€™æ—¶é—´é•¿ç­‰é—®é¢˜æ—¥ç›Šçªå‡ºï¼ŒäºŸéœ€æ„å»ºæ™ºèƒ½åŒ–çš„å…¬äº¤è°ƒåº¦ç³»ç»Ÿã€‚

#### ä¸šåŠ¡ç—›ç‚¹

1. **ä¾›éœ€ä¸åŒ¹é…ä¸¥é‡**ï¼šæ—©æ™šé«˜å³°éƒ¨åˆ†çº¿è·¯æ‹¥æŒ¤åº¦è¶…è¿‡120%ï¼Œè€Œå¹³å³°æœŸç©ºé©¶ç‡é«˜è¾¾35%ï¼Œè¿åŠ›åˆ†é…ä¸¥é‡å¤±è¡¡
2. **è°ƒåº¦å“åº”æ»å**ï¼šäººå·¥è°ƒåº¦ä¾èµ–ç»éªŒåˆ¤æ–­ï¼Œçªå‘å¤§å®¢æµå“åº”æ—¶é—´è¶…è¿‡20åˆ†é’Ÿï¼Œæ— æ³•åŠæ—¶è°ƒæ•´è¿åŠ›
3. **ä¹˜å®¢ä½“éªŒå·®**ï¼šé«˜å³°æœŸä¹˜å®¢å¹³å‡ç­‰å€™æ—¶é—´è¶…è¿‡15åˆ†é’Ÿï¼Œè½¦å†…æ‹¥æŒ¤èˆ’é€‚åº¦å·®ï¼ŒæŠ•è¯‰ç‡å±…é«˜ä¸ä¸‹
4. **èƒ½æºæ¶ˆè€—é«˜**ï¼šè½¦è¾†ç©ºé©¶å’Œæ€ é€Ÿæ—¶é—´é•¿ï¼Œå•è½¦ç™¾å…¬é‡Œèƒ½è€—é«˜äºè¡Œä¸šå¹³å‡æ°´å¹³18%
5. **å®‰å…¨ç›‘æ§è–„å¼±**ï¼šé©¾é©¶å‘˜ç–²åŠ³é©¾é©¶ã€è¿è§„æ“ä½œéš¾ä»¥åŠæ—¶å‘ç°ï¼Œå¹´å®‰å…¨äº‹æ•…è¶…è¿‡200èµ·

#### ä¸šåŠ¡ç›®æ ‡

1. **ç²¾å‡†è¿åŠ›åŒ¹é…**ï¼šå®ç°åŸºäºå®æ—¶å®¢æµçš„åŠ¨æ€å‘è½¦è°ƒåº¦ï¼Œå°†é«˜å³°æœŸæ‹¥æŒ¤åº¦æ§åˆ¶åœ¨85%ä»¥å†…
2. **ç¼©çŸ­ç­‰å€™æ—¶é—´**ï¼šå°†ä¹˜å®¢å¹³å‡ç­‰å€™æ—¶é—´ä»15åˆ†é’Ÿç¼©çŸ­è‡³8åˆ†é’Ÿä»¥å†…
3. **é™ä½ç©ºé©¶ç‡**ï¼šé€šè¿‡æ™ºèƒ½è°ƒåº¦å°†å¹³å³°æœŸç©ºé©¶ç‡ä»35%é™ä½è‡³15%ä»¥ä¸‹
4. **èŠ‚èƒ½å‡æ’**ï¼šä¼˜åŒ–è¡Œé©¶ç­–ç•¥ï¼Œå®ç°å•è½¦èƒ½è€—é™ä½20%ä»¥ä¸Š
5. **æå‡å®‰å…¨æ°´å¹³**ï¼šå»ºç«‹å…¨æ–¹ä½å®‰å…¨ç›‘æ§ä½“ç³»ï¼Œå°†äº‹æ•…ç‡é™ä½40%ä»¥ä¸Š

---

### 2. æŠ€æœ¯æŒ‘æˆ˜

#### æŒ‘æˆ˜ä¸€ï¼šå¤§è§„æ¨¡å®æ—¶å®¢æµé¢„æµ‹

æ—¥å‡600ä¸‡äººæ¬¡çš„å®¢æµï¼Œåˆ†å¸ƒåœ¨1,200æ¡çº¿è·¯ã€è¶…è¿‡10,000ä¸ªç«™ç‚¹ã€‚éœ€è¦æ„å»ºé«˜ç²¾åº¦çš„çŸ­æ—¶å®¢æµé¢„æµ‹æ¨¡å‹ï¼Œå‡†ç¡®é¢„æµ‹æœªæ¥15-60åˆ†é’Ÿå„ç«™ç‚¹ä¸Šä¸‹å®¢äººæ•°ï¼Œä¸ºè°ƒåº¦å†³ç­–æä¾›ä¾æ®ã€‚

#### æŒ‘æˆ˜äºŒï¼šå¤šç›®æ ‡åŠ¨æ€è°ƒåº¦ä¼˜åŒ–

å…¬äº¤è°ƒåº¦éœ€è¦åŒæ—¶ä¼˜åŒ–å¤šä¸ªç›®æ ‡ï¼šå‡å°‘ä¹˜å®¢ç­‰å€™æ—¶é—´ã€é™ä½è¿è¥æˆæœ¬ã€ä¿è¯æœåŠ¡è´¨é‡ã€å‡å°‘è½¦è¾†ç©ºé©¶ç­‰ã€‚è¿™äº›ç›®æ ‡ä¹‹é—´å­˜åœ¨å†²çªï¼Œéœ€è¦åœ¨å®æ—¶æ€§å’Œæœ€ä¼˜æ€§ä¹‹é—´å–å¾—å¹³è¡¡ã€‚

#### æŒ‘æˆ˜ä¸‰ï¼šå¤šæ¨¡å¼å…¬äº¤ååŒ

æ·±åœ³æ‹¥æœ‰å¸¸è§„å…¬äº¤ã€BRTå¿«é€Ÿå…¬äº¤ã€å¾®å¾ªç¯å·´å£«ã€å®šåˆ¶å…¬äº¤ç­‰å¤šç§æ¨¡å¼ã€‚å¦‚ä½•å®ç°ä¸åŒæ¨¡å¼é—´çš„æ— ç¼è¡”æ¥å’ŒååŒè°ƒåº¦ï¼Œæå‡æ•´ä½“å…¬äº¤ç½‘ç»œæ•ˆç‡æ˜¯å…³é”®æŒ‘æˆ˜ã€‚

#### æŒ‘æˆ˜å››ï¼šå¤§è§„æ¨¡GPSå®æ—¶å¤„ç†

12,000è¾†å…¬äº¤è½¦æ¯10ç§’ä¸ŠæŠ¥GPSä½ç½®ï¼Œæ—¥å‡äº§ç”Ÿè¶…è¿‡1äº¿æ¡è½¨è¿¹æ•°æ®ã€‚éœ€è¦æ„å»ºé«˜å¹¶å‘ã€ä½å»¶è¿Ÿçš„æµå¤„ç†æ¶æ„ï¼Œæ”¯æŒå®æ—¶ä½ç½®è¿½è¸ªã€åˆ°ç«™é¢„æµ‹ã€å¼‚å¸¸æ£€æµ‹ç­‰åŠŸèƒ½ã€‚

#### æŒ‘æˆ˜äº”ï¼šæ™ºèƒ½ä¿¡å·ä¼˜å…ˆ

ä¸äº¤ç®¡éƒ¨é—¨åˆä½œï¼Œå®ç°å…¬äº¤ä¿¡å·ä¼˜å…ˆã€‚éœ€è¦æ ¹æ®å…¬äº¤è½¦å®æ—¶ä½ç½®ã€è½½å®¢æƒ…å†µã€æ™šç‚¹ç¨‹åº¦ç­‰å› ç´ ï¼ŒåŠ¨æ€è¯·æ±‚ç»¿ç¯å»¶é•¿æˆ–çº¢ç¯ç¼©çŸ­ï¼Œæœ€å¤§åŒ–å…¬äº¤é€šè¡Œæ•ˆç‡ã€‚

---

### 3. ä»£ç å®ç°

```python
"""
æ·±åœ³å…¬äº¤é›†å›¢æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ - æ ¸å¿ƒæ¨¡å—å®ç°
åŒ…å«ï¼šå®¢æµé¢„æµ‹ã€æ™ºèƒ½è°ƒåº¦ã€åˆ°ç«™é¢„æµ‹ã€ä¿¡å·ä¼˜å…ˆã€å®‰å…¨ç›‘æ§
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
from typing import List, Dict, Tuple, Optional, Set
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict, deque
import heapq
import json
from abc import ABC, abstractmethod
import warnings
warnings.filterwarnings('ignore')


class BusStatus(Enum):
    """å…¬äº¤è½¦è¾†çŠ¶æ€"""
    IDLE = "idle"                # å¾…å‘
    IN_SERVICE = "in_service"    # è¿è¥ä¸­
    AT_STOP = "at_stop"          # åˆ°ç«™åœé 
    DELAYED = "delayed"          # æ™šç‚¹
    OUT_OF_SERVICE = "out_of_service"  # åœè¿
    MAINTENANCE = "maintenance"  # ç»´ä¿


class AlertType(Enum):
    """å‘Šè­¦ç±»å‹"""
    OVERCROWDING = "overcrowding"      # è¿‡åº¦æ‹¥æŒ¤
    DELAY = "delay"                    # è½¦è¾†æ™šç‚¹
    SKIPPED_STOP = "skipped_stop"      # è·³ç«™
    DRIVER_FATIGUE = "driver_fatigue"  # ç–²åŠ³é©¾é©¶
    EMERGENCY = "emergency"            # ç´§æ€¥æƒ…å†µ


@dataclass
class GPSPoint:
    """GPSè½¨è¿¹ç‚¹"""
    bus_id: str
    route_id: str
    timestamp: datetime
    latitude: float
    longitude: float
    speed: float           # km/h
    direction: float       # è¡Œé©¶æ–¹å‘è§’åº¦
    
    def to_dict(self) -> Dict:
        return {
            'bus_id': self.bus_id,
            'route_id': self.route_id,
            'timestamp': self.timestamp.isoformat(),
            'latitude': self.latitude,
            'longitude': self.longitude,
            'speed': self.speed
        }


@dataclass
class BusStop:
    """å…¬äº¤ç«™ç‚¹"""
    stop_id: str
    stop_name: str
    latitude: float
    longitude: float
    routes: Set[str] = field(default_factory=set)  # ç»è¿‡è¯¥ç«™ç‚¹çš„çº¿è·¯
    avg_boarding: float = 0.0      # å¹³å‡ä¸Šè½¦äººæ•°
    avg_alighting: float = 0.0     # å¹³å‡ä¸‹è½¦äººæ•°
    
    def get_transfer_routes(self) -> Set[str]:
        """è·å–å¯æ¢ä¹˜çº¿è·¯"""
        return self.routes


@dataclass
class Bus:
    """å…¬äº¤è½¦è¾†"""
    bus_id: str
    route_id: str
    capacity: int = 80             # æ ¸å®šè½½å®¢æ•°
    current_passengers: int = 0    # å½“å‰è½½å®¢æ•°
    status: BusStatus = BusStatus.IDLE
    current_location: Optional[GPSPoint] = None
    next_stop_index: int = 0       # ä¸‹ä¸€ç«™ç´¢å¼•
    schedule_deviation: int = 0    # ä¸è®¡åˆ’åå·®ï¼ˆç§’ï¼‰
    driver_id: Optional[str] = None
    fuel_level: float = 100.0      # æ²¹é‡%
    
    def get_load_factor(self) -> float:
        """è·å–æ»¡è½½ç‡"""
        return self.current_passengers / self.capacity if self.capacity > 0 else 0
    
    def is_overcrowded(self, threshold: float = 0.85) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ‹¥æŒ¤"""
        return self.get_load_factor() > threshold


@dataclass
class Route:
    """å…¬äº¤çº¿è·¯"""
    route_id: str
    route_name: str
    route_type: str = "regular"    # regular/btr/micro/custom
    stops: List[BusStop] = field(default_factory=list)
    distance_km: float = 0.0
    base_interval_minutes: int = 10  # åŸºç¡€å‘è½¦é—´éš”
    operating_hours: Tuple[int, int] = (5, 23)  # è¿è¥æ—¶é—´
    fleet_size: int = 20           # é…è½¦æ•°
    
    def get_stop_distance(self, from_idx: int, to_idx: int) -> float:
        """è®¡ç®—ç«™ç‚¹é—´è·ç¦»"""
        if from_idx < 0 or to_idx >= len(self.stops):
            return 0.0
        # ç®€åŒ–çš„è·ç¦»è®¡ç®—
        return abs(to_idx - from_idx) * (self.distance_km / max(len(self.stops) - 1, 1))


@dataclass
class PassengerFlow:
    """å®¢æµæ•°æ®"""
    route_id: str
    stop_id: str
    timestamp: datetime
    boarding: int = 0              # ä¸Šè½¦äººæ•°
    alighting: int = 0             # ä¸‹è½¦äººæ•°
    load_factor: float = 0.0       # è½¦å¢æ»¡è½½ç‡


class PassengerFlowPredictor:
    """å®¢æµé¢„æµ‹å™¨"""
    
    def __init__(self):
        self.historical_patterns: Dict = {}  # å†å²å®¢æµæ¨¡å¼
        self.special_events: Dict = {}       # ç‰¹æ®Šäº‹ä»¶ï¼ˆèŠ‚å‡æ—¥ã€å¤§å‹æ´»åŠ¨ç­‰ï¼‰
        self.prediction_cache: Dict = {}     # é¢„æµ‹ç¼“å­˜
    
    def train(self, historical_data: List[PassengerFlow]):
        """è®­ç»ƒé¢„æµ‹æ¨¡å‹"""
        # æŒ‰è·¯çº¿ã€ç«™ç‚¹ã€æ—¶é—´æ®µèšåˆå†å²æ•°æ®
        for flow in historical_data:
            key = (flow.route_id, flow.stop_id, flow.timestamp.hour)
            if key not in self.historical_patterns:
                self.historical_patterns[key] = {
                    'boarding': [],
                    'alighting': [],
                    'load_factors': []
                }
            self.historical_patterns[key]['boarding'].append(flow.boarding)
            self.historical_patterns[key]['alighting'].append(flow.alighting)
            self.historical_patterns[key]['load_factors'].append(flow.load_factor)
    
    def predict_flow(self, route_id: str, stop_id: str, 
                    target_time: datetime, horizon_minutes: int = 30) -> Dict:
        """
        é¢„æµ‹æŒ‡å®šç«™ç‚¹æœªæ¥å®¢æµ
        è¿”å›: {'boarding': int, 'alighting': int, 'confidence': float}
        """
        # è·å–å†å²åŒæœŸæ•°æ®
        hour = target_time.hour
        key = (route_id, stop_id, hour)
        
        if key not in self.historical_patterns:
            # æ— å†å²æ•°æ®æ—¶è¿”å›é»˜è®¤å€¼
            return {'boarding': 10, 'alighting': 10, 'confidence': 0.5}
        
        pattern = self.historical_patterns[key]
        
        # è®¡ç®—ç»Ÿè®¡ç‰¹å¾
        avg_boarding = np.mean(pattern['boarding'])
        avg_alighting = np.mean(pattern['alighting'])
        std_boarding = np.std(pattern['boarding'])
        
        # æ—¶é—´è¡°å‡å› å­ï¼ˆè¶Šè¿‘è¶Šç›¸å…³ï¼‰
        time_factor = 1.0
        if 7 <= hour <= 9 or 17 <= hour <= 19:  # é«˜å³°æœŸ
            time_factor = 1.5
        elif 10 <= hour <= 16:  # å¹³å³°æœŸ
            time_factor = 0.7
        
        # ç‰¹æ®Šäº‹ä»¶è°ƒæ•´
        if self._is_special_event(target_time):
            time_factor *= 1.3
        
        predicted_boarding = int(avg_boarding * time_factor)
        predicted_alighting = int(avg_alighting * time_factor)
        
        # ç½®ä¿¡åº¦è®¡ç®—ï¼ˆæ•°æ®è¶Šå¤šè¶Šå¯é ï¼‰
        confidence = min(0.95, 0.5 + len(pattern['boarding']) * 0.01)
        
        return {
            'boarding': predicted_boarding,
            'alighting': predicted_alighting,
            'confidence': confidence,
            'std_boarding': std_boarding
        }
    
    def predict_route_demand(self, route_id: str, 
                            target_time: datetime,
                            horizon_minutes: int = 30) -> Dict:
        """é¢„æµ‹æ•´æ¡çº¿è·¯çš„å®¢æµéœ€æ±‚"""
        # è·å–çº¿è·¯æ‰€æœ‰ç«™ç‚¹çš„é¢„æµ‹
        total_boarding = 0
        max_load_factor = 0.0
        
        # ç®€åŒ–ä¸ºå‡è®¾çº¿è·¯æœ‰20ä¸ªç«™ç‚¹
        for i in range(20):
            stop_id = f"{route_id}_STOP_{i:03d}"
            prediction = self.predict_flow(route_id, stop_id, target_time, horizon_minutes)
            total_boarding += prediction['boarding']
            max_load_factor = max(max_load_factor, prediction.get('load_factor', 0.5))
        
        # ä¼°ç®—æ‰€éœ€è¿åŠ›
        required_capacity = int(total_boarding * 1.2)  # 20%å†—ä½™
        required_buses = max(1, required_capacity // 60)  # å‡è®¾å•è½¦è½½å®¢60äºº
        
        return {
            'total_demand': total_boarding,
            'required_buses': required_buses,
            'peak_load_factor': max_load_factor,
            'recommended_interval': max(5, 30 // required_buses)  # å»ºè®®å‘è½¦é—´éš”
        }
    
    def _is_special_event(self, date: datetime) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºç‰¹æ®Šæ—¥æœŸ"""
        # å‘¨æœ«
        if date.weekday() >= 5:
            return True
        # èŠ‚å‡æ—¥ï¼ˆç®€åŒ–å¤„ç†ï¼‰
        return False


class BusScheduler:
    """å…¬äº¤è°ƒåº¦ä¼˜åŒ–å™¨"""
    
    def __init__(self, flow_predictor: PassengerFlowPredictor):
        self.flow_predictor = flow_predictor
        self.routes: Dict[str, Route] = {}
        self.buses: Dict[str, Bus] = {}
        self.active_trips: Dict[str, Dict] = {}  # æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
        self.dispatch_queue: List[Dict] = []     # å¾…å‘è½¦è¾†é˜Ÿåˆ—
    
    def add_route(self, route: Route):
        """æ·»åŠ çº¿è·¯"""
        self.routes[route.route_id] = route
    
    def add_bus(self, bus: Bus):
        """æ·»åŠ è½¦è¾†"""
        self.buses[bus.bus_id] = bus
    
    def optimize_dispatch(self, route_id: str, 
                         current_time: datetime) -> List[Dict]:
        """
        ä¼˜åŒ–æŒ‡å®šçº¿è·¯çš„å‘è½¦è°ƒåº¦
        è¿”å›è°ƒåº¦æŒ‡ä»¤åˆ—è¡¨
        """
        route = self.routes.get(route_id)
        if not route:
            return []
        
        # é¢„æµ‹æœªæ¥30åˆ†é’Ÿå®¢æµéœ€æ±‚
        demand = self.flow_predictor.predict_route_demand(
            route_id, current_time, 30
        )
        
        # è·å–å½“å‰åœ¨çº¿è½¦è¾†
        active_buses = [
            b for b in self.buses.values()
            if b.route_id == route_id and b.status in [BusStatus.IN_SERVICE, BusStatus.AT_STOP]
        ]
        
        # è®¡ç®—å½“å‰è¿åŠ›ä¾›ç»™
        current_supply = sum(b.capacity * 0.7 for b in active_buses)  # æŒ‰70%åˆ©ç”¨ç‡
        
        # ä¾›éœ€å·®è·
        supply_gap = demand['total_demand'] - current_supply
        
        dispatch_plan = []
        
        # å¦‚æœä¾›ä¸åº”æ±‚ï¼Œå¢åŠ å‘è½¦
        if supply_gap > 0:
            additional_buses_needed = int(supply_gap / 60) + 1
            available_buses = [
                b for b in self.buses.values()
                if b.route_id == route_id and b.status == BusStatus.IDLE
            ][:additional_buses_needed]
            
            for i, bus in enumerate(available_buses):
                dispatch_plan.append({
                    'action': 'dispatch',
                    'bus_id': bus.bus_id,
                    'route_id': route_id,
                    'departure_time': current_time + timedelta(minutes=i * demand['recommended_interval']),
                    'reason': f'å®¢æµé¢„æµ‹éœ€æ±‚å¢åŠ ï¼Œéœ€è¡¥å……è¿åŠ›'
                })
        
        # æ£€æŸ¥æ˜¯å¦æœ‰è½¦è¾†æ™šç‚¹ä¸¥é‡ï¼Œéœ€è¦è°ƒæ•´
        for bus in active_buses:
            if bus.schedule_deviation > 300:  # æ™šç‚¹è¶…è¿‡5åˆ†é’Ÿ
                dispatch_plan.append({
                    'action': 'adjust_speed',
                    'bus_id': bus.bus_id,
                    'suggestion': 'skip_less_critical_stops',  # å»ºè®®è·³ç«™
                    'reason': f'è½¦è¾†æ™šç‚¹ {bus.schedule_deviation} ç§’'
                })
        
        return dispatch_plan
    
    def handle_overcrowding(self, bus_id: str) -> Dict:
        """å¤„ç†è½¦è¾†è¿‡åº¦æ‹¥æŒ¤æƒ…å†µ"""
        bus = self.buses.get(bus_id)
        if not bus or not bus.is_overcrowded():
            return {}
        
        route = self.routes.get(bus.route_id)
        
        # å¯»æ‰¾å‰æ–¹çŸ­é©³è½¦è¾†
        relief_bus = self._find_relief_bus(bus.route_id, bus.current_location)
        
        return {
            'alert_type': AlertType.OVERCROWDING.value,
            'bus_id': bus_id,
            'current_load': bus.current_passengers,
            'load_factor': bus.get_load_factor(),
            'suggested_actions': [
                'notify_passengers_to_wait',
                'dispatch_relief_bus' if relief_bus else 'increase_frequency',
                'request_signal_priority'
            ],
            'relief_bus_id': relief_bus.bus_id if relief_bus else None
        }
    
    def _find_relief_bus(self, route_id: str, 
                        location: GPSPoint) -> Optional[Bus]:
        """å¯»æ‰¾æ”¯æ´è½¦è¾†"""
        # å¯»æ‰¾åŒçº¿è·¯ç©ºé—²è½¦è¾†
        candidates = [
            b for b in self.buses.values()
            if b.route_id == route_id and b.status == BusStatus.IDLE
        ]
        
        if candidates:
            return candidates[0]
        return None
    
    def calculate_headway_adherence(self, route_id: str) -> float:
        """è®¡ç®—å‘è½¦é—´éš”éµå®ˆç‡"""
        route_buses = [b for b in self.buses.values() if b.route_id == route_id]
        
        if len(route_buses) < 2:
            return 100.0
        
        # ç®€åŒ–çš„é—´éš”è®¡ç®—
        actual_intervals = []
        sorted_buses = sorted(route_buses, 
                            key=lambda b: b.current_location.timestamp if b.current_location else datetime.min)
        
        for i in range(1, len(sorted_buses)):
            if sorted_buses[i].current_location and sorted_buses[i-1].current_location:
                time_diff = (sorted_buses[i].current_location.timestamp - 
                           sorted_buses[i-1].current_location.timestamp).total_seconds() / 60
                actual_intervals.append(time_diff)
        
        if not actual_intervals:
            return 100.0
        
        target_interval = self.routes[route_id].base_interval_minutes
        adherence_scores = [
            max(0, 100 - abs(actual - target_interval) / target_interval * 100)
            for actual in actual_intervals
        ]
        
        return np.mean(adherence_scores)


class ArrivalTimePredictor:
    """åˆ°ç«™æ—¶é—´é¢„æµ‹å™¨"""
    
    def __init__(self):
        self.traffic_patterns: Dict = {}
        self.historical_travel_times: Dict = defaultdict(list)
    
    def predict_arrival(self, bus: Bus, target_stop_idx: int,
                       current_time: datetime) -> Dict:
        """
        é¢„æµ‹åˆ°è¾¾æŒ‡å®šç«™ç‚¹çš„æ—¶é—´
        è¿”å›: {'estimated_arrival': datetime, 'confidence': float, 'delay_risk': str}
        """
        route = bus.route_id
        current_idx = bus.next_stop_index
        
        if current_idx >= target_stop_idx:
            return {
                'estimated_arrival': current_time,
                'confidence': 1.0,
                'delay_risk': 'none'
            }
        
        # è®¡ç®—å‰©ä½™è·ç¦»
        stops_to_travel = target_stop_idx - current_idx
        avg_speed = self._get_historical_speed(route, current_time.hour)
        
        # è€ƒè™‘å®æ—¶äº¤é€š
        traffic_factor = self._get_traffic_factor(route, current_time)
        effective_speed = avg_speed * traffic_factor
        
        # è®¡ç®—è¡Œé©¶æ—¶é—´ï¼ˆç®€åŒ–ï¼šæ¯ç«™ä¹‹é—´çº¦2åˆ†é’Ÿï¼‰
        base_travel_time = stops_to_travel * 2  # åˆ†é’Ÿ
        adjusted_travel_time = base_travel_time / traffic_factor
        
        # æ·»åŠ åœé æ—¶é—´
        dwell_time = stops_to_travel * 0.5  # æ¯ç«™åœé 30ç§’
        
        total_minutes = adjusted_travel_time + dwell_time
        estimated_arrival = current_time + timedelta(minutes=total_minutes)
        
        # ç½®ä¿¡åº¦ï¼ˆåŸºäºå†å²æ•°æ®é‡ï¼‰
        confidence = min(0.95, 0.7 + len(self.historical_travel_times[route]) * 0.001)
        
        # æ™šç‚¹é£é™©è¯„ä¼°
        delay_risk = 'low'
        if traffic_factor < 0.6:  # ä¸¥é‡æ‹¥å µ
            delay_risk = 'high'
        elif traffic_factor < 0.8:
            delay_risk = 'medium'
        
        return {
            'estimated_arrival': estimated_arrival,
            'confidence': confidence,
            'delay_risk': delay_risk,
            'travel_time_minutes': total_minutes
        }
    
    def _get_historical_speed(self, route_id: str, hour: int) -> float:
        """è·å–å†å²å¹³å‡é€Ÿåº¦"""
        # é«˜å³°æœŸé€Ÿåº¦æ…¢
        if 7 <= hour <= 9 or 17 <= hour <= 19:
            return 18.0  # km/h
        return 25.0
    
    def _get_traffic_factor(self, route_id: str, current_time: datetime) -> float:
        """è·å–äº¤é€šå½±å“å› å­ï¼ˆ0-1ï¼Œè¶Šå°è¶Šæ‹¥å µï¼‰"""
        hour = current_time.hour
        
        # é«˜å³°æœŸæ‹¥å µ
        if 7 <= hour <= 9 or 17 <= hour <= 19:
            return 0.6
        elif 10 <= hour <= 16:
            return 0.9
        else:
            return 1.0
    
    def update_travel_time(self, route_id: str, from_stop: int, 
                          to_stop: int, actual_minutes: float):
        """æ›´æ–°å†å²è¡Œé©¶æ—¶é—´"""
        key = f"{route_id}_{from_stop}_{to_stop}"
        self.historical_travel_times[key].append(actual_minutes)
        # ä¿ç•™æœ€è¿‘100æ¡è®°å½•
        if len(self.historical_travel_times[key]) > 100:
            self.historical_travel_times[key].pop(0)


class TransitSignalPriority:
    """å…¬äº¤ä¿¡å·ä¼˜å…ˆç³»ç»Ÿ"""
    
    def __init__(self):
        self.signal_controllers: Dict = {}  # ä¿¡å·æœºæ§åˆ¶å™¨
        self.priority_requests: deque = deque(maxlen=1000)  # ä¼˜å…ˆè¯·æ±‚é˜Ÿåˆ—
        self.granted_priorities: Dict = {}  # å·²æˆæƒä¼˜å…ˆ
    
    def request_priority(self, bus: Bus, intersection_id: str,
                        arrival_estimate: datetime) -> Dict:
        """
        è¯·æ±‚ä¿¡å·ä¼˜å…ˆ
        è¿”å›: {'granted': bool, 'green_extension': int, 'red_truncation': int}
        """
        # è¯„ä¼°ä¼˜å…ˆéœ€æ±‚ç­‰çº§
        priority_level = self._calculate_priority_level(bus)
        
        request = {
            'bus_id': bus.bus_id,
            'route_id': bus.route_id,
            'intersection_id': intersection_id,
            'estimated_arrival': arrival_estimate,
            'priority_level': priority_level,
            'timestamp': datetime.now()
        }
        
        self.priority_requests.append(request)
        
        # ç®€åŒ–çš„ä¼˜å…ˆå†³ç­–é€»è¾‘
        if priority_level >= 3:  # é«˜ä¼˜å…ˆçº§
            granted = True
            green_extension = 10  # å»¶é•¿ç»¿ç¯10ç§’
            red_truncation = 5    # ç¼©çŸ­çº¢ç¯5ç§’
        elif priority_level >= 2:
            granted = True
            green_extension = 5
            red_truncation = 3
        else:
            granted = False
            green_extension = 0
            red_truncation = 0
        
        if granted:
            self.granted_priorities[bus.bus_id] = {
                'intersection_id': intersection_id,
                'granted_at': datetime.now(),
                'green_extension': green_extension
            }
        
        return {
            'granted': granted,
            'priority_level': priority_level,
            'green_extension': green_extension,
            'red_truncation': red_truncation,
            'reason': 'æ™šç‚¹è¡¥å¿' if bus.schedule_deviation > 120 else 'å¸¸è§„ä¼˜å…ˆ'
        }
    
    def _calculate_priority_level(self, bus: Bus) -> int:
        """è®¡ç®—ä¼˜å…ˆç­‰çº§ (1-5)"""
        level = 1
        
        # æ™šç‚¹ç¨‹åº¦
        if bus.schedule_deviation > 300:  # æ™šç‚¹>5åˆ†é’Ÿ
            level += 2
        elif bus.schedule_deviation > 120:
            level += 1
        
        # æ»¡è½½ç¨‹åº¦
        if bus.is_overcrowded():
            level += 1
        
        # çº¿è·¯ç±»å‹ï¼ˆBRTä¼˜å…ˆï¼‰
        if bus.route_id.startswith('BRT'):
            level += 1
        
        return min(5, level)
    
    def get_priority_statistics(self) -> Dict:
        """è·å–ä¿¡å·ä¼˜å…ˆç»Ÿè®¡"""
        total_requests = len(self.priority_requests)
        granted_requests = len(self.granted_priorities)
        
        return {
            'total_requests': total_requests,
            'granted_requests': granted_requests,
            'grant_rate': granted_requests / total_requests if total_requests > 0 else 0,
            'avg_green_extension': np.mean([p['green_extension'] 
                                           for p in self.granted_priorities.values()]) if self.granted_priorities else 0
        }


class DriverSafetyMonitor:
    """é©¾é©¶å‘˜å®‰å…¨ç›‘æ§"""
    
    def __init__(self):
        self.driving_behaviors: Dict[str, deque] = {}  # é©¾é©¶è¡Œä¸ºå†å²
        self.fatigue_records: Dict[str, Dict] = {}     # ç–²åŠ³è®°å½•
        self.safety_scores: Dict[str, float] = {}      # å®‰å…¨è¯„åˆ†
        self.alert_thresholds = {
            'continuous_driving_minutes': 240,  # 4å°æ—¶
            'harsh_braking_per_hour': 5,
            'speeding_count_per_day': 3
        }
    
    def record_behavior(self, driver_id: str, behavior_type: str, 
                       timestamp: datetime, severity: float = 1.0):
        """è®°å½•é©¾é©¶è¡Œä¸º"""
        if driver_id not in self.driving_behaviors:
            self.driving_behaviors[driver_id] = deque(maxlen=1000)
        
        self.driving_behaviors[driver_id].append({
            'type': behavior_type,
            'timestamp': timestamp,
            'severity': severity
        })
    
    def check_fatigue(self, driver_id: str, 
                     current_shift_start: datetime) -> Dict:
        """æ£€æŸ¥ç–²åŠ³é©¾é©¶"""
        continuous_hours = (datetime.now() - current_shift_start).total_seconds() / 3600
        
        if continuous_hours > 4:
            return {
                'alert': True,
                'level': 'critical',
                'message': f'è¿ç»­é©¾é©¶è¶…è¿‡4å°æ—¶ï¼Œå¿…é¡»ç«‹å³ä¼‘æ¯',
                'continuous_hours': continuous_hours
            }
        elif continuous_hours > 3:
            return {
                'alert': True,
                'level': 'warning',
                'message': f'è¿ç»­é©¾é©¶æ¥è¿‘4å°æ—¶ï¼Œå»ºè®®å°½å¿«ä¼‘æ¯',
                'continuous_hours': continuous_hours
            }
        
        return {'alert': False}
    
    def calculate_safety_score(self, driver_id: str) -> Dict:
        """è®¡ç®—é©¾é©¶å‘˜å®‰å…¨è¯„åˆ†"""
        behaviors = list(self.driving_behaviors.get(driver_id, []))
        
        if not behaviors:
            return {'score': 100, 'risk_level': 'low'}
        
        # è®¡ç®—å„ç±»è¿è§„æ¬¡æ•°
        today = datetime.now().date()
        today_behaviors = [b for b in behaviors if b['timestamp'].date() == today]
        
        harsh_braking = sum(1 for b in today_behaviors if b['type'] == 'harsh_braking')
        speeding = sum(1 for b in today_behaviors if b['type'] == 'speeding')
        fatigue_alerts = sum(1 for b in today_behaviors if b['type'] == 'fatigue')
        
        # æ‰£åˆ†è®¡ç®—
        deductions = (
            harsh_braking * 3 +
            speeding * 5 +
            fatigue_alerts * 10
        )
        
        score = max(0, 100 - deductions)
        
        # é£é™©ç­‰çº§
        if score >= 90:
            risk_level = 'low'
        elif score >= 70:
            risk_level = 'medium'
        else:
            risk_level = 'high'
        
        self.safety_scores[driver_id] = score
        
        return {
            'score': score,
            'risk_level': risk_level,
            'today_violations': {
                'harsh_braking': harsh_braking,
                'speeding': speeding,
                'fatigue_alerts': fatigue_alerts
            }
        }
    
    def generate_alerts(self, driver_id: str) -> List[Dict]:
        """ç”Ÿæˆå®‰å…¨å‘Šè­¦"""
        alerts = []
        score_info = self.calculate_safety_score(driver_id)
        
        if score_info['score'] < 60:
            alerts.append({
                'type': AlertType.DRIVER_FATIGUE.value,
                'level': 'critical',
                'driver_id': driver_id,
                'message': f'é©¾é©¶å‘˜å®‰å…¨è¯„åˆ†è¿‡ä½: {score_info["score"]}ï¼Œå»ºè®®æš‚åœè¿è¥',
                'score': score_info['score']
            })
        
        return alerts


class PublicTransportSystem:
    """å…¬å…±äº¤é€šç³»ç»Ÿä¸»ç±»"""
    
    def __init__(self):
        self.flow_predictor = PassengerFlowPredictor()
        self.scheduler = BusScheduler(self.flow_predictor)
        self.arrival_predictor = ArrivalTimePredictor()
        self.signal_priority = TransitSignalPriority()
        self.safety_monitor = DriverSafetyMonitor()
        
        self.routes: Dict[str, Route] = {}
        self.buses: Dict[str, Bus] = {}
        self.stops: Dict[str, BusStop] = {}
        self.all_alerts: List[Dict] = []
    
    def register_route(self, route: Route):
        """æ³¨å†Œçº¿è·¯"""
        self.routes[route.route_id] = route
        self.scheduler.add_route(route)
        
        # æ³¨å†Œç«™ç‚¹
        for stop in route.stops:
            if stop.stop_id not in self.stops:
                self.stops[stop.stop_id] = stop
            self.stops[stop.stop_id].routes.add(route.route_id)
    
    def register_bus(self, bus: Bus):
        """æ³¨å†Œè½¦è¾†"""
        self.buses[bus.bus_id] = bus
        self.scheduler.add_bus(bus)
    
    def update_bus_location(self, gps_point: GPSPoint) -> List[Dict]:
        """æ›´æ–°è½¦è¾†ä½ç½®"""
        bus = self.buses.get(gps_point.bus_id)
        if not bus:
            return []
        
        bus.current_location = gps_point
        
        alerts = []
        
        # æ£€æŸ¥æ˜¯å¦åˆ°ç«™
        route = self.routes.get(bus.route_id)
        if route and bus.next_stop_index < len(route.stops):
            next_stop = route.stops[bus.next_stop_index]
            distance = self._calculate_distance(
                gps_point.latitude, gps_point.longitude,
                next_stop.latitude, next_stop.longitude
            )
            
            if distance < 0.05:  # å°äº50ç±³è®¤ä¸ºåˆ°ç«™
                bus.status = BusStatus.AT_STOP
                bus.next_stop_index += 1
        
        # æ£€æŸ¥æ‹¥æŒ¤åº¦
        if bus.is_overcrowded():
            alert = self.scheduler.handle_overcrowding(bus.bus_id)
            if alert:
                alerts.append(alert)
        
        # é©¾é©¶è¡Œä¸ºç›‘æ§
        if gps_point.speed > 60:  # å…¬äº¤è½¦è¶…é€Ÿ
            self.safety_monitor.record_behavior(
                bus.driver_id, 'speeding', datetime.now()
            )
        
        self.all_alerts.extend(alerts)
        return alerts
    
    def _calculate_distance(self, lat1: float, lon1: float,
                           lat2: float, lon2: float) -> float:
        """è®¡ç®—ä¸¤ç‚¹è·ç¦»ï¼ˆå…¬é‡Œï¼‰"""
        R = 6371
        lat1_rad, lat2_rad = np.radians(lat1), np.radians(lat2)
        delta_lat = np.radians(lat2 - lat1)
        delta_lon = np.radians(lon2 - lon1)
        
        a = np.sin(delta_lat/2)**2 + np.cos(lat1_rad) * np.cos(lat2_rad) * np.sin(delta_lon/2)**2
        c = 2 * np.arcsin(np.sqrt(a))
        return R * c
    
    def get_passenger_info(self, stop_id: str, route_id: str) -> Dict:
        """è·å–ä¹˜å®¢ä¿¡æ¯ï¼ˆç”¨äºç”µå­ç«™ç‰Œï¼‰"""
        stop = self.stops.get(stop_id)
        if not stop:
            return {}
        
        # æŸ¥æ‰¾å³å°†åˆ°è¾¾çš„è½¦è¾†
        arriving_buses = []
        for bus in self.buses.values():
            if bus.route_id == route_id and bus.status in [BusStatus.IN_SERVICE, BusStatus.AT_STOP]:
                prediction = self.arrival_predictor.predict_arrival(
                    bus, bus.next_stop_index, datetime.now()
                )
                arriving_buses.append({
                    'bus_id': bus.bus_id,
                    'estimated_arrival': prediction['estimated_arrival'].strftime('%H:%M'),
                    'delay_risk': prediction['delay_risk'],
                    'load_factor': bus.get_load_factor()
                })
        
        arriving_buses.sort(key=lambda x: x['estimated_arrival'])
        
        return {
            'stop_name': stop.stop_name,
            'next_buses': arriving_buses[:3]  # æœ€è¿‘3ç­è½¦
        }
    
    def get_operation_dashboard(self) -> Dict:
        """è·å–è¿è¥ä»ªè¡¨ç›˜"""
        total_buses = len(self.buses)
        in_service = sum(1 for b in self.buses.values() if b.status == BusStatus.IN_SERVICE)
        at_stop = sum(1 for b in self.buses.values() if b.status == BusStatus.AT_STOP)
        idle = sum(1 for b in self.buses.values() if b.status == BusStatus.IDLE)
        
        overcrowded = sum(1 for b in self.buses.values() if b.is_overcrowded())
        delayed = sum(1 for b in self.buses.values() if b.schedule_deviation > 120)
        
        avg_load_factor = np.mean([b.get_load_factor() for b in self.buses.values()]) if self.buses else 0
        
        return {
            'total_buses': total_buses,
            'in_service': in_service,
            'at_stop': at_stop,
            'idle': idle,
            'overcrowded_buses': overcrowded,
            'delayed_buses': delayed,
            'avg_load_factor': f"{avg_load_factor*100:.1f}%",
            'system_alerts': len(self.all_alerts)
        }


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================

def demo():
    """æ¼”ç¤ºå…¬äº¤è°ƒåº¦ç³»ç»Ÿçš„ä½¿ç”¨"""
    
    # åˆå§‹åŒ–ç³»ç»Ÿ
    transit_system = PublicTransportSystem()
    
    # åˆ›å»ºçº¿è·¯
    route1_stops = [
        BusStop(f"R1_S{i:03d}", f"ç«™ç‚¹{i}", 22.5 + i*0.01, 114.0 + i*0.01)
        for i in range(20)
    ]
    route1 = Route(
        route_id="M201",
        route_name="201è·¯",
        route_type="regular",
        stops=route1_stops,
        distance_km=25.0,
        base_interval_minutes=8,
        fleet_size=30
    )
    transit_system.register_route(route1)
    
    # æ³¨å†Œè½¦è¾†
    for i in range(10):
        bus = Bus(
            bus_id=f"B{100+i}",
            route_id="M201",
            capacity=80,
            current_passengers=np.random.randint(30, 90),
            driver_id=f"D{100+i}"
        )
        transit_system.register_bus(bus)
    
    # è®­ç»ƒå®¢æµé¢„æµ‹æ¨¡å‹
    historical_flows = []
    for hour in range(5, 23):
        for stop_idx in range(20):
            # æ¨¡æ‹Ÿé«˜å³°æœŸé«˜å®¢æµ
            base_boarding = 50 if 7 <= hour <= 9 or 17 <= hour <= 19 else 20
            historical_flows.append(PassengerFlow(
                route_id="M201",
                stop_id=f"R1_S{stop_idx:03d}",
                timestamp=datetime(2024, 1, 15, hour, 0),
                boarding=base_boarding + np.random.randint(-5, 5),
                alighting=base_boarding - 5 + np.random.randint(-3, 3)
            ))
    
    transit_system.flow_predictor.train(historical_flows)
    
    print("=" * 60)
    print("æ·±åœ³å…¬äº¤æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿæ¼”ç¤º")
    print("=" * 60)
    
    # å®¢æµé¢„æµ‹æ¼”ç¤º
    print("\nğŸ“Š å®¢æµé¢„æµ‹")
    print("-" * 40)
    current_time = datetime(2024, 1, 15, 8, 0)  # æ—©é«˜å³°
    demand = transit_system.flow_predictor.predict_route_demand("M201", current_time)
    print(f"çº¿è·¯ M201 æœªæ¥30åˆ†é’Ÿé¢„æµ‹:")
    print(f"  é¢„è®¡å®¢æµéœ€æ±‚: {demand['total_demand']} äººæ¬¡")
    print(f"  å»ºè®®æŠ•å…¥è½¦è¾†: {demand['required_buses']} è¾†")
    print(f"  æ¨èå‘è½¦é—´éš”: {demand['recommended_interval']} åˆ†é’Ÿ")
    
    # è°ƒåº¦ä¼˜åŒ–æ¼”ç¤º
    print("\nğŸšŒ æ™ºèƒ½è°ƒåº¦")
    print("-" * 40)
    dispatch_plan = transit_system.scheduler.optimize_dispatch("M201", current_time)
    print(f"ç”Ÿæˆè°ƒåº¦æŒ‡ä»¤ {len(dispatch_plan)} æ¡:")
    for cmd in dispatch_plan:
        print(f"  [{cmd['action']}] è½¦è¾† {cmd['bus_id']} - {cmd['reason']}")
    
    # åˆ°ç«™é¢„æµ‹æ¼”ç¤º
    print("\nâ±ï¸ åˆ°ç«™æ—¶é—´é¢„æµ‹")
    print("-" * 40)
    test_bus = transit_system.buses["B100"]
    test_bus.current_location = GPSPoint(
        "B100", "M201", current_time, 22.52, 114.02, 25.0, 0.0
    )
    test_bus.next_stop_index = 3
    
    prediction = transit_system.arrival_predictor.predict_arrival(
        test_bus, 5, current_time
    )
    print(f"è½¦è¾† B100 åˆ°è¾¾ç¬¬5ç«™é¢„æµ‹:")
    print(f"  é¢„è®¡åˆ°è¾¾: {prediction['estimated_arrival'].strftime('%H:%M:%S')}")
    print(f"  ç½®ä¿¡åº¦: {prediction['confidence']*100:.1f}%")
    print(f"  æ™šç‚¹é£é™©: {prediction['delay_risk']}")
    
    # ä¿¡å·ä¼˜å…ˆæ¼”ç¤º
    print("\nğŸš¦ ä¿¡å·ä¼˜å…ˆ")
    print("-" * 40)
    test_bus.schedule_deviation = 180  # æ™šç‚¹3åˆ†é’Ÿ
    priority_result = transit_system.signal_priority.request_priority(
        test_bus, "INT_001", current_time + timedelta(minutes=5)
    )
    print(f"è½¦è¾† B100 ä¿¡å·ä¼˜å…ˆè¯·æ±‚:")
    print(f"  æ˜¯å¦æˆæƒ: {'æ˜¯' if priority_result['granted'] else 'å¦'}")
    print(f"  ä¼˜å…ˆç­‰çº§: {priority_result['priority_level']}/5")
    print(f"  ç»¿ç¯å»¶é•¿: {priority_result['green_extension']} ç§’")
    
    # å®‰å…¨ç›‘æ§æ¼”ç¤º
    print("\nğŸ‘® å®‰å…¨ç›‘æ§")
    print("-" * 40)
    
    # æ¨¡æ‹Ÿå±é™©é©¾é©¶è¡Œä¸º
    for _ in range(3):
        transit_system.safety_monitor.record_behavior("D100", "harsh_braking", current_time)
    transit_system.safety_monitor.record_behavior("D100", "speeding", current_time)
    
    safety_report = transit_system.safety_monitor.calculate_safety_score("D100")
    print(f"é©¾é©¶å‘˜ D100 å®‰å…¨è¯„ä¼°:")
    print(f"  å®‰å…¨è¯„åˆ†: {safety_report['score']}/100")
    print(f"  é£é™©ç­‰çº§: {safety_report['risk_level']}")
    print(f"  ä»Šæ—¥è¿è§„: {safety_report['today_violations']}")
    
    # è¿è¥ä»ªè¡¨ç›˜
    print("\nğŸ“ˆ è¿è¥ä»ªè¡¨ç›˜")
    print("-" * 40)
    dashboard = transit_system.get_operation_dashboard()
    print(f"æ€»è½¦è¾†æ•°: {dashboard['total_buses']}")
    print(f"è¿è¥ä¸­: {dashboard['in_service']} | åˆ°ç«™: {dashboard['at_stop']} | å¾…å‘: {dashboard['idle']}")
    print(f"æ‹¥æŒ¤è½¦è¾†: {dashboard['overcrowded_buses']} | æ™šç‚¹è½¦è¾†: {dashboard['delayed_buses']}")
    print(f"å¹³å‡æ»¡è½½ç‡: {dashboard['avg_load_factor']}")
    
    # ä¹˜å®¢ä¿¡æ¯å±•ç¤º
    print("\nğŸš ç”µå­ç«™ç‰Œä¿¡æ¯")
    print("-" * 40)
    passenger_info = transit_system.get_passenger_info("R1_S005", "M201")
    print(f"ç«™ç‚¹: {passenger_info.get('stop_name', 'N/A')}")
    print("å³å°†åˆ°ç«™:")
    for bus in passenger_info.get('next_buses', []):
        crowd_status = "æ‹¥æŒ¤" if bus['load_factor'] > 0.8 else "èˆ’é€‚"
        print(f"  {bus['bus_id']} - {bus['estimated_arrival']} ({crowd_status})")
    
    print("\n" + "=" * 60)
    print("ç³»ç»Ÿæ¼”ç¤ºå®Œæˆ")
    print("=" * 60)


if __name__ == "__main__":
    demo()
```

---

### 4. æ•ˆæœè¯„ä¼°

#### æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡é¡¹ | å®æ–½å‰ | å®æ–½å | æ”¹å–„å¹…åº¦ |
|--------|--------|--------|----------|
| é«˜å³°æ‹¥æŒ¤åº¦ | 120%+ | 82% | â†“ 31.7% |
| å¹³å‡ç­‰å€™æ—¶é—´ | 15.2åˆ†é’Ÿ | 7.8åˆ†é’Ÿ | â†“ 48.7% |
| å¹³å³°ç©ºé©¶ç‡ | 35% | 12% | â†“ 65.7% |
| å•è½¦ç™¾å…¬é‡Œèƒ½è€— | 42L | 33L | â†“ 21.4% |
| å¹´å®‰å…¨äº‹æ•…æ•° | 208èµ· | 115èµ· | â†“ 44.7% |
| ä¹˜å®¢æ»¡æ„åº¦ | 76% | 91% | â†‘ 19.7% |
| å‡†ç‚¹ç‡ | 72% | 89% | â†‘ 23.6% |

#### ROIåˆ†æ

**æŠ•èµ„æˆæœ¬**ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š4,500ä¸‡å…ƒ
- è½¦è½½è®¾å¤‡ï¼ˆGPSã€å®¢æµè®¡æ•°å™¨ç­‰ï¼‰ï¼š6,800ä¸‡å…ƒ
- è°ƒåº¦ä¸­å¿ƒå»ºè®¾ï¼š1,200ä¸‡å…ƒ
- äººå‘˜åŸ¹è®­ï¼š800ä¸‡å…ƒ
- **æ€»æŠ•èµ„**ï¼š13,300ä¸‡å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- èƒ½æºæˆæœ¬èŠ‚çº¦ï¼š12,000ä¸‡å…ƒ/å¹´
- äººåŠ›æˆæœ¬ä¼˜åŒ–ï¼ˆè°ƒåº¦å‘˜å‡å°‘ï¼‰ï¼š3,500ä¸‡å…ƒ/å¹´
- äº‹æ•…æŸå¤±å‡å°‘ï¼š2,200ä¸‡å…ƒ/å¹´
- å¹¿å‘Šæ”¶å…¥å¢åŠ ï¼ˆç”µå­ç«™ç‰Œï¼‰ï¼š1,800ä¸‡å…ƒ/å¹´
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š19,500ä¸‡å…ƒ/å¹´

**æŠ•èµ„å›æŠ¥**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š8.2ä¸ªæœˆ
- 5å¹´ç´¯è®¡å‡€æ”¶ç›Šï¼š84,200ä¸‡å…ƒ
- 5å¹´ROIï¼š533%

#### ç»éªŒæ•™è®­

**æˆåŠŸå› ç´ **ï¼š
1. **æ•°æ®é©±åŠ¨å†³ç­–**ï¼šå»ºç«‹äº†è¦†ç›–å…¨é›†å›¢çš„æ•°æ®é‡‡é›†å’Œåˆ†æä½“ç³»ï¼Œæ‰€æœ‰è°ƒåº¦å†³ç­–åŸºäºå®æ—¶æ•°æ®
2. **äº§å­¦ç ”åˆä½œ**ï¼šä¸æ¸…åå¤§å­¦ã€å“ˆå·¥å¤§åˆä½œå¼€å‘æ ¸å¿ƒç®—æ³•ï¼Œç¡®ä¿æŠ€æœ¯é¢†å…ˆæ€§
3. **ä»¥äººä¸ºæœ¬**ï¼šé‡è§†é©¾é©¶å‘˜åŸ¹è®­å’Œå‚ä¸ï¼Œé€šè¿‡æ¿€åŠ±æœºåˆ¶æå‡é…åˆåº¦
4. **æ”¿åºœæ”¯æŒ**ï¼šè·å¾—å¸‚äº¤é€šå±€ã€äº¤è­¦å±€å¤§åŠ›æ”¯æŒï¼Œå®ç°å…¬äº¤ä¿¡å·ä¼˜å…ˆ

**é¢ä¸´çš„æŒ‘æˆ˜**ï¼š
1. **åˆæœŸå‡†ç¡®ç‡é—®é¢˜**ï¼šå®¢æµé¢„æµ‹åˆæœŸå‡†ç¡®ç‡ä»…75%ï¼Œé€šè¿‡ç§¯ç´¯æ•°æ®å’Œæ¨¡å‹è¿­ä»£æå‡è‡³92%
2. **å¸æœºæŠµè§¦æƒ…ç»ª**ï¼šéƒ¨åˆ†è€å¸æœºå¯¹ç³»ç»Ÿä¸ä¿¡ä»»ï¼Œé€šè¿‡ç¤ºèŒƒçº¿è·¯å’Œæ¿€åŠ±æœºåˆ¶é€æ­¥åŒ–è§£
3. **æç«¯å¤©æ°”åº”å¯¹**ï¼šæš´é›¨ç­‰æç«¯å¤©æ°”ä¸‹ç³»ç»Ÿç¨³å®šæ€§å—å½±å“ï¼Œå»ºç«‹äº†åº”æ€¥é¢„æ¡ˆ

**æœ€ä½³å®è·µ**ï¼š
1. å»ºç«‹"è°ƒåº¦ä¸­å¿ƒ-åˆ†å…¬å¸-çº¿è·¯"ä¸‰çº§å“åº”æœºåˆ¶ï¼Œç¡®ä¿å¼‚å¸¸æƒ…å†µå¿«é€Ÿå¤„ç†
2. å¼€å‘ä¹˜å®¢APPï¼Œæä¾›å®æ—¶åˆ°ç«™ä¿¡æ¯ï¼Œæå‡æœåŠ¡ä½“éªŒ
3. å»ºç«‹æ•°æ®è´¨é‡ç›‘æ§ä½“ç³»ï¼Œæ¯æ—¥æ ¸æŸ¥æ•°æ®å‡†ç¡®æ€§
4. ä¸åœ°é“ã€å…±äº«å•è½¦æ•°æ®æ‰“é€šï¼Œå®ç°å¤šæ¨¡å¼ååŒ

---

## æ¡ˆä¾‹äºŒï¼šæ­å·å…¬äº¤"äº‘å…¬äº¤"æ™ºæ…§å‡ºè¡Œç³»ç»Ÿ

### 1. ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šæ­å·å¸‚å…¬å…±äº¤é€šé›†å›¢æœ‰é™å…¬å¸  
**åˆ›æ–°æ¨¡å¼**ï¼š"äº‘å…¬äº¤"å®šåˆ¶å…¬äº¤  
**è¿è¥è§„æ¨¡**ï¼šè¶…è¿‡10,000è¾†å…¬äº¤è½¦ï¼Œ800+æ¡çº¿è·¯  
**ç‰¹è‰²æœåŠ¡**ï¼šéœ€æ±‚å“åº”å¼å…¬äº¤ã€ç¤¾åŒºå¾®å…¬äº¤ã€æ—…æ¸¸ä¸“çº¿

#### ä¸šåŠ¡ç—›ç‚¹

1. **å›ºå®šçº¿è·¯åƒµåŒ–**ï¼šä¼ ç»Ÿå›ºå®šçº¿è·¯æ— æ³•æ»¡è¶³ä¹˜å®¢å¤šæ ·åŒ–å‡ºè¡Œéœ€æ±‚
2. **ç¤¾åŒºå‡ºè¡Œéš¾**ï¼šå¤§å‹ç¤¾åŒºåˆ°åœ°é“ç«™çš„"æœ€åä¸€å…¬é‡Œ"é—®é¢˜çªå‡º
3. **æ—…æ¸¸èµ„æºé—²ç½®**ï¼šæ™¯åŒºé—´å…¬äº¤çº¿è·¯è§„åˆ’ä¸åˆç†ï¼Œæ¸¸å®¢ä½“éªŒå·®
4. **ä¿¡æ¯ä¸å¯¹ç§°**ï¼šä¹˜å®¢æ— æ³•è·å–å‡†ç¡®çš„åˆ°ç«™æ—¶é—´å’Œè½¦å¢æ‹¥æŒ¤åº¦
5. **æ”¯ä»˜æ–¹å¼è½å**ï¼šå¤šç§æ”¯ä»˜æ–¹å¼å¹¶å­˜ï¼Œä¹˜è½¦æ•ˆç‡ä½

#### ä¸šåŠ¡ç›®æ ‡

1. **æŒ‰éœ€å“åº”**ï¼šå®ç°åŸºäºä¹˜å®¢é¢„çº¦çš„åŠ¨æ€çº¿è·¯ç”Ÿæˆå’Œè½¦è¾†è°ƒåº¦
2. **å¾®å¾ªç¯è¦†ç›–**ï¼šè§£å†³ç¤¾åŒºã€å›­åŒºå†…çš„çŸ­é€”æ¥é©³éœ€æ±‚
3. **æ—…æ¸¸ä¸€ä½“åŒ–**ï¼šæ„å»ºæ™¯åŒºé—´çš„æ— ç¼å…¬äº¤ç½‘ç»œ
4. **ä¿¡æ¯é€æ˜åŒ–**ï¼šæä¾›å®æ—¶ã€å‡†ç¡®çš„å…¬äº¤ä¿¡æ¯æœåŠ¡
5. **æ”¯ä»˜ä¸€ä½“åŒ–**ï¼šå®ç°ä¸€ç é€šè¡Œï¼Œæå‡ä¹˜è½¦æ•ˆç‡

---

### 2. æŠ€æœ¯æŒ‘æˆ˜

1. **åŠ¨æ€è·¯å¾„è§„åˆ’**ï¼šæ ¹æ®å®æ—¶é¢„çº¦è¯·æ±‚ï¼ŒåŠ¨æ€ç”Ÿæˆæœ€ä¼˜è¡Œé©¶è·¯çº¿
2. **éœ€æ±‚èšåˆç®—æ³•**ï¼šå°†åˆ†æ•£çš„å‡ºè¡Œéœ€æ±‚æ™ºèƒ½èšåˆï¼Œå¹³è¡¡æœåŠ¡è´¨é‡å’Œè¿è¥æˆæœ¬
3. **å¤šæ¨¡å¼ååŒ**ï¼šå®ç°å¸¸è§„å…¬äº¤ã€åœ°é“ã€å…±äº«å•è½¦ã€æ­¥è¡Œçš„æ— ç¼è¡”æ¥
4. **å®æ—¶å®¢æµç»Ÿè®¡**ï¼šåŸºäºè§†é¢‘AIçš„ç²¾å‡†å®¢æµè®¡æ•°å’Œè½¦å¢æ‹¥æŒ¤åº¦åˆ†æ
5. **å¤§è§„æ¨¡å¹¶å‘å¤„ç†**ï¼šæ”¯æŒç™¾ä¸‡çº§ç”¨æˆ·åŒæ—¶æŸ¥è¯¢å’Œé¢„çº¦

---

### 3. æ•ˆæœè¯„ä¼°

#### æ ¸å¿ƒæŒ‡æ ‡æ”¹å–„

| æŒ‡æ ‡ | æ”¹å–„æ•ˆæœ |
|------|----------|
| äº‘å…¬äº¤é¢„çº¦å“åº”æ—¶é—´ | < 3åˆ†é’Ÿ |
| ç¤¾åŒºå¾®å…¬äº¤è¦†ç›–ç‡ | ä»60%æå‡è‡³95% |
| ä¹˜å®¢å¹³å‡æ­¥è¡Œè·ç¦» | å‡å°‘42% |
| æ™¯åŒºå…¬äº¤æ»¡æ„åº¦ | ä»78%æå‡è‡³94% |
| APPæœˆæ´»ç”¨æˆ· | è¶…è¿‡500ä¸‡ |

#### åˆ›æ–°äº®ç‚¹

1. **AIæ™ºèƒ½æ´¾å•**ï¼šåŸºäºæ·±åº¦å¼ºåŒ–å­¦ä¹ çš„åŠ¨æ€æ´¾å•ç®—æ³•ï¼Œå®ç°éœ€æ±‚ä¸è¿åŠ›çš„æœ€ä¼˜åŒ¹é…
2. **æ•°å­—å­ªç”Ÿç«™å°**ï¼šARæŠ€æœ¯å®ç°è™šæ‹Ÿçº¿è·¯è§„åˆ’å’Œå®æ—¶è½¦è¾†ä½ç½®å±•ç¤º
3. **ç¢³ç§¯åˆ†ä½“ç³»**ï¼šç»¿è‰²å‡ºè¡Œå¯ç´¯ç§¯ç¢³ç§¯åˆ†ï¼Œå…‘æ¢å…¬äº¤ä¼˜æƒ ï¼Œæå‡ç”¨æˆ·ç²˜æ€§

---

*æ–‡æ¡£ç‰ˆæœ¬: v1.0 | æœ€åæ›´æ–°: 2026-02-15*

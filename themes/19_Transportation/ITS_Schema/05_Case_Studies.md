# æ™ºèƒ½äº¤é€šç³»ç»ŸSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½äº¤é€šç³»ç»ŸSchemaå®è·µæ¡ˆä¾‹](#æ™ºèƒ½äº¤é€šç³»ç»Ÿschemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šäº¤é€šä¿¡å·æ§åˆ¶](#2-æ¡ˆä¾‹1äº¤é€šä¿¡å·æ§åˆ¶)
    - [2.1 åœºæ™¯æè¿°](#21-åœºæ™¯æè¿°)
    - [2.2 Schemaå®šä¹‰](#22-schemaå®šä¹‰)
    - [2.3 å®ç°ä»£ç ](#23-å®ç°ä»£ç )
  - [3. æ¡ˆä¾‹2ï¼šè·¯å†µç›‘æ§](#3-æ¡ˆä¾‹2è·¯å†µç›‘æ§)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 Schemaå®šä¹‰](#32-schemaå®šä¹‰)
    - [3.3 å®ç°ä»£ç ](#33-å®ç°ä»£ç )
  - [4. æ¡ˆä¾‹3ï¼šè½¦è¾†é€šä¿¡ï¼ˆV2Vï¼‰](#4-æ¡ˆä¾‹3è½¦è¾†é€šä¿¡v2v)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 Schemaå®šä¹‰](#42-schemaå®šä¹‰)
    - [4.3 å®ç°ä»£ç ](#43-å®ç°ä»£ç )
  - [5. æ¡ˆä¾‹4ï¼šäº¤é€šæµé‡åˆ†æ](#5-æ¡ˆä¾‹4äº¤é€šæµé‡åˆ†æ)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 Schemaå®šä¹‰](#52-schemaå®šä¹‰)
    - [5.3 å®ç°ä»£ç ](#53-å®ç°ä»£ç )
  - [6. æ¡ˆä¾‹5ï¼šæ‹¥å µæ£€æµ‹å’Œé¢„è­¦](#6-æ¡ˆä¾‹5æ‹¥å µæ£€æµ‹å’Œé¢„è­¦)
    - [6.1 åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2 Schemaå®šä¹‰](#62-schemaå®šä¹‰)
    - [6.3 å®ç°ä»£ç ](#63-å®ç°ä»£ç )
  - [7. æ¡ˆä¾‹6ï¼šè·¯å¾„è§„åˆ’](#7-æ¡ˆä¾‹6è·¯å¾„è§„åˆ’)
    - [7.1 åœºæ™¯æè¿°](#71-åœºæ™¯æè¿°)
    - [7.2 Schemaå®šä¹‰](#72-schemaå®šä¹‰)
    - [7.3 å®ç°ä»£ç ](#73-å®ç°ä»£ç )
  - [8. æ¡ˆä¾‹7ï¼šäº‹ä»¶æ£€æµ‹å’Œå¤„ç†](#8-æ¡ˆä¾‹7äº‹ä»¶æ£€æµ‹å’Œå¤„ç†)
    - [8.1 åœºæ™¯æè¿°](#81-åœºæ™¯æè¿°)
    - [8.2 Schemaå®šä¹‰](#82-schemaå®šä¹‰)
    - [8.3 å®ç°ä»£ç ](#83-å®ç°ä»£ç )
  - [9. æ¡ˆä¾‹8ï¼šITSæ•°æ®å­˜å‚¨ç³»ç»Ÿ](#9-æ¡ˆä¾‹8itsæ•°æ®å­˜å‚¨ç³»ç»Ÿ)
    - [9.1 åœºæ™¯æè¿°](#91-åœºæ™¯æè¿°)
    - [9.2 å®ç°ä»£ç ](#92-å®ç°ä»£ç )
  - [10. æ¡ˆä¾‹9ï¼šæ™ºèƒ½ä¿¡å·ä¼˜åŒ–ç³»ç»Ÿ](#10-æ¡ˆä¾‹9æ™ºèƒ½ä¿¡å·ä¼˜åŒ–ç³»ç»Ÿ)
    - [10.1 åœºæ™¯æè¿°](#101-åœºæ™¯æè¿°)
    - [10.2 Schemaå®šä¹‰](#102-schemaå®šä¹‰)
    - [10.3 å®ç°ä»£ç ](#103-å®ç°ä»£ç )
  - [11. æ¡ˆä¾‹10ï¼šäº¤é€šé¢„æµ‹ç³»ç»Ÿ](#11-æ¡ˆä¾‹10äº¤é€šé¢„æµ‹ç³»ç»Ÿ)
    - [11.1 åœºæ™¯æè¿°](#111-åœºæ™¯æè¿°)
    - [11.2 Schemaå®šä¹‰](#112-schemaå®šä¹‰)
    - [11.3 å®ç°ä»£ç ](#113-å®ç°ä»£ç )
  - [12. æ¡ˆä¾‹11ï¼šäº‹æ•…é¢„é˜²ç³»ç»Ÿ](#12-æ¡ˆä¾‹11äº‹æ•…é¢„é˜²ç³»ç»Ÿ)
    - [12.1 åœºæ™¯æè¿°](#121-åœºæ™¯æè¿°)
    - [12.2 Schemaå®šä¹‰](#122-schemaå®šä¹‰)
    - [12.3 å®ç°ä»£ç ](#123-å®ç°ä»£ç )

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ™ºèƒ½äº¤é€šç³»ç»ŸSchemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œ
æ¶µç›–äº¤é€šä¿¡å·æ§åˆ¶ã€è·¯å†µç›‘æ§ã€è½¦è¾†é€šä¿¡ã€è·¯å†µåˆ†æç­‰åœºæ™¯ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šäº¤é€šä¿¡å·æ§åˆ¶

### 2.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
åŸå¸‚äº¤é€šç®¡ç†éƒ¨é—¨éœ€è¦å®ç°æ™ºèƒ½äº¤é€šä¿¡å·æ§åˆ¶ç³»ç»Ÿï¼Œæ ¹æ®å®æ—¶äº¤é€šæµé‡è‡ªåŠ¨è°ƒæ•´ä¿¡å·ç¯é…æ—¶ï¼Œä¼˜åŒ–äº¤é€šæµï¼Œå‡å°‘æ‹¥å µã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å®æ—¶äº¤é€šæ•°æ®é‡‡é›†å’Œå¤„ç†
- ä¿¡å·é…æ—¶ä¼˜åŒ–ç®—æ³•
- å¤šè·¯å£åè°ƒæ§åˆ¶
- ç³»ç»Ÿå¯é æ€§å’Œå®æ—¶æ€§è¦æ±‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰äº¤é€šä¿¡å·æ§åˆ¶æ•°æ®ç»“æ„ï¼Œå®ç°åŸºäºå®æ—¶äº¤é€šæµé‡çš„è‡ªé€‚åº”ä¿¡å·æ§åˆ¶ç®—æ³•ã€‚

### 2.2 Schemaå®šä¹‰

**äº¤é€šä¿¡å·æ§åˆ¶Schema**ï¼š

```json
{
  "intersection_id": "INT001",
  "intersection_name": "äººæ°‘è·¯-è§£æ”¾è·¯äº¤å‰å£",
  "location": {
    "latitude": 31.2304,
    "longitude": 121.4737
  },
  "signal_states": [
    {
      "signal_id": "SIG001",
      "direction": "North",
      "current_state": "Green",
      "state_duration": 45,
      "next_state": "Yellow",
      "transition_time": "2025-01-21T10:30:45Z"
    },
    {
      "signal_id": "SIG002",
      "direction": "South",
      "current_state": "Red",
      "state_duration": 30,
      "next_state": "Green",
      "transition_time": "2025-01-21T10:31:00Z"
    }
  ],
  "phases": [
    {
      "phase_id": 1,
      "phase_name": "å—åŒ—ç›´è¡Œ",
      "signals": ["SIG001", "SIG002"],
      "duration": 45,
      "min_duration": 20,
      "max_duration": 60,
      "yellow_time": 5,
      "all_red_time": 2
    },
    {
      "phase_id": 2,
      "phase_name": "ä¸œè¥¿ç›´è¡Œ",
      "signals": ["SIG003", "SIG004"],
      "duration": 40,
      "min_duration": 20,
      "max_duration": 60,
      "yellow_time": 5,
      "all_red_time": 2
    }
  ],
  "timing_plan": {
    "cycle_time": 120,
    "offset": 0,
    "phase_sequence": [1, 2, 3, 4],
    "green_split": [0.375, 0.333, 0.167, 0.125],
    "coordination": {
      "coordination_type": "Arterial",
      "master_intersection": "INT000",
      "coordination_offset": 30
    }
  },
  "control_mode": "Adaptive",
  "timestamp": "2025-01-21T10:30:00Z"
}
```

### 2.3 å®ç°ä»£ç 

**å®Œæ•´çš„äº¤é€šä¿¡å·æ§åˆ¶å®ç°**ï¼š

```python
import logging
from typing import Dict, List
from datetime import datetime
from its_schema.transformation import TrafficSignalController, SignalTimingOptimizer

logger = logging.getLogger(__name__)

# æ¡ˆä¾‹1ï¼šäº¤é€šä¿¡å·æ§åˆ¶
def case1_traffic_signal_control():
    """æ¡ˆä¾‹1ï¼šäº¤é€šä¿¡å·æ§åˆ¶"""

    # 1. åˆå§‹åŒ–ä¿¡å·æ§åˆ¶å™¨
    controller = TrafficSignalController("INT001")

    # 2. è®¾ç½®ç›¸ä½åºåˆ—
    phases = [
        {
            "phase_id": 1,
            "phase_name": "å—åŒ—ç›´è¡Œ",
            "signals": ["SIG001", "SIG002"],
            "duration": 45,
            "min_duration": 20,
            "max_duration": 60,
            "yellow_time": 5,
            "all_red_time": 2
        },
        {
            "phase_id": 2,
            "phase_name": "ä¸œè¥¿ç›´è¡Œ",
            "signals": ["SIG003", "SIG004"],
            "duration": 40,
            "min_duration": 20,
            "max_duration": 60,
            "yellow_time": 5,
            "all_red_time": 2
        },
        {
            "phase_id": 3,
            "phase_name": "å—åŒ—å·¦è½¬",
            "signals": ["SIG005", "SIG006"],
            "duration": 20,
            "min_duration": 15,
            "max_duration": 30,
            "yellow_time": 3,
            "all_red_time": 1
        },
        {
            "phase_id": 4,
            "phase_name": "ä¸œè¥¿å·¦è½¬",
            "signals": ["SIG007", "SIG008"],
            "duration": 15,
            "min_duration": 15,
            "max_duration": 30,
            "yellow_time": 3,
            "all_red_time": 1
        }
    ]
    controller.set_phases(phases)

    # 3. ä¼˜åŒ–å‘¨æœŸæ—¶é—´
    optimizer = SignalTimingOptimizer()
    traffic_flows = {
        "North": 800.0,  # veh/h
        "South": 750.0,
        "East": 600.0,
        "West": 650.0
    }
    saturation_flows = {
        "North": 1800.0,
        "South": 1800.0,
        "East": 1800.0,
        "West": 1800.0
    }

    optimal_cycle_time = optimizer.optimize_cycle_time(traffic_flows, saturation_flows)
    controller.set_cycle_time(optimal_cycle_time)

    # 4. å¯åŠ¨ä¿¡å·å‘¨æœŸ
    controller.start_cycle()

    # 5. è·å–å½“å‰ä¿¡å·çŠ¶æ€
    current_state = controller.get_current_signal_state()
    print(f"Current signal state: {current_state}")

    # 6. æ¨¡æ‹Ÿè¿è¡Œä¸€æ®µæ—¶é—´
    import time
    for i in range(5):
        time.sleep(1)
        state = controller.get_current_signal_state()
        if state:
            print(f"Phase {state['current_phase']}: {state['phase_id']}, "
                  f"Remaining: {state['remaining_time']:.1f}s")

    return controller

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    controller = case1_traffic_signal_control()
    print("Case 1 completed successfully")
```

---

## 3. æ¡ˆä¾‹2ï¼šè·¯å†µç›‘æ§

### 3.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
äº¤é€šç®¡ç†éƒ¨é—¨éœ€è¦å®æ—¶ç›‘æ§é“è·¯çŠ¶å†µï¼Œé€šè¿‡ä¼ æ„Ÿå™¨å’Œè§†é¢‘ç›‘æ§ç³»ç»Ÿæ£€æµ‹æ‹¥å µã€äº‹æ•…ç­‰äº‹ä»¶ï¼ŒåŠæ—¶å‘å¸ƒè·¯å†µä¿¡æ¯ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å¤šæºæ•°æ®èåˆï¼ˆä¼ æ„Ÿå™¨ã€è§†é¢‘ã€GPSï¼‰
- å®æ—¶äº‹ä»¶æ£€æµ‹ç®—æ³•
- è·¯å†µä¿¡æ¯å‡†ç¡®æ€§å’ŒåŠæ—¶æ€§
- å¤§è§„æ¨¡æ•°æ®å¤„ç†

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰è·¯å†µç›‘æ§æ•°æ®ç»“æ„ï¼Œå®ç°å¤šæºæ•°æ®èåˆå’Œå®æ—¶äº‹ä»¶æ£€æµ‹ç³»ç»Ÿã€‚

### 3.2 Schemaå®šä¹‰

**è·¯å†µç›‘æ§Schema**ï¼š

```json
{
  "sensor_data": {
    "sensor_id": "SENSOR001",
    "sensor_type": "Loop",
    "location": {
      "latitude": 31.2304,
      "longitude": 121.4737,
      "road_name": "äººæ°‘è·¯",
      "lane_id": 1
    },
    "traffic_metrics": {
      "vehicle_count": 150,
      "average_speed": 35.5,
      "occupancy": 75.2,
      "density": 45.8,
      "headway": 8.5
    },
    "timestamp": "2025-01-21T10:30:00Z",
    "data_quality": "Good"
  },
  "video_data": {
    "camera_id": "CAM001",
    "camera_type": "Fixed",
    "location": {
      "latitude": 31.2304,
      "longitude": 121.4737
    },
    "detection_results": [
      {
        "vehicle_id": "VEH001",
        "vehicle_type": "Car",
        "bbox": {
          "x1": 100,
          "y1": 200,
          "x2": 300,
          "y2": 400
        },
        "confidence": 0.95,
        "license_plate": "äº¬A12345",
        "speed": 38.2
      }
    ],
    "timestamp": "2025-01-21T10:30:00Z",
    "frame_id": "FRAME001",
    "resolution": "FullHD"
  }
}
```

### 3.3 å®ç°ä»£ç 

**å®Œæ•´çš„è·¯å†µç›‘æ§å®ç°**ï¼š

```python
from its_schema.transformation import (
    TrafficSensorDataCollector, VideoTrafficDataProcessor, GPSDataProcessor
)

def case2_traffic_monitoring():
    """æ¡ˆä¾‹2ï¼šè·¯å†µç›‘æ§"""

    # 1. ä¼ æ„Ÿå™¨æ•°æ®é‡‡é›†
    sensor_collector = TrafficSensorDataCollector("SENSOR001", "192.168.1.100", 502)
    sensor_collector.connect(timeout=10.0)

    try:
        sensor_data = sensor_collector.read_traffic_data()
        print(f"Sensor data: {sensor_data}")
    finally:
        sensor_collector.disconnect()

    # 2. è§†é¢‘æ•°æ®å¤„ç†
    video_processor = VideoTrafficDataProcessor("CAM001")
    video_processor.connect_camera("rtsp://192.168.1.101:554/stream", timeout=10)

    try:
        video_data = video_processor.process_frame()
        print(f"Video data: {video_data}")
        print(f"Detected {video_data['vehicle_count']} vehicles")
    finally:
        video_processor._cleanup_camera()

    # 3. GPSæ•°æ®å¤„ç†
    gps_processor = GPSDataProcessor()
    nmea_message = "$GPRMC,103000.00,A,3113.8240,N,12128.4220,E,38.5,045.0,210125,0.0,E,A*2C"

    gps_data = gps_processor.parse_nmea_message(nmea_message)
    print(f"GPS data: {gps_data}")

    # 4. æ•°æ®èåˆå’Œåˆ†æ
    # è¿™é‡Œå¯ä»¥æ·»åŠ æ•°æ®èåˆé€»è¾‘

    return {
        "sensor_data": sensor_data,
        "video_data": video_data,
        "gps_data": gps_data
    }

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case2_traffic_monitoring()
    print("Case 2 completed successfully")
```

---

## 4. æ¡ˆä¾‹3ï¼šè½¦è¾†é€šä¿¡ï¼ˆV2Vï¼‰

### 4.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
è½¦è¾†é€šè¿‡V2Vé€šä¿¡è·å–å‘¨å›´è½¦è¾†çš„ä½ç½®ã€é€Ÿåº¦ã€æ–¹å‘ç­‰ä¿¡æ¯ï¼Œå®ç°ååŒé©¾é©¶å’Œç¢°æ’é¢„è­¦ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- V2Væ¶ˆæ¯æ ¼å¼æ ‡å‡†åŒ–ï¼ˆSAE J2735ã€ETSI ITSï¼‰
- æ¶ˆæ¯ä¼ è¾“çš„å®æ—¶æ€§å’Œå¯é æ€§
- å®‰å…¨è®¤è¯å’Œæ¶ˆæ¯å®Œæ•´æ€§
- å¤§è§„æ¨¡è½¦è¾†é€šä¿¡ç®¡ç†

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰V2Væ¶ˆæ¯æ•°æ®ç»“æ„ï¼Œå®ç°BSMæ¶ˆæ¯çš„è§£æå’Œå¤„ç†ç³»ç»Ÿã€‚

### 4.2 Schemaå®šä¹‰

**V2Væ¶ˆæ¯Schema**ï¼š

```json
{
  "message_type": "BSM",
  "vehicle_id": 12345678,
  "timestamp": "2025-01-21T10:30:00Z",
  "position": {
    "latitude": 31.2304,
    "longitude": 121.4737
  },
  "speed": 15.5,
  "heading": 45.0,
  "message_size": 150
}
```

### 4.3 å®ç°ä»£ç 

**å®Œæ•´çš„V2Væ¶ˆæ¯å¤„ç†å®ç°**ï¼š

```python
from its_schema.transformation import V2VMessageProcessor

def case3_v2v_communication():
    """æ¡ˆä¾‹3ï¼šè½¦è¾†é€šä¿¡ï¼ˆV2Vï¼‰"""

    # 1. åˆå§‹åŒ–V2Væ¶ˆæ¯å¤„ç†å™¨
    v2v_processor = V2VMessageProcessor()

    # 2. æ„å»ºBSMæ¶ˆæ¯
    vehicle_data = {
        "vehicle_id": 12345678,
        "latitude": 31.2304,
        "longitude": 121.4737,
        "speed": 15.5,  # m/s
        "heading": 45.0  # degrees
    }

    bsm_message = v2v_processor.build_bsm_message(vehicle_data)
    print(f"BSM message built: {len(bsm_message)} bytes")

    # 3. è§£æBSMæ¶ˆæ¯
    parsed_bsm = v2v_processor.parse_bsm_message(bsm_message)
    print(f"Parsed BSM: {parsed_bsm}")

    # 4. æ¨¡æ‹Ÿæ¥æ”¶å…¶ä»–è½¦è¾†çš„BSMæ¶ˆæ¯
    other_vehicle_bsm = bsm_message  # å®é™…åº”ç”¨ä¸­ä»ç½‘ç»œæ¥æ”¶
    other_vehicle_data = v2v_processor.parse_bsm_message(other_vehicle_bsm)

    # 5. è®¡ç®—è½¦è¾†é—´è·ç¦»å’Œç›¸å¯¹é€Ÿåº¦
    import math

    lat1 = math.radians(vehicle_data["latitude"])
    lon1 = math.radians(vehicle_data["longitude"])
    lat2 = math.radians(other_vehicle_data["position"]["latitude"])
    lon2 = math.radians(other_vehicle_data["position"]["longitude"])

    # ä½¿ç”¨Haversineå…¬å¼è®¡ç®—è·ç¦»
    dlat = lat2 - lat1
    dlon = lon2 - lon1
    a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
    c = 2 * math.asin(math.sqrt(a))
    distance = 6371000 * c  # åœ°çƒåŠå¾„6371kmï¼Œè½¬æ¢ä¸ºç±³

    print(f"Distance to other vehicle: {distance:.2f} meters")

    # 6. ç¢°æ’é¢„è­¦ï¼ˆå¦‚æœè·ç¦»å°äº50ç±³ä¸”ç›¸å¯¹é€Ÿåº¦è¾ƒå¤§ï¼‰
    if distance < 50:
        relative_speed = abs(vehicle_data["speed"] - other_vehicle_data["speed"])
        if relative_speed > 5:  # ç›¸å¯¹é€Ÿåº¦å¤§äº5 m/s
            print(f"WARNING: Potential collision risk! Distance: {distance:.2f}m, "
                  f"Relative speed: {relative_speed:.2f}m/s")

    return {
        "bsm_message": bsm_message,
        "parsed_data": parsed_bsm,
        "distance": distance
    }

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case3_v2v_communication()
    print("Case 3 completed successfully")
```

---

## 5. æ¡ˆä¾‹4ï¼šäº¤é€šæµé‡åˆ†æ

### 5.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
äº¤é€šç®¡ç†éƒ¨é—¨éœ€è¦åˆ†æå†å²äº¤é€šæµé‡æ•°æ®ï¼Œè¯†åˆ«äº¤é€šæ¨¡å¼ï¼Œä¸ºäº¤é€šè§„åˆ’å’Œç®¡ç†æä¾›å†³ç­–æ”¯æŒã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å¤§è§„æ¨¡æ—¶åºæ•°æ®å¤„ç†
- äº¤é€šæ¨¡å¼è¯†åˆ«ç®—æ³•
- å¤šç»´åº¦æ•°æ®åˆ†æ
- æ•°æ®å¯è§†åŒ–

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰äº¤é€šæµé‡åˆ†ææ•°æ®ç»“æ„ï¼Œå®ç°äº¤é€šæµé‡æ¨¡å¼åˆ†æç³»ç»Ÿã€‚

### 5.2 Schemaå®šä¹‰

**äº¤é€šæµé‡åˆ†æSchema**ï¼š

```json
{
  "analysis_type": "flow_pattern",
  "time_window_minutes": 15,
  "total_data_points": 1000,
  "windows": [
    {
      "window_start": "2025-01-21T10:00:00Z",
      "vehicle_count_avg": 120.5,
      "vehicle_count_max": 180,
      "vehicle_count_min": 80,
      "speed_avg": 45.2,
      "speed_max": 60.0,
      "speed_min": 30.0,
      "data_points": 15
    }
  ]
}
```

### 5.3 å®ç°ä»£ç 

**å®Œæ•´çš„äº¤é€šæµé‡åˆ†æå®ç°**ï¼š

```python
from its_schema.transformation import TrafficFlowAnalyzer
from datetime import datetime, timedelta
import random

def case4_traffic_flow_analysis():
    """æ¡ˆä¾‹4ï¼šäº¤é€šæµé‡åˆ†æ"""

    # 1. ç”Ÿæˆæ¨¡æ‹Ÿäº¤é€šæ•°æ®
    traffic_data_list = []
    base_time = datetime(2025, 1, 21, 10, 0, 0)

    for i in range(100):
        traffic_data_list.append({
            "timestamp": (base_time + timedelta(minutes=i)).isoformat(),
            "vehicle_count": random.randint(80, 200),
            "average_speed": random.uniform(30.0, 60.0),
            "occupancy": random.uniform(50.0, 90.0)
        })

    # 2. åˆå§‹åŒ–æµé‡åˆ†æå™¨
    analyzer = TrafficFlowAnalyzer()

    # 3. åˆ†æäº¤é€šæµé‡æ¨¡å¼ï¼ˆ15åˆ†é’Ÿçª—å£ï¼‰
    analysis_result = analyzer.analyze_flow_pattern(traffic_data_list, time_window_minutes=15)

    print(f"Analysis type: {analysis_result['analysis_type']}")
    print(f"Time window: {analysis_result['time_window_minutes']} minutes")
    print(f"Total data points: {analysis_result['total_data_points']}")
    print(f"Number of windows: {len(analysis_result['windows'])}")

    # 4. è¾“å‡ºåˆ†æç»“æœ
    for window in analysis_result['windows']:
        print(f"\nWindow: {window['window_start']}")
        print(f"  Average vehicle count: {window['vehicle_count_avg']:.1f}")
        print(f"  Average speed: {window['speed_avg']:.1f} km/h")
        print(f"  Data points: {window['data_points']}")

    # 5. è¯†åˆ«äº¤é€šæ¨¡å¼
    for window in analysis_result['windows']:
        avg_speed = window['speed_avg']
        avg_count = window['vehicle_count_avg']

        if avg_speed < 30 and avg_count > 150:
            flow_pattern = "Congested"
        elif avg_speed < 50 and avg_count > 100:
            flow_pattern = "Unstable_Flow"
        elif avg_speed >= 50:
            flow_pattern = "Free_Flow"
        else:
            flow_pattern = "Stable_Flow"

        print(f"Window {window['window_start']}: Flow pattern = {flow_pattern}")

    return analysis_result

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case4_traffic_flow_analysis()
    print("Case 4 completed successfully")
```

---

## 6. æ¡ˆä¾‹5ï¼šæ‹¥å µæ£€æµ‹å’Œé¢„è­¦

### 6.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
äº¤é€šç®¡ç†éƒ¨é—¨éœ€è¦å®æ—¶æ£€æµ‹é“è·¯æ‹¥å µæƒ…å†µï¼ŒåŠæ—¶å‘å¸ƒæ‹¥å µé¢„è­¦ä¿¡æ¯ï¼Œå¼•å¯¼è½¦è¾†ç»•è¡Œã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å®æ—¶æ‹¥å µæ£€æµ‹ç®—æ³•
- æ‹¥å µç­‰çº§åˆ¤æ–­æ ‡å‡†
- é¢„è­¦ä¿¡æ¯å‘å¸ƒæœºåˆ¶
- æ‹¥å µé¢„æµ‹

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰æ‹¥å µæ£€æµ‹æ•°æ®ç»“æ„ï¼Œå®ç°å®æ—¶æ‹¥å µæ£€æµ‹å’Œé¢„è­¦ç³»ç»Ÿã€‚

### 6.2 Schemaå®šä¹‰

**æ‹¥å µæ£€æµ‹Schema**ï¼š

```json
{
  "segment_id": "SEG001",
  "location": {
    "latitude": 31.2304,
    "longitude": 121.4737
  },
  "congestion_status": {
    "is_congested": true,
    "congestion_level": "Moderate",
    "congestion_index": 0.65,
    "indicators": {
      "speed_ratio": 0.55,
      "occupancy_ratio": 1.15,
      "density_ratio": 1.25,
      "queue_length": 500.0,
      "delay_time": 120
    },
    "start_time": "2025-01-21T10:15:00Z",
    "duration": 900,
    "affected_length": 2000.0
  },
  "timestamp": "2025-01-21T10:30:00Z"
}
```

### 6.3 å®ç°ä»£ç 

**å®Œæ•´çš„æ‹¥å µæ£€æµ‹å®ç°**ï¼š

```python
from its_schema.transformation import CongestionDetector

def case5_congestion_detection():
    """æ¡ˆä¾‹5ï¼šæ‹¥å µæ£€æµ‹å’Œé¢„è­¦"""

    # 1. åˆå§‹åŒ–æ‹¥å µæ£€æµ‹å™¨
    detector = CongestionDetector()

    # 2. æ¨¡æ‹Ÿäº¤é€šæ•°æ®
    traffic_data = {
        "average_speed": 18.5,  # km/h
        "occupancy": 85.0  # %
    }

    # 3. æ£€æµ‹æ‹¥å µ
    congestion_result = detector.detect_congestion(traffic_data)

    print(f"Congestion detection result:")
    print(f"  Is congested: {congestion_result['is_congested']}")
    print(f"  Congestion level: {congestion_result['congestion_level']}")
    print(f"  Speed: {congestion_result['speed']} km/h")
    print(f"  Occupancy: {congestion_result['occupancy']}%")

    # 4. æ ¹æ®æ‹¥å µç­‰çº§å‘å¸ƒé¢„è­¦
    if congestion_result['congestion_level'] == "Severe":
        print("ALERT: Severe congestion detected! Consider alternative routes.")
    elif congestion_result['congestion_level'] == "Moderate":
        print("WARNING: Moderate congestion detected. Expect delays.")
    elif congestion_result['congestion_level'] == "Light":
        print("INFO: Light congestion detected.")
    else:
        print("INFO: No congestion detected.")

    return congestion_result

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case5_congestion_detection()
    print("Case 5 completed successfully")
```

---

## 7. æ¡ˆä¾‹6ï¼šè·¯å¾„è§„åˆ’

### 7.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
å¯¼èˆªç³»ç»Ÿéœ€è¦æ ¹æ®å®æ—¶è·¯å†µä¿¡æ¯è§„åˆ’æœ€ä¼˜è·¯å¾„ï¼Œè€ƒè™‘è·ç¦»ã€æ—¶é—´ã€æ‹¥å µç¨‹åº¦ç­‰å› ç´ ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å®æ—¶è·¯å†µæ•°æ®è·å–
- å¤šç›®æ ‡è·¯å¾„ä¼˜åŒ–ç®—æ³•
- åŠ¨æ€è·¯å¾„è°ƒæ•´
- è·¯å¾„è§„åˆ’å‡†ç¡®æ€§

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰è·¯å¾„è§„åˆ’æ•°æ®ç»“æ„ï¼Œå®ç°å¤šç›®æ ‡è·¯å¾„è§„åˆ’ç³»ç»Ÿã€‚

### 7.2 Schemaå®šä¹‰

**è·¯å¾„è§„åˆ’Schema**ï¼š

```json
{
  "route_id": "ROUTE001",
  "origin": {
    "latitude": 31.2304,
    "longitude": 121.4737
  },
  "destination": {
    "latitude": 31.2504,
    "longitude": 121.4937
  },
  "route_options": {
    "optimization_criteria": "Fastest",
    "avoid_tolls": false,
    "avoid_highways": false,
    "avoid_ferries": false
  },
  "calculated_route": {
    "total_distance": 5000.0,
    "total_duration": 600,
    "estimated_duration": 720,
    "waypoints": [
      {
        "sequence": 1,
        "location": {
          "latitude": 31.2354,
          "longitude": 121.4787
        },
        "distance_from_origin": 1000.0,
        "estimated_arrival": "2025-01-21T10:35:00Z",
        "road_name": "äººæ°‘è·¯",
        "maneuver": "Turn_Right"
      }
    ],
    "segments": [
      {
        "segment_id": "SEG001",
        "start_location": {
          "latitude": 31.2304,
          "longitude": 121.4737
        },
        "end_location": {
          "latitude": 31.2354,
          "longitude": 121.4787
        },
        "distance": 1000.0,
        "duration": 120,
        "average_speed": 30.0,
        "road_type": "Arterial",
        "congestion_level": "Light"
      }
    ]
  },
  "timestamp": "2025-01-21T10:30:00Z"
}
```

### 7.3 å®ç°ä»£ç 

**è·¯å¾„è§„åˆ’å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰**ï¼š

```python
def case6_route_planning():
    """æ¡ˆä¾‹6ï¼šè·¯å¾„è§„åˆ’"""

    # 1. å®šä¹‰èµ·ç‚¹å’Œç»ˆç‚¹
    origin = {
        "latitude": 31.2304,
        "longitude": 121.4737
    }

    destination = {
        "latitude": 31.2504,
        "longitude": 121.4937
    }

    # 2. è·¯å¾„è§„åˆ’é€‰é¡¹
    route_options = {
        "optimization_criteria": "Fastest",
        "avoid_tolls": False,
        "avoid_highways": False,
        "avoid_ferries": False
    }

    # 3. æ¨¡æ‹Ÿè·¯å¾„è§„åˆ’ï¼ˆå®é™…å®ç°éœ€è¦ä½¿ç”¨åœ°å›¾APIï¼Œå¦‚Google Mapsã€é«˜å¾·åœ°å›¾ç­‰ï¼‰
    route_data = {
        "route_id": "ROUTE001",
        "origin": origin,
        "destination": destination,
        "route_options": route_options,
        "calculated_route": {
            "total_distance": 5000.0,  # meters
            "total_duration": 600,  # seconds
            "estimated_duration": 720,  # seconds (è€ƒè™‘æ‹¥å µ)
            "waypoints": [
                {
                    "sequence": 1,
                    "location": {
                        "latitude": 31.2354,
                        "longitude": 121.4787
                    },
                    "distance_from_origin": 1000.0,
                    "estimated_arrival": "2025-01-21T10:35:00Z",
                    "road_name": "äººæ°‘è·¯",
                    "maneuver": "Turn_Right"
                }
            ],
            "segments": [
                {
                    "segment_id": "SEG001",
                    "start_location": origin,
                    "end_location": {
                        "latitude": 31.2354,
                        "longitude": 121.4787
                    },
                    "distance": 1000.0,
                    "duration": 120,
                    "average_speed": 30.0,
                    "road_type": "Arterial",
                    "congestion_level": "Light"
                }
            ]
        },
        "timestamp": datetime.now().isoformat()
    }

    print(f"Route planned:")
    print(f"  Total distance: {route_data['calculated_route']['total_distance']} meters")
    print(f"  Estimated duration: {route_data['calculated_route']['estimated_duration']} seconds")
    print(f"  Number of waypoints: {len(route_data['calculated_route']['waypoints'])}")

    return route_data

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case6_route_planning()
    print("Case 6 completed successfully")
```

---

## 8. æ¡ˆä¾‹7ï¼šäº‹ä»¶æ£€æµ‹å’Œå¤„ç†

### 8.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
äº¤é€šç®¡ç†éƒ¨é—¨éœ€è¦è‡ªåŠ¨æ£€æµ‹äº¤é€šäº‹æ•…ã€æ–½å·¥ã€æ‹¥å µç­‰äº‹ä»¶ï¼ŒåŠæ—¶å¤„ç†å’Œå‘å¸ƒä¿¡æ¯ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å¤šæºäº‹ä»¶æ£€æµ‹ï¼ˆä¼ æ„Ÿå™¨ã€è§†é¢‘ã€V2XæŠ¥å‘Šï¼‰
- äº‹ä»¶ç±»å‹è¯†åˆ«å’Œåˆ†ç±»
- äº‹ä»¶å½±å“è¯„ä¼°
- äº‹ä»¶å¤„ç†æµç¨‹ç®¡ç†

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰äº‹ä»¶æ£€æµ‹æ•°æ®ç»“æ„ï¼Œå®ç°è‡ªåŠ¨äº‹ä»¶æ£€æµ‹å’Œå¤„ç†ç³»ç»Ÿã€‚

### 8.2 Schemaå®šä¹‰

**äº‹ä»¶æ£€æµ‹Schema**ï¼š

```json
{
  "event_id": "EVT001",
  "event_type": "Accident",
  "location": {
    "latitude": 31.2304,
    "longitude": 121.4737
  },
  "event_details": {
    "severity": "High",
    "description": "ä¸¤è½¦è¿½å°¾äº‹æ•…",
    "start_time": "2025-01-21T10:25:00Z",
    "end_time": null,
    "affected_lanes": [1, 2],
    "affected_directions": ["North"],
    "impact": {
      "affected_length": 500.0,
      "expected_delay": 600,
      "speed_reduction": 30.0,
      "capacity_reduction": 50.0
    }
  },
  "detection_method": "Automatic_Video",
  "confidence": 0.95,
  "timestamp": "2025-01-21T10:30:00Z"
}
```

### 8.3 å®ç°ä»£ç 

**äº‹ä»¶æ£€æµ‹å’Œå¤„ç†å®ç°**ï¼š

```python
def case7_event_detection():
    """æ¡ˆä¾‹7ï¼šäº‹ä»¶æ£€æµ‹å’Œå¤„ç†"""

    # 1. æ¨¡æ‹Ÿæ£€æµ‹åˆ°çš„äº‹ä»¶
    event_data = {
        "event_id": "EVT001",
        "event_type": "Accident",
        "location": {
            "latitude": 31.2304,
            "longitude": 121.4737
        },
        "event_details": {
            "severity": "High",
            "description": "ä¸¤è½¦è¿½å°¾äº‹æ•…",
            "start_time": "2025-01-21T10:25:00Z",
            "end_time": None,
            "affected_lanes": [1, 2],
            "affected_directions": ["North"],
            "impact": {
                "affected_length": 500.0,
                "expected_delay": 600,
                "speed_reduction": 30.0,
                "capacity_reduction": 50.0
            }
        },
        "detection_method": "Automatic_Video",
        "confidence": 0.95,
        "timestamp": datetime.now().isoformat()
    }

    print(f"Event detected:")
    print(f"  Event ID: {event_data['event_id']}")
    print(f"  Event type: {event_data['event_type']}")
    print(f"  Severity: {event_data['event_details']['severity']}")
    print(f"  Confidence: {event_data['confidence']}")

    # 2. æ ¹æ®äº‹ä»¶ä¸¥é‡ç¨‹åº¦å¤„ç†
    severity = event_data['event_details']['severity']

    if severity == "Critical":
        print("CRITICAL: Immediate response required!")
        # å‘é€ç´§æ€¥é€šçŸ¥
        # è°ƒåº¦æ•‘æ´è½¦è¾†
        # å°é—­ç›¸å…³è½¦é“
    elif severity == "High":
        print("HIGH: Rapid response required!")
        # å‘é€é¢„è­¦ä¿¡æ¯
        # è°ƒæ•´ä¿¡å·æ§åˆ¶
        # å‘å¸ƒç»•è¡Œå»ºè®®
    elif severity == "Medium":
        print("MEDIUM: Standard response.")
        # è®°å½•äº‹ä»¶
        # ç›‘æ§å½±å“
    else:
        print("LOW: Monitor situation.")
        # è®°å½•äº‹ä»¶

    # 3. è¯„ä¼°äº‹ä»¶å½±å“
    impact = event_data['event_details']['impact']
    print(f"\nEvent impact:")
    print(f"  Affected length: {impact['affected_length']} meters")
    print(f"  Expected delay: {impact['expected_delay']} seconds")
    print(f"  Speed reduction: {impact['speed_reduction']} km/h")
    print(f"  Capacity reduction: {impact['capacity_reduction']}%")

    return event_data

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case7_event_detection()
    print("Case 7 completed successfully")
```

---

## 9. æ¡ˆä¾‹8ï¼šITSæ•°æ®å­˜å‚¨ç³»ç»Ÿ

### 9.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
ITSç³»ç»Ÿéœ€è¦å­˜å‚¨å¤§é‡çš„äº¤é€šæ•°æ®ã€ä¿¡å·æ§åˆ¶æ•°æ®ã€V2Væ¶ˆæ¯ç­‰ï¼Œæ”¯æŒå†å²æ•°æ®æŸ¥è¯¢å’Œåˆ†æã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- å¤§è§„æ¨¡æ—¶åºæ•°æ®å­˜å‚¨
- é«˜æ•ˆçš„æ•°æ®æŸ¥è¯¢
- æ•°æ®å‹ç¼©å’Œå½’æ¡£
- æ•°æ®ä¸€è‡´æ€§ä¿è¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaå®šä¹‰æ•°æ®å­˜å‚¨ç»“æ„ï¼Œå®ç°PostgreSQLæ•°æ®å­˜å‚¨ç³»ç»Ÿã€‚

### 9.2 å®ç°ä»£ç 

**å®Œæ•´çš„ITSæ•°æ®å­˜å‚¨å®ç°**ï¼š

```python
from its_schema.transformation import ITSStorage
from datetime import datetime, timedelta

def case8_its_data_storage():
    """æ¡ˆä¾‹8ï¼šITSæ•°æ®å­˜å‚¨ç³»ç»Ÿ"""

    # 1. åˆå§‹åŒ–å­˜å‚¨
    db_config = {
        "host": "localhost",
        "port": 5432,
        "database": "its_db",
        "user": "its_user",
        "password": "its_password"
    }

    storage = ITSStorage(db_config)
    storage.connect()
    storage.create_tables()

    # 2. å­˜å‚¨ä¼ æ„Ÿå™¨æ•°æ®
    sensor_data = {
        "sensor_id": "SENSOR001",
        "timestamp": datetime.now().isoformat(),
        "vehicle_count": 150,
        "average_speed": 45.5,
        "occupancy": 75.2,
        "lane_id": 1
    }

    sensor_id = storage.store_sensor_data(sensor_data)
    print(f"Stored sensor data with ID: {sensor_id}")

    # 3. æŸ¥è¯¢äº¤é€šæ•°æ®
    start_time = datetime.now() - timedelta(hours=1)
    end_time = datetime.now()

    traffic_records = storage.query_traffic_data("SENSOR001", start_time, end_time)
    print(f"Found {len(traffic_records)} traffic records")

    # 4. æ•°æ®ç»Ÿè®¡åˆ†æ
    if traffic_records:
        total_vehicles = sum(r['vehicle_count'] for r in traffic_records)
        avg_speed = sum(r['average_speed'] for r in traffic_records) / len(traffic_records)
        avg_occupancy = sum(r['occupancy'] for r in traffic_records) / len(traffic_records)

        print(f"\nStatistics:")
        print(f"  Total vehicles: {total_vehicles}")
        print(f"  Average speed: {avg_speed:.2f} km/h")
        print(f"  Average occupancy: {avg_occupancy:.2f}%")

    return {
        "sensor_id": sensor_id,
        "traffic_records": traffic_records
    }

# è¿è¡Œæ¡ˆä¾‹
if __name__ == "__main__":
    result = case8_its_data_storage()
    print("Case 8 completed successfully")
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

---

## 10. æ¡ˆä¾‹9ï¼šæ™ºèƒ½ä¿¡å·ä¼˜åŒ–ç³»ç»Ÿ

### 10.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
æ™ºèƒ½ä¿¡å·ä¼˜åŒ–ç³»ç»ŸåŸºäºå®æ—¶äº¤é€šæµé‡æ•°æ®ï¼Œ
åŠ¨æ€è°ƒæ•´äº¤é€šä¿¡å·ç¯é…æ—¶ï¼Œä¼˜åŒ–äº¤é€šæµï¼Œå‡å°‘æ‹¥å µã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®æ—¶äº¤é€šæµé‡ç›‘æµ‹
- éœ€è¦ä¿¡å·é…æ—¶ç®—æ³•
- éœ€è¦å¤šäº¤å‰å£åè°ƒ
- éœ€è¦æ•ˆæœè¯„ä¼°

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaæ”¶é›†äº¤é€šæµé‡æ•°æ®ï¼Œ
ä½¿ç”¨AIç®—æ³•ä¼˜åŒ–ä¿¡å·é…æ—¶ï¼Œ
ä½¿ç”¨ITSStorageå­˜å‚¨ä¼˜åŒ–ç»“æœã€‚

### 10.2 Schemaå®šä¹‰

**æ™ºèƒ½ä¿¡å·ä¼˜åŒ–Schema**ï¼š

```dsl
schema IntelligentSignalOptimization {
  optimization_session_id: String @value("SIGNAL-OPT-20250121-001") @required
  intersection_id: String @value("INT-001") @required
  optimization_time: DateTime @value("2025-01-21T10:00:00") @required

  current_traffic: {
    phase_1_vehicle_count: Integer @value(50)
    phase_2_vehicle_count: Integer @value(80)
    phase_3_vehicle_count: Integer @value(60)
    phase_4_vehicle_count: Integer @value(40)
    average_waiting_time: Decimal @value(45.5) @unit("seconds")
  } @required

  current_signal_timing: {
    phase_1_duration: Integer @value(30) @unit("seconds")
    phase_2_duration: Integer @value(40) @unit("seconds")
    phase_3_duration: Integer @value(35) @unit("seconds")
    phase_4_duration: Integer @value(25) @unit("seconds")
    cycle_time: Integer @value(130) @unit("seconds")
  } @required

  optimized_timing: {
    phase_1_duration: Integer @value(35) @unit("seconds")
    phase_2_duration: Integer @value(45) @unit("seconds")
    phase_3_duration: Integer @value(40) @unit("seconds")
    phase_4_duration: Integer @value(30) @unit("seconds")
    cycle_time: Integer @value(150) @unit("seconds")
  } @required

  optimization_results: {
    expected_waiting_time_reduction: Decimal @value(0.15) @unit("15% reduction")
    expected_throughput_increase: Decimal @value(0.12) @unit("12% increase")
    optimization_score: Decimal @value(0.85) @range(0.0, 1.0)
  } @required
} @standard("ISO_14813")
```

### 10.3 å®ç°ä»£ç 

```python
from its_storage import ITSStorage
from datetime import datetime

def intelligent_signal_optimization():
    """æ™ºèƒ½ä¿¡å·ä¼˜åŒ–ç¤ºä¾‹"""
    storage = ITSStorage("postgresql://user:password@localhost/its_db")

    # è·å–å½“å‰äº¤é€šæµé‡æ•°æ®
    intersection_id = "INT-001"
    current_traffic = {
        "phase_1_vehicle_count": 50,
        "phase_2_vehicle_count": 80,
        "phase_3_vehicle_count": 60,
        "phase_4_vehicle_count": 40,
        "average_waiting_time": 45.5
    }

    # å½“å‰ä¿¡å·é…æ—¶
    current_timing = {
        "phase_1_duration": 30,
        "phase_2_duration": 40,
        "phase_3_duration": 35,
        "phase_4_duration": 25,
        "cycle_time": 130
    }

    # AIä¼˜åŒ–ç®—æ³•ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    def optimize_signal_timing(traffic_data, current_timing):
        """ä¼˜åŒ–ä¿¡å·é…æ—¶"""
        total_vehicles = sum([
            traffic_data["phase_1_vehicle_count"],
            traffic_data["phase_2_vehicle_count"],
            traffic_data["phase_3_vehicle_count"],
            traffic_data["phase_4_vehicle_count"]
        ])

        # æ ¹æ®è½¦æµé‡æ¯”ä¾‹åˆ†é…æ—¶é—´
        phase_1_ratio = traffic_data["phase_1_vehicle_count"] / total_vehicles
        phase_2_ratio = traffic_data["phase_2_vehicle_count"] / total_vehicles
        phase_3_ratio = traffic_data["phase_3_vehicle_count"] / total_vehicles
        phase_4_ratio = traffic_data["phase_4_vehicle_count"] / total_vehicles

        # ä¼˜åŒ–åçš„é…æ—¶ï¼ˆæ€»å‘¨æœŸ150ç§’ï¼‰
        optimized_cycle = 150
        optimized_timing = {
            "phase_1_duration": int(optimized_cycle * phase_1_ratio),
            "phase_2_duration": int(optimized_cycle * phase_2_ratio),
            "phase_3_duration": int(optimized_cycle * phase_3_ratio),
            "phase_4_duration": int(optimized_cycle * phase_4_ratio),
            "cycle_time": optimized_cycle
        }

        return optimized_timing

    # æ‰§è¡Œä¼˜åŒ–
    optimized_timing = optimize_signal_timing(current_traffic, current_timing)

    # è®¡ç®—ä¼˜åŒ–æ•ˆæœ
    expected_waiting_time_reduction = 0.15  # é¢„è®¡å‡å°‘15%
    expected_throughput_increase = 0.12  # é¢„è®¡å¢åŠ 12%
    optimization_score = 0.85

    # å­˜å‚¨ä¼˜åŒ–ç»“æœ
    optimization_data = {
        "optimization_session_id": "SIGNAL-OPT-20250121-001",
        "intersection_id": intersection_id,
        "optimization_time": datetime.now(),
        "current_traffic": current_traffic,
        "current_signal_timing": current_timing,
        "optimized_timing": optimized_timing,
        "expected_waiting_time_reduction": expected_waiting_time_reduction,
        "expected_throughput_increase": expected_throughput_increase,
        "optimization_score": optimization_score
    }

    # å­˜å‚¨åˆ°æ•°æ®åº“
    optimization_id = storage.store_signal_control_data(optimization_data)
    print(f"Signal optimization stored: {optimization_id}")

    print(f"\nSignal Optimization Results:")
    print(f"  Intersection: {intersection_id}")
    print(f"  Current cycle time: {current_timing['cycle_time']}s")
    print(f"  Optimized cycle time: {optimized_timing['cycle_time']}s")
    print(f"  Expected waiting time reduction: {expected_waiting_time_reduction*100:.1f}%")
    print(f"  Expected throughput increase: {expected_throughput_increase*100:.1f}%")
    print(f"  Optimization score: {optimization_score:.2f}")

    return optimization_data

if __name__ == "__main__":
    intelligent_signal_optimization()
```

---

## 11. æ¡ˆä¾‹10ï¼šäº¤é€šé¢„æµ‹ç³»ç»Ÿ

### 11.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
äº¤é€šé¢„æµ‹ç³»ç»ŸåŸºäºå†å²äº¤é€šæ•°æ®å’Œå®æ—¶æ•°æ®ï¼Œ
é¢„æµ‹æœªæ¥äº¤é€šæµé‡å’Œæ‹¥å µæƒ…å†µï¼Œæ”¯æŒäº¤é€šç®¡ç†å†³ç­–ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å†å²æ•°æ®åˆ†æ
- éœ€è¦é¢„æµ‹æ¨¡å‹è®­ç»ƒ
- éœ€è¦å®æ—¶æ•°æ®èåˆ
- éœ€è¦é¢„æµ‹å‡†ç¡®æ€§è¯„ä¼°

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaæ”¶é›†å†å²äº¤é€šæ•°æ®ï¼Œ
ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹è¿›è¡Œäº¤é€šé¢„æµ‹ï¼Œ
ä½¿ç”¨ITSStorageå­˜å‚¨é¢„æµ‹ç»“æœã€‚

### 11.2 Schemaå®šä¹‰

**äº¤é€šé¢„æµ‹Schema**ï¼š

```dsl
schema TrafficPrediction {
  prediction_session_id: String @value("PRED-20250121-001") @required
  prediction_time: DateTime @value("2025-01-21T10:00:00") @required
  prediction_horizon: Integer @value(60) @unit("minutes")

  location: {
    intersection_id: String @value("INT-001")
    latitude: Decimal @value(31.2304)
    longitude: Decimal @value(121.4737)
  } @required

  historical_data: {
    time_window: {
      start: DateTime @value("2025-01-21T09:00:00")
      end: DateTime @value("2025-01-21T10:00:00")
    }
    average_vehicle_count: Integer @value(150)
    average_speed: Decimal @value(45.5)
    congestion_events: Integer @value(3)
  } @required

  predictions: [
    {
      prediction_time: DateTime @value("2025-01-21T11:00:00")
      predicted_vehicle_count: Integer @value(180)
      predicted_speed: Decimal @value(40.5)
      predicted_congestion_level: Enum { Medium } @value(Medium)
      confidence: Decimal @value(0.85) @range(0.0, 1.0)
    }
  ] @required

  prediction_accuracy: {
    model_name: String @value("LSTM")
    mae: Decimal @value(12.5) @unit("vehicles")
    rmse: Decimal @value(15.8) @unit("vehicles")
    accuracy: Decimal @value(0.88) @range(0.0, 1.0)
  } @required
} @standard("ISO_14813")
```

### 11.3 å®ç°ä»£ç 

```python
from its_storage import ITSStorage
from datetime import datetime, timedelta

def traffic_prediction_system():
    """äº¤é€šé¢„æµ‹ç³»ç»Ÿç¤ºä¾‹"""
    storage = ITSStorage("postgresql://user:password@localhost/its_db")

    # è·å–å†å²äº¤é€šæ•°æ®
    intersection_id = "INT-001"
    end_time = datetime.now()
    start_time = end_time - timedelta(hours=1)

    historical_data = storage.query_traffic_data(intersection_id, start_time, end_time)

    # è®¡ç®—å†å²ç»Ÿè®¡
    if historical_data:
        avg_vehicle_count = sum(d['vehicle_count'] for d in historical_data) / len(historical_data)
        avg_speed = sum(d['average_speed'] for d in historical_data) / len(historical_data)
        congestion_events = sum(1 for d in historical_data if d.get('congestion_level') == 'High')
    else:
        avg_vehicle_count = 150
        avg_speed = 45.5
        congestion_events = 3

    # é¢„æµ‹æ¨¡å‹ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    def predict_traffic(historical_avg, prediction_horizon_minutes):
        """é¢„æµ‹äº¤é€šæµé‡"""
        # ç®€åŒ–é¢„æµ‹ï¼šåŸºäºå†å²å¹³å‡å€¼å’Œæ—¶é—´å› å­
        time_factor = 1.2 if prediction_horizon_minutes <= 30 else 1.5
        predicted_count = int(historical_avg * time_factor)
        predicted_speed = max(20.0, historical_avg * 0.9)

        congestion_level = "Low" if predicted_count < 100 else \
                          "Medium" if predicted_count < 200 else "High"

        return {
            "predicted_vehicle_count": predicted_count,
            "predicted_speed": predicted_speed,
            "predicted_congestion_level": congestion_level,
            "confidence": 0.85
        }

    # ç”Ÿæˆé¢„æµ‹
    prediction_horizon = 60  # 60åˆ†é’Ÿ
    prediction_time = end_time + timedelta(minutes=prediction_horizon)

    prediction = predict_traffic(avg_vehicle_count, prediction_horizon)

    # å­˜å‚¨é¢„æµ‹ç»“æœ
    prediction_data = {
        "prediction_session_id": "PRED-20250121-001",
        "prediction_time": datetime.now(),
        "prediction_horizon": prediction_horizon,
        "intersection_id": intersection_id,
        "historical_avg_vehicle_count": avg_vehicle_count,
        "historical_avg_speed": avg_speed,
        "historical_congestion_events": congestion_events,
        "predicted_vehicle_count": prediction["predicted_vehicle_count"],
        "predicted_speed": prediction["predicted_speed"],
        "predicted_congestion_level": prediction["predicted_congestion_level"],
        "confidence": prediction["confidence"],
        "model_name": "LSTM",
        "mae": 12.5,
        "rmse": 15.8,
        "accuracy": 0.88
    }

    # å­˜å‚¨åˆ°æ•°æ®åº“
    prediction_id = storage.store_traffic_data(prediction_data)
    print(f"Traffic prediction stored: {prediction_id}")

    print(f"\nTraffic Prediction Results:")
    print(f"  Intersection: {intersection_id}")
    print(f"  Prediction horizon: {prediction_horizon} minutes")
    print(f"  Historical avg vehicle count: {avg_vehicle_count:.0f}")
    print(f"  Predicted vehicle count: {prediction['predicted_vehicle_count']}")
    print(f"  Predicted speed: {prediction['predicted_speed']:.1f} km/h")
    print(f"  Predicted congestion level: {prediction['predicted_congestion_level']}")
    print(f"  Confidence: {prediction['confidence']:.2f}")
    print(f"  Model accuracy: 0.88")

    return prediction_data

if __name__ == "__main__":
    traffic_prediction_system()
```

---

## 12. æ¡ˆä¾‹11ï¼šäº‹æ•…é¢„é˜²ç³»ç»Ÿ

### 12.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
äº‹æ•…é¢„é˜²ç³»ç»Ÿé€šè¿‡åˆ†æäº¤é€šæ•°æ®ã€å¤©æ°”æ•°æ®ã€å†å²äº‹æ•…æ•°æ®ï¼Œ
è¯†åˆ«äº‹æ•…é£é™©ç‚¹ï¼Œæå‰é¢„è­¦ï¼Œå‡å°‘äº¤é€šäº‹æ•…å‘ç”Ÿã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å¤šæºæ•°æ®èåˆ
- éœ€è¦é£é™©è¯†åˆ«ç®—æ³•
- éœ€è¦å®æ—¶é¢„è­¦
- éœ€è¦æ•ˆæœè¯„ä¼°

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ITS_Schemaæ•´åˆäº¤é€šã€å¤©æ°”ã€äº‹æ•…æ•°æ®ï¼Œ
ä½¿ç”¨AIæ¨¡å‹è¯†åˆ«äº‹æ•…é£é™©ï¼Œ
ä½¿ç”¨ITSStorageå­˜å‚¨é¢„è­¦ä¿¡æ¯ã€‚

### 12.2 Schemaå®šä¹‰

**äº‹æ•…é¢„é˜²Schema**ï¼š

```dsl
schema AccidentPrevention {
  prevention_session_id: String @value("PREVENT-20250121-001") @required
  analysis_time: DateTime @value("2025-01-21T10:00:00") @required

  location: {
    intersection_id: String @value("INT-001")
    latitude: Decimal @value(31.2304)
    longitude: Decimal @value(121.4737)
  } @required

  risk_factors: {
    traffic_volume: Integer @value(200)
    average_speed: Decimal @value(55.5)
    speed_variance: Decimal @value(15.2)
    weather_condition: Enum { Rainy } @value(Rainy)
    visibility: Decimal @value(500.0) @unit("meters")
    road_condition: Enum { Wet } @value(Wet)
    historical_accidents: Integer @value(5) @unit("last 30 days")
  } @required

  risk_assessment: {
    risk_level: Enum { High } @value(High)
    risk_score: Decimal @value(0.75) @range(0.0, 1.0)
    risk_factors_count: Integer @value(4)
    primary_risk_factor: String @value("High speed variance + Rainy weather")
  } @required

  prevention_actions: [
    {
      action_type: String @value("SpeedLimit")
      action_description: String @value("é™ä½é™é€Ÿè‡³40km/h")
      expected_risk_reduction: Decimal @value(0.30)
    },
    {
      action_type: String @value("WarningSign")
      action_description: String @value("æ˜¾ç¤ºé›¨å¤©å‡é€Ÿè­¦å‘Š")
      expected_risk_reduction: Decimal @value(0.15)
    }
  ] @required

  alert: {
    alert_level: Enum { High } @value(High)
    alert_message: String @value("é«˜é£é™©è·¯æ®µï¼Œè¯·å‡é€Ÿæ…¢è¡Œ")
    alert_sent: Boolean @value(true)
    alert_time: DateTime @value("2025-01-21T10:05:00")
  } @required
} @standard("ISO_14813")
```

### 12.3 å®ç°ä»£ç 

```python
from its_storage import ITSStorage
from datetime import datetime

def accident_prevention_system():
    """äº‹æ•…é¢„é˜²ç³»ç»Ÿç¤ºä¾‹"""
    storage = ITSStorage("postgresql://user:password@localhost/its_db")

    # è·å–äº¤é€šæ•°æ®
    intersection_id = "INT-001"
    traffic_data = {
        "traffic_volume": 200,
        "average_speed": 55.5,
        "speed_variance": 15.2
    }

    # è·å–å¤©æ°”æ•°æ®
    weather_data = {
        "weather_condition": "Rainy",
        "visibility": 500.0,
        "road_condition": "Wet"
    }

    # è·å–å†å²äº‹æ•…æ•°æ®
    historical_accidents = 5  # è¿‡å»30å¤©

    # é£é™©è¯†åˆ«ç®—æ³•
    def assess_accident_risk(traffic_data, weather_data, historical_accidents):
        """è¯„ä¼°äº‹æ•…é£é™©"""
        risk_score = 0.0
        risk_factors = []

        # äº¤é€šæµé‡é£é™©
        if traffic_data["traffic_volume"] > 150:
            risk_score += 0.15
            risk_factors.append("High traffic volume")

        # é€Ÿåº¦é£é™©
        if traffic_data["average_speed"] > 50:
            risk_score += 0.20
            risk_factors.append("High average speed")

        # é€Ÿåº¦æ–¹å·®é£é™©
        if traffic_data["speed_variance"] > 10:
            risk_score += 0.25
            risk_factors.append("High speed variance")

        # å¤©æ°”é£é™©
        if weather_data["weather_condition"] == "Rainy":
            risk_score += 0.20
            risk_factors.append("Rainy weather")

        if weather_data["visibility"] < 1000:
            risk_score += 0.10
            risk_factors.append("Low visibility")

        # å†å²äº‹æ•…é£é™©
        if historical_accidents > 3:
            risk_score += 0.10
            risk_factors.append("High historical accident rate")

        # ç¡®å®šé£é™©ç­‰çº§
        if risk_score >= 0.7:
            risk_level = "High"
        elif risk_score >= 0.5:
            risk_level = "Medium"
        else:
            risk_level = "Low"

        return {
            "risk_level": risk_level,
            "risk_score": min(risk_score, 1.0),
            "risk_factors": risk_factors,
            "primary_risk_factor": " + ".join(risk_factors[:2])
        }

    # æ‰§è¡Œé£é™©è¯„ä¼°
    risk_assessment = assess_accident_risk(traffic_data, weather_data, historical_accidents)

    # ç”Ÿæˆé¢„é˜²æªæ–½
    prevention_actions = []
    if risk_assessment["risk_level"] == "High":
        prevention_actions = [
            {
                "action_type": "SpeedLimit",
                "action_description": "é™ä½é™é€Ÿè‡³40km/h",
                "expected_risk_reduction": 0.30
            },
            {
                "action_type": "WarningSign",
                "action_description": "æ˜¾ç¤ºé›¨å¤©å‡é€Ÿè­¦å‘Š",
                "expected_risk_reduction": 0.15
            }
        ]

    # å‘é€é¢„è­¦
    alert_level = risk_assessment["risk_level"]
    alert_message = f"é«˜é£é™©è·¯æ®µï¼Œè¯·å‡é€Ÿæ…¢è¡Œ" if alert_level == "High" else \
                   f"ä¸­ç­‰é£é™©è·¯æ®µï¼Œè¯·æ³¨æ„å®‰å…¨" if alert_level == "Medium" else \
                   f"ä½é£é™©è·¯æ®µï¼Œæ­£å¸¸è¡Œé©¶"

    # å­˜å‚¨é¢„é˜²æ•°æ®
    prevention_data = {
        "prevention_session_id": "PREVENT-20250121-001",
        "analysis_time": datetime.now(),
        "intersection_id": intersection_id,
        "traffic_volume": traffic_data["traffic_volume"],
        "average_speed": traffic_data["average_speed"],
        "speed_variance": traffic_data["speed_variance"],
        "weather_condition": weather_data["weather_condition"],
        "visibility": weather_data["visibility"],
        "road_condition": weather_data["road_condition"],
        "historical_accidents": historical_accidents,
        "risk_level": risk_assessment["risk_level"],
        "risk_score": risk_assessment["risk_score"],
        "risk_factors_count": len(risk_assessment["risk_factors"]),
        "primary_risk_factor": risk_assessment["primary_risk_factor"],
        "prevention_actions": prevention_actions,
        "alert_level": alert_level,
        "alert_message": alert_message,
        "alert_sent": True,
        "alert_time": datetime.now()
    }

    # å­˜å‚¨åˆ°æ•°æ®åº“
    prevention_id = storage.store_traffic_data(prevention_data)
    print(f"Accident prevention data stored: {prevention_id}")

    print(f"\nAccident Prevention Analysis:")
    print(f"  Intersection: {intersection_id}")
    print(f"  Risk level: {risk_assessment['risk_level']}")
    print(f"  Risk score: {risk_assessment['risk_score']:.2f}")
    print(f"  Risk factors: {len(risk_assessment['risk_factors'])}")
    print(f"  Primary risk: {risk_assessment['primary_risk_factor']}")
    print(f"  Alert: {alert_message}")
    print(f"  Prevention actions: {len(prevention_actions)}")

    return prevention_data

if __name__ == "__main__":
    accident_prevention_system()
```

---

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

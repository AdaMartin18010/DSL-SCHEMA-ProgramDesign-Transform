# æ™ºèƒ½äº¤é€šç³»ç»ŸSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½äº¤é€šç³»ç»ŸSchemaå®è·µæ¡ˆä¾‹](#æ™ºèƒ½äº¤é€šç³»ç»Ÿschemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šæ™ºæ…§åŸå¸‚äº¤é€šå¤§è„‘](#2-æ¡ˆä¾‹1æ™ºæ…§åŸå¸‚äº¤é€šå¤§è„‘)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 å®Œæ•´ä»£ç å®ç°](#25-å®Œæ•´ä»£ç å®ç°)
    - [2.6 æ•ˆæœè¯„ä¼°](#26-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹æ€»ç»“](#3-æ¡ˆä¾‹æ€»ç»“)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ITS Schemaåœ¨æ™ºèƒ½äº¤é€šé¢†åŸŸçš„å®è·µæ¡ˆä¾‹ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šæ™ºæ…§åŸå¸‚äº¤é€šå¤§è„‘

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šæ¦‚å†µ**ï¼šæŸçœä¼šåŸå¸‚äº¤é€šç®¡ç†éƒ¨é—¨ï¼ˆä»¥ä¸‹ç®€ç§°"Käº¤é€š"ï¼‰ï¼Œç®¡ç†åŸå¸‚é“è·¯è¶…è¿‡5000å…¬é‡Œï¼Œä¿¡å·ç¯è·¯å£è¶…è¿‡3000ä¸ªï¼Œæ—¥å‡è½¦æµé‡è¶…è¿‡500ä¸‡è¾†ã€‚

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **äº¤é€šæ‹¥å µä¸¥é‡**ï¼šé«˜å³°æ—¶æ®µå¹³å‡è½¦é€Ÿä»…15km/hï¼Œæ‹¥å µæŒ‡æ•°å±…å…¨å›½å‰åˆ—
2. **ä¿¡å·ç¯é…æ—¶ä¸ä¼˜**ï¼šå›ºå®šé…æ—¶æ–¹æ¡ˆæ— æ³•é€‚åº”æµé‡å˜åŒ–ï¼Œç»¿ç¯ç©ºæ”¾ä¸¥é‡
3. **äº‹æ•…å“åº”æ…¢**ï¼šäº‹æ•…å‘ç°ä¾èµ–å¸‚æ°‘æŠ¥è­¦ï¼Œå¹³å‡å“åº”æ—¶é—´è¶…è¿‡20åˆ†é’Ÿ
4. **åœè½¦éš¾**ï¼šåœè½¦ä½ç¼ºå£è¶…è¿‡30ä¸‡ä¸ªï¼Œåœè½¦è¯±å¯¼ç³»ç»Ÿç¼ºå¤±
5. **å…¬äº¤å‡†ç‚¹ç‡ä½**ï¼šå…¬äº¤å‡†ç‚¹ç‡ä»…65%ï¼Œå¸å¼•åŠ›ä¸è¶³

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **ç¼“è§£äº¤é€šæ‹¥å µ**ï¼šé«˜å³°å¹³å‡è½¦é€Ÿæå‡è‡³25km/hï¼Œæ‹¥å µæŒ‡æ•°ä¸‹é™30%
2. **ä¼˜åŒ–ä¿¡å·æ§åˆ¶**ï¼šå®ç°è‡ªé€‚åº”ä¿¡å·æ§åˆ¶ï¼Œé€šè¡Œæ•ˆç‡æå‡20%
3. **å¿«é€Ÿäº‹æ•…å“åº”**ï¼šäº‹æ•…è‡ªåŠ¨å‘ç°ï¼Œå¹³å‡å“åº”æ—¶é—´ç¼©çŸ­è‡³5åˆ†é’Ÿ
4. **æ™ºæ…§åœè½¦ç®¡ç†**ï¼šåœè½¦ä½åˆ©ç”¨ç‡æå‡è‡³85%ï¼Œå¹³å‡å¯»ä½æ—¶é—´ç¼©çŸ­è‡³3åˆ†é’Ÿ
5. **æå‡å…¬äº¤æœåŠ¡**ï¼šå…¬äº¤å‡†ç‚¹ç‡æå‡è‡³90%ï¼Œåˆ†æ‹…ç‡æå‡è‡³35%

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šæºæ•°æ®èåˆ**ï¼šéœ€è¦èåˆå¡å£ã€åœ°ç£ã€æµ®åŠ¨è½¦ã€äº’è”ç½‘ç­‰æ•°æ®
2. **å®æ—¶è®¡ç®—èƒ½åŠ›**ï¼šéœ€è¦æ”¯æŒç™¾ä¸‡çº§è½¦è¾†çš„å®æ—¶è½¨è¿¹è®¡ç®—
3. **ç®—æ³•ä¼˜åŒ–**ï¼šéœ€è¦æ”¯æŒå¤§è§„æ¨¡è·¯ç½‘çš„å…¨å±€æœ€ä¼˜ä¿¡å·é…æ—¶
4. **ç³»ç»Ÿå¯é æ€§**ï¼šéœ€è¦æ»¡è¶³99.99%å¯ç”¨æ€§è¦æ±‚

### 2.5 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
æ™ºæ…§åŸå¸‚äº¤é€šå¤§è„‘ç³»ç»Ÿ
åŠŸèƒ½ï¼šäº¤é€šç›‘æ§ã€ä¿¡å·ä¼˜åŒ–ã€äº‹ä»¶æ£€æµ‹ã€åœè½¦ç®¡ç†
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
import random
import heapq


class TrafficStatus(str, Enum):
    """äº¤é€šçŠ¶æ€"""
    FREE = "free"
    SLOW = "slow"
    CONGESTED = "congested"
    BLOCKED = "blocked"


class SignalPhase(str, Enum):
    """ä¿¡å·ç›¸ä½"""
    RED = "red"
    YELLOW = "yellow"
    GREEN = "green"


@dataclass
class Intersection:
    """è·¯å£"""
    intersection_id: str
    name: str
    latitude: float
    longitude: float
    cycle_time: int = 120  # å‘¨æœŸæ—¶é•¿(ç§’)
    phases: Dict[str, Dict] = field(default_factory=dict)
    current_phase: str = ""
    time_remaining: int = 0


@dataclass
class RoadSegment:
    """è·¯æ®µ"""
    segment_id: str
    road_name: str
    from_intersection: str
    to_intersection: str
    length: float  # ç±³
    lanes: int
    speed_limit: int  # km/h
    
    current_speed: float = 0.0
    vehicle_count: int = 0
    occupancy: float = 0.0  # å æœ‰ç‡
    
    def get_status(self) -> TrafficStatus:
        """è·å–äº¤é€šçŠ¶æ€"""
        if self.current_speed >= self.speed_limit * 0.8:
            return TrafficStatus.FREE
        elif self.current_speed >= self.speed_limit * 0.5:
            return TrafficStatus.SLOW
        elif self.current_speed >= self.speed_limit * 0.2:
            return TrafficStatus.CONGESTED
        else:
            return TrafficStatus.BLOCKED


@dataclass
class Vehicle:
    """è½¦è¾†"""
    vehicle_id: str
    vehicle_type: str
    latitude: float
    longitude: float
    speed: float
    direction: float
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class TrafficEvent:
    """äº¤é€šäº‹ä»¶"""
    event_id: str
    event_type: str  # accident, congestion, construction
    segment_id: str
    start_time: datetime
    status: str = "active"
    severity: str = "medium"  # low, medium, high


class TrafficBrain:
    """äº¤é€šå¤§è„‘æ ¸å¿ƒ"""
    
    def __init__(self):
        self.intersections: Dict[str, Intersection] = {}
        self.segments: Dict[str, RoadSegment] = {}
        self.vehicles: Dict[str, Vehicle] = {}
        self.events: Dict[str, TrafficEvent] = {}
        self.traffic_history: List[Dict] = []
    
    def add_intersection(self, intersection: Intersection):
        """æ·»åŠ è·¯å£"""
        self.intersections[intersection.intersection_id] = intersection
    
    def add_segment(self, segment: RoadSegment):
        """æ·»åŠ è·¯æ®µ"""
        self.segments[segment.segment_id] = segment
    
    def update_vehicle(self, vehicle: Vehicle):
        """æ›´æ–°è½¦è¾†ä½ç½®"""
        self.vehicles[vehicle.vehicle_id] = vehicle
    
    def detect_congestion(self) -> List[str]:
        """æ£€æµ‹æ‹¥å µè·¯æ®µ"""
        congested = []
        for segment_id, segment in self.segments.items():
            if segment.get_status() in [TrafficStatus.CONGESTED, TrafficStatus.BLOCKED]:
                congested.append(segment_id)
        return congested
    
    def optimize_signal(self, intersection_id: str) -> Dict:
        """ä¼˜åŒ–ä¿¡å·é…æ—¶"""
        intersection = self.intersections.get(intersection_id)
        if not intersection:
            return {}
        
        # ç®€åŒ–çš„è‡ªé€‚åº”é…æ—¶ç®—æ³•
        # æ ¹æ®å„æ–¹å‘è½¦æµé‡è°ƒæ•´ç»¿ç¯æ—¶é—´
        
        # è·å–è¿æ¥è¯¥è·¯å£çš„è·¯æ®µ
        connected_segments = [
            seg for seg in self.segments.values()
            if seg.from_intersection == intersection_id or seg.to_intersection == intersection_id
        ]
        
        # è®¡ç®—å„æ–¹å‘æµé‡
        flow_by_direction = {}
        for seg in connected_segments:
            direction = seg.road_name
            flow_by_direction[direction] = flow_by_direction.get(direction, 0) + seg.vehicle_count
        
        total_flow = sum(flow_by_direction.values())
        if total_flow == 0:
            return {}
        
        # æ ¹æ®æµé‡æ¯”ä¾‹åˆ†é…ç»¿ç¯æ—¶é—´
        green_splits = {}
        for direction, flow in flow_by_direction.items():
            green_splits[direction] = int((flow / total_flow) * intersection.cycle_time * 0.8)
        
        return {
            "intersection_id": intersection_id,
            "cycle_time": intersection.cycle_time,
            "green_splits": green_splits,
            "optimized_at": datetime.now().isoformat()
        }
    
    def calculate_route(self, from_segment: str, to_segment: str) -> List[str]:
        """è®¡ç®—æœ€ä¼˜è·¯å¾„"""
        # Dijkstraç®—æ³•ç®€åŒ–ç‰ˆ
        distances = {seg_id: float('inf') for seg_id in self.segments}
        distances[from_segment] = 0
        previous = {}
        
        pq = [(0, from_segment)]
        
        while pq:
            current_dist, current_seg = heapq.heappop(pq)
            
            if current_seg == to_segment:
                break
            
            if current_dist > distances[current_seg]:
                continue
            
            # æŸ¥æ‰¾ç›¸é‚»è·¯æ®µ
            current = self.segments.get(current_seg)
            if not current:
                continue
            
            for seg_id, seg in self.segments.items():
                if seg.from_intersection == current.to_intersection:
                    # æ ¹æ®å½“å‰é€Ÿåº¦è®¡ç®—é€šè¡Œæ—¶é—´
                    travel_time = seg.length / max(seg.current_speed * 1000 / 3600, 1)
                    distance = current_dist + travel_time
                    
                    if distance < distances[seg_id]:
                        distances[seg_id] = distance
                        previous[seg_id] = current_seg
                        heapq.heappush(pq, (distance, seg_id))
        
        # é‡å»ºè·¯å¾„
        path = []
        current = to_segment
        while current in previous:
            path.append(current)
            current = previous[current]
        path.append(from_segment)
        path.reverse()
        
        return path
    
    def predict_traffic(self, segment_id: str, minutes_ahead: int = 15) -> float:
        """é¢„æµ‹æœªæ¥äº¤é€šçŠ¶å†µ"""
        segment = self.segments.get(segment_id)
        if not segment:
            return 0.0
        
        # ç®€åŒ–çš„é¢„æµ‹ï¼šåŸºäºå†å²è¶‹åŠ¿
        current_speed = segment.current_speed
        
        # æ¨¡æ‹Ÿè¶‹åŠ¿ï¼ˆå®é™…åº”ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹ï¼‰
        trend = random.uniform(-5, 5)
        predicted_speed = max(0, current_speed + trend)
        
        return round(predicted_speed, 2)
    
    def get_city_traffic_index(self) -> Dict:
        """è·å–åŸå¸‚äº¤é€šæŒ‡æ•°"""
        total_segments = len(self.segments)
        if total_segments == 0:
            return {}
        
        status_counts = {"free": 0, "slow": 0, "congested": 0, "blocked": 0}
        
        for segment in self.segments.values():
            status = segment.get_status()
            status_counts[status.value] += 1
        
        # è®¡ç®—æ‹¥å µæŒ‡æ•° (0-10)
        congestion_index = (
            status_counts["slow"] * 0.3 +
            status_counts["congested"] * 0.6 +
            status_counts["blocked"] * 1.0
        ) / total_segments * 10
        
        # è®¡ç®—å¹³å‡è½¦é€Ÿ
        avg_speed = sum(seg.current_speed for seg in self.segments.values()) / total_segments
        
        return {
            "timestamp": datetime.now().isoformat(),
            "congestion_index": round(congestion_index, 2),
            "average_speed": round(avg_speed, 2),
            "total_segments": total_segments,
            "status_distribution": status_counts
        }


def main():
    """äº¤é€šå¤§è„‘æ¼”ç¤º"""
    
    print("=" * 60)
    print("æ™ºæ…§åŸå¸‚äº¤é€šå¤§è„‘æ¼”ç¤º")
    print("=" * 60)
    
    brain = TrafficBrain()
    
    # 1. åˆ›å»ºè·¯å£
    print("\n[1] åˆ›å»ºè·¯å£")
    for i in range(1, 6):
        intersection = Intersection(
            intersection_id=f"INT-{i:03d}",
            name=f"è·¯å£{i}",
            latitude=31.23 + i * 0.01,
            longitude=121.47 + i * 0.01
        )
        brain.add_intersection(intersection)
    print(f"å·²åˆ›å»º {len(brain.intersections)} ä¸ªè·¯å£")
    
    # 2. åˆ›å»ºè·¯æ®µ
    print("\n[2] åˆ›å»ºè·¯æ®µ")
    roads = [
        ("SEG-001", "äººæ°‘è·¯", "INT-001", "INT-002", 800, 4, 60),
        ("SEG-002", "äººæ°‘è·¯", "INT-002", "INT-003", 900, 4, 60),
        ("SEG-003", "è§£æ”¾è·¯", "INT-001", "INT-004", 1000, 6, 80),
        ("SEG-004", "è§£æ”¾è·¯", "INT-004", "INT-005", 850, 6, 80),
        ("SEG-005", "ä¸­å±±è·¯", "INT-002", "INT-005", 700, 4, 50),
    ]
    
    for seg_id, name, from_int, to_int, length, lanes, speed in roads:
        segment = RoadSegment(
            segment_id=seg_id,
            road_name=name,
            from_intersection=from_int,
            to_intersection=to_int,
            length=length,
            lanes=lanes,
            speed_limit=speed,
            current_speed=random.uniform(speed * 0.3, speed * 0.9),
            vehicle_count=random.randint(20, 100)
        )
        brain.add_segment(segment)
    print(f"å·²åˆ›å»º {len(brain.segments)} ä¸ªè·¯æ®µ")
    
    # 3. æ‹¥å µæ£€æµ‹
    print("\n[3] æ‹¥å µæ£€æµ‹")
    congested = brain.detect_congestion()
    print(f"æ‹¥å µè·¯æ®µ: {congested}")
    
    # 4. ä¿¡å·ä¼˜åŒ–
    print("\n[4] ä¿¡å·é…æ—¶ä¼˜åŒ–")
    for int_id in list(brain.intersections.keys())[:2]:
        optimization = brain.optimize_signal(int_id)
        print(f"{int_id}: {optimization.get('green_splits', {})}")
    
    # 5. è·¯å¾„è§„åˆ’
    print("\n[5] è·¯å¾„è§„åˆ’")
    route = brain.calculate_route("SEG-001", "SEG-005")
    print(f"æœ€ä¼˜è·¯å¾„: {route}")
    
    # 6. äº¤é€šæŒ‡æ•°
    print("\n[6] åŸå¸‚äº¤é€šæŒ‡æ•°")
    index = brain.get_city_traffic_index()
    print(f"æ‹¥å µæŒ‡æ•°: {index['congestion_index']}")
    print(f"å¹³å‡è½¦é€Ÿ: {index['average_speed']} km/h")
    print(f"è·¯æ®µåˆ†å¸ƒ: {index['status_distribution']}")


if __name__ == "__main__":
    main()
```

### 2.6 æ•ˆæœè¯„ä¼°

| æŒ‡æ ‡ | åŸºçº¿å€¼ | ç›®æ ‡å€¼ | å®é™…å€¼ | è¾¾æˆç‡ |
|------|--------|--------|--------|--------|
| é«˜å³°å¹³å‡è½¦é€Ÿ | 15km/h | 25km/h | 27km/h | 108% |
| é€šè¡Œæ•ˆç‡ | åŸºå‡† | æå‡20% | æå‡25% | 125% |
| äº‹æ•…å“åº”æ—¶é—´ | 20åˆ†é’Ÿ | â‰¤5åˆ†é’Ÿ | 4åˆ†é’Ÿ | 125% |
| å…¬äº¤å‡†ç‚¹ç‡ | 65% | 90% | 92% | 102% |

**ROIåˆ†æ**ï¼š
- é¡¹ç›®æ€»æŠ•èµ„ï¼š1.5äº¿å…ƒ
- å¹´åº¦æ€»æ”¶ç›Šï¼ˆå«ç¤¾ä¼šæ•ˆç›Šï¼‰ï¼š4äº¿å…ƒ
- **æŠ•èµ„å›æ”¶æœŸï¼š4.5ä¸ªæœˆ**
- **3å¹´ROIï¼š700%**

---

## 3. æ¡ˆä¾‹æ€»ç»“

**å…³é”®æˆåŠŸå› ç´ **ï¼š
1. æ•°æ®èåˆæ˜¯åŸºç¡€
2. å®æ—¶è®¡ç®—èƒ½åŠ›æ˜¯å…³é”®
3. ç®—æ³•æŒç»­ä¼˜åŒ–æ˜¯ä¿éšœ

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æœ€åæ›´æ–°**ï¼š2025-02-15

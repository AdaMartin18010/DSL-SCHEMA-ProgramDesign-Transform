# åŠå…¬è‡ªåŠ¨åŒ–Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [åŠå…¬è‡ªåŠ¨åŒ–Schemaå®è·µæ¡ˆä¾‹](#åŠå…¬è‡ªåŠ¨åŒ–schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šTechCorpé›†å›¢æ™ºèƒ½OAç³»ç»Ÿ](#2-æ¡ˆä¾‹1techcorpé›†å›¢æ™ºèƒ½oaç³»ç»Ÿ)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´å®ç°ä»£ç ](#26-å®Œæ•´å®ç°ä»£ç )
    - [2.7 æ•ˆæœè¯„ä¼°ä¸ROI](#27-æ•ˆæœè¯„ä¼°ä¸roi)
  - [3. æ¡ˆä¾‹2ï¼šæ™ºèƒ½æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ](#3-æ¡ˆä¾‹2æ™ºèƒ½æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ)
    - [3.1 ä¼ä¸šèƒŒæ™¯](#31-ä¼ä¸šèƒŒæ™¯)
    - [3.2 ä¸šåŠ¡ç—›ç‚¹](#32-ä¸šåŠ¡ç—›ç‚¹)
    - [3.3 ä¸šåŠ¡ç›®æ ‡](#33-ä¸šåŠ¡ç›®æ ‡)
    - [3.4 æŠ€æœ¯æŒ‘æˆ˜](#34-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.5 å®Œæ•´å®ç°ä»£ç ](#35-å®Œæ•´å®ç°ä»£ç )
    - [3.6 æ•ˆæœè¯„ä¼°ä¸ROI](#36-æ•ˆæœè¯„ä¼°ä¸roi)
  - [4. æ¡ˆä¾‹3ï¼šæµç¨‹è‡ªåŠ¨åŒ–å¼•æ“](#4-æ¡ˆä¾‹3æµç¨‹è‡ªåŠ¨åŒ–å¼•æ“)
    - [4.1 ä¼ä¸šèƒŒæ™¯](#41-ä¼ä¸šèƒŒæ™¯)
    - [4.2 ä¸šåŠ¡ç—›ç‚¹](#42-ä¸šåŠ¡ç—›ç‚¹)
    - [4.3 ä¸šåŠ¡ç›®æ ‡](#43-ä¸šåŠ¡ç›®æ ‡)
    - [4.4 æŠ€æœ¯æŒ‘æˆ˜](#44-æŠ€æœ¯æŒ‘æˆ˜)
    - [4.5 å®Œæ•´å®ç°ä»£ç ](#45-å®Œæ•´å®ç°ä»£ç )
    - [4.6 æ•ˆæœè¯„ä¼°ä¸ROI](#46-æ•ˆæœè¯„ä¼°ä¸roi)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›åŠå…¬è‡ªåŠ¨åŒ–Schemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–æ™ºèƒ½OAç³»ç»Ÿã€æ–‡æ¡£ç®¡ç†ã€æµç¨‹è‡ªåŠ¨åŒ–ç­‰æ ¸å¿ƒåœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **æ™ºèƒ½OAç³»ç»Ÿ**ï¼šé›†æˆå¤šç§åŠå…¬åŠŸèƒ½çš„ç»Ÿä¸€å¹³å°
2. **æ™ºèƒ½æ–‡æ¡£ç®¡ç†**ï¼šæ–‡æ¡£ç‰ˆæœ¬æ§åˆ¶ã€æƒé™ç®¡ç†ã€æ™ºèƒ½æ£€ç´¢
3. **æµç¨‹è‡ªåŠ¨åŒ–å¼•æ“**ï¼šBPMNå·¥ä½œæµã€å®¡æ‰¹æµç¨‹è‡ªåŠ¨åŒ–

**å‚è€ƒæ ‡å‡†**ï¼š

- **ODFæ ‡å‡†**ï¼šOpenDocument Format
- **OOXMLæ ‡å‡†**ï¼šOffice Open XML
- **BPMN 2.0**ï¼šä¸šåŠ¡æµç¨‹æ¨¡å‹å’Œæ ‡è®°æ³•

---

## 2. æ¡ˆä¾‹1ï¼šTechCorpé›†å›¢æ™ºèƒ½OAç³»ç»Ÿ

### 2.1 ä¼ä¸šèƒŒæ™¯

**TechCorpé›†å›¢**æ˜¯ä¸€å®¶è·¨å›½ç§‘æŠ€ä¼ä¸šï¼Œæ‹¥æœ‰å‘˜å·¥15,000äººï¼Œåˆ†å¸ƒåœ¨å…¨çƒ20ä¸ªå›½å®¶çš„50ä¸ªåŠå…¬å®¤ã€‚é›†å›¢éœ€è¦ç»Ÿä¸€çš„OAç³»ç»Ÿæ¥æ”¯æ’‘æ—¥å¸¸åŠå…¬ã€ååŒå·¥ä½œå’Œä¸šåŠ¡å®¡æ‰¹ã€‚

- **æˆç«‹æ—¶é—´**ï¼š2005å¹´
- **å‘˜å·¥è§„æ¨¡**ï¼š15,000äºº
- **å…¨çƒåŠå…¬å®¤**ï¼š50ä¸ª
- **æ—¥å¤„ç†æµç¨‹**ï¼š5,000+ä¸ªå®¡æ‰¹æµç¨‹
- **æ–‡æ¡£å­˜å‚¨é‡**ï¼š50TB+
- **åŸOAç³»ç»Ÿ**ï¼šåˆ†æ•£çš„å¤šä¸ªç³»ç»Ÿï¼Œæ•°æ®å­¤å²›ä¸¥é‡

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **ç³»ç»Ÿåˆ†æ•£** | ä¸¥é‡ | ä½¿ç”¨8ä¸ªä¸åŒç³»ç»Ÿï¼Œå‘˜å·¥éœ€è¦åœ¨å¤šä¸ªç³»ç»Ÿé—´åˆ‡æ¢ï¼Œæ•ˆç‡ä½ä¸‹ |
| 2 | **æµç¨‹å®¡æ‰¹æ…¢** | ä¸¥é‡ | å¹³å‡å®¡æ‰¹å‘¨æœŸ5å¤©ï¼Œç´§æ€¥æµç¨‹æ— æ³•å¿«é€Ÿå“åº”ï¼Œå½±å“ä¸šåŠ¡è¿›å±• |
| 3 | **æ–‡æ¡£ç®¡ç†æ··ä¹±** | ä¸¥é‡ | æ–‡æ¡£ç‰ˆæœ¬æ··ä¹±ï¼Œå¹´å‡å‘ç”Ÿ30+æ¬¡é‡è¦æ–‡æ¡£è¯¯ç”¨äº‹ä»¶ |
| 4 | **ç§»åŠ¨åŠå…¬æ”¯æŒå·®** | é«˜ | ç§»åŠ¨ç«¯åŠŸèƒ½æœ‰é™ï¼Œè¿œç¨‹åŠå…¬å‘˜å·¥ä½“éªŒå·® |
| 5 | **æ•°æ®å­¤å²›** | é«˜ | HRã€è´¢åŠ¡ã€é¡¹ç›®ç³»ç»Ÿæ•°æ®ä¸äº’é€šï¼Œéœ€è¦é‡å¤å½•å…¥ |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | ç³»ç»Ÿæ•´åˆåº¦ | 20% | 95% | 12ä¸ªæœˆ |
| 2 | å¹³å‡å®¡æ‰¹å‘¨æœŸ | 5å¤© | <1å¤© | 9ä¸ªæœˆ |
| 3 | æ–‡æ¡£ç‰ˆæœ¬å‡†ç¡®ç‡ | 70% | 99% | 6ä¸ªæœˆ |
| 4 | ç§»åŠ¨åŠå…¬è¦†ç›–ç‡ | 30% | 90% | 9ä¸ªæœˆ |
| 5 | å‘˜å·¥æ»¡æ„åº¦ | 55% | 85% | 12ä¸ªæœˆ |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šç§Ÿæˆ·æ¶æ„**ï¼šéœ€è¦æ”¯æŒå…¨çƒ50ä¸ªåŠå…¬å®¤çš„ç‹¬ç«‹é…ç½®ï¼ŒåŒæ—¶ä¿æŒç»Ÿä¸€çš„æ•°æ®æ ‡å‡†å’Œæµç¨‹è§„èŒƒ

2. **é«˜å¹¶å‘å¤„ç†**ï¼šå·¥ä½œæ—¥é«˜å³°æ—¶æ®µåŒæ—¶åœ¨çº¿ç”¨æˆ·è¶…è¿‡8,000äººï¼Œæ—¥æ´»è·ƒç”¨æˆ·12,000äººï¼Œè¦æ±‚ç³»ç»Ÿå…·å¤‡é«˜å¹¶å‘å¤„ç†èƒ½åŠ›

3. **å¤æ‚å®¡æ‰¹è·¯ç”±**ï¼šéœ€è¦æ”¯æŒæ¡ä»¶åˆ†æ”¯ã€ä¼šç­¾ã€è½¬åŠã€å‚¬åŠã€è¶…æ—¶å¤„ç†ç­‰å¤æ‚å®¡æ‰¹é€»è¾‘

4. **æ–‡æ¡£æ ¼å¼å…¼å®¹**ï¼šéœ€è¦æ”¯æŒODFã€OOXMLã€PDFç­‰æ ¼å¼çš„äº’è½¬å’Œåœ¨çº¿é¢„è§ˆï¼Œå…¼å®¹å¤šç§åŠå…¬è½¯ä»¶

5. **å…¨çƒæ•°æ®åˆè§„**ï¼šéœ€è¦æ»¡è¶³GDPRã€ä¸­å›½ç½‘ç»œå®‰å…¨æ³•ç­‰æ•°æ®åˆè§„è¦æ±‚ï¼Œæ”¯æŒæ•°æ®æœ¬åœ°åŒ–å­˜å‚¨

### 2.5 è§£å†³æ–¹æ¡ˆ

**æ™ºèƒ½OAç³»ç»Ÿæ¶æ„**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     åº”ç”¨æœåŠ¡å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ å®¡æ‰¹ä¸­å¿ƒ â”‚ â”‚ æ–‡æ¡£ä¸­å¿ƒ â”‚ â”‚ æ—¥ç¨‹ä¸­å¿ƒ â”‚ â”‚ ä¼šè®®ç®¡ç†      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ è€ƒå‹¤ç®¡ç† â”‚ â”‚ ä»»åŠ¡åä½œ â”‚ â”‚ çŸ¥è¯†åº“   â”‚ â”‚ å³æ—¶é€šè®¯      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ ¸å¿ƒæœåŠ¡å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æµç¨‹å¼•æ“ â”‚ â”‚ æ–‡æ¡£å¼•æ“ â”‚ â”‚ æ¶ˆæ¯å¼•æ“ â”‚ â”‚ æœç´¢æœåŠ¡      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ•°æ®å­˜å‚¨å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ å…³ç³»æ•°æ®åº“â”‚ â”‚ æ–‡æ¡£å­˜å‚¨ â”‚ â”‚ ç¼“å­˜     â”‚ â”‚ å¯¹è±¡å­˜å‚¨      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.6 å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
TechCorpé›†å›¢æ™ºèƒ½OAç³»ç»Ÿ - æ ¸å¿ƒå®ç°
é›†æˆå®¡æ‰¹ã€æ–‡æ¡£ã€æ—¥ç¨‹ã€ä»»åŠ¡ç­‰åŠŸèƒ½
"""

import asyncio
import json
import logging
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Any, Set
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ApprovalStatus(Enum):
    """å®¡æ‰¹çŠ¶æ€"""
    DRAFT = "draft"
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    CANCELLED = "cancelled"


class ApprovalAction(Enum):
    """å®¡æ‰¹åŠ¨ä½œ"""
    SUBMIT = "submit"
    APPROVE = "approve"
    REJECT = "reject"
    TRANSFER = "transfer"
    RETURN = "return"


class DocumentStatus(Enum):
    """æ–‡æ¡£çŠ¶æ€"""
    ACTIVE = "active"
    ARCHIVED = "archived"
    DELETED = "deleted"


class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€"""
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    CANCELLED = "cancelled"


@dataclass
class User:
    """ç”¨æˆ·"""
    user_id: str
    username: str
    email: str
    department: str
    title: str
    manager_id: Optional[str] = None
    roles: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "user_id": self.user_id,
            "username": self.username,
            "email": self.email,
            "department": self.department,
            "title": self.title,
            "manager_id": self.manager_id,
            "roles": self.roles
        }


@dataclass
class ApprovalStep:
    """å®¡æ‰¹æ­¥éª¤"""
    step_id: str
    step_order: int
    approver_id: Optional[str]
    approver_role: Optional[str]
    status: ApprovalStatus
    action: Optional[ApprovalAction] = None
    comment: str = ""
    action_time: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "step_id": self.step_id,
            "step_order": self.step_order,
            "approver_id": self.approver_id,
            "approver_role": self.approver_role,
            "status": self.status.value,
            "action": self.action.value if self.action else None,
            "comment": self.comment,
            "action_time": self.action_time.isoformat() if self.action_time else None
        }


@dataclass
class ApprovalProcess:
    """å®¡æ‰¹æµç¨‹"""
    process_id: str
    process_type: str
    title: str
    submitter_id: str
    current_step: int = 0
    status: ApprovalStatus = ApprovalStatus.DRAFT
    steps: List[ApprovalStep] = field(default_factory=list)
    form_data: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "process_id": self.process_id,
            "process_type": self.process_type,
            "title": self.title,
            "submitter_id": self.submitter_id,
            "current_step": self.current_step,
            "status": self.status.value,
            "steps": [s.to_dict() for s in self.steps],
            "form_data": self.form_data,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None
        }


@dataclass
class Document:
    """æ–‡æ¡£"""
    document_id: str
    title: str
    document_type: str
    owner_id: str
    content: str = ""
    version: int = 1
    status: DocumentStatus = DocumentStatus.ACTIVE
    parent_version_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    collaborators: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "document_id": self.document_id,
            "title": self.title,
            "document_type": self.document_type,
            "owner_id": self.owner_id,
            "version": self.version,
            "status": self.status.value,
            "parent_version_id": self.parent_version_id,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "collaborators": self.collaborators,
            "tags": self.tags
        }


@dataclass
class Task:
    """ä»»åŠ¡"""
    task_id: str
    title: str
    description: str
    creator_id: str
    assignee_id: str
    status: TaskStatus = TaskStatus.TODO
    priority: int = 3  # 1-5, 5æœ€é«˜
    due_date: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    created_at: datetime = field(default_factory=datetime.now)
    tags: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "task_id": self.task_id,
            "title": self.title,
            "description": self.description,
            "creator_id": self.creator_id,
            "assignee_id": self.assignee_id,
            "status": self.status.value,
            "priority": self.priority,
            "due_date": self.due_date.isoformat() if self.due_date else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "created_at": self.created_at.isoformat(),
            "tags": self.tags
        }


class OASystem:
    """OAç³»ç»Ÿæ ¸å¿ƒ"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.approval_processes: Dict[str, ApprovalProcess] = {}
        self.documents: Dict[str, Document] = {}
        self.tasks: Dict[str, Task] = {}
        
        # æ–‡æ¡£ç‰ˆæœ¬å†å²
        self.document_versions: Dict[str, List[str]] = defaultdict(list)
        
        # ç»Ÿè®¡
        self.stats = {
            "total_approvals": 0,
            "avg_approval_hours": 0,
            "total_documents": 0,
            "total_tasks": 0
        }
        
        logger.info("OA System initialized")
    
    def register_user(self, user: User):
        """æ³¨å†Œç”¨æˆ·"""
        self.users[user.user_id] = user
    
    def create_approval_process(self, process_type: str, title: str,
                               submitter_id: str, form_data: Dict[str, Any],
                               workflow_definition: List[Dict]) -> str:
        """åˆ›å»ºå®¡æ‰¹æµç¨‹"""
        process_id = f"APR-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"
        
        # åˆ›å»ºå®¡æ‰¹æ­¥éª¤
        steps = []
        for i, step_def in enumerate(workflow_definition):
            step = ApprovalStep(
                step_id=f"{process_id}-STEP{i+1}",
                step_order=i + 1,
                approver_id=step_def.get("approver_id"),
                approver_role=step_def.get("approver_role"),
                status=ApprovalStatus.PENDING if i == 0 else ApprovalStatus.DRAFT
            )
            steps.append(step)
        
        process = ApprovalProcess(
            process_id=process_id,
            process_type=process_type,
            title=title,
            submitter_id=submitter_id,
            steps=steps,
            form_data=form_data,
            status=ApprovalStatus.PENDING
        )
        
        self.approval_processes[process_id] = process
        self.stats["total_approvals"] += 1
        
        logger.info(f"Created approval process: {process_id}")
        return process_id
    
    def process_approval(self, process_id: str, step_id: str,
                        approver_id: str, action: ApprovalAction,
                        comment: str = "") -> bool:
        """å¤„ç†å®¡æ‰¹"""
        if process_id not in self.approval_processes:
            return False
        
        process = self.approval_processes[process_id]
        
        # æ‰¾åˆ°å½“å‰æ­¥éª¤
        current_step = None
        for step in process.steps:
            if step.step_id == step_id and step.status == ApprovalStatus.PENDING:
                current_step = step
                break
        
        if not current_step:
            return False
        
        # æ›´æ–°æ­¥éª¤
        current_step.approver_id = approver_id
        current_step.action = action
        current_step.comment = comment
        current_step.action_time = datetime.now()
        
        if action == ApprovalAction.APPROVE:
            current_step.status = ApprovalStatus.APPROVED
            
            # è¿›å…¥ä¸‹ä¸€æ­¥
            if process.current_step < len(process.steps) - 1:
                process.current_step += 1
                next_step = process.steps[process.current_step]
                next_step.status = ApprovalStatus.PENDING
            else:
                # æµç¨‹å®Œæˆ
                process.status = ApprovalStatus.APPROVED
                process.completed_at = datetime.now()
                
                # è®¡ç®—å®¡æ‰¹æ—¶é—´
                duration = (process.completed_at - process.created_at).total_seconds() / 3600
                n = self.stats["total_approvals"]
                self.stats["avg_approval_hours"] = (
                    self.stats["avg_approval_hours"] * (n-1) + duration
                ) / n
                
                logger.info(f"Approval process {process_id} completed in {duration:.2f} hours")
                
        elif action == ApprovalAction.REJECT:
            current_step.status = ApprovalStatus.REJECTED
            process.status = ApprovalStatus.REJECTED
            process.completed_at = datetime.now()
            
        elif action == ApprovalAction.RETURN:
            # é€€å›ä¸Šä¸€æ­¥æˆ–ç”³è¯·äºº
            current_step.status = ApprovalStatus.DRAFT
            if process.current_step > 0:
                process.current_step -= 1
                prev_step = process.steps[process.current_step]
                prev_step.status = ApprovalStatus.PENDING
                prev_step.action = None
                prev_step.comment = ""
                prev_step.action_time = None
        
        return True
    
    def create_document(self, title: str, document_type: str,
                       owner_id: str, content: str = "",
                       tags: List[str] = None) -> str:
        """åˆ›å»ºæ–‡æ¡£"""
        document_id = f"DOC-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"
        
        doc = Document(
            document_id=document_id,
            title=title,
            document_type=document_type,
            owner_id=owner_id,
            content=content,
            tags=tags or []
        )
        
        self.documents[document_id] = doc
        self.document_versions[document_id].append(document_id)
        self.stats["total_documents"] += 1
        
        logger.info(f"Created document: {document_id}")
        return document_id
    
    def create_document_version(self, document_id: str, new_content: str,
                               editor_id: str) -> Optional[str]:
        """åˆ›å»ºæ–‡æ¡£æ–°ç‰ˆæœ¬"""
        if document_id not in self.documents:
            return None
        
        original = self.documents[document_id]
        
        # åˆ›å»ºæ–°ç‰ˆæœ¬
        new_doc_id = f"DOC-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"
        new_doc = Document(
            document_id=new_doc_id,
            title=original.title,
            document_type=original.document_type,
            owner_id=original.owner_id,
            content=new_content,
            version=original.version + 1,
            parent_version_id=document_id,
            collaborators=original.collaborators,
            tags=original.tags
        )
        
        self.documents[new_doc_id] = new_doc
        
        # æ›´æ–°ç‰ˆæœ¬é“¾
        root_id = self._get_root_document_id(document_id)
        self.document_versions[root_id].append(new_doc_id)
        
        logger.info(f"Created document version: {new_doc_id} (from {document_id})")
        return new_doc_id
    
    def _get_root_document_id(self, document_id: str) -> str:
        """è·å–æ–‡æ¡£æ ¹ç‰ˆæœ¬ID"""
        doc = self.documents.get(document_id)
        if doc and doc.parent_version_id:
            return self._get_root_document_id(doc.parent_version_id)
        return document_id
    
    def get_document_history(self, document_id: str) -> List[Dict]:
        """è·å–æ–‡æ¡£ç‰ˆæœ¬å†å²"""
        root_id = self._get_root_document_id(document_id)
        version_ids = self.document_versions.get(root_id, [])
        
        return [self.documents[vid].to_dict() for vid in version_ids if vid in self.documents]
    
    def create_task(self, title: str, description: str, creator_id: str,
                   assignee_id: str, due_date: datetime = None,
                   priority: int = 3, tags: List[str] = None) -> str:
        """åˆ›å»ºä»»åŠ¡"""
        task_id = f"TASK-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"
        
        task = Task(
            task_id=task_id,
            title=title,
            description=description,
            creator_id=creator_id,
            assignee_id=assignee_id,
            due_date=due_date,
            priority=priority,
            tags=tags or []
        )
        
        self.tasks[task_id] = task
        self.stats["total_tasks"] += 1
        
        logger.info(f"Created task: {task_id}")
        return task_id
    
    def update_task_status(self, task_id: str, status: TaskStatus) -> bool:
        """æ›´æ–°ä»»åŠ¡çŠ¶æ€"""
        if task_id not in self.tasks:
            return False
        
        task = self.tasks[task_id]
        task.status = status
        
        if status == TaskStatus.COMPLETED:
            task.completed_at = datetime.now()
        
        return True
    
    def get_user_tasks(self, user_id: str, status: TaskStatus = None) -> List[Dict]:
        """è·å–ç”¨æˆ·ä»»åŠ¡åˆ—è¡¨"""
        tasks = [
            task.to_dict() for task in self.tasks.values()
            if task.assignee_id == user_id
        ]
        
        if status:
            tasks = [t for t in tasks if t["status"] == status.value]
        
        return sorted(tasks, key=lambda x: x["created_at"], reverse=True)
    
    def get_user_approvals(self, user_id: str, pending_only: bool = True) -> List[Dict]:
        """è·å–ç”¨æˆ·å¾…åŠå®¡æ‰¹"""
        approvals = []
        
        for process in self.approval_processes.values():
            if pending_only and process.status != ApprovalStatus.PENDING:
                continue
            
            # æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰æ­¥éª¤çš„å®¡æ‰¹äºº
            if process.current_step < len(process.steps):
                current_step = process.steps[process.current_step]
                if (current_step.status == ApprovalStatus.PENDING and
                    (current_step.approver_id == user_id or
                     self._user_has_role(user_id, current_step.approver_role))):
                    approvals.append(process.to_dict())
        
        return approvals
    
    def _user_has_role(self, user_id: str, role: str) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰æŒ‡å®šè§’è‰²"""
        if not role or user_id not in self.users:
            return False
        return role in self.users[user_id].roles
    
    def get_system_stats(self) -> Dict[str, Any]:
        """è·å–ç³»ç»Ÿç»Ÿè®¡"""
        # è®¡ç®—å„çŠ¶æ€ä»»åŠ¡æ•°é‡
        task_status_count = defaultdict(int)
        for task in self.tasks.values():
            task_status_count[task.status.value] += 1
        
        # è®¡ç®—å„çŠ¶æ€å®¡æ‰¹æ•°é‡
        approval_status_count = defaultdict(int)
        for proc in self.approval_processes.values():
            approval_status_count[proc.status.value] += 1
        
        return {
            "timestamp": datetime.now().isoformat(),
            "users": len(self.users),
            "documents": len(self.documents),
            "tasks": {
                "total": len(self.tasks),
                "by_status": dict(task_status_count)
            },
            "approvals": {
                "total": len(self.approval_processes),
                "by_status": dict(approval_status_count),
                "avg_processing_hours": self.stats["avg_approval_hours"]
            }
        }


def main():
    """æ¼”ç¤ºOAç³»ç»Ÿ"""
    oa = OASystem()
    
    # æ³¨å†Œç”¨æˆ·
    users = [
        User("U001", "zhangsan", "zhangsan@techcorp.com", "ç ”å‘éƒ¨", "ç»ç†", roles=["manager"]),
        User("U002", "lisi", "lisi@techcorp.com", "ç ”å‘éƒ¨", "å·¥ç¨‹å¸ˆ", manager_id="U001"),
        User("U003", "wangwu", "wangwu@techcorp.com", "è´¢åŠ¡éƒ¨", "æ€»ç›‘", roles=["director", "finance_approver"]),
    ]
    for user in users:
        oa.register_user(user)
    
    # åˆ›å»ºå®¡æ‰¹æµç¨‹ï¼ˆè¯·å‡ç”³è¯·ï¼‰
    workflow = [
        {"approver_role": "manager"},  # éƒ¨é—¨ç»ç†å®¡æ‰¹
        {"approver_role": "hr_approver"}  # HRå®¡æ‰¹
    ]
    
    process_id = oa.create_approval_process(
        process_type="leave_request",
        title="å¼ ä¸‰è¯·å‡ç”³è¯·",
        submitter_id="U002",
        form_data={
            "leave_type": "annual",
            "start_date": "2025-03-01",
            "end_date": "2025-03-05",
            "days": 5,
            "reason": "ä¸ªäººäº‹åŠ¡"
        },
        workflow_definition=workflow
    )
    
    # ç»ç†å®¡æ‰¹
    oa.process_approval(
        process_id=process_id,
        step_id=oa.approval_processes[process_id].steps[0].step_id,
        approver_id="U001",
        action=ApprovalAction.APPROVE,
        comment="åŒæ„è¯·å‡"
    )
    
    # åˆ›å»ºæ–‡æ¡£
    doc_id = oa.create_document(
        title="é¡¹ç›®è®¡åˆ’ä¹¦",
        document_type="project_plan",
        owner_id="U002",
        content="é¡¹ç›®èƒŒæ™¯...",
        tags=["project", "planning"]
    )
    
    # åˆ›å»ºæ–‡æ¡£ç‰ˆæœ¬
    oa.create_document_version(doc_id, "é¡¹ç›®èƒŒæ™¯...\n\né¡¹ç›®ç›®æ ‡...", "U002")
    
    # åˆ›å»ºä»»åŠ¡
    task_id = oa.create_task(
        title="å®Œæˆéœ€æ±‚åˆ†ææ–‡æ¡£",
        description="æ ¹æ®å®¢æˆ·åé¦ˆå®Œå–„éœ€æ±‚åˆ†æ",
        creator_id="U001",
        assignee_id="U002",
        due_date=datetime.now() + timedelta(days=7),
        priority=4
    )
    
    # ç³»ç»Ÿç»Ÿè®¡
    stats = oa.get_system_stats()
    print("OA System Stats:")
    print(json.dumps(stats, indent=2))
    
    # ç”¨æˆ·å¾…åŠ
    user_tasks = oa.get_user_tasks("U002")
    print(f"\nUser U002 tasks: {len(user_tasks)}")
    
    # æ–‡æ¡£å†å²
    history = oa.get_document_history(doc_id)
    print(f"\nDocument {doc_id} history: {len(history)} versions")


if __name__ == "__main__":
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°ä¸ROI

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| ç³»ç»Ÿæ•´åˆåº¦ | 20% | 94% | +74% |
| å¹³å‡å®¡æ‰¹å‘¨æœŸ | 5å¤© | 0.8å¤© | -84% |
| æ–‡æ¡£ç‰ˆæœ¬å‡†ç¡®ç‡ | 70% | 99.5% | +29% |
| ç§»åŠ¨åŠå…¬è¦†ç›–ç‡ | 30% | 88% | +58% |
| å‘˜å·¥æ»¡æ„åº¦ | 55% | 87% | +32% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š1,500ä¸‡å…ƒ
- å®æ–½éƒ¨ç½²ï¼š500ä¸‡å…ƒ
- **æ€»æŠ•èµ„**ï¼š2,000ä¸‡å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- æ•ˆç‡æå‡ï¼š3,000ä¸‡å…ƒ
- äººåŠ›æˆæœ¬èŠ‚çœï¼š1,500ä¸‡å…ƒ
- é”™è¯¯å‡å°‘ï¼š500ä¸‡å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š5,000ä¸‡å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š4.8ä¸ªæœˆ
- 3å¹´ROIï¼š650%

---

## 3. æ¡ˆä¾‹2ï¼šæ™ºèƒ½æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ

### 3.1 ä¼ä¸šèƒŒæ™¯

**æŸå¾‹å¸ˆäº‹åŠ¡æ‰€**æ‹¥æœ‰300åå¾‹å¸ˆï¼Œå¹´å‡å¤„ç†æ¡ˆä»¶10,000ä»¶ï¼Œäº§ç”Ÿæ–‡æ¡£è¶…è¿‡100ä¸‡ä»½ï¼Œå¯¹æ–‡æ¡£ç®¡ç†çš„ä¸“ä¸šæ€§å’Œå®‰å…¨æ€§è¦æ±‚æé«˜ã€‚

- **å‘˜å·¥è§„æ¨¡**ï¼š300äºº
- **å¹´å¤„ç†æ¡ˆä»¶**ï¼š10,000ä»¶
- **æ–‡æ¡£æ•°é‡**ï¼š100ä¸‡+ä»½
- **æ—¥æ–°å¢æ–‡æ¡£**ï¼š500+ä»½

### 3.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **æ–‡æ¡£æ£€ç´¢å›°éš¾** | ä¸¥é‡ | æŸ¥æ‰¾å†å²æ¡ˆä¾‹å¹³å‡éœ€30åˆ†é’Ÿï¼Œä¸¥é‡å½±å“å·¥ä½œæ•ˆç‡ |
| 2 | **ç‰ˆæœ¬æ§åˆ¶æ··ä¹±** | ä¸¥é‡ | åˆåŒå¤šç‰ˆæœ¬å¹¶è¡Œï¼Œå¹´å‡å‘ç”Ÿ15æ¬¡ç‰ˆæœ¬è¯¯ç”¨ |
| 3 | **æƒé™ç®¡ç†ç²—æ”¾** | é«˜ | æ— æ³•ç²¾ç¡®æ§åˆ¶æ–‡æ¡£è®¿é—®æƒé™ï¼Œå­˜åœ¨æ³„å¯†é£é™© |
| 4 | **åä½œæ•ˆç‡ä½** | é«˜ | å¤šäººåä½œç¼–è¾‘å†²çªé¢‘ç¹ï¼Œéœ€è¦é¢‘ç¹åˆå¹¶ |
| 5 | **åˆè§„å®¡è®¡å›°éš¾** | ä¸­ | æ— æ³•å®Œæ•´è¿½è¸ªæ–‡æ¡£è®¿é—®å’Œä¿®æ”¹è®°å½• |

### 3.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | æ–‡æ¡£æ£€ç´¢æ—¶é—´ | 30åˆ†é’Ÿ | <30ç§’ | 6ä¸ªæœˆ |
| 2 | ç‰ˆæœ¬æ§åˆ¶å‡†ç¡®ç‡ | 60% | 99.9% | 6ä¸ªæœˆ |
| 3 | æƒé™æ§åˆ¶ç²’åº¦ | æ–‡ä»¶çº§ | æ®µè½çº§ | 12ä¸ªæœˆ |
| 4 | åä½œå†²çªç‡ | 20% | <1% | 9ä¸ªæœˆ |
| 5 | å®¡è®¡è¿½è¸ªå®Œæ•´ç‡ | 40% | 100% | 6ä¸ªæœˆ |

### 3.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å…¨æ–‡æ£€ç´¢æ€§èƒ½**ï¼š100ä¸‡æ–‡æ¡£çš„å…¨æ–‡ç´¢å¼•ï¼Œè¦æ±‚æ£€ç´¢å“åº”æ—¶é—´<1ç§’

2. **ç»†ç²’åº¦æƒé™æ§åˆ¶**ï¼šéœ€è¦æ”¯æŒåŸºäºè§’è‰²ã€éƒ¨é—¨ã€é¡¹ç›®çš„å¤šç»´æƒé™ï¼Œä»¥åŠæ–‡æ¡£å†…æ®µè½çº§æƒé™

3. **å®æ—¶åä½œç¼–è¾‘**ï¼šéœ€è¦æ”¯æŒå¤šäººå®æ—¶åä½œï¼ŒOTç®—æ³•å¤„ç†å†²çªï¼Œå»¶è¿Ÿ<100ms

4. **ç‰ˆæœ¬åˆ†æ”¯ç®¡ç†**ï¼šæ³•å¾‹æ–‡æ¡£éœ€è¦æ”¯æŒåˆ†æ”¯ç‰ˆæœ¬ï¼ˆå¦‚åˆåŒçš„ä¸åŒè°ˆåˆ¤ç‰ˆæœ¬ï¼‰ï¼Œç±»ä¼¼Gitçš„ç‰ˆæœ¬ç®¡ç†

5. **å®¡è®¡æ—¥å¿—å®Œæ•´æ€§**ï¼šéœ€è¦è®°å½•æ‰€æœ‰æ–‡æ¡£æ“ä½œï¼Œæ”¯æŒä¸å¯ç¯¡æ”¹çš„å®¡è®¡è¿½è¸ª

### 3.5 å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
æ™ºèƒ½æ–‡æ¡£ç®¡ç†ç³»ç»Ÿ - æ ¸å¿ƒå®ç°
æ”¯æŒç‰ˆæœ¬æ§åˆ¶ã€ç»†ç²’åº¦æƒé™ã€å…¨æ–‡æ£€ç´¢
"""

import hashlib
import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Set
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Permission(Enum):
    """æƒé™ç±»å‹"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    SHARE = "share"
    ADMIN = "admin"


class DocumentOperation(Enum):
    """æ–‡æ¡£æ“ä½œ"""
    CREATE = "create"
    READ = "read"
    UPDATE = "update"
    DELETE = "delete"
    SHARE = "share"
    VERSION = "version"


@dataclass
class PermissionRule:
    """æƒé™è§„åˆ™"""
    user_id: Optional[str]
    role: Optional[str]
    department: Optional[str]
    permissions: Set[Permission] = field(default_factory=set)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "user_id": self.user_id,
            "role": self.role,
            "department": self.department,
            "permissions": [p.value for p in self.permissions]
        }


@dataclass
class DocumentVersion:
    """æ–‡æ¡£ç‰ˆæœ¬"""
    version_id: str
    document_id: str
    version_number: int
    content: str
    checksum: str
    created_by: str
    created_at: datetime
    comment: str = ""
    parent_versions: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "version_id": self.version_id,
            "document_id": self.document_id,
            "version_number": self.version_number,
            "checksum": self.checksum,
            "created_by": self.created_by,
            "created_at": self.created_at.isoformat(),
            "comment": self.comment,
            "parent_versions": self.parent_versions
        }


@dataclass
class AuditLog:
    """å®¡è®¡æ—¥å¿—"""
    log_id: str
    document_id: str
    user_id: str
    operation: DocumentOperation
    timestamp: datetime
    details: Dict[str, Any] = field(default_factory=dict)
    ip_address: str = ""
    user_agent: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "log_id": self.log_id,
            "document_id": self.document_id,
            "user_id": self.user_id,
            "operation": self.operation.value,
            "timestamp": self.timestamp.isoformat(),
            "details": self.details,
            "ip_address": self.ip_address,
            "user_agent": self.user_agent
        }


class DocumentManager:
    """æ–‡æ¡£ç®¡ç†å™¨"""
    
    def __init__(self):
        # æ–‡æ¡£å­˜å‚¨
        self.documents: Dict[str, Dict[str, Any]] = {}
        self.document_versions: Dict[str, List[DocumentVersion]] = defaultdict(list)
        
        # æƒé™ç®¡ç†
        self.permissions: Dict[str, List[PermissionRule]] = defaultdict(list)
        
        # å…¨æ–‡ç´¢å¼• (ç®€åŒ–çš„å€’æ’ç´¢å¼•)
        self.index: Dict[str, Set[str]] = defaultdict(set)
        
        # å®¡è®¡æ—¥å¿—
        self.audit_logs: List[AuditLog] = []
        
        # ç”¨æˆ·è§’è‰²ä¿¡æ¯
        self.user_roles: Dict[str, Dict] = {}
        
        logger.info("Document Manager initialized")
    
    def register_user(self, user_id: str, roles: List[str], department: str):
        """æ³¨å†Œç”¨æˆ·"""
        self.user_roles[user_id] = {
            "roles": roles,
            "department": department
        }
    
    def create_document(self, document_id: str, title: str, content: str,
                       owner_id: str, metadata: Dict[str, Any] = None) -> bool:
        """åˆ›å»ºæ–‡æ¡£"""
        # æ£€æŸ¥æƒé™
        if not self._check_permission(None, owner_id, Permission.WRITE):
            logger.warning(f"User {owner_id} does not have permission to create documents")
            return False
        
        # åˆ›å»ºæ–‡æ¡£
        self.documents[document_id] = {
            "document_id": document_id,
            "title": title,
            "current_version": 0,
            "owner_id": owner_id,
            "metadata": metadata or {},
            "created_at": datetime.now().isoformat()
        }
        
        # åˆ›å»ºåˆå§‹ç‰ˆæœ¬
        version = DocumentVersion(
            version_id=f"{document_id}-V1",
            document_id=document_id,
            version_number=1,
            content=content,
            checksum=hashlib.sha256(content.encode()).hexdigest(),
            created_by=owner_id,
            created_at=datetime.now(),
            comment="Initial version"
        )
        self.document_versions[document_id].append(version)
        self.documents[document_id]["current_version"] = 1
        
        # å»ºç«‹ç´¢å¼•
        self._index_document(document_id, content)
        
        # å®¡è®¡æ—¥å¿—
        self._log_operation(document_id, owner_id, DocumentOperation.CREATE,
                          {"title": title})
        
        logger.info(f"Created document: {document_id}")
        return True
    
    def update_document(self, document_id: str, new_content: str,
                       user_id: str, comment: str = "") -> bool:
        """æ›´æ–°æ–‡æ¡£"""
        if document_id not in self.documents:
            return False
        
        # æ£€æŸ¥æƒé™
        if not self._check_permission(document_id, user_id, Permission.WRITE):
            logger.warning(f"User {user_id} does not have write permission")
            return False
        
        # åˆ›å»ºæ–°ç‰ˆæœ¬
        versions = self.document_versions[document_id]
        new_version_number = len(versions) + 1
        
        version = DocumentVersion(
            version_id=f"{document_id}-V{new_version_number}",
            document_id=document_id,
            version_number=new_version_number,
            content=new_content,
            checksum=hashlib.sha256(new_content.encode()).hexdigest(),
            created_by=user_id,
            created_at=datetime.now(),
            comment=comment,
            parent_versions=[versions[-1].version_id] if versions else []
        )
        
        versions.append(version)
        self.documents[document_id]["current_version"] = new_version_number
        
        # æ›´æ–°ç´¢å¼•
        self._index_document(document_id, new_content)
        
        # å®¡è®¡æ—¥å¿—
        self._log_operation(document_id, user_id, DocumentOperation.UPDATE,
                          {"version": new_version_number, "comment": comment})
        
        logger.info(f"Updated document: {document_id} to version {new_version_number}")
        return True
    
    def get_document(self, document_id: str, user_id: str,
                    version_number: int = None) -> Optional[Dict]:
        """è·å–æ–‡æ¡£"""
        if document_id not in self.documents:
            return None
        
        # æ£€æŸ¥æƒé™
        if not self._check_permission(document_id, user_id, Permission.READ):
            logger.warning(f"User {user_id} does not have read permission")
            return None
        
        # å®¡è®¡æ—¥å¿—
        self._log_operation(document_id, user_id, DocumentOperation.READ,
                          {"version": version_number})
        
        # è·å–æŒ‡å®šç‰ˆæœ¬æˆ–æœ€æ–°ç‰ˆæœ¬
        versions = self.document_versions[document_id]
        if version_number:
            for v in versions:
                if v.version_number == version_number:
                    return {
                        **self.documents[document_id],
                        "content": v.content,
                        "version": v.to_dict()
                    }
            return None
        else:
            latest = versions[-1] if versions else None
            if latest:
                return {
                    **self.documents[document_id],
                    "content": latest.content,
                    "version": latest.to_dict()
                }
            return None
    
    def _check_permission(self, document_id: Optional[str], user_id: str,
                         permission: Permission) -> bool:
        """æ£€æŸ¥æƒé™"""
        if document_id is None or document_id not in self.permissions:
            # åˆ›å»ºæƒé™æ£€æŸ¥
            return True
        
        user_info = self.user_roles.get(user_id, {})
        user_roles = user_info.get("roles", [])
        user_dept = user_info.get("department", "")
        
        # æ£€æŸ¥æƒé™è§„åˆ™
        for rule in self.permissions[document_id]:
            # ç”¨æˆ·åŒ¹é…
            if rule.user_id and rule.user_id == user_id:
                return permission in rule.permissions
            
            # è§’è‰²åŒ¹é…
            if rule.role and rule.role in user_roles:
                return permission in rule.permissions
            
            # éƒ¨é—¨åŒ¹é…
            if rule.department and rule.department == user_dept:
                return permission in rule.permissions
        
        return False
    
    def set_permission(self, document_id: str, rule: PermissionRule):
        """è®¾ç½®æƒé™"""
        self.permissions[document_id].append(rule)
    
    def search_documents(self, query: str, user_id: str) -> List[Dict]:
        """æœç´¢æ–‡æ¡£"""
        # ç®€å•çš„åˆ†è¯æœç´¢
        terms = query.lower().split()
        matching_docs = set()
        
        for term in terms:
            if term in self.index:
                if not matching_docs:
                    matching_docs = self.index[term].copy()
                else:
                    matching_docs &= self.index[term]
        
        results = []
        for doc_id in matching_docs:
            # æ£€æŸ¥è¯»å–æƒé™
            if self._check_permission(doc_id, user_id, Permission.READ):
                doc = self.documents[doc_id]
                results.append({
                    "document_id": doc_id,
                    "title": doc["title"],
                    "owner_id": doc["owner_id"],
                    "current_version": doc["current_version"]
                })
        
        return results
    
    def _index_document(self, document_id: str, content: str):
        """å»ºç«‹æ–‡æ¡£ç´¢å¼•"""
        # ä»æ—§ç´¢å¼•ä¸­ç§»é™¤
        for term_docs in self.index.values():
            term_docs.discard(document_id)
        
        # æ·»åŠ æ–°ç´¢å¼•
        terms = set(content.lower().split())
        for term in terms:
            self.index[term].add(document_id)
    
    def _log_operation(self, document_id: str, user_id: str,
                      operation: DocumentOperation, details: Dict):
        """è®°å½•æ“ä½œæ—¥å¿—"""
        log = AuditLog(
            log_id=f"LOG-{datetime.now().strftime('%Y%m%d%H%M%S%f')}",
            document_id=document_id,
            user_id=user_id,
            operation=operation,
            timestamp=datetime.now(),
            details=details
        )
        self.audit_logs.append(log)
    
    def get_version_history(self, document_id: str) -> List[Dict]:
        """è·å–ç‰ˆæœ¬å†å²"""
        versions = self.document_versions.get(document_id, [])
        return [v.to_dict() for v in versions]
    
    def compare_versions(self, document_id: str, version1: int,
                        version2: int) -> Dict[str, Any]:
        """æ¯”è¾ƒä¸¤ä¸ªç‰ˆæœ¬"""
        versions = self.document_versions.get(document_id, [])
        
        v1_content = None
        v2_content = None
        
        for v in versions:
            if v.version_number == version1:
                v1_content = v.content
            if v.version_number == version2:
                v2_content = v.content
        
        if v1_content is None or v2_content is None:
            return {"error": "Version not found"}
        
        # ç®€å•çš„è¡Œçº§æ¯”è¾ƒ
        v1_lines = v1_content.split('\n')
        v2_lines = v2_content.split('\n')
        
        diff = {
            "version1": version1,
            "version2": version2,
            "added_lines": [],
            "removed_lines": [],
            "modified_lines": []
        }
        
        max_lines = max(len(v1_lines), len(v2_lines))
        for i in range(max_lines):
            line1 = v1_lines[i] if i < len(v1_lines) else None
            line2 = v2_lines[i] if i < len(v2_lines) else None
            
            if line1 is None:
                diff["added_lines"].append({"line": i+1, "content": line2})
            elif line2 is None:
                diff["removed_lines"].append({"line": i+1, "content": line1})
            elif line1 != line2:
                diff["modified_lines"].append({
                    "line": i+1,
                    "old": line1,
                    "new": line2
                })
        
        return diff


def main():
    """æ¼”ç¤ºæ–‡æ¡£ç®¡ç†"""
    dm = DocumentManager()
    
    # æ³¨å†Œç”¨æˆ·
    dm.register_user("U001", ["admin"], "Legal")
    dm.register_user("U002", ["lawyer"], "Legal")
    dm.register_user("U003", ["paralegal"], "Legal")
    
    # åˆ›å»ºæ–‡æ¡£
    doc_id = "DOC-001"
    content = """
    CONTRACT AGREEMENT
    
    Party A: Company X
    Party B: Company Y
    
    Terms and Conditions:
    1. Payment terms: Net 30
    2. Delivery: FOB Shanghai
    3. Warranty: 12 months
    """
    
    dm.create_document(doc_id, "Service Contract Template", content, "U001")
    
    # è®¾ç½®æƒé™
    dm.set_permission(doc_id, PermissionRule(
        user_id=None,
        role="lawyer",
        department="Legal",
        permissions={Permission.READ, Permission.WRITE}
    ))
    
    # æ›´æ–°æ–‡æ¡£
    new_content = content + "\n4. Confidentiality: Both parties agree..."
    dm.update_document(doc_id, new_content, "U002", "Added confidentiality clause")
    
    # æœç´¢
    results = dm.search_documents("contract agreement", "U002")
    print(f"Search results: {len(results)}")
    for r in results:
        print(f"  - {r['title']}")
    
    # ç‰ˆæœ¬å†å²
    history = dm.get_version_history(doc_id)
    print(f"\nVersion history: {len(history)} versions")
    
    # ç‰ˆæœ¬æ¯”è¾ƒ
    diff = dm.compare_versions(doc_id, 1, 2)
    print(f"\nVersion comparison:")
    print(json.dumps(diff, indent=2))


if __name__ == "__main__":
    main()
```

### 3.6 æ•ˆæœè¯„ä¼°ä¸ROI

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| æ–‡æ¡£æ£€ç´¢æ—¶é—´ | 30åˆ†é’Ÿ | 5ç§’ | -99.7% |
| ç‰ˆæœ¬æ§åˆ¶å‡†ç¡®ç‡ | 60% | 99.9% | +40% |
| åä½œå†²çªç‡ | 20% | 0.5% | -97.5% |
| å®¡è®¡è¿½è¸ªå®Œæ•´ç‡ | 40% | 100% | +60% |
| æ–‡æ¡£å®‰å…¨äº‹ä»¶ | 5æ¬¡/å¹´ | 0æ¬¡ | -100% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š300ä¸‡å…ƒ
- æ•°æ®è¿ç§»ï¼š50ä¸‡å…ƒ
- **æ€»æŠ•èµ„**ï¼š350ä¸‡å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- æ•ˆç‡æå‡ï¼š800ä¸‡å…ƒ
- é£é™©å‡å°‘ï¼š200ä¸‡å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š1,000ä¸‡å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š4.2ä¸ªæœˆ
- 3å¹´ROIï¼š757%

---

## 4. æ¡ˆä¾‹3ï¼šæµç¨‹è‡ªåŠ¨åŒ–å¼•æ“

### 4.1 ä¼ä¸šèƒŒæ™¯

**æŸå¤§å‹åˆ¶é€ ä¼ä¸š**æ‹¥æœ‰50ä¸ªå·¥å‚ï¼Œ10,000åå‘˜å·¥ï¼Œå¹´å‡å¤„ç†å®¡æ‰¹æµç¨‹20ä¸‡ä¸ªï¼Œæ¶‰åŠé‡‡è´­ã€ç”Ÿäº§ã€äººäº‹ã€è´¢åŠ¡ç­‰å¤šä¸ªä¸šåŠ¡é¢†åŸŸã€‚

- **å·¥å‚æ•°é‡**ï¼š50ä¸ª
- **å‘˜å·¥è§„æ¨¡**ï¼š10,000äºº
- **å¹´å¤„ç†æµç¨‹**ï¼š20ä¸‡ä¸ª
- **æµç¨‹ç±»å‹**ï¼š30+ç§

### 4.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **æµç¨‹è®¾è®¡å¤æ‚** | ä¸¥é‡ | æ–°æµç¨‹ä¸Šçº¿éœ€2ä¸ªæœˆï¼Œæ— æ³•å¿«é€Ÿå“åº”ä¸šåŠ¡å˜åŒ– |
| 2 | **æµç¨‹æ‰§è¡Œä¸é€æ˜** | ä¸¥é‡ | æµç¨‹å¡åœ¨æŸä¸ªç¯èŠ‚ï¼Œæ— æ³•åŠæ—¶å‘ç°å’Œå‚¬åŠ |
| 3 | **è·¨ç³»ç»Ÿé›†æˆéš¾** | é«˜ | æµç¨‹ä¸ERPã€CRMç³»ç»Ÿè„±èŠ‚ï¼Œéœ€è¦é‡å¤å½•å…¥ |
| 4 | **æ•°æ®åˆ†æç¼ºå¤±** | é«˜ | æ— æ³•åˆ†ææµç¨‹ç“¶é¢ˆï¼Œæ— æ³•æŒç»­ä¼˜åŒ– |
| 5 | **ç§»åŠ¨å®¡æ‰¹ä½“éªŒå·®** | ä¸­ | ç§»åŠ¨ç«¯åŠŸèƒ½ç®€é™‹ï¼Œå®¡æ‰¹ä½“éªŒå·® |

### 4.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | æ–°æµç¨‹ä¸Šçº¿æ—¶é—´ | 2ä¸ªæœˆ | <1å‘¨ | 9ä¸ªæœˆ |
| 2 | æµç¨‹å¯è§†åŒ–è¦†ç›–ç‡ | 30% | 100% | 6ä¸ªæœˆ |
| 3 | ç³»ç»Ÿé›†æˆç‡ | 20% | 90% | 12ä¸ªæœˆ |
| 4 | æµç¨‹ä¼˜åŒ–å‘¨æœŸ | 6ä¸ªæœˆ | <1ä¸ªæœˆ | 9ä¸ªæœˆ |
| 5 | ç§»åŠ¨ç«¯ä½¿ç”¨ç‡ | 25% | 80% | 6ä¸ªæœˆ |

### 4.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¯è§†åŒ–æµç¨‹è®¾è®¡å™¨**ï¼šéœ€è¦æ”¯æŒæ‹–æ‹½å¼æµç¨‹è®¾è®¡ï¼Œæ”¯æŒBPMN 2.0æ ‡å‡†

2. **åŠ¨æ€æµç¨‹æ‰§è¡Œ**ï¼šéœ€è¦æ”¯æŒä¼šç­¾ã€è½¬åŠã€è·³è½¬ã€å›é€€ç­‰å¤æ‚æµç¨‹æ¨¡å¼

3. **é«˜æ€§èƒ½æµç¨‹å¼•æ“**ï¼šéœ€è¦æ”¯æŒæ—¥å¤„ç†10ä¸‡+æµç¨‹å®ä¾‹ï¼Œå“åº”æ—¶é—´<100ms

4. **è§„åˆ™å¼•æ“é›†æˆ**ï¼šéœ€è¦æ”¯æŒå¤æ‚çš„ä¸šåŠ¡è§„åˆ™åˆ¤æ–­ï¼ŒåŠ¨æ€å†³å®šæµç¨‹èµ°å‘

5. **åˆ†å¸ƒå¼äº‹åŠ¡**ï¼šéœ€è¦ä¿è¯è·¨ç³»ç»Ÿé›†æˆçš„æ•°æ®ä¸€è‡´æ€§

### 4.5 å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
æµç¨‹è‡ªåŠ¨åŒ–å¼•æ“ - æ ¸å¿ƒå®ç°
æ”¯æŒBPMNæµç¨‹ã€è§„åˆ™å¼•æ“ã€è·¨ç³»ç»Ÿé›†æˆ
"""

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Callable
from collections import defaultdict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class NodeType(Enum):
    """èŠ‚ç‚¹ç±»å‹"""
    START = "start"
    END = "end"
    TASK = "task"
    GATEWAY = "gateway"
    EVENT = "event"


class TaskType(Enum):
    """ä»»åŠ¡ç±»å‹"""
    USER_TASK = "user_task"
    SERVICE_TASK = "service_task"
    SCRIPT_TASK = "script_task"


class GatewayType(Enum):
    """ç½‘å…³ç±»å‹"""
    EXCLUSIVE = "exclusive"  # æ’ä»–ç½‘å…³
    PARALLEL = "parallel"    # å¹¶è¡Œç½‘å…³
    INCLUSIVE = "inclusive"  # åŒ…å®¹ç½‘å…³


class ProcessStatus(Enum):
    """æµç¨‹çŠ¶æ€"""
    RUNNING = "running"
    COMPLETED = "completed"
    SUSPENDED = "suspended"
    TERMINATED = "terminated"


class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€"""
    PENDING = "pending"
    ASSIGNED = "assigned"
    COMPLETED = "completed"


@dataclass
class FlowNode:
    """æµç¨‹èŠ‚ç‚¹"""
    node_id: str
    node_type: NodeType
    name: str
    properties: Dict[str, Any] = field(default_factory=dict)
    outgoing: List[str] = field(default_factory=list)
    incoming: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "node_id": self.node_id,
            "node_type": self.node_type.value,
            "name": self.name,
            "properties": self.properties,
            "outgoing": self.outgoing,
            "incoming": self.incoming
        }


@dataclass
class ProcessDefinition:
    """æµç¨‹å®šä¹‰"""
    definition_id: str
    name: str
    version: int
    nodes: Dict[str, FlowNode] = field(default_factory=dict)
    start_node: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "definition_id": self.definition_id,
            "name": self.name,
            "version": self.version,
            "nodes": {k: v.to_dict() for k, v in self.nodes.items()},
            "start_node": self.start_node
        }


@dataclass
class ProcessInstance:
    """æµç¨‹å®ä¾‹"""
    instance_id: str
    definition_id: str
    status: ProcessStatus
    variables: Dict[str, Any] = field(default_factory=dict)
    current_nodes: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "instance_id": self.instance_id,
            "definition_id": self.definition_id,
            "status": self.status.value,
            "variables": self.variables,
            "current_nodes": self.current_nodes,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None
        }


@dataclass
class TaskInstance:
    """ä»»åŠ¡å®ä¾‹"""
    task_id: str
    instance_id: str
    node_id: str
    task_type: TaskType
    assignee: Optional[str]
    status: TaskStatus
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None
    form_data: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "task_id": self.task_id,
            "instance_id": self.instance_id,
            "node_id": self.node_id,
            "task_type": self.task_type.value,
            "assignee": self.assignee,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "completed_at": self.completed_at.isoformat() if self.completed_at else None
        }


class ProcessEngine:
    """æµç¨‹å¼•æ“"""
    
    def __init__(self):
        self.process_definitions: Dict[str, ProcessDefinition] = {}
        self.process_instances: Dict[str, ProcessInstance] = {}
        self.task_instances: Dict[str, TaskInstance] = {}
        
        # ä»»åŠ¡å¤„ç†å™¨
        self.task_handlers: Dict[TaskType, Callable] = {}
        
        # è§„åˆ™å¼•æ“ï¼ˆç®€åŒ–ç‰ˆï¼‰
        self.rules: List[Dict] = []
        
        # ç»Ÿè®¡
        self.stats = {
            "total_instances": 0,
            "completed_instances": 0,
            "avg_duration_seconds": 0
        }
        
        logger.info("Process Engine initialized")
    
    def register_process_definition(self, definition: ProcessDefinition):
        """æ³¨å†Œæµç¨‹å®šä¹‰"""
        self.process_definitions[definition.definition_id] = definition
        logger.info(f"Registered process definition: {definition.name}")
    
    def start_process(self, definition_id: str,
                     variables: Dict[str, Any] = None) -> Optional[str]:
        """å¯åŠ¨æµç¨‹"""
        if definition_id not in self.process_definitions:
            return None
        
        definition = self.process_definitions[definition_id]
        
        instance_id = f"INST-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        instance = ProcessInstance(
            instance_id=instance_id,
            definition_id=definition_id,
            status=ProcessStatus.RUNNING,
            variables=variables or {},
            current_nodes=[definition.start_node]
        )
        
        self.process_instances[instance_id] = instance
        self.stats["total_instances"] += 1
        
        # æ¿€æ´»èµ·å§‹èŠ‚ç‚¹
        self._activate_node(instance_id, definition.start_node)
        
        logger.info(f"Started process instance: {instance_id}")
        return instance_id
    
    def _activate_node(self, instance_id: str, node_id: str):
        """æ¿€æ´»èŠ‚ç‚¹"""
        instance = self.process_instances[instance_id]
        definition = self.process_definitions[instance.definition_id]
        node = definition.nodes[node_id]
        
        if node.node_type == NodeType.TASK:
            # åˆ›å»ºä»»åŠ¡
            task_type = TaskType(node.properties.get("task_type", "user_task"))
            task = TaskInstance(
                task_id=f"TASK-{datetime.now().strftime('%Y%m%d%H%M%S%f')}",
                instance_id=instance_id,
                node_id=node_id,
                task_type=task_type,
                assignee=node.properties.get("assignee"),
                status=TaskStatus.PENDING
            )
            self.task_instances[task.task_id] = task
            
            logger.info(f"Created task: {task.task_id} for node {node_id}")
            
        elif node.node_type == NodeType.GATEWAY:
            # æ‰§è¡Œç½‘å…³é€»è¾‘
            self._execute_gateway(instance_id, node_id)
            
        elif node.node_type == NodeType.END:
            # ç»“æŸæµç¨‹
            instance.status = ProcessStatus.COMPLETED
            instance.completed_at = datetime.now()
            instance.current_nodes = []
            
            duration = (instance.completed_at - instance.created_at).total_seconds()
            self.stats["completed_instances"] += 1
            n = self.stats["completed_instances"]
            self.stats["avg_duration_seconds"] = (
                self.stats["avg_duration_seconds"] * (n-1) + duration
            ) / n
            
            logger.info(f"Process {instance_id} completed in {duration:.2f} seconds")
    
    def _execute_gateway(self, instance_id: str, node_id: str):
        """æ‰§è¡Œç½‘å…³"""
        instance = self.process_instances[instance_id]
        definition = self.process_definitions[instance.definition_id]
        node = definition.nodes[node_id]
        
        gateway_type = GatewayType(node.properties.get("gateway_type", "exclusive"))
        
        if gateway_type == GatewayType.EXCLUSIVE:
            # æ’ä»–ç½‘å…³ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„åˆ†æ”¯
            for next_node_id in node.outgoing:
                if self._evaluate_condition(instance_id, node_id, next_node_id):
                    self._transition(instance_id, node_id, next_node_id)
                    break
                    
        elif gateway_type == GatewayType.PARALLEL:
            # å¹¶è¡Œç½‘å…³ï¼šæ‰€æœ‰åˆ†æ”¯å¹¶è¡Œæ‰§è¡Œ
            for next_node_id in node.outgoing:
                self._transition(instance_id, node_id, next_node_id)
    
    def _evaluate_condition(self, instance_id: str,
                           from_node: str, to_node: str) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        instance = self.process_instances[instance_id]
        
        # ç®€åŒ–çš„æ¡ä»¶è¯„ä¼°
        # å®é™…åº”è¯¥è§£æå’Œæ‰§è¡Œæ¡ä»¶è¡¨è¾¾å¼
        return True
    
    def _transition(self, instance_id: str, from_node: str, to_node: str):
        """æµç¨‹æµè½¬"""
        instance = self.process_instances[instance_id]
        
        # ç§»é™¤å½“å‰èŠ‚ç‚¹
        if from_node in instance.current_nodes:
            instance.current_nodes.remove(from_node)
        
        # æ·»åŠ æ–°èŠ‚ç‚¹
        instance.current_nodes.append(to_node)
        
        # æ¿€æ´»æ–°èŠ‚ç‚¹
        self._activate_node(instance_id, to_node)
    
    def complete_task(self, task_id: str, assignee: str,
                     form_data: Dict[str, Any] = None) -> bool:
        """å®Œæˆä»»åŠ¡"""
        if task_id not in self.task_instances:
            return False
        
        task = self.task_instances[task_id]
        
        # æ£€æŸ¥åˆ†é…
        if task.assignee and task.assignee != assignee:
            logger.warning(f"Task {task_id} is assigned to {task.assignee}, not {assignee}")
            return False
        
        task.status = TaskStatus.COMPLETED
        task.completed_at = datetime.now()
        task.form_data = form_data or {}
        
        # æ›´æ–°æµç¨‹å˜é‡
        instance = self.process_instances[task.instance_id]
        instance.variables.update(form_data or {})
        
        # æµè½¬åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        definition = self.process_definitions[instance.definition_id]
        node = definition.nodes[task.node_id]
        
        for next_node_id in node.outgoing:
            self._transition(task.instance_id, task.node_id, next_node_id)
        
        logger.info(f"Completed task: {task_id}")
        return True
    
    def get_user_tasks(self, user_id: str) -> List[Dict]:
        """è·å–ç”¨æˆ·ä»»åŠ¡"""
        tasks = [
            task.to_dict() for task in self.task_instances.values()
            if task.status in [TaskStatus.PENDING, TaskStatus.ASSIGNED]
            and (task.assignee == user_id or task.assignee is None)
        ]
        return tasks
    
    def get_process_status(self, instance_id: str) -> Optional[Dict]:
        """è·å–æµç¨‹çŠ¶æ€"""
        if instance_id not in self.process_instances:
            return None
        
        instance = self.process_instances[instance_id]
        definition = self.process_definitions[instance.definition_id]
        
        # è·å–å½“å‰èŠ‚ç‚¹çš„è¯¦ç»†ä¿¡æ¯
        current_nodes_info = []
        for node_id in instance.current_nodes:
            if node_id in definition.nodes:
                node = definition.nodes[node_id]
                current_nodes_info.append({
                    "node_id": node_id,
                    "name": node.name,
                    "type": node.node_type.value
                })
        
        return {
            **instance.to_dict(),
            "current_nodes_detail": current_nodes_info,
            "tasks": [
                t.to_dict() for t in self.task_instances.values()
                if t.instance_id == instance_id and t.status != TaskStatus.COMPLETED
            ]
        }
    
    def create_simple_approval_process(self, definition_id: str, name: str,
                                      approvers: List[str]) -> ProcessDefinition:
        """åˆ›å»ºç®€å•å®¡æ‰¹æµç¨‹"""
        definition = ProcessDefinition(
            definition_id=definition_id,
            name=name,
            version=1
        )
        
        # å¼€å§‹èŠ‚ç‚¹
        start = FlowNode(
            node_id="start",
            node_type=NodeType.START,
            name="Start",
            outgoing=["task1"]
        )
        definition.nodes["start"] = start
        definition.start_node = "start"
        
        # å®¡æ‰¹ä»»åŠ¡èŠ‚ç‚¹
        prev_node = "start"
        for i, approver in enumerate(approvers):
            task_id = f"task{i+1}"
            task = FlowNode(
                node_id=task_id,
                node_type=NodeType.TASK,
                name=f"Approval {i+1}",
                properties={
                    "task_type": "user_task",
                    "assignee": approver
                },
                incoming=[prev_node],
                outgoing=[f"task{i+2}" if i < len(approvers) - 1 else "end"]
            )
            definition.nodes[task_id] = task
            prev_node = task_id
        
        # ç»“æŸèŠ‚ç‚¹
        end = FlowNode(
            node_id="end",
            node_type=NodeType.END,
            name="End",
            incoming=[prev_node]
        )
        definition.nodes["end"] = end
        
        self.register_process_definition(definition)
        return definition


def main():
    """æ¼”ç¤ºæµç¨‹å¼•æ“"""
    engine = ProcessEngine()
    
    # åˆ›å»ºå®¡æ‰¹æµç¨‹å®šä¹‰
    engine.create_simple_approval_process(
        definition_id="purchase-approval",
        name="é‡‡è´­å®¡æ‰¹æµç¨‹",
        approvers=["manager", "finance", "director"]
    )
    
    # å¯åŠ¨æµç¨‹
    instance_id = engine.start_process(
        "purchase-approval",
        variables={
            "amount": 50000,
            "item": "æœåŠ¡å™¨è®¾å¤‡",
            "requester": "ITéƒ¨é—¨"
        }
    )
    
    print(f"Started process: {instance_id}")
    
    # æŸ¥çœ‹æµç¨‹çŠ¶æ€
    status = engine.get_process_status(instance_id)
    print(f"\nProcess status:")
    print(json.dumps(status, indent=2))
    
    # è·å–å¾…åŠä»»åŠ¡
    tasks = engine.get_user_tasks("manager")
    print(f"\nManager's tasks: {len(tasks)}")
    
    # å®Œæˆç¬¬ä¸€ä¸ªä»»åŠ¡
    if tasks:
        engine.complete_task(
            tasks[0]["task_id"],
            "manager",
            {"approved": True, "comment": "åŒæ„é‡‡è´­"}
        )
    
    # å†æ¬¡æŸ¥çœ‹çŠ¶æ€
    status = engine.get_process_status(instance_id)
    print(f"\nUpdated process status:")
    print(json.dumps(status, indent=2))


if __name__ == "__main__":
    main()
```

### 4.6 æ•ˆæœè¯„ä¼°ä¸ROI

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| æ–°æµç¨‹ä¸Šçº¿æ—¶é—´ | 2ä¸ªæœˆ | 3å¤© | -95% |
| æµç¨‹å¯è§†åŒ–è¦†ç›–ç‡ | 30% | 100% | +70% |
| ç³»ç»Ÿé›†æˆç‡ | 20% | 88% | +68% |
| æµç¨‹ä¼˜åŒ–å‘¨æœŸ | 6ä¸ªæœˆ | 2å‘¨ | -92% |
| ç§»åŠ¨ç«¯ä½¿ç”¨ç‡ | 25% | 82% | +57% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š800ä¸‡å…ƒ
- é›†æˆå®æ–½ï¼š400ä¸‡å…ƒ
- **æ€»æŠ•èµ„**ï¼š1,200ä¸‡å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- æ•ˆç‡æå‡ï¼š2,000ä¸‡å…ƒ
- äººåŠ›èŠ‚çœï¼š600ä¸‡å…ƒ
- é”™è¯¯å‡å°‘ï¼š300ä¸‡å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š2,900ä¸‡å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š5ä¸ªæœˆ
- 3å¹´ROIï¼š625%

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

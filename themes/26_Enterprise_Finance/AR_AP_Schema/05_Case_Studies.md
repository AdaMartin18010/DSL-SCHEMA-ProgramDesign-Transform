# åº”æ”¶åº”ä»˜Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [åº”æ”¶åº”ä»˜Schemaå®è·µæ¡ˆä¾‹](#åº”æ”¶åº”ä»˜schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šå¤§å‹è´¸æ˜“é›†å›¢åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ](#2-æ¡ˆä¾‹1å¤§å‹è´¸æ˜“é›†å›¢åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 æŠ€æœ¯æŒ‘æˆ˜](#22-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.3 è§£å†³æ–¹æ¡ˆ](#23-è§£å†³æ–¹æ¡ˆ)
    - [2.4 å®Œæ•´ä»£ç å®ç°](#24-å®Œæ•´ä»£ç å®ç°)
    - [2.5 æ•ˆæœè¯„ä¼°](#25-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šåˆ¶é€ ä¸šåº”ä»˜è´¦æ¬¾ä¸ä¾›åº”é“¾é‡‘èç³»ç»Ÿ](#3-æ¡ˆä¾‹2åˆ¶é€ ä¸šåº”ä»˜è´¦æ¬¾ä¸ä¾›åº”é“¾é‡‘èç³»ç»Ÿ)
    - [3.1 ä¸šåŠ¡èƒŒæ™¯](#31-ä¸šåŠ¡èƒŒæ™¯)
    - [3.2 æŠ€æœ¯æŒ‘æˆ˜](#32-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.3 è§£å†³æ–¹æ¡ˆ](#33-è§£å†³æ–¹æ¡ˆ)
    - [3.4 å®Œæ•´ä»£ç å®ç°](#34-å®Œæ•´ä»£ç å®ç°)
    - [3.5 æ•ˆæœè¯„ä¼°](#35-æ•ˆæœè¯„ä¼°)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›åº”æ”¶åº”ä»˜Schemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–åº”æ”¶è´¦æ¬¾ç®¡ç†ã€åº”ä»˜è´¦æ¬¾ç®¡ç†ã€ä¾›åº”é“¾é‡‘èã€è‡ªåŠ¨å¯¹è´¦ç­‰çœŸå®åœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **å¤§å‹è´¸æ˜“é›†å›¢åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ**ï¼šå®¢æˆ·ä¿¡ç”¨ã€å‘ç¥¨ã€æ”¶æ¬¾ã€è´¦é¾„ç®¡ç†
2. **åˆ¶é€ ä¸šåº”ä»˜è´¦æ¬¾ä¸ä¾›åº”é“¾é‡‘èç³»ç»Ÿ**ï¼šä¾›åº”å•†ç®¡ç†ã€ä»˜æ¬¾æ’ç¨‹ã€ä¾›åº”é“¾é‡‘è

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **é˜¿é‡Œå·´å·´**ï¼šä¾›åº”é“¾é‡‘èå¹³å°
- **æµ·å°”**ï¼šåº”æ”¶åº”ä»˜ç®¡ç†å¹³å°

---

## 2. æ¡ˆä¾‹1ï¼šå¤§å‹è´¸æ˜“é›†å›¢åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
ä¸œæ–¹è´¸æ˜“é›†å›¢æ˜¯ä¸€å®¶å¹´è¥æ”¶è¶…è¿‡800äº¿å…ƒçš„å¤§å‹è¿›å‡ºå£è´¸æ˜“ä¼ä¸šï¼Œæ‹¥æœ‰è¶…è¿‡5000å®¶æ´»è·ƒå®¢æˆ·ï¼Œä¸šåŠ¡èŒƒå›´è¦†ç›–å…¨çƒ80å¤šä¸ªå›½å®¶å’Œåœ°åŒºã€‚é›†å›¢å¹´å¼€ç¥¨é‡è¶…è¿‡50ä¸‡å¼ ï¼Œåº”æ”¶è´¦æ¬¾ä½™é¢å¹³å‡åœ¨120äº¿å…ƒå·¦å³ï¼Œè´¦æœŸç®¡ç†å¤æ‚ï¼Œå›æ¬¾å‹åŠ›å¤§ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **å®¢æˆ·ä¿¡ç”¨ç®¡ç†ç¼ºå¤±**ï¼šç¼ºä¹ç»Ÿä¸€çš„å®¢æˆ·ä¿¡ç”¨è¯„ä¼°ä½“ç³»ï¼Œåè´¦ç‡é«˜è¾¾2.5%ï¼Œå¹´åè´¦æŸå¤±è¶…è¿‡2äº¿å…ƒ
2. **å‘ç¥¨ç®¡ç†æ··ä¹±**ï¼šå‘ç¥¨å¼€å…·ã€å¯„é€ã€æ ¸é”€æµç¨‹ä¸è§„èŒƒï¼Œå‘ç¥¨ä¸¢å¤±ç‡é«˜è¾¾1%ï¼Œå®¢æˆ·æŠ•è¯‰é¢‘ç¹
3. **å›æ¬¾è·Ÿè¸ªå›°éš¾**ï¼šç¼ºä¹æœ‰æ•ˆçš„å›æ¬¾é¢„æµ‹å’Œè·Ÿè¸ªæœºåˆ¶ï¼Œè¶…æœŸåº”æ”¶è´¦æ¬¾å æ¯”é«˜è¾¾35%ï¼Œèµ„é‡‘å‘¨è½¬æ•ˆç‡ä½
4. **è´¦é¾„åˆ†ææ»å**ï¼šè´¦é¾„åˆ†æä¾èµ–æ‰‹å·¥æŠ¥è¡¨ï¼Œæ›´æ–°å‘¨æœŸé•¿ï¼ˆæœˆåº¦ï¼‰ï¼Œæ— æ³•åŠæ—¶å‘ç°é£é™©å®¢æˆ·
5. **å¯¹è´¦æ•ˆç‡ä½ä¸‹**ï¼šä¸å®¢æˆ·å¯¹è´¦ä¾èµ–äººå·¥æ ¸å¯¹ï¼Œæœˆå‡å¤„ç†å¯¹è´¦å•è¶…è¿‡2000ä»½ï¼Œå¯¹è´¦å‘¨æœŸé•¿è¾¾15å¤©

**ä¸šåŠ¡ç›®æ ‡**ï¼š

1. **å»ºç«‹ä¿¡ç”¨ç®¡ç†ä½“ç³»**ï¼šå»ºç«‹å®¢æˆ·ä¿¡ç”¨è¯„ä¼°å’ŒåŠ¨æ€è°ƒæ•´æœºåˆ¶ï¼Œå°†åè´¦ç‡é™ä½è‡³0.8%ä»¥å†…
2. **è§„èŒƒå‘ç¥¨å…¨æµç¨‹**ï¼šå®ç°å‘ç¥¨å…¨ç”Ÿå‘½å‘¨æœŸç”µå­åŒ–ç®¡ç†ï¼Œå‘ç¥¨ä¸¢å¤±ç‡é™è‡³0.01%ä»¥ä¸‹
3. **æ™ºèƒ½å›æ¬¾é¢„æµ‹**ï¼šå»ºç«‹å›æ¬¾é¢„æµ‹æ¨¡å‹ï¼Œå‡†ç¡®ç‡è¾¾åˆ°85%ä»¥ä¸Šï¼Œè¶…æœŸåº”æ”¶å æ¯”é™è‡³15%ä»¥å†…
4. **å®æ—¶è´¦é¾„ç›‘æ§**ï¼šå®ç°è´¦é¾„å®æ—¶ç›‘æ§å’Œè‡ªåŠ¨é¢„è­¦ï¼Œé‡å¤§é£é™©å®¢æˆ·24å°æ—¶å†…é¢„è­¦
5. **è‡ªåŠ¨å¯¹è´¦ç³»ç»Ÿ**ï¼šå®ç°é“¶ä¼ç›´è”å’Œå®¢æˆ·è‡ªåŠ©å¯¹è´¦ï¼Œå¯¹è´¦æ•ˆç‡æå‡80%ä»¥ä¸Š

### 2.2 æŠ€æœ¯æŒ‘æˆ˜

1. **æµ·é‡æ•°æ®å¤„ç†**ï¼šéœ€è¦å¤„ç†å¹´50ä¸‡+çš„å‘ç¥¨æ•°æ®å’Œåƒä¸‡çº§çš„äº¤æ˜“è®°å½•ï¼Œç³»ç»Ÿæ€§èƒ½è¦æ±‚é«˜
2. **å¤æ‚ä¿¡ç”¨æ¨¡å‹**ï¼šéœ€è¦æ„å»ºè€ƒè™‘å¤šç»´åº¦å› ç´ çš„å®¢æˆ·ä¿¡ç”¨è¯„ä¼°æ¨¡å‹ï¼Œå¹¶æ”¯æŒåŠ¨æ€è°ƒæ•´
3. **å¤šå¸ç§æ ¸ç®—**ï¼šæ¶‰åŠå¤šç§å¤–å¸çš„åº”æ”¶æ ¸ç®—ï¼Œæ±‡ç‡æ³¢åŠ¨å¯¹è´¦é¾„å’Œåè´¦å‡†å¤‡è®¡ç®—å½±å“å¤æ‚
4. **ç³»ç»Ÿé›†æˆ**ï¼šéœ€è¦ä¸ERPã€CRMã€é“¶è¡Œç³»ç»Ÿã€ç¨åŠ¡ç³»ç»Ÿç­‰å¤šç³»ç»Ÿé›†æˆ
5. **å®æ—¶è®¡ç®—**ï¼šè´¦é¾„ã€åè´¦å‡†å¤‡ã€ä¿¡ç”¨é¢åº¦ç­‰éœ€è¦å®æ—¶è®¡ç®—å’Œæ›´æ–°

### 2.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨Schemaå®šä¹‰åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ**ï¼Œå®ç°å®¢æˆ·ä¿¡ç”¨ç®¡ç†ã€å‘ç¥¨ç®¡ç†ã€å›æ¬¾è·Ÿè¸ªã€è´¦é¾„åˆ†æçš„å…¨æµç¨‹è‡ªåŠ¨åŒ–ã€‚

### 2.4 å®Œæ•´ä»£ç å®ç°

**åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿå®Œæ•´ä»£ç ï¼ˆçº¦480è¡Œï¼‰**ï¼š

```python
#!/usr/bin/env python3
"""
å¤§å‹è´¸æ˜“é›†å›¢åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ
æ”¯æŒï¼šå®¢æˆ·ä¿¡ç”¨ç®¡ç†ã€å‘ç¥¨ç®¡ç†ã€å›æ¬¾è·Ÿè¸ªã€è´¦é¾„åˆ†æã€è‡ªåŠ¨å¯¹è´¦
"""

from typing import Dict, List, Optional, Tuple
from datetime import date, datetime, timedelta
from decimal import Decimal, ROUND_HALF_UP
from dataclasses import dataclass, field
from enum import Enum, auto
import json
import uuid
from collections import defaultdict


class CreditRating(str, Enum):
    """ä¿¡ç”¨ç­‰çº§"""
    AAA = "AAA"  # ä¼˜ç§€
    AA = "AA"    # è‰¯å¥½
    A = "A"      # è¾ƒå¥½
    BBB = "BBB"  # ä¸€èˆ¬
    BB = "BB"    # è¾ƒå·®
    B = "B"      # å·®
    C = "C"      # æå·®


class InvoiceStatus(str, Enum):
    """å‘ç¥¨çŠ¶æ€"""
    DRAFT = "Draft"
    ISSUED = "Issued"
    SENT = "Sent"
    ACKNOWLEDGED = "Acknowledged"
    PARTIALLY_PAID = "PartiallyPaid"
    PAID = "Paid"
    OVERDUE = "Overdue"
    CANCELLED = "Cancelled"
    WRITE_OFF = "WriteOff"


class PaymentStatus(str, Enum):
    """ä»˜æ¬¾çŠ¶æ€"""
    UNPAID = "Unpaid"
    PARTIALLY_PAID = "PartiallyPaid"
    PAID = "Paid"
    OVERDUE = "Overdue"
    DISPUTED = "Disputed"


@dataclass
class CustomerCreditProfile:
    """å®¢æˆ·ä¿¡ç”¨æ¡£æ¡ˆ"""
    customer_id: str
    customer_code: str
    customer_name: str
    credit_rating: CreditRating = CreditRating.BBB
    credit_limit: Decimal = Decimal('0')
    credit_limit_currency: str = "CNY"
    payment_terms_days: int = 30
    annual_revenue: Decimal = Decimal('0')
    years_in_business: int = 0
    country_risk_score: int = 50  # 0-100
    industry_risk_score: int = 50  # 0-100
    historical_payment_score: int = 50  # 0-100
    credit_limit_expiry_date: Optional[date] = None
    is_credit_hold: bool = False
    hold_reason: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def calculate_credit_score(self) -> int:
        """è®¡ç®—ä¿¡ç”¨è¯„åˆ†ï¼ˆ0-100ï¼‰"""
        weights = {
            'years_in_business': 0.15,
            'annual_revenue': 0.20,
            'country_risk': 0.15,
            'industry_risk': 0.15,
            'payment_history': 0.35
        }
        
        # ç»è¥å¹´é™å¾—åˆ†ï¼ˆ0-100ï¼‰
        years_score = min(self.years_in_business * 5, 100)
        
        # å¹´æ”¶å…¥å¾—åˆ†ï¼ˆå¯¹æ•°åˆ»åº¦ï¼‰
        if self.annual_revenue > 0:
            revenue_score = min(int(self.annual_revenue.log10() * 10), 100)
        else:
            revenue_score = 0
        
        # ç»¼åˆè¯„åˆ†
        score = (
            years_score * weights['years_in_business'] +
            revenue_score * weights['annual_revenue'] +
            (100 - self.country_risk_score) * weights['country_risk'] +
            (100 - self.industry_risk_score) * weights['industry_risk'] +
            self.historical_payment_score * weights['payment_history']
        )
        
        return int(score)
    
    def update_credit_rating(self) -> None:
        """æ›´æ–°ä¿¡ç”¨ç­‰çº§"""
        score = self.calculate_credit_score()
        if score >= 90:
            self.credit_rating = CreditRating.AAA
        elif score >= 80:
            self.credit_rating = CreditRating.AA
        elif score >= 70:
            self.credit_rating = CreditRating.A
        elif score >= 60:
            self.credit_rating = CreditRating.BBB
        elif score >= 50:
            self.credit_rating = CreditRating.BB
        elif score >= 40:
            self.credit_rating = CreditRating.B
        else:
            self.credit_rating = CreditRating.C
        
        self.updated_at = datetime.now()


@dataclass
class SalesInvoice:
    """é”€å”®å‘ç¥¨"""
    invoice_id: str
    invoice_number: str
    invoice_date: date
    customer_id: str
    customer_name: str
    due_date: date
    invoice_amount: Decimal
    tax_amount: Decimal = Decimal('0')
    total_amount: Decimal = Decimal('0')
    currency: str = "CNY"
    exchange_rate: Decimal = Decimal('1')
    status: InvoiceStatus = InvoiceStatus.DRAFT
    payment_status: PaymentStatus = PaymentStatus.UNPAID
    paid_amount: Decimal = Decimal('0')
    outstanding_amount: Decimal = Decimal('0')
    contract_number: Optional[str] = None
    po_number: Optional[str] = None
    sales_rep: Optional[str] = None
    payment_terms_days: int = 30
    sent_date: Optional[date] = None
    acknowledged_date: Optional[date] = None
    description: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        """åˆå§‹åŒ–åè®¡ç®—æ€»é‡‘é¢å’Œæœªæ¸…é‡‘é¢"""
        if self.total_amount == Decimal('0'):
            self.total_amount = self.invoice_amount + self.tax_amount
        if self.outstanding_amount == Decimal('0'):
            self.outstanding_amount = self.total_amount
    
    @property
    def days_outstanding(self) -> int:
        """é€¾æœŸå¤©æ•°"""
        if self.payment_status == PaymentStatus.PAID:
            return 0
        return (date.today() - self.due_date).days
    
    @property
    def is_overdue(self) -> bool:
        """æ˜¯å¦é€¾æœŸ"""
        return self.days_outstanding > 0 and self.payment_status != PaymentStatus.PAID
    
    @property
    def aging_bucket(self) -> str:
        """è´¦é¾„åˆ†æ®µ"""
        if self.payment_status == PaymentStatus.PAID:
            return "Paid"
        
        days = self.days_outstanding
        if days <= 0:
            return "Current"
        elif days <= 30:
            return "1-30 Days"
        elif days <= 60:
            return "31-60 Days"
        elif days <= 90:
            return "61-90 Days"
        else:
            return "Over 90 Days"
    
    def record_payment(self, amount: Decimal) -> None:
        """è®°å½•æ”¶æ¬¾"""
        self.paid_amount += amount
        self.outstanding_amount = self.total_amount - self.paid_amount
        
        if self.outstanding_amount <= Decimal('0'):
            self.payment_status = PaymentStatus.PAID
            self.status = InvoiceStatus.PAID
        elif self.paid_amount > Decimal('0'):
            self.payment_status = PaymentStatus.PARTIALLY_PAID
            self.status = InvoiceStatus.PARTIALLY_PAID
        
        if self.is_overdue():
            self.payment_status = PaymentStatus.OVERDUE
        
        self.updated_at = datetime.now()


@dataclass
class Receipt:
    """æ”¶æ¬¾"""
    receipt_id: str
    receipt_number: str
    receipt_date: date
    customer_id: str
    customer_name: str
    receipt_amount: Decimal
    currency: str = "CNY"
    exchange_rate: Decimal = Decimal('1')
    payment_method: str = "Bank Transfer"
    bank_reference: Optional[str] = None
    applied_amount: Decimal = Decimal('0')
    unapplied_amount: Decimal = Decimal('0')
    applied_invoices: List[str] = field(default_factory=list)
    description: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    
    def apply_to_invoice(self, invoice: SalesInvoice, amount: Decimal) -> bool:
        """åº”ç”¨åˆ°å‘ç¥¨"""
        if amount > self.unapplied_amount:
            return False
        
        invoice.record_payment(amount)
        self.applied_amount += amount
        self.unapplied_amount -= amount
        self.applied_invoices.append(invoice.invoice_id)
        return True


@dataclass
class AgingBucket:
    """è´¦é¾„åˆ†æ®µ"""
    bucket_name: str
    bucket_order: int
    min_days: int
    max_days: int
    total_amount: Decimal = Decimal('0')
    invoice_count: int = 0
    percentage: Decimal = Decimal('0')


class AccountsReceivableSystem:
    """åº”æ”¶è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ"""
    
    def __init__(self):
        self.customers: Dict[str, CustomerCreditProfile] = {}
        self.invoices: Dict[str, SalesInvoice] = {}
        self.receipts: Dict[str, Receipt] = {}
        self.aging_buckets = [
            AgingBucket("Current", 1, -9999, 0),
            AgingBucket("1-30 Days", 2, 1, 30),
            AgingBucket("31-60 Days", 3, 31, 60),
            AgingBucket("61-90 Days", 4, 61, 90),
            AgingBucket("Over 90 Days", 5, 91, 9999)
        ]
    
    def add_customer(self, customer: CustomerCreditProfile) -> None:
        """æ·»åŠ å®¢æˆ·"""
        self.customers[customer.customer_id] = customer
    
    def create_invoice(self, invoice: SalesInvoice) -> Tuple[bool, str]:
        """åˆ›å»ºå‘ç¥¨"""
        # æ£€æŸ¥å®¢æˆ·ä¿¡ç”¨
        if invoice.customer_id not in self.customers:
            return False, "å®¢æˆ·ä¸å­˜åœ¨"
        
        customer = self.customers[invoice.customer_id]
        
        # æ£€æŸ¥ä¿¡ç”¨é¢åº¦
        if customer.is_credit_hold:
            return False, f"å®¢æˆ· {customer.customer_name} å¤„äºä¿¡ç”¨å†»ç»“çŠ¶æ€"
        
        # è®¡ç®—å®¢æˆ·å½“å‰ä½™é¢
        current_balance = self.get_customer_balance(invoice.customer_id)
        if current_balance + invoice.total_amount > customer.credit_limit:
            return False, (f"è¶…å‡ºä¿¡ç”¨é¢åº¦. å½“å‰ä½™é¢: {current_balance}, "
                          f"ä¿¡ç”¨é¢åº¦: {customer.credit_limit}")
        
        # ç”Ÿæˆå‘ç¥¨ç¼–å·
        if not invoice.invoice_number:
            invoice.invoice_number = f"INV-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}"
        
        invoice.status = InvoiceStatus.ISSUED
        self.invoices[invoice.invoice_id] = invoice
        
        return True, invoice.invoice_number
    
    def record_receipt(self, receipt: Receipt) -> Tuple[bool, str]:
        """è®°å½•æ”¶æ¬¾"""
        self.receipts[receipt.receipt_id] = receipt
        receipt.unapplied_amount = receipt.receipt_amount
        return True, receipt.receipt_number
    
    def apply_receipt_to_invoice(self, receipt_id: str, 
                                  invoice_id: str,
                                  amount: Optional[Decimal] = None) -> Tuple[bool, str]:
        """å°†æ”¶æ¬¾åº”ç”¨åˆ°å‘ç¥¨"""
        if receipt_id not in self.receipts:
            return False, "æ”¶æ¬¾ä¸å­˜åœ¨"
        if invoice_id not in self.invoices:
            return False, "å‘ç¥¨ä¸å­˜åœ¨"
        
        receipt = self.receipts[receipt_id]
        invoice = self.invoices[invoice_id]
        
        if amount is None:
            amount = min(receipt.unapplied_amount, invoice.outstanding_amount)
        
        success = receipt.apply_to_invoice(invoice, amount)
        if success:
            return True, f"æˆåŠŸåº”ç”¨ {amount} åˆ°å‘ç¥¨ {invoice.invoice_number}"
        return False, "åº”ç”¨å¤±è´¥ï¼Œé‡‘é¢ä¸è¶³"
    
    def get_customer_balance(self, customer_id: str) -> Decimal:
        """è·å–å®¢æˆ·ä½™é¢"""
        balance = Decimal('0')
        for invoice in self.invoices.values():
            if invoice.customer_id == customer_id:
                balance += invoice.outstanding_amount
        return balance
    
    def get_customer_open_invoices(self, customer_id: str) -> List[SalesInvoice]:
        """è·å–å®¢æˆ·æœªæ¸…å‘ç¥¨"""
        return [
            inv for inv in self.invoices.values()
            if inv.customer_id == customer_id and inv.outstanding_amount > Decimal('0')
        ]
    
    def get_aging_report(self, customer_id: Optional[str] = None) -> Dict:
        """è·å–è´¦é¾„æŠ¥å‘Š"""
        # é‡ç½®è´¦é¾„åˆ†æ®µ
        for bucket in self.aging_buckets:
            bucket.total_amount = Decimal('0')
            bucket.invoice_count = 0
        
        total_outstanding = Decimal('0')
        
        # ç»Ÿè®¡å‘ç¥¨
        for invoice in self.invoices.values():
            if invoice.outstanding_amount <= Decimal('0'):
                continue
            if customer_id and invoice.customer_id != customer_id:
                continue
            
            bucket_name = invoice.aging_bucket
            for bucket in self.aging_buckets:
                if bucket.bucket_name == bucket_name:
                    bucket.total_amount += invoice.outstanding_amount
                    bucket.invoice_count += 1
                    total_outstanding += invoice.outstanding_amount
                    break
        
        # è®¡ç®—ç™¾åˆ†æ¯”
        if total_outstanding > Decimal('0'):
            for bucket in self.aging_buckets:
                bucket.percentage = (bucket.total_amount / total_outstanding * 100).quantize(
                    Decimal('0.01'), rounding=ROUND_HALF_UP)
        
        # ç”ŸæˆæŠ¥å‘Š
        report = {
            'report_date': date.today().isoformat(),
            'customer_id': customer_id,
            'total_outstanding': float(total_outstanding),
            'buckets': [
                {
                    'name': bucket.bucket_name,
                    'amount': float(bucket.total_amount),
                    'count': bucket.invoice_count,
                    'percentage': float(bucket.percentage)
                }
                for bucket in self.aging_buckets
            ]
        }
        
        return report
    
    def calculate_bad_debt_provision(self) -> Decimal:
        """è®¡ç®—åè´¦å‡†å¤‡"""
        provision = Decimal('0')
        
        # è´¦é¾„è®¡ææ¯”ä¾‹
        provision_rates = {
            "Current": Decimal('0.01'),
            "1-30 Days": Decimal('0.05'),
            "31-60 Days": Decimal('0.10'),
            "61-90 Days": Decimal('0.30'),
            "Over 90 Days": Decimal('0.50')
        }
        
        for invoice in self.invoices.values():
            if invoice.outstanding_amount > Decimal('0'):
                rate = provision_rates.get(invoice.aging_bucket, Decimal('0'))
                provision += invoice.outstanding_amount * rate
        
        return provision.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
    
    def get_collection_forecast(self, days: int = 30) -> Dict:
        """æ”¶æ¬¾é¢„æµ‹"""
        forecast = defaultdict(Decimal)
        
        for invoice in self.invoices.values():
            if invoice.outstanding_amount <= Decimal('0'):
                continue
            
            # åŸºäºå®¢æˆ·å†å²ä»˜æ¬¾è¡Œä¸ºå’Œå‘ç¥¨é€¾æœŸæƒ…å†µé¢„æµ‹
            customer = self.customers.get(invoice.customer_id)
            if customer:
                # æ ¹æ®ä¿¡ç”¨ç­‰çº§è°ƒæ•´é¢„æµ‹
                payment_probability = {
                    CreditRating.AAA: 0.95,
                    CreditRating.AA: 0.90,
                    CreditRating.A: 0.85,
                    CreditRating.BBB: 0.75,
                    CreditRating.BB: 0.60,
                    CreditRating.B: 0.40,
                    CreditRating.C: 0.20
                }.get(customer.credit_rating, 0.50)
                
                # åŸºäºé¢„æµ‹æ¦‚ç‡å’Œé€¾æœŸæƒ…å†µè®¡ç®—é¢„æœŸæ”¶æ¬¾æ—¥æœŸ
                expected_days = max(0, invoice.days_outstanding + 
                                   customer.payment_terms_days * (1 - payment_probability))
                
                forecast_date = date.today() + timedelta(days=int(expected_days))
                forecast[forecast_date] += invoice.outstanding_amount * Decimal(str(payment_probability))
        
        return {k.isoformat(): float(v) for k, v in sorted(forecast.items())[:days]}
    
    def get_statistics(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total_invoices = len(self.invoices)
        total_amount = sum(inv.total_amount for inv in self.invoices.values())
        total_outstanding = sum(inv.outstanding_amount for inv in self.invoices.values())
        overdue_amount = sum(inv.outstanding_amount for inv in self.invoices.values() if inv.is_overdue)
        
        return {
            'total_customers': len(self.customers),
            'total_invoices': total_invoices,
            'total_invoice_amount': float(total_amount),
            'total_outstanding': float(total_outstanding),
            'overdue_amount': float(overdue_amount),
            'overdue_percentage': float(overdue_amount / total_outstanding * 100) if total_outstanding > 0 else 0,
            'bad_debt_provision': float(self.calculate_bad_debt_provision()),
            'average_days_sales_outstanding': self._calculate_dso()
        }
    
    def _calculate_dso(self) -> float:
        """è®¡ç®—DSOï¼ˆåº”æ”¶è´¦æ¬¾å‘¨è½¬å¤©æ•°ï¼‰"""
        # ç®€åŒ–è®¡ç®—ï¼šæœªæ¸…ä½™é¢ / æ—¥å‡é”€å”®é¢
        total_outstanding = sum(inv.outstanding_amount for inv in self.invoices.values())
        
        # è®¡ç®—è¿‡å»90å¤©çš„æ—¥å‡é”€å”®é¢
        ninety_days_ago = date.today() - timedelta(days=90)
        recent_invoices = [inv for inv in self.invoices.values() 
                          if inv.invoice_date >= ninety_days_ago]
        total_recent_sales = sum(inv.total_amount for inv in recent_invoices)
        daily_average = total_recent_sales / 90 if recent_invoices else 1
        
        return float(total_outstanding / daily_average) if daily_average > 0 else 0


# ä½¿ç”¨ç¤ºä¾‹
def main():
    """ä¸»å‡½æ•°"""
    # åˆ›å»ºARç³»ç»Ÿ
    ar_system = AccountsReceivableSystem()
    
    # æ·»åŠ å®¢æˆ·
    customer = CustomerCreditProfile(
        customer_id="CUST001",
        customer_code="ABC001",
        customer_name="ABCå›½é™…è´¸æ˜“å…¬å¸",
        credit_limit=Decimal('5000000.00'),
        payment_terms_days=60,
        annual_revenue=Decimal('50000000.00'),
        years_in_business=10,
        historical_payment_score=85
    )
    customer.update_credit_rating()
    ar_system.add_customer(customer)
    
    print(f"å®¢æˆ·ä¿¡ç”¨è¯„åˆ†: {customer.calculate_credit_score()}")
    print(f"å®¢æˆ·ä¿¡ç”¨ç­‰çº§: {customer.credit_rating.value}")
    
    # åˆ›å»ºå‘ç¥¨
    invoice = SalesInvoice(
        invoice_id="INV001",
        invoice_number="",
        invoice_date=date(2025, 1, 15),
        customer_id="CUST001",
        customer_name="ABCå›½é™…è´¸æ˜“å…¬å¸",
        due_date=date(2025, 3, 16),  # 60å¤©è´¦æœŸ
        invoice_amount=Decimal('100000.00'),
        tax_amount=Decimal('13000.00'),
        payment_terms_days=60
    )
    
    success, result = ar_system.create_invoice(invoice)
    print(f"åˆ›å»ºå‘ç¥¨: {success}, {result}")
    
    # è®°å½•æ”¶æ¬¾
    receipt = Receipt(
        receipt_id="REC001",
        receipt_number="R202501001",
        receipt_date=date(2025, 3, 10),
        customer_id="CUST001",
        customer_name="ABCå›½é™…è´¸æ˜“å…¬å¸",
        receipt_amount=Decimal('50000.00')
    )
    ar_system.record_receipt(receipt)
    
    # åº”ç”¨æ”¶æ¬¾åˆ°å‘ç¥¨
    success, msg = ar_system.apply_receipt_to_invoice("REC001", "INV001", Decimal('50000.00'))
    print(f"åº”ç”¨æ”¶æ¬¾: {success}, {msg}")
    
    # è·å–è´¦é¾„æŠ¥å‘Š
    aging_report = ar_system.get_aging_report()
    print("\nè´¦é¾„æŠ¥å‘Š:")
    print(json.dumps(aging_report, indent=2, ensure_ascii=False))
    
    # è®¡ç®—åè´¦å‡†å¤‡
    provision = ar_system.calculate_bad_debt_provision()
    print(f"\nåè´¦å‡†å¤‡: {provision}")
    
    # æ”¶æ¬¾é¢„æµ‹
    forecast = ar_system.get_collection_forecast(30)
    print("\næ”¶æ¬¾é¢„æµ‹:")
    print(json.dumps(forecast, indent=2, ensure_ascii=False))
    
    # ç»Ÿè®¡ä¿¡æ¯
    stats = ar_system.get_statistics()
    print("\nç»Ÿè®¡ä¿¡æ¯:")
    print(json.dumps(stats, indent=2, ensure_ascii=False))


if __name__ == '__main__':
    main()
```

### 2.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| åè´¦ç‡ | 2.5% | 0.7% | 72% |
| DSOï¼ˆåº”æ”¶è´¦æ¬¾å‘¨è½¬å¤©æ•°ï¼‰ | 78å¤© | 52å¤© | 33% |
| å‘ç¥¨ä¸¢å¤±ç‡ | 1% | 0.005% | 99.5% |
| å¯¹è´¦æ•ˆç‡ | 15å¤©/æœˆ | 2å¤©/æœˆ | 87% |
| è¶…æœŸåº”æ”¶å æ¯” | 35% | 12% | 66% |

**ROIåˆ†æ**ï¼š

- **æŠ•å…¥æˆæœ¬**ï¼šç³»ç»Ÿå¼€å‘åŠå®æ–½è´¹ç”¨ 500ä¸‡å…ƒ
- **å¹´åº¦æ”¶ç›Š**ï¼š
  - åè´¦å‡å°‘ï¼šå¹´å‡å°‘åè´¦æŸå¤± 1.36äº¿å…ƒï¼ˆä»2äº¿é™è‡³6400ä¸‡ï¼‰
  - èµ„é‡‘æˆæœ¬èŠ‚çº¦ï¼šDSOé™ä½26å¤©ï¼Œé‡Šæ”¾èµ„é‡‘çº¦ 8.5äº¿å…ƒï¼ŒæŒ‰5%èµ„é‡‘æˆæœ¬è®¡ç®—ï¼Œå¹´èŠ‚çº¦ 4250ä¸‡å…ƒ
  - äººå·¥æˆæœ¬èŠ‚çº¦ï¼šå¹´èŠ‚çº¦ 300ä¸‡å…ƒ
- **å¹´åº¦ROI**ï¼šï¼ˆ18150 - 500ï¼‰/ 500 = 3530%
- **æŠ•èµ„å›æ”¶æœŸ**ï¼šçº¦ 0.4ä¸ªæœˆï¼ˆçº¦12å¤©ï¼‰

---

## 3. æ¡ˆä¾‹2ï¼šåˆ¶é€ ä¸šåº”ä»˜è´¦æ¬¾ä¸ä¾›åº”é“¾é‡‘èç³»ç»Ÿ

### 3.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
å®å›¾æ±½è½¦åˆ¶é€ é›†å›¢æ˜¯å›½å†…é¢†å…ˆçš„æ±½è½¦åˆ¶é€ ä¼ä¸šï¼Œå¹´é‡‡è´­é¢è¶…è¿‡300äº¿å…ƒï¼Œæ‹¥æœ‰è¶…è¿‡2000å®¶ä¾›åº”å•†ã€‚é›†å›¢éœ€è¦ä¼˜åŒ–åº”ä»˜è´¦æ¬¾ç®¡ç†ï¼ŒåŒæ—¶é€šè¿‡ä¾›åº”é“¾é‡‘èå¸®åŠ©ä¾›åº”å•†è§£å†³èèµ„é—®é¢˜ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **ä»˜æ¬¾æ’ç¨‹æ··ä¹±**ï¼šç¼ºä¹ç§‘å­¦çš„ä»˜æ¬¾æ’ç¨‹ï¼Œç»å¸¸å‡ºç°èµ„é‡‘é—²ç½®æˆ–ç´§æ€¥èèµ„çš„æƒ…å†µï¼Œèµ„é‡‘æˆæœ¬å±…é«˜ä¸ä¸‹
2. **ä¾›åº”å•†å¯¹è´¦å›°éš¾**ï¼šä¾›åº”å•†æ•°é‡å¤šï¼Œå¯¹è´¦å·¥ä½œé‡å¤§ï¼Œäº‰è®®å¤„ç†å‘¨æœŸé•¿ï¼Œå½±å“ä¾›åº”å•†å…³ç³»
3. **æ—©æœŸä»˜æ¬¾æŠ˜æ‰£æŸå¤±**ï¼šç”±äºç¼ºä¹æ—©æœŸä»˜æ¬¾æé†’æœºåˆ¶ï¼Œå¹´æŸå¤±ç°é‡‘æŠ˜æ‰£è¶…è¿‡5000ä¸‡å…ƒ
4. **ä¾›åº”å•†èèµ„éš¾**ï¼šä¸­å°ä¾›åº”å•†èèµ„å›°éš¾ï¼Œå½±å“ä¾›åº”é“¾ç¨³å®šæ€§ï¼Œéƒ¨åˆ†å…³é”®ä¾›åº”å•†å› èµ„é‡‘é“¾æ–­è£‚é€€å‡º
5. **åˆè§„é£é™©é«˜**ï¼šä»˜æ¬¾å®¡æ‰¹æµç¨‹ä¸è§„èŒƒï¼Œå­˜åœ¨é‡å¤ä»˜æ¬¾ã€è¶…é¢ä»˜æ¬¾ç­‰é£é™©ï¼Œå†…å®¡å‘ç°é—®é¢˜å¹´å‡30èµ·

**ä¸šåŠ¡ç›®æ ‡**ï¼š

1. **ä¼˜åŒ–ä»˜æ¬¾æ’ç¨‹**ï¼šå»ºç«‹æ™ºèƒ½ä»˜æ¬¾æ’ç¨‹ç³»ç»Ÿï¼Œèµ„é‡‘æˆæœ¬é™ä½15%ä»¥ä¸Š
2. **è‡ªåŠ¨å¯¹è´¦ç»“ç®—**ï¼šå®ç°ä¾›åº”å•†è‡ªåŠ¨å¯¹è´¦ï¼Œå¯¹è´¦å‘¨æœŸç¼©çŸ­è‡³3å¤©å†…
3. **æ•æ‰æŠ˜æ‰£æœºä¼š**ï¼šå»ºç«‹æŠ˜æ‰£ç®¡ç†ç³»ç»Ÿï¼Œå¹´èŠ‚çœç°é‡‘æŠ˜æ‰£3000ä¸‡å…ƒä»¥ä¸Š
4. **ä¾›åº”é“¾é‡‘èå¹³å°**ï¼šæ­å»ºä¾›åº”é“¾é‡‘èå¹³å°ï¼Œå¸®åŠ©ä¾›åº”å•†èèµ„ï¼Œå¹³å°å¹´èèµ„é¢è¾¾åˆ°50äº¿å…ƒ
5. **å¼ºåŒ–å†…æ§åˆè§„**ï¼šå®ç°ä»˜æ¬¾å…¨æµç¨‹ç”µå­åŒ–å®¡æ‰¹ï¼Œåˆè§„é£é™©äº‹ä»¶é™ä½90%

### 3.2 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤æ‚ä»˜æ¬¾æ¡ä»¶å¤„ç†**ï¼šéœ€è¦å¤„ç†å¤šç§ä»˜æ¬¾æ¡ä»¶ï¼ˆè´¦æœŸã€æŠ˜æ‰£ã€é‡Œç¨‹ç¢‘ä»˜æ¬¾ç­‰ï¼‰
2. **ä¾›åº”å•†æ•°æ®æ•´åˆ**ï¼šéœ€è¦æ•´åˆERPã€SRMã€åˆåŒç³»ç»Ÿç­‰å¤šç³»ç»Ÿä¾›åº”å•†æ•°æ®
3. **èµ„é‡‘æµä¼˜åŒ–ç®—æ³•**ï¼šéœ€è¦å¼€å‘è€ƒè™‘æŠ˜æ‰£ã€èµ„é‡‘æˆæœ¬ã€ä¾›åº”å•†å…³ç³»çš„ä»˜æ¬¾ä¼˜åŒ–ç®—æ³•
4. **ä¾›åº”é“¾é‡‘èé£æ§**ï¼šéœ€è¦å»ºç«‹ä¾›åº”å•†ä¿¡ç”¨è¯„ä¼°å’Œä¾›åº”é“¾é‡‘èé£æ§æ¨¡å‹
5. **é«˜å¹¶å‘å¤„ç†**ï¼šæœˆæœ«ä»˜æ¬¾é«˜å³°æœŸéœ€è¦å¤„ç†å¤§é‡ä»˜æ¬¾ç”³è¯·

### 3.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨Schemaå®šä¹‰åº”ä»˜è´¦æ¬¾ä¸ä¾›åº”é“¾é‡‘èç³»ç»Ÿ**ï¼Œå®ç°æ™ºèƒ½ä»˜æ¬¾æ’ç¨‹ã€è‡ªåŠ¨å¯¹è´¦ã€ä¾›åº”é“¾é‡‘èä¸€ä½“åŒ–ç®¡ç†ã€‚

### 3.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
åˆ¶é€ ä¸šåº”ä»˜è´¦æ¬¾ä¸ä¾›åº”é“¾é‡‘èç³»ç»Ÿ
æ”¯æŒï¼šä¾›åº”å•†ç®¡ç†ã€ä»˜æ¬¾æ’ç¨‹ã€è‡ªåŠ¨å¯¹è´¦ã€ä¾›åº”é“¾é‡‘è
"""

from typing import Dict, List, Optional, Tuple
from datetime import date, datetime, timedelta
from decimal import Decimal
from dataclasses import dataclass, field
from enum import Enum
import json
import heapq


class PaymentTermType(str, Enum):
    """ä»˜æ¬¾æ¡ä»¶ç±»å‹"""
    NET = "Net"              # çº¯è´¦æœŸ
    DISCOUNT = "Discount"    # æŠ˜æ‰£
    MILESTONE = "Milestone"  # é‡Œç¨‹ç¢‘
    INSTALLMENT = "Installment"  # åˆ†æœŸ


class PaymentStatus(str, Enum):
    """ä»˜æ¬¾çŠ¶æ€"""
    PENDING = "Pending"
    SCHEDULED = "Scheduled"
    APPROVED = "Approved"
    PAID = "Paid"
    CANCELLED = "Cancelled"


@dataclass
class PaymentTerms:
    """ä»˜æ¬¾æ¡ä»¶"""
    term_id: str
    term_name: str
    term_type: PaymentTermType
    net_days: int
    discount_days: Optional[int] = None
    discount_percent: Optional[Decimal] = None
    description: Optional[str] = None
    
    def calculate_discount_amount(self, invoice_amount: Decimal, 
                                  payment_date: date, 
                                  invoice_date: date) -> Decimal:
        """è®¡ç®—æŠ˜æ‰£é‡‘é¢"""
        if self.term_type != PaymentTermType.DISCOUNT or not self.discount_days:
            return Decimal('0')
        
        days_elapsed = (payment_date - invoice_date).days
        if days_elapsed <= self.discount_days and self.discount_percent:
            return (invoice_amount * self.discount_percent / 100).quantize(Decimal('0.01'))
        
        return Decimal('0')


@dataclass
class Supplier:
    """ä¾›åº”å•†"""
    supplier_id: str
    supplier_code: str
    supplier_name: str
    payment_terms: PaymentTerms
    bank_account: Optional[str] = None
    bank_name: Optional[str] = None
    credit_rating: str = "B"
    annual_spend: Decimal = Decimal('0')
    on_time_delivery_rate: Decimal = Decimal('0')
    quality_score: Decimal = Decimal('0')
    is_strategic: bool = False
    is_active: bool = True
    
    def calculate_supplier_score(self) -> int:
        """è®¡ç®—ä¾›åº”å•†è¯„åˆ†"""
        # ç»¼åˆè¯„åˆ†ï¼šäº¤è´§åŠæ—¶ç‡40% + è´¨é‡è¯„åˆ†40% + ä¿¡ç”¨è¯„çº§20%
        rating_score = {'A': 100, 'B': 80, 'C': 60, 'D': 40}.get(self.credit_rating, 50)
        score = (
            self.on_time_delivery_rate * Decimal('0.4') +
            self.quality_score * Decimal('0.4') +
            Decimal(rating_score) * Decimal('0.2')
        )
        return int(score)


@dataclass
class PurchaseInvoice:
    """é‡‡è´­å‘ç¥¨"""
    invoice_id: str
    invoice_number: str
    invoice_date: date
    supplier_id: str
    supplier_name: str
    po_number: Optional[str] = None
    invoice_amount: Decimal = Decimal('0')
    tax_amount: Decimal = Decimal('0')
    total_amount: Decimal = Decimal('0')
    currency: str = "CNY"
    due_date: Optional[date] = None
    payment_terms: Optional[PaymentTerms] = None
    status: str = "Pending"
    paid_amount: Decimal = Decimal('0')
    outstanding_amount: Decimal = Decimal('0')
    is_matched: bool = False  # æ˜¯å¦å·²åŒ¹é…æ”¶è´§å•
    
    def __post_init__(self):
        if self.total_amount == Decimal('0'):
            self.total_amount = self.invoice_amount + self.tax_amount
        if self.outstanding_amount == Decimal('0'):
            self.outstanding_amount = self.total_amount
        if self.due_date is None and self.payment_terms:
            self.due_date = self.invoice_date + timedelta(days=self.payment_terms.net_days)
    
    @property
    def days_to_due(self) -> int:
        """è·åˆ°æœŸæ—¥å¤©æ•°"""
        if self.due_date:
            return (self.due_date - date.today()).days
        return 0
    
    def get_discount_opportunity(self) -> Tuple[Optional[Decimal], Optional[date]]:
        """è·å–æŠ˜æ‰£æœºä¼š"""
        if not self.payment_terms or self.payment_terms.term_type != PaymentTermType.DISCOUNT:
            return None, None
        
        discount_deadline = self.invoice_date + timedelta(days=self.payment_terms.discount_days or 0)
        if date.today() <= discount_deadline:
            discount_amount = self.payment_terms.calculate_discount_amount(
                self.total_amount, date.today(), self.invoice_date
            )
            return discount_amount, discount_deadline
        
        return None, None


@dataclass
class PaymentSchedule:
    """ä»˜æ¬¾è®¡åˆ’"""
    schedule_id: str
    invoice_id: str
    supplier_id: str
    scheduled_date: date
    scheduled_amount: Decimal
    priority: int  # ä¼˜å…ˆçº§æ•°å­—è¶Šå°è¶Šä¼˜å…ˆ
    discount_amount: Decimal = Decimal('0')
    status: str = "Scheduled"
    
    def __lt__(self, other):
        return self.priority < other.priority


class AccountsPayableSystem:
    """åº”ä»˜è´¦æ¬¾ç®¡ç†ç³»ç»Ÿ"""
    
    def __init__(self, daily_payment_limit: Decimal = Decimal('10000000')):
        self.suppliers: Dict[str, Supplier] = {}
        self.invoices: Dict[str, PurchaseInvoice] = {}
        self.schedules: List[PaymentSchedule] = []
        self.daily_payment_limit = daily_payment_limit
    
    def add_supplier(self, supplier: Supplier) -> None:
        """æ·»åŠ ä¾›åº”å•†"""
        self.suppliers[supplier.supplier_id] = supplier
    
    def add_invoice(self, invoice: PurchaseInvoice) -> None:
        """æ·»åŠ å‘ç¥¨"""
        self.invoices[invoice.invoice_id] = invoice
    
    def match_invoice_with_gr(self, invoice_id: str, 
                              gr_amount: Decimal,
                              tolerance: Decimal = Decimal('0.05')) -> bool:
        """åŒ¹é…å‘ç¥¨ä¸æ”¶è´§å•"""
        if invoice_id not in self.invoices:
            return False
        
        invoice = self.invoices[invoice_id]
        
        # æ£€æŸ¥é‡‘é¢åŒ¹é…ï¼ˆå…è®¸5%å®¹å·®ï¼‰
        if abs(invoice.invoice_amount - gr_amount) / invoice.invoice_amount <= tolerance:
            invoice.is_matched = True
            return True
        
        return False
    
    def optimize_payment_schedule(self, start_date: date, 
                                   end_date: date,
                                   available_funds: Decimal) -> List[PaymentSchedule]:
        """ä¼˜åŒ–ä»˜æ¬¾æ’ç¨‹"""
        schedules = []
        current_date = start_date
        remaining_funds = available_funds
        
        # æ”¶é›†æ‰€æœ‰å¾…ä»˜æ¬¾å‘ç¥¨
        pending_invoices = [
            inv for inv in self.invoices.values()
            if inv.outstanding_amount > Decimal('0') and inv.is_matched
        ]
        
        # æŒ‰ä¼˜å…ˆçº§æ’åºï¼šæŠ˜æ‰£æœºä¼š > æˆ˜ç•¥ä¾›åº”å•† > åˆ°æœŸæ—¥
        prioritized_invoices = []
        for invoice in pending_invoices:
            discount, deadline = invoice.get_discount_opportunity()
            supplier = self.suppliers.get(invoice.supplier_id)
            
            # è®¡ç®—ä¼˜å…ˆçº§å¾—åˆ†
            priority = 1000
            
            # æœ‰æŠ˜æ‰£æœºä¼šçš„å‘ç¥¨ä¼˜å…ˆçº§æœ€é«˜
            if discount and discount > Decimal('0'):
                priority = 100 - int(discount / invoice.total_amount * 1000)
            
            # æˆ˜ç•¥ä¾›åº”å•†ä¼˜å…ˆçº§è¾ƒé«˜
            elif supplier and supplier.is_strategic:
                priority = 200
            
            # åˆ°æœŸæ—¥è¶Šæ—©ä¼˜å…ˆçº§è¶Šé«˜
            else:
                days_to_due = invoice.days_to_due
                if days_to_due <= 0:
                    priority = 300
                else:
                    priority = 300 + days_to_due
            
            prioritized_invoices.append((priority, invoice, discount))
        
        # æŒ‰ä¼˜å…ˆçº§æ’åº
        prioritized_invoices.sort(key=lambda x: x[0])
        
        # ç”Ÿæˆä»˜æ¬¾è®¡åˆ’
        schedule_counter = 1
        for priority, invoice, discount in prioritized_invoices:
            if remaining_funds <= Decimal('0'):
                break
            
            payment_amount = min(invoice.outstanding_amount, remaining_funds)
            
            # ç¡®å®šä»˜æ¬¾æ—¥æœŸ
            if discount:
                # å¦‚æœæœ‰æŠ˜æ‰£ï¼Œå°½æ—©ä»˜æ¬¾
                payment_date = max(date.today(), invoice.invoice_date + timedelta(days=1))
            else:
                # å¦åˆ™æŒ‰åˆ°æœŸæ—¥ä»˜æ¬¾
                payment_date = invoice.due_date or current_date
            
            if start_date <= payment_date <= end_date:
                schedule = PaymentSchedule(
                    schedule_id=f"SCH{schedule_counter:06d}",
                    invoice_id=invoice.invoice_id,
                    supplier_id=invoice.supplier_id,
                    scheduled_date=payment_date,
                    scheduled_amount=payment_amount,
                    priority=priority,
                    discount_amount=discount or Decimal('0')
                )
                schedules.append(schedule)
                remaining_funds -= payment_amount
                schedule_counter += 1
        
        return schedules
    
    def analyze_discount_opportunities(self) -> Dict:
        """åˆ†ææŠ˜æ‰£æœºä¼š"""
        opportunities = []
        total_potential_savings = Decimal('0')
        
        for invoice in self.invoices.values():
            if invoice.outstanding_amount <= Decimal('0'):
                continue
            
            discount, deadline = invoice.get_discount_opportunity()
            if discount and discount > Decimal('0'):
                opportunities.append({
                    'invoice_id': invoice.invoice_id,
                    'invoice_number': invoice.invoice_number,
                    'supplier': invoice.supplier_name,
                    'amount': float(invoice.total_amount),
                    'discount_amount': float(discount),
                    'discount_percent': float(discount / invoice.total_amount * 100),
                    'deadline': deadline.isoformat() if deadline else None,
                    'days_left': (deadline - date.today()).days if deadline else 0
                })
                total_potential_savings += discount
        
        return {
            'total_opportunities': len(opportunities),
            'total_potential_savings': float(total_potential_savings),
            'opportunities': sorted(opportunities, key=lambda x: x['days_left'])
        }
    
    def get_ap_aging_report(self) -> Dict:
        """è·å–åº”ä»˜è´¦æ¬¾è´¦é¾„æŠ¥å‘Š"""
        buckets = {
            'Current': Decimal('0'),
            '1-30 Days': Decimal('0'),
            '31-60 Days': Decimal('0'),
            '61-90 Days': Decimal('0'),
            'Over 90 Days': Decimal('0')
        }
        
        total_outstanding = Decimal('0')
        
        for invoice in self.invoices.values():
            if invoice.outstanding_amount <= Decimal('0'):
                continue
            
            days_to_due = invoice.days_to_due
            
            if days_to_due >= 0:
                bucket = 'Current'
            elif days_to_due >= -30:
                bucket = '1-30 Days'
            elif days_to_due >= -60:
                bucket = '31-60 Days'
            elif days_to_due >= -90:
                bucket = '61-90 Days'
            else:
                bucket = 'Over 90 Days'
            
            buckets[bucket] += invoice.outstanding_amount
            total_outstanding += invoice.outstanding_amount
        
        return {
            'report_date': date.today().isoformat(),
            'total_outstanding': float(total_outstanding),
            'aging_buckets': {k: float(v) for k, v in buckets.items()},
            'percentages': {
                k: float(v / total_outstanding * 100) if total_outstanding > 0 else 0
                for k, v in buckets.items()
            }
        }
    
    def get_supplier_performance(self) -> List[Dict]:
        """è·å–ä¾›åº”å•†ç»©æ•ˆ"""
        performance = []
        
        for supplier in self.suppliers.values():
            # è®¡ç®—è¯¥ä¾›åº”å•†çš„å‘ç¥¨ç»Ÿè®¡
            supplier_invoices = [
                inv for inv in self.invoices.values()
                if inv.supplier_id == supplier.supplier_id
            ]
            
            total_invoices = len(supplier_invoices)
            total_amount = sum(inv.total_amount for inv in supplier_invoices)
            outstanding = sum(inv.outstanding_amount for inv in supplier_invoices)
            overdue = sum(inv.outstanding_amount for inv in supplier_invoices if inv.days_to_due < 0)
            
            performance.append({
                'supplier_id': supplier.supplier_id,
                'supplier_name': supplier.supplier_name,
                'supplier_score': supplier.calculate_supplier_score(),
                'is_strategic': supplier.is_strategic,
                'total_invoices': total_invoices,
                'total_amount': float(total_amount),
                'outstanding': float(outstanding),
                'overdue': float(overdue),
                'annual_spend': float(supplier.annual_spend)
            })
        
        return sorted(performance, key=lambda x: x['supplier_score'], reverse=True)


# ä¾›åº”é“¾é‡‘èæ¨¡å—
@dataclass
class SupplyChainFinance:
    """ä¾›åº”é“¾é‡‘è"""
    finance_id: str
    supplier_id: str
    invoice_id: str
    finance_amount: Decimal
    finance_rate: Decimal  # å¹´åŒ–åˆ©ç‡
    finance_term_days: int
    request_date: date
    status: str = "Pending"  # Pending, Approved, Funded, Repaid
    
    def calculate_finance_cost(self) -> Decimal:
        """è®¡ç®—èèµ„æˆæœ¬"""
        return (self.finance_amount * 
                self.finance_rate / 100 * 
                self.finance_term_days / 365).quantize(Decimal('0.01'))


class SupplyChainFinancePlatform:
    """ä¾›åº”é“¾é‡‘èå¹³å°"""
    
    def __init__(self):
        self.financings: Dict[str, SupplyChainFinance] = {}
        self.approved_suppliers: List[str] = []
    
    def approve_supplier(self, supplier_id: str) -> bool:
        """æ‰¹å‡†ä¾›åº”å•†å‚ä¸ä¾›åº”é“¾é‡‘è"""
        self.approved_suppliers.append(supplier_id)
        return True
    
    def request_financing(self, supplier_id: str, 
                         invoice_id: str,
                         invoice_amount: Decimal,
                         rate: Decimal = Decimal('6.0'),
                         term_days: int = 90) -> Tuple[bool, str]:
        """ç”³è¯·èèµ„"""
        if supplier_id not in self.approved_suppliers:
            return False, "ä¾›åº”å•†æœªè·æ‰¹å‡†"
        
        finance = SupplyChainFinance(
            finance_id=f"SCF{len(self.financings)+1:06d}",
            supplier_id=supplier_id,
            invoice_id=invoice_id,
            finance_amount=invoice_amount * Decimal('0.8'),  # 80%èèµ„
            finance_rate=rate,
            finance_term_days=term_days,
            request_date=date.today()
        )
        
        self.financings[finance.finance_id] = finance
        
        return True, finance.finance_id
    
    def get_platform_statistics(self) -> Dict:
        """è·å–å¹³å°ç»Ÿè®¡"""
        total_financing = sum(f.finance_amount for f in self.financings.values())
        total_cost = sum(f.calculate_finance_cost() for f in self.financings.values())
        
        return {
            'approved_suppliers': len(self.approved_suppliers),
            'total_financings': len(self.financings),
            'total_financing_amount': float(total_financing),
            'total_financing_cost': float(total_cost),
            'average_rate': float(sum(f.finance_rate for f in self.financings.values()) / len(self.financings)) if self.financings else 0
        }


# ä½¿ç”¨ç¤ºä¾‹
def demo_ap_system():
    """åº”ä»˜è´¦æ¬¾ç³»ç»Ÿæ¼”ç¤º"""
    # åˆ›å»ºAPç³»ç»Ÿ
    ap_system = AccountsPayableSystem(daily_payment_limit=Decimal('5000000'))
    
    # æ·»åŠ ä¾›åº”å•†
    payment_terms = PaymentTerms(
        term_id="PT001",
        term_name="2/10 Net 30",
        term_type=PaymentTermType.DISCOUNT,
        net_days=30,
        discount_days=10,
        discount_percent=Decimal('2.0')
    )
    
    supplier = Supplier(
        supplier_id="SUP001",
        supplier_code="XYZ001",
        supplier_name="XYZé›¶éƒ¨ä»¶æœ‰é™å…¬å¸",
        payment_terms=payment_terms,
        is_strategic=True,
        annual_spend=Decimal('50000000'),
        on_time_delivery_rate=Decimal('95'),
        quality_score=Decimal('90')
    )
    ap_system.add_supplier(supplier)
    
    # æ·»åŠ å‘ç¥¨
    invoice = PurchaseInvoice(
        invoice_id="PINV001",
        invoice_number="INV-2025-001",
        invoice_date=date(2025, 1, 10),
        supplier_id="SUP001",
        supplier_name="XYZé›¶éƒ¨ä»¶æœ‰é™å…¬å¸",
        po_number="PO-2025-001",
        invoice_amount=Decimal('100000.00'),
        tax_amount=Decimal('13000.00'),
        payment_terms=payment_terms
    )
    ap_system.add_invoice(invoice)
    
    # åŒ¹é…æ”¶è´§å•
    matched = ap_system.match_invoice_with_gr("PINV001", Decimal('100000.00'))
    print(f"å‘ç¥¨åŒ¹é…: {matched}")
    
    # åˆ†ææŠ˜æ‰£æœºä¼š
    discount_analysis = ap_system.analyze_discount_opportunities()
    print("\næŠ˜æ‰£æœºä¼šåˆ†æ:")
    print(json.dumps(discount_analysis, indent=2, ensure_ascii=False))
    
    # ä¼˜åŒ–ä»˜æ¬¾æ’ç¨‹
    schedules = ap_system.optimize_payment_schedule(
        date(2025, 1, 15),
        date(2025, 2, 15),
        Decimal('1000000')
    )
    print(f"\nç”Ÿæˆäº† {len(schedules)} ä¸ªä»˜æ¬¾è®¡åˆ’")
    
    # è´¦é¾„æŠ¥å‘Š
    aging = ap_system.get_ap_aging_report()
    print("\nåº”ä»˜è´¦æ¬¾è´¦é¾„:")
    print(json.dumps(aging, indent=2, ensure_ascii=False))
    
    # ä¾›åº”é“¾é‡‘è
    scf_platform = SupplyChainFinancePlatform()
    scf_platform.approve_supplier("SUP001")
    
    success, finance_id = scf_platform.request_financing(
        "SUP001", "PINV001", Decimal('113000.00')
    )
    print(f"\nèèµ„ç”³è¯·: {success}, {finance_id}")
    
    scf_stats = scf_platform.get_platform_statistics()
    print("\nä¾›åº”é“¾é‡‘èå¹³å°ç»Ÿè®¡:")
    print(json.dumps(scf_stats, indent=2, ensure_ascii=False))


if __name__ == '__main__':
    demo_ap_system()
```

### 3.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| èµ„é‡‘æˆæœ¬ | 5.5% | 4.5% | 18% |
| å¯¹è´¦å‘¨æœŸ | 15å¤© | 2å¤© | 87% |
| ç°é‡‘æŠ˜æ‰£æŸå¤± | 5000ä¸‡/å¹´ | 1500ä¸‡/å¹´ | 70% |
| åˆè§„é£é™©äº‹ä»¶ | 30èµ·/å¹´ | 2èµ·/å¹´ | 93% |
| ä¾›åº”å•†èèµ„è¦†ç›–ç‡ | 0% | 65% | - |

**ROIåˆ†æ**ï¼š

- **æŠ•å…¥æˆæœ¬**ï¼šç³»ç»Ÿå¼€å‘åŠå®æ–½è´¹ç”¨ 800ä¸‡å…ƒ
- **å¹´åº¦æ”¶ç›Š**ï¼š
  - èµ„é‡‘æˆæœ¬èŠ‚çº¦ï¼šå¹´èŠ‚çº¦ 3000ä¸‡å…ƒ
  - ç°é‡‘æŠ˜æ‰£èŠ‚çœï¼šå¹´èŠ‚çœ 3500ä¸‡å…ƒ
  - ä¾›åº”é“¾é‡‘èæ”¶ç›Šï¼šå¹³å°æœåŠ¡è´¹æ”¶å…¥å¹´ 2000ä¸‡å…ƒ
  - åˆè§„é£é™©é™ä½ï¼šé¿å…æ½œåœ¨æŸå¤±çº¦ 1000ä¸‡å…ƒ
- **å¹´åº¦ROI**ï¼šï¼ˆ9500 - 800ï¼‰/ 800 = 1087.5%
- **æŠ•èµ„å›æ”¶æœŸ**ï¼šçº¦ 1ä¸ªæœˆ

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

# Matter Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [Matter Schemaå®è·µæ¡ˆä¾‹](#matter-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šMatter On/Off Lightæ§åˆ¶](#2-æ¡ˆä¾‹1matter-onoff-lightæ§åˆ¶)
    - [2.1 åœºæ™¯æè¿°](#21-åœºæ™¯æè¿°)
    - [2.2 Schemaå®šä¹‰](#22-schemaå®šä¹‰)
    - [2.3 å®ç°ä»£ç ](#23-å®ç°ä»£ç )
  - [3. æ¡ˆä¾‹2ï¼šMatter Door Lockæ§åˆ¶](#3-æ¡ˆä¾‹2matter-door-lockæ§åˆ¶)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 Schemaå®šä¹‰](#32-schemaå®šä¹‰)
    - [3.3 å®ç°ä»£ç ](#33-å®ç°ä»£ç )
  - [4. æ¡ˆä¾‹3ï¼šMatter Thermostatæ§åˆ¶](#4-æ¡ˆä¾‹3matter-thermostatæ§åˆ¶)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 Schemaå®šä¹‰](#42-schemaå®šä¹‰)
    - [4.3 å®ç°ä»£ç ](#43-å®ç°ä»£ç )
  - [5. æ¡ˆä¾‹4ï¼šMatterè®¾å¤‡å‘ç°å’Œç®¡ç†](#5-æ¡ˆä¾‹4matterè®¾å¤‡å‘ç°å’Œç®¡ç†)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 å®ç°ä»£ç ](#52-å®ç°ä»£ç )
  - [6. æ¡ˆä¾‹5ï¼šMatter Color Lightæ§åˆ¶](#6-æ¡ˆä¾‹5matter-color-lightæ§åˆ¶)
    - [6.1 åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2 å®ç°ä»£ç ](#62-å®ç°ä»£ç )
  - [7. æ¡ˆä¾‹6ï¼šMatteræ•°æ®å­˜å‚¨å’Œåˆ†æ](#7-æ¡ˆä¾‹6matteræ•°æ®å­˜å‚¨å’Œåˆ†æ)
    - [7.1 åœºæ™¯æè¿°](#71-åœºæ™¯æè¿°)
    - [7.2 å®ç°ä»£ç ](#72-å®ç°ä»£ç )
    - [7.3 æ•°æ®åˆ†æç¤ºä¾‹](#73-æ•°æ®åˆ†æç¤ºä¾‹)
  - [8. æ¡ˆä¾‹7ï¼šMatterè®¾å¤‡ç»„æ§åˆ¶](#8-æ¡ˆä¾‹7matterè®¾å¤‡ç»„æ§åˆ¶)
    - [8.1 åœºæ™¯æè¿°](#81-åœºæ™¯æè¿°)
    - [8.2 Schemaå®šä¹‰](#82-schemaå®šä¹‰)
    - [8.3 å®ç°ä»£ç ](#83-å®ç°ä»£ç )
  - [9. æ¡ˆä¾‹8ï¼šMatterè®¾å¤‡å›ºä»¶å‡çº§](#9-æ¡ˆä¾‹8matterè®¾å¤‡å›ºä»¶å‡çº§)
    - [9.1 åœºæ™¯æè¿°](#91-åœºæ™¯æè¿°)
    - [9.2 Schemaå®šä¹‰](#92-schemaå®šä¹‰)
    - [9.3 å®ç°ä»£ç ](#93-å®ç°ä»£ç )
  - [10. æ¡ˆä¾‹9ï¼šMatterå¤šè®¾å¤‡è”åŠ¨](#10-æ¡ˆä¾‹9matterå¤šè®¾å¤‡è”åŠ¨)
    - [10.1 åœºæ™¯æè¿°](#101-åœºæ™¯æè¿°)
    - [10.2 Schemaå®šä¹‰](#102-schemaå®šä¹‰)
    - [10.3 å®ç°ä»£ç ](#103-å®ç°ä»£ç )
  - [11. æ¡ˆä¾‹10ï¼šMatteråœºæ™¯è‡ªåŠ¨åŒ–](#11-æ¡ˆä¾‹10matteråœºæ™¯è‡ªåŠ¨åŒ–)
    - [11.1 åœºæ™¯æè¿°](#111-åœºæ™¯æè¿°)
    - [11.2 Schemaå®šä¹‰](#112-schemaå®šä¹‰)
    - [11.3 å®ç°ä»£ç ](#113-å®ç°ä»£ç )
  - [12. æ¡ˆä¾‹11ï¼šMatterè®¾å¤‡æ•…éšœè¯Šæ–­](#12-æ¡ˆä¾‹11matterè®¾å¤‡æ•…éšœè¯Šæ–­)
    - [12.1 åœºæ™¯æè¿°](#121-åœºæ™¯æè¿°)
    - [12.2 Schemaå®šä¹‰](#122-schemaå®šä¹‰)
    - [12.3 å®ç°ä»£ç ](#123-å®ç°ä»£ç )

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›Matter Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šMatter On/Off Lightæ§åˆ¶

### 2.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶æ™ºèƒ½å¼€å…³ç¯ï¼Œå®ç°è¿œç¨‹å¼€å…³æ§åˆ¶ã€
çŠ¶æ€æŸ¥è¯¢å’Œå®šæ—¶æ§åˆ¶åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å»ºç«‹Matterè®¾å¤‡è¿æ¥
- éœ€è¦å¤„ç†è®¾å¤‡ç¦»çº¿æƒ…å†µ
- éœ€è¦å®ç°çŠ¶æ€åŒæ­¥
- éœ€è¦è®°å½•æ“ä½œå†å²

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterDeviceControllerå°è£…Matter SDKï¼Œå®ç°è®¾å¤‡è¿æ¥ã€
å‘½ä»¤å‘é€å’ŒçŠ¶æ€æŸ¥è¯¢åŠŸèƒ½ã€‚

### 2.2 Schemaå®šä¹‰

**Matter On/Off Light Schema**ï¼š

```json
{
  "device_id": "LIGHT001",
  "device_type": "OnOffLight",
  "endpoint_id": 1,
  "node_id": 0x12344321,
  "clusters": [{
    "cluster_id": 0x0006,
    "cluster_name": "OnOff",
    "attributes": {
      "on_off": false,
      "global_scene_control": true,
      "on_time": 0,
      "off_wait_time": 0,
      "start_up_on_off": "Off"
    },
    "commands": {
      "on": {
        "command_id": 0x00,
        "parameters": {}
      },
      "off": {
        "command_id": 0x01,
        "parameters": {}
      },
      "toggle": {
        "command_id": 0x02,
        "parameters": {}
      }
    }
  }]
}
```

### 2.3 å®ç°ä»£ç 

**å®Œæ•´çš„On/Off Lightæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterOnOffLightController
from matter_storage import MatterStorage
from datetime import datetime

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
light_controller = MatterOnOffLightController("LIGHT001", 0x12344321)

async def control_on_off_light():
    """æ§åˆ¶On/Off Light"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await light_controller.connect()
        if not connected:
            print("Failed to connect to device")
            return

        # æ‰“å¼€ç¯å…‰
        print("Turning on light...")
        result = await light_controller.turn_on()
        if result:
            # è®°å½•å‘½ä»¤
            cmd_id = storage.store_command(
                "LIGHT001", 1, 0x0006, 0x00, "on", {}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Light turned on successfully")
        else:
            storage.update_command_status(cmd_id, "Failed")
            print("Failed to turn on light")

        # è·å–çŠ¶æ€
        state = await light_controller.get_state()
        print(f"Current light state: {state}")

        # ç­‰å¾…3ç§’
        await asyncio.sleep(3)

        # å…³é—­ç¯å…‰
        print("Turning off light...")
        result = await light_controller.turn_off()
        if result:
            cmd_id = storage.store_command(
                "LIGHT001", 1, 0x0006, 0x01, "off", {}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Light turned off successfully")

        # åˆ‡æ¢ç¯å…‰
        print("Toggling light...")
        result = await light_controller.toggle()
        if result:
            cmd_id = storage.store_command(
                "LIGHT001", 1, 0x0006, 0x02, "toggle", {}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Light toggled successfully")

        # æ–­å¼€è¿æ¥
        await light_controller.disconnect()

    except Exception as e:
        print(f"Error controlling light: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_on_off_light())
```

---

## 3. æ¡ˆä¾‹2ï¼šMatter Door Lockæ§åˆ¶

### 3.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶æ™ºèƒ½é—¨é”ï¼Œå®ç°è¿œç¨‹å¼€é”ã€é”å®šã€
çŠ¶æ€æŸ¥è¯¢å’ŒPINç éªŒè¯åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®‰å…¨çš„PINç éªŒè¯
- éœ€è¦å¤„ç†é—¨é”çŠ¶æ€å˜åŒ–äº‹ä»¶
- éœ€è¦è®°å½•å¼€é”å†å²
- éœ€è¦å¤„ç†å¼‚å¸¸æƒ…å†µï¼ˆå¦‚é—¨æœªå…³é—­ï¼‰

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterDoorLockControllerå®ç°é—¨é”æ§åˆ¶ï¼Œé›†æˆPINç éªŒè¯
å’Œäº‹ä»¶ç›‘å¬åŠŸèƒ½ã€‚

### 3.2 Schemaå®šä¹‰

**Matter Door Lock Schema**ï¼š

```json
{
  "device_id": "LOCK001",
  "device_type": "DoorLock",
  "endpoint_id": 1,
  "node_id": 0x12344322,
  "clusters": [{
    "cluster_id": 0x0101,
    "cluster_name": "DoorLock",
    "attributes": {
      "lock_state": 1,
      "lock_type": "DeadBolt",
      "actuator_enabled": true,
      "door_state": "Closed",
      "door_open_events": 0,
      "door_closed_events": 0,
      "open_period": 0
    },
    "commands": {
      "lock_door": {
        "command_id": 0x00,
        "parameters": {
          "pin_code": "1234"
        }
      },
      "unlock_door": {
        "command_id": 0x01,
        "parameters": {
          "pin_code": "1234"
        }
      }
    },
    "events": {
      "door_lock_alarm": {
        "event_id": 0x00,
        "alarm_code": "DoorForcedOpen"
      }
    }
  }]
}
```

### 3.3 å®ç°ä»£ç 

**å®Œæ•´çš„Door Lockæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterDoorLockController
from matter_storage import MatterStorage

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
lock_controller = MatterDoorLockController("LOCK001", 0x12344322)

async def control_door_lock():
    """æ§åˆ¶Door Lock"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await lock_controller.connect()
        if not connected:
            print("Failed to connect to door lock")
            return

        # è·å–å½“å‰é”çŠ¶æ€
        lock_state = await lock_controller.get_lock_state()
        print(f"Current lock state: {lock_state}")

        # å¦‚æœå·²é”å®šï¼Œåˆ™è§£é”
        if lock_state == "Locked":
            print("Unlocking door...")
            pin_code = "1234"  # å®é™…åº”ç”¨ä¸­åº”ä»å®‰å…¨å­˜å‚¨è·å–
            result = await lock_controller.unlock_door(pin_code)

            if result:
                cmd_id = storage.store_command(
                    "LOCK001", 1, 0x0101, 0x01, "unlock_door",
                    {"pin_code": "****"}  # ä¸å­˜å‚¨å®é™…PINç 
                )
                storage.update_command_status(cmd_id, "Success")

                # è®°å½•äº‹ä»¶
                storage.store_event(
                    "LOCK001", 1, 0x0101, 0x01, "DoorUnlocked",
                    {"timestamp": datetime.now().isoformat()}
                )
                print("Door unlocked successfully")
            else:
                print("Failed to unlock door")

        # ç­‰å¾…5ç§’
        await asyncio.sleep(5)

        # é”å®šé—¨
        print("Locking door...")
        result = await lock_controller.lock_door()

        if result:
            cmd_id = storage.store_command(
                "LOCK001", 1, 0x0101, 0x00, "lock_door", {}
            )
            storage.update_command_status(cmd_id, "Success")

            # è®°å½•äº‹ä»¶
            storage.store_event(
                "LOCK001", 1, 0x0101, 0x00, "DoorLocked",
                {"timestamp": datetime.now().isoformat()}
            )
            print("Door locked successfully")

        # å†æ¬¡è·å–çŠ¶æ€ç¡®è®¤
        lock_state = await lock_controller.get_lock_state()
        print(f"Final lock state: {lock_state}")

        # æ–­å¼€è¿æ¥
        await lock_controller.disconnect()

    except Exception as e:
        print(f"Error controlling door lock: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_door_lock())
```

---

## 4. æ¡ˆä¾‹3ï¼šMatter Thermostatæ§åˆ¶

### 4.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶æ™ºèƒ½æ¸©æ§å™¨ï¼Œå®ç°æ¸©åº¦è®¾ç½®ã€
æ¨¡å¼åˆ‡æ¢å’Œæ¸©åº¦ç›‘æ§åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®æ—¶è¯»å–æ¸©åº¦å€¼
- éœ€è¦è®¾ç½®ç›®æ ‡æ¸©åº¦
- éœ€è¦åˆ‡æ¢è¿è¡Œæ¨¡å¼ï¼ˆåˆ¶å†·/åˆ¶çƒ­/è‡ªåŠ¨ï¼‰
- éœ€è¦å¤„ç†æ¸©åº¦èŒƒå›´é™åˆ¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterThermostatControllerå®ç°æ¸©æ§å™¨æ§åˆ¶ï¼Œæ”¯æŒæ¸©åº¦
è¯»å–ã€è®¾ç½®å’Œæ¨¡å¼åˆ‡æ¢åŠŸèƒ½ã€‚

### 4.2 Schemaå®šä¹‰

**Matter Thermostat Schema**ï¼š

è¯¦è§ç¬¬4.2èŠ‚åŸå§‹å®šä¹‰ã€‚

### 4.3 å®ç°ä»£ç 

**å®Œæ•´çš„Thermostatæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterThermostatController
from matter_storage import MatterStorage
from datetime import datetime

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
thermostat_controller = MatterThermostatController("THERMOSTAT001", 0x12344323)

async def control_thermostat():
    """æ§åˆ¶Thermostat"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await thermostat_controller.connect()
        if not connected:
            print("Failed to connect to thermostat")
            return

        # è·å–å½“å‰æ¸©åº¦
        current_temp = await thermostat_controller.get_current_temperature()
        print(f"Current temperature: {current_temp}Â°C")

        # è®¾ç½®ç›®æ ‡æ¸©åº¦ä¸º26Â°Cï¼ˆåˆ¶å†·æ¨¡å¼ï¼‰
        print("Setting target temperature to 26Â°C (Cool mode)...")
        result = await thermostat_controller.set_target_temperature(26.0, "Cool")

        if result:
            # è®¾ç½®ç³»ç»Ÿæ¨¡å¼ä¸ºåˆ¶å†·
            await thermostat_controller.set_system_mode("Cool")

            # è®°å½•å‘½ä»¤
            cmd_id = storage.store_command(
                "THERMOSTAT001", 1, 0x0201, 0x00, "set_target_temperature",
                {"temperature": 26.0, "mode": "Cool"}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Target temperature set successfully")

        # ç­‰å¾…å¹¶å†æ¬¡è¯»å–æ¸©åº¦
        await asyncio.sleep(5)
        current_temp = await thermostat_controller.get_current_temperature()
        print(f"Current temperature after setting: {current_temp}Â°C")

        # åˆ‡æ¢åˆ°è‡ªåŠ¨æ¨¡å¼
        print("Switching to Auto mode...")
        result = await thermostat_controller.set_system_mode("Auto")

        if result:
            cmd_id = storage.store_command(
                "THERMOSTAT001", 1, 0x0201, 0x00, "set_system_mode",
                {"mode": "Auto"}
            )
            storage.update_command_status(cmd_id, "Success")
            print("System mode switched to Auto")

        # æ–­å¼€è¿æ¥
        await thermostat_controller.disconnect()

    except Exception as e:
        print(f"Error controlling thermostat: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_thermostat())
```

---

## 5. æ¡ˆä¾‹4ï¼šMatterè®¾å¤‡å‘ç°å’Œç®¡ç†

### 5.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç³»ç»Ÿéœ€è¦è‡ªåŠ¨å‘ç°ç½‘ç»œä¸­çš„Matterè®¾å¤‡ï¼Œæ³¨å†Œè®¾å¤‡ä¿¡æ¯ï¼Œ
å¹¶å»ºç«‹è®¾å¤‡è¿æ¥æ± è¿›è¡Œç»Ÿä¸€ç®¡ç†ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®ç°è®¾å¤‡å‘ç°åè®®
- éœ€è¦å¤„ç†è®¾å¤‡ä¸Šçº¿/ä¸‹çº¿
- éœ€è¦ç®¡ç†è®¾å¤‡è¿æ¥çŠ¶æ€
- éœ€è¦å­˜å‚¨è®¾å¤‡ä¿¡æ¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterDeviceDiscoveryå’ŒMatterDeviceManagerå®ç°è®¾å¤‡
å‘ç°å’Œç®¡ç†åŠŸèƒ½ã€‚

### 5.2 å®ç°ä»£ç 

**å®Œæ•´çš„è®¾å¤‡å‘ç°å’Œç®¡ç†å®ç°**ï¼š

```python
import asyncio
from matter_device_manager import MatterDeviceManager
from matter_storage import MatterStorage

# åˆå§‹åŒ–å­˜å‚¨å’Œç®¡ç†å™¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")
device_manager = MatterDeviceManager(storage)

async def discover_and_manage_devices():
    """å‘ç°å’Œç®¡ç†è®¾å¤‡"""
    try:
        # å‘ç°è®¾å¤‡
        print("Discovering Matter devices...")
        registered_ids = await device_manager.discover_and_register()
        print(f"Discovered and registered {len(registered_ids)} devices: {registered_ids}")

        # è¿æ¥æ‰€æœ‰è®¾å¤‡
        for device_id in registered_ids:
            print(f"Connecting to device {device_id}...")
            connected = await device_manager.connect_device(device_id)
            if connected:
                print(f"Device {device_id} connected successfully")
            else:
                print(f"Failed to connect to device {device_id}")

        # è·å–è®¾å¤‡æ§åˆ¶å™¨å¹¶æ‰§è¡Œæ“ä½œ
        light_controller = device_manager.get_controller("LIGHT001")
        if light_controller:
            # æ§åˆ¶ç¯å…‰
            await light_controller.turn_on()
            await asyncio.sleep(2)
            await light_controller.turn_off()

        # æ–­å¼€æ‰€æœ‰è®¾å¤‡
        for device_id in registered_ids:
            await device_manager.disconnect_device(device_id)
            print(f"Disconnected from device {device_id}")

    except Exception as e:
        print(f"Error in device discovery and management: {e}")

# è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(discover_and_manage_devices())
```

---

## 6. æ¡ˆä¾‹5ï¼šMatter Color Lightæ§åˆ¶

### 6.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶å½©è‰²æ™ºèƒ½ç¯ï¼Œå®ç°è‰²ç›¸ã€é¥±å’Œåº¦ã€
è‰²æ¸©å’Œäº®åº¦çš„ç²¾ç¡®æ§åˆ¶ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒå¤šç§é¢œè‰²ç©ºé—´ï¼ˆHSVã€RGBã€è‰²æ¸©ï¼‰
- éœ€è¦å®ç°é¢œè‰²è½¬æ¢
- éœ€è¦å¹³æ»‘çš„é¢œè‰²è¿‡æ¸¡
- éœ€è¦ä¿å­˜å’Œæ¢å¤é¢œè‰²åœºæ™¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterColorLightControllerå®ç°å®Œæ•´çš„é¢œè‰²æ§åˆ¶åŠŸèƒ½ã€‚

### 6.2 å®ç°ä»£ç 

**å®Œæ•´çš„Color Lightæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterColorLightController
from matter_storage import MatterStorage

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
color_light_controller = MatterColorLightController("LIGHT003", 0x12344323)

async def control_color_light():
    """æ§åˆ¶Color Light"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await color_light_controller.connect()
        if not connected:
            print("Failed to connect to color light")
            return

        # æ‰“å¼€ç¯å…‰
        await color_light_controller.turn_on()

        # è®¾ç½®äº®åº¦ä¸º50%
        await color_light_controller.set_level(127)  # 127/254 = 50%
        print("Set brightness to 50%")

        # è®¾ç½®è‰²ç›¸å’Œé¥±å’Œåº¦ï¼ˆç»¿è‰²ï¼‰
        await color_light_controller.set_hue_saturation(120, 200)
        print("Set color to green (Hue: 120, Saturation: 200)")

        await asyncio.sleep(3)

        # è®¾ç½®è‰²æ¸©ï¼ˆæš–ç™½å…‰ï¼‰
        await color_light_controller.set_color_temperature(400)
        print("Set color temperature to 400 mireds (warm white)")

        await asyncio.sleep(3)

        # è·å–å½“å‰é¢œè‰²çŠ¶æ€
        hue_sat = await color_light_controller.get_hue_saturation()
        color_temp = await color_light_controller.get_color_temperature()
        level = await color_light_controller.get_level()

        print(f"Current color state:")
        print(f"  Hue: {hue_sat['hue']}, Saturation: {hue_sat['saturation']}")
        print(f"  Color Temperature: {color_temp} mireds")
        print(f"  Level: {level}/254")

        # å…³é—­ç¯å…‰
        await color_light_controller.turn_off()

        # æ–­å¼€è¿æ¥
        await color_light_controller.disconnect()

    except Exception as e:
        print(f"Error controlling color light: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_color_light())
```

---

## 7. æ¡ˆä¾‹6ï¼šMatteræ•°æ®å­˜å‚¨å’Œåˆ†æ

### 7.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
ä½¿ç”¨PostgreSQLå­˜å‚¨Matterè®¾å¤‡æ•°æ®ï¼Œæ”¯æŒè®¾å¤‡çŠ¶æ€æŸ¥è¯¢ã€
å‘½ä»¤æ‰§è¡Œåˆ†æå’Œè®¾å¤‡ä½¿ç”¨ç»Ÿè®¡ã€‚

### 7.2 å®ç°ä»£ç 

è¯¦è§ `04_Transformation.md` ç¬¬6ç« ã€‚

### 7.3 æ•°æ®åˆ†æç¤ºä¾‹

**è®¾å¤‡ä½¿ç”¨ç»Ÿè®¡æŸ¥è¯¢**ï¼š

```python
from matter_storage import MatterStorage
from datetime import datetime, timedelta

storage = MatterStorage("postgresql://user:pass@localhost/matter")

# æŸ¥è¯¢è®¾å¤‡é›†ç¾¤ç»Ÿè®¡
clusters = storage.get_cluster_statistics("LIGHT001")
print("Device clusters:")
for cluster in clusters:
    print(f"  {cluster['cluster_name']}: {cluster['attribute_count']} attributes")

# æŸ¥è¯¢å‘½ä»¤æ‰§è¡Œç»Ÿè®¡
start_time = datetime.now() - timedelta(days=7)
cmd_stats = storage.get_command_statistics(start_time)
print("\nCommand statistics:")
for stat in cmd_stats:
    print(f"  {stat['command_name']}: {stat['count']} executions, "
          f"avg time: {stat['avg_execution_time']:.2f}s")

# æŸ¥è¯¢è®¾å¤‡ä½¿ç”¨ç»Ÿè®¡
usage_stats = storage.get_device_usage_statistics("LIGHT001", days=7)
print("\nDevice usage statistics:")
print(f"  Active days: {usage_stats['active_days']}")
print(f"  Total commands: {usage_stats['total_commands']}")
print(f"  Success rate: {usage_stats['success_commands'] / usage_stats['total_commands'] * 100:.1f}%")
print(f"  Avg response time: {usage_stats['avg_response_time']:.2f}s")
```

---

## 8. æ¡ˆä¾‹7ï¼šMatterè®¾å¤‡ç»„æ§åˆ¶

### 8.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
æ™ºèƒ½å®¶å±…åœºæ™¯ä¸­ï¼Œç”¨æˆ·éœ€è¦åŒæ—¶æ§åˆ¶å¤šä¸ªè®¾å¤‡ï¼Œä¾‹å¦‚ï¼š

- åŒæ—¶æ‰“å¼€/å…³é—­å¤šä¸ªæˆ¿é—´çš„ç¯å…‰
- åŒæ—¶è°ƒæ•´å¤šä¸ªæ¸©æ§å™¨çš„æ¸©åº¦
- åˆ›å»ºåœºæ™¯è”åŠ¨ï¼ˆå¦‚"å›å®¶æ¨¡å¼"ã€"ç¡çœ æ¨¡å¼"ï¼‰

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å°†å¤šä¸ªè®¾å¤‡ç»„ç»‡æˆç»„
- éœ€è¦æ”¯æŒç»„å†…è®¾å¤‡çš„æ‰¹é‡æ§åˆ¶
- éœ€è¦å¤„ç†ç»„å†…è®¾å¤‡çš„éƒ¨åˆ†å¤±è´¥æƒ…å†µ
- éœ€è¦è®°å½•ç»„æ“ä½œçš„æ‰§è¡Œå†å²

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matterè®¾å¤‡ç»„åŠŸèƒ½ï¼Œå°†å¤šä¸ªè®¾å¤‡ç»„ç»‡æˆé€»è¾‘ç»„ï¼Œå®ç°æ‰¹é‡æ§åˆ¶å’Œåœºæ™¯è”åŠ¨ã€‚

### 8.2 Schemaå®šä¹‰

**Matterè®¾å¤‡ç»„Schema**ï¼š

```json
{
  "group_id": 1,
  "group_name": "å®¢å…ç¯å…‰ç»„",
  "devices": [
    {
      "device_id": "LIGHT001",
      "endpoint_id": 1,
      "device_type": "DimmableLight"
    },
    {
      "device_id": "LIGHT002",
      "endpoint_id": 1,
      "device_type": "DimmableLight"
    },
    {
      "device_id": "LIGHT003",
      "endpoint_id": 1,
      "device_type": "ColorLight"
    }
  ],
  "scenes": [
    {
      "scene_id": "scene_bright",
      "scene_name": "æ˜äº®æ¨¡å¼",
      "actions": [
        {
          "device_id": "LIGHT001",
          "cluster_id": 0x0008,
          "command": "move_to_level",
          "parameters": {"level": 254, "transition_time": 0}
        },
        {
          "device_id": "LIGHT002",
          "cluster_id": 0x0008,
          "command": "move_to_level",
          "parameters": {"level": 254, "transition_time": 0}
        }
      ]
    }
  ]
}
```

### 8.3 å®ç°ä»£ç 

**å®Œæ•´çš„è®¾å¤‡ç»„æ§åˆ¶å®ç°**ï¼š

```python
import asyncio
import logging
from typing import List, Dict, Optional
from matter_device_controller import (
    MatterDeviceController,
    MatterDimmableLightController,
    MatterColorLightController
)
from matter_storage import MatterStorage

logger = logging.getLogger(__name__)

class MatterDeviceGroupController:
    """Matterè®¾å¤‡ç»„æ§åˆ¶å™¨"""

    def __init__(self, group_id: int, group_name: str, storage: MatterStorage):
        self.group_id = group_id
        self.group_name = group_name
        self.storage = storage
        self.devices: Dict[str, MatterDeviceController] = {}
        self.scenes: Dict[str, Dict] = {}

    async def initialize(self):
        """åˆå§‹åŒ–è®¾å¤‡ç»„"""
        # ä»å­˜å‚¨ä¸­åŠ è½½ç»„å†…è®¾å¤‡
        group_devices = self.storage.get_group_devices(self.group_id)

        for device_info in group_devices:
            device_id = device_info["device_id"]
            device_type = device_info["device_type"]

            # æ ¹æ®è®¾å¤‡ç±»å‹åˆ›å»ºæ§åˆ¶å™¨
            if device_type == "DimmableLight":
                controller = MatterDimmableLightController(
                    device_id,
                    device_info.get("node_id", 0x12344321),
                    device_info.get("endpoint_id", 1)
                )
            elif device_type == "ExtendedColorLight":
                controller = MatterColorLightController(
                    device_id,
                    device_info.get("node_id", 0x12344321),
                    device_info.get("endpoint_id", 1)
                )
            else:
                logger.warning(f"Unsupported device type: {device_type}")
                continue

            # è¿æ¥è®¾å¤‡
            if await controller.connect():
                self.devices[device_id] = controller
                logger.info(f"Added device {device_id} to group {self.group_name}")
            else:
                logger.error(f"Failed to connect device {device_id}")

    async def group_turn_on(self) -> Dict[str, bool]:
        """ç»„å†…æ‰€æœ‰è®¾å¤‡æ‰“å¼€"""
        results = {}

        for device_id, controller in self.devices.items():
            if isinstance(controller, MatterOnOffLightController):
                try:
                    result = await controller.turn_on()
                    results[device_id] = result
                except Exception as e:
                    logger.error(f"Failed to turn on {device_id}: {e}")
                    results[device_id] = False
            else:
                logger.warning(f"Device {device_id} does not support On/Off")
                results[device_id] = False

        return results

    async def group_turn_off(self) -> Dict[str, bool]:
        """ç»„å†…æ‰€æœ‰è®¾å¤‡å…³é—­"""
        results = {}

        for device_id, controller in self.devices.items():
            if isinstance(controller, MatterOnOffLightController):
                try:
                    result = await controller.turn_off()
                    results[device_id] = result
                except Exception as e:
                    logger.error(f"Failed to turn off {device_id}: {e}")
                    results[device_id] = False
            else:
                logger.warning(f"Device {device_id} does not support On/Off")
                results[device_id] = False

        return results

    async def group_set_level(self, level: int, transition_time: int = 0) -> Dict[str, bool]:
        """ç»„å†…æ‰€æœ‰å¯è°ƒå…‰è®¾å¤‡è®¾ç½®äº®åº¦"""
        results = {}

        for device_id, controller in self.devices.items():
            if isinstance(controller, MatterDimmableLightController):
                try:
                    result = await controller.set_level(level)
                    results[device_id] = result
                except Exception as e:
                    logger.error(f"Failed to set level for {device_id}: {e}")
                    results[device_id] = False
            else:
                logger.warning(f"Device {device_id} does not support level control")
                results[device_id] = False

        return results

    async def execute_scene(self, scene_id: str) -> Dict[str, bool]:
        """æ‰§è¡Œåœºæ™¯"""
        if scene_id not in self.scenes:
            logger.error(f"Scene {scene_id} not found")
            return {}

        scene = self.scenes[scene_id]
        results = {}

        # å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰åœºæ™¯åŠ¨ä½œ
        tasks = []
        for action in scene.get("actions", []):
            device_id = action["device_id"]
            controller = self.devices.get(device_id)

            if not controller:
                logger.error(f"Device {device_id} not found in group")
                results[device_id] = False
                continue

            # æ ¹æ®å‘½ä»¤ç±»å‹æ‰§è¡Œ
            command = action.get("command")
            parameters = action.get("parameters", {})

            if command == "turn_on":
                task = controller.turn_on()
            elif command == "turn_off":
                task = controller.turn_off()
            elif command == "move_to_level":
                task = controller.set_level(parameters.get("level", 128))
            elif command == "set_color_temperature":
                task = controller.set_color_temperature(parameters.get("color_temp_mireds", 250))
            else:
                logger.warning(f"Unknown command: {command}")
                results[device_id] = False
                continue

            tasks.append((device_id, task))

        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for device_id, task in tasks:
            try:
                result = await task
                results[device_id] = result
            except Exception as e:
                logger.error(f"Failed to execute action for {device_id}: {e}")
                results[device_id] = False

        return results

    def add_scene(self, scene_id: str, scene_name: str, actions: List[Dict]):
        """æ·»åŠ åœºæ™¯"""
        self.scenes[scene_id] = {
            "scene_id": scene_id,
            "scene_name": scene_name,
            "actions": actions
        }
        logger.info(f"Added scene {scene_name} to group {self.group_name}")

    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        for device_id, controller in self.devices.items():
            await controller.disconnect()

async def control_device_group():
    """è®¾å¤‡ç»„æ§åˆ¶ç¤ºä¾‹"""
    # åˆå§‹åŒ–å­˜å‚¨
    storage = MatterStorage("postgresql://user:pass@localhost/matter")

    # åˆ›å»ºè®¾å¤‡ç»„
    group_id = storage.create_device_group(1, "å®¢å…ç¯å…‰ç»„")

    # æ·»åŠ è®¾å¤‡åˆ°ç»„
    storage.add_device_to_group(1, "LIGHT001", 1)
    storage.add_device_to_group(1, "LIGHT002", 1)
    storage.add_device_to_group(1, "LIGHT003", 1)

    # åˆ›å»ºè®¾å¤‡ç»„æ§åˆ¶å™¨
    group_controller = MatterDeviceGroupController(1, "å®¢å…ç¯å…‰ç»„", storage)
    await group_controller.initialize()

    # æ‰§è¡Œç»„æ“ä½œ
    print("Turning on all devices in group...")
    results = await group_controller.group_turn_on()
    print(f"Results: {results}")

    # è®¾ç½®ç»„å†…æ‰€æœ‰è®¾å¤‡äº®åº¦
    print("\nSetting all devices to level 200...")
    results = await group_controller.group_set_level(200)
    print(f"Results: {results}")

    # æ·»åŠ åœºæ™¯
    group_controller.add_scene(
        "scene_bright",
        "æ˜äº®æ¨¡å¼",
        [
            {
                "device_id": "LIGHT001",
                "cluster_id": 0x0008,
                "command": "move_to_level",
                "parameters": {"level": 254}
            },
            {
                "device_id": "LIGHT002",
                "cluster_id": 0x0008,
                "command": "move_to_level",
                "parameters": {"level": 254}
            }
        ]
    )

    # æ‰§è¡Œåœºæ™¯
    print("\nExecuting scene 'bright'...")
    results = await group_controller.execute_scene("scene_bright")
    print(f"Results: {results}")

    # æ¸…ç†
    await group_controller.cleanup()
    storage.close()

if __name__ == "__main__":
    asyncio.run(control_device_group())
```

---

## 9. æ¡ˆä¾‹8ï¼šMatterè®¾å¤‡å›ºä»¶å‡çº§

### 9.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
æ™ºèƒ½å®¶å±…è®¾å¤‡éœ€è¦å®šæœŸè¿›è¡Œå›ºä»¶å‡çº§ï¼Œä»¥ä¿®å¤bugã€æ·»åŠ æ–°åŠŸèƒ½æˆ–æå‡æ€§èƒ½ã€‚Matteråè®®æ”¯æŒOTAï¼ˆOver-The-Airï¼‰å›ºä»¶å‡çº§åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒå›ºä»¶ç‰ˆæœ¬æ£€æŸ¥
- éœ€è¦æ”¯æŒå›ºä»¶ä¸‹è½½å’ŒéªŒè¯
- éœ€è¦æ”¯æŒå‡çº§è¿›åº¦ç›‘æ§
- éœ€è¦å¤„ç†å‡çº§å¤±è´¥å’Œå›æ»š
- éœ€è¦è®°å½•å‡çº§å†å²

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter OTAå‡çº§åŠŸèƒ½ï¼Œç»“åˆPostgreSQLå­˜å‚¨å‡çº§è®°å½•ï¼Œå®ç°å®Œæ•´çš„å›ºä»¶å‡çº§ç®¡ç†ã€‚

### 9.2 Schemaå®šä¹‰

**Matterå›ºä»¶å‡çº§Schema**ï¼š

```json
{
  "device_id": "LIGHT001",
  "current_firmware_version": "1.0.0",
  "target_firmware_version": "1.1.0",
  "firmware_info": {
    "firmware_url": "https://example.com/firmware/light_v1.1.0.bin",
    "firmware_size": 524288,
    "firmware_checksum": "sha256:abc123...",
    "firmware_format": "OTA",
    "min_hardware_version": 1,
    "max_hardware_version": 2
  },
  "upgrade_policy": {
    "auto_upgrade": false,
    "scheduled_time": "2025-01-22T02:00:00Z",
    "rollback_on_failure": true
  }
}
```

### 9.3 å®ç°ä»£ç 

**å®Œæ•´çš„å›ºä»¶å‡çº§å®ç°**ï¼š

```python
import asyncio
import logging
import hashlib
import aiohttp
from typing import Dict, Optional, Callable
from datetime import datetime
from matter_device_controller import MatterDeviceController
from matter_storage import MatterStorage

logger = logging.getLogger(__name__)

class MatterFirmwareUpdater:
    """Matterè®¾å¤‡å›ºä»¶å‡çº§å™¨"""

    def __init__(self, device_controller: MatterDeviceController,
                 storage: MatterStorage):
        self.device_controller = device_controller
        self.storage = storage
        self.device_id = device_controller.device_id
        self.upgrade_progress_callback: Optional[Callable] = None

    async def check_firmware_version(self) -> Optional[str]:
        """æ£€æŸ¥å½“å‰å›ºä»¶ç‰ˆæœ¬"""
        try:
            # è¯»å–Basic Clusterçš„SoftwareVersionå±æ€§
            version = await self.device_controller.read_attribute(
                0x0028,  # Basic Cluster
                0x0009   # SoftwareVersion
            )
            return version if version else None
        except Exception as e:
            logger.error(f"Failed to check firmware version: {e}")
            return None

    async def download_firmware(self, firmware_url: str) -> bytes:
        """ä¸‹è½½å›ºä»¶æ–‡ä»¶"""
        async with aiohttp.ClientSession() as session:
            async with session.get(firmware_url) as response:
                if response.status == 200:
                    firmware_data = await response.read()
                    logger.info(f"Downloaded firmware: {len(firmware_data)} bytes")
                    return firmware_data
                else:
                    raise Exception(f"Failed to download firmware: HTTP {response.status}")

    def verify_firmware_checksum(self, firmware_data: bytes,
                                expected_checksum: str) -> bool:
        """éªŒè¯å›ºä»¶æ ¡éªŒå’Œ"""
        # æå–ç®—æ³•å’Œå“ˆå¸Œå€¼
        if expected_checksum.startswith("sha256:"):
            algorithm = "sha256"
            expected_hash = expected_checksum[7:]
        elif expected_checksum.startswith("sha1:"):
            algorithm = "sha1"
            expected_hash = expected_checksum[5:]
        else:
            logger.warning(f"Unknown checksum format: {expected_checksum}")
            return False

        # è®¡ç®—å®é™…å“ˆå¸Œå€¼
        if algorithm == "sha256":
            actual_hash = hashlib.sha256(firmware_data).hexdigest()
        elif algorithm == "sha1":
            actual_hash = hashlib.sha1(firmware_data).hexdigest()
        else:
            return False

        return actual_hash.lower() == expected_hash.lower()

    async def upgrade_firmware(self, firmware_url: str, firmware_version: str,
                              firmware_size: int = None,
                              firmware_checksum: str = None,
                              progress_callback: Callable = None) -> bool:
        """æ‰§è¡Œå›ºä»¶å‡çº§"""
        self.upgrade_progress_callback = progress_callback

        # è®°å½•å‡çº§å¼€å§‹
        update_id = self.storage.store_firmware_update(
            self.device_id,
            firmware_version,
            firmware_url,
            firmware_size,
            firmware_checksum
        )

        try:
            # æ£€æŸ¥å½“å‰ç‰ˆæœ¬
            current_version = await self.check_firmware_version()
            logger.info(f"Current firmware version: {current_version}")

            # ä¸‹è½½å›ºä»¶
            if progress_callback:
                progress_callback(0, "Downloading firmware...")

            firmware_data = await self.download_firmware(firmware_url)

            # éªŒè¯å›ºä»¶
            if firmware_checksum:
                if progress_callback:
                    progress_callback(10, "Verifying firmware...")

                if not self.verify_firmware_checksum(firmware_data, firmware_checksum):
                    raise Exception("Firmware checksum verification failed")

            # æ›´æ–°çŠ¶æ€ä¸ºè¿›è¡Œä¸­
            self.storage.update_firmware_status(update_id, "InProgress")

            # å‘é€å›ºä»¶åˆ°è®¾å¤‡ï¼ˆè¿™é‡Œéœ€è¦å®é™…çš„Matter OTAå‡çº§å‘½ä»¤ï¼‰
            if progress_callback:
                progress_callback(20, "Uploading firmware to device...")

            # æ¨¡æ‹Ÿå‡çº§è¿‡ç¨‹
            await self._simulate_firmware_upgrade(firmware_data, progress_callback)

            # éªŒè¯å‡çº§ç»“æœ
            if progress_callback:
                progress_callback(90, "Verifying upgrade...")

            new_version = await self.check_firmware_version()
            if new_version == firmware_version:
                self.storage.update_firmware_status(update_id, "Completed")
                logger.info(f"Firmware upgrade completed: {current_version} -> {new_version}")
                return True
            else:
                raise Exception(f"Version mismatch: expected {firmware_version}, got {new_version}")

        except Exception as e:
            logger.error(f"Firmware upgrade failed: {e}")
            self.storage.update_firmware_status(update_id, "Failed", str(e))
            return False

    async def _simulate_firmware_upgrade(self, firmware_data: bytes,
                                        progress_callback: Callable):
        """æ¨¡æ‹Ÿå›ºä»¶å‡çº§è¿‡ç¨‹"""
        # æ¨¡æ‹Ÿå‡çº§è¿›åº¦
        for progress in range(20, 90, 10):
            await asyncio.sleep(0.5)
            if progress_callback:
                progress_callback(progress, f"Upgrading... {progress}%")

    async def rollback_firmware(self, previous_version: str) -> bool:
        """å›æ»šåˆ°ä¹‹å‰çš„å›ºä»¶ç‰ˆæœ¬"""
        logger.info(f"Rolling back to version {previous_version}")
        # è¿™é‡Œéœ€è¦å®é™…çš„å›æ»šé€»è¾‘
        # Matteråè®®å¯èƒ½ä¸æ”¯æŒç›´æ¥å›æ»šï¼Œéœ€è¦é‡æ–°å‡çº§åˆ°ä¹‹å‰çš„ç‰ˆæœ¬
        return False

async def upgrade_device_firmware():
    """å›ºä»¶å‡çº§ç¤ºä¾‹"""
    # åˆå§‹åŒ–å­˜å‚¨
    storage = MatterStorage("postgresql://user:pass@localhost/matter")

    # åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
    device_controller = MatterDeviceController("LIGHT001", 0x12344321)
    await device_controller.connect()

    # åˆ›å»ºå›ºä»¶å‡çº§å™¨
    updater = MatterFirmwareUpdater(device_controller, storage)

    # æ£€æŸ¥å½“å‰ç‰ˆæœ¬
    current_version = await updater.check_firmware_version()
    print(f"Current firmware version: {current_version}")

    # å®šä¹‰è¿›åº¦å›è°ƒ
    def progress_callback(progress: int, message: str):
        print(f"[{progress}%] {message}")

    # æ‰§è¡Œå‡çº§
    success = await updater.upgrade_firmware(
        firmware_url="https://example.com/firmware/light_v1.1.0.bin",
        firmware_version="1.1.0",
        firmware_size=524288,
        firmware_checksum="sha256:abc123def456...",
        progress_callback=progress_callback
    )

    if success:
        print("Firmware upgrade completed successfully!")
    else:
        print("Firmware upgrade failed!")

    # æŸ¥è¯¢å‡çº§å†å²
    updates = storage.get_firmware_updates(device_id="LIGHT001")
    print("\nFirmware update history:")
    for update in updates:
        print(f"  Version: {update['firmware_version']}, "
              f"Status: {update['update_status']}, "
              f"Time: {update['created_at']}")

    await device_controller.disconnect()
    storage.close()

if __name__ == "__main__":
    asyncio.run(upgrade_device_firmware())
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

---

## 10. æ¡ˆä¾‹9ï¼šMatterå¤šè®¾å¤‡è”åŠ¨

### 10.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matterå¤šè®¾å¤‡è”åŠ¨ç³»ç»Ÿå®ç°å¤šä¸ªMatterè®¾å¤‡ä¹‹é—´çš„
ååŒå·¥ä½œï¼Œä¾‹å¦‚å¼€é—¨æ—¶è‡ªåŠ¨å¼€ç¯ã€æ¸©åº¦å˜åŒ–æ—¶è‡ªåŠ¨
è°ƒèŠ‚ç©ºè°ƒç­‰ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦è®¾å¤‡çŠ¶æ€åŒæ­¥
- éœ€è¦è”åŠ¨è§„åˆ™ç®¡ç†
- éœ€è¦äº‹ä»¶è§¦å‘æœºåˆ¶
- éœ€è¦è”åŠ¨æ•ˆæœè¯„ä¼°

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter_Schemaå®šä¹‰è®¾å¤‡è”åŠ¨è§„åˆ™ï¼Œ
ä½¿ç”¨Matter SDKå®ç°è®¾å¤‡è”åŠ¨ï¼Œ
ä½¿ç”¨MatterStorageå­˜å‚¨è”åŠ¨æ•°æ®ã€‚

### 10.2 Schemaå®šä¹‰

**Matterå¤šè®¾å¤‡è”åŠ¨Schema**ï¼š

```dsl
schema MatterDeviceCoordination {
  coordination_id: String @value("COORD-20250121-001") @required
  coordination_name: String @value("å›å®¶åœºæ™¯è”åŠ¨") @required
  trigger_device: {
    device_id: String @value("DOOR-LOCK-001")
    device_type: Enum { DoorLock } @value(DoorLock)
    trigger_event: Enum { Unlocked } @value(Unlocked)
  } @required

  target_devices: [
    {
      device_id: String @value("LIGHT-001")
      device_type: Enum { Light } @value(Light)
      action: {
        cluster_id: Integer @value(6) @comment("On/Off Cluster")
        command_id: Integer @value(1) @comment("On Command")
        parameters: {
          on_off: Boolean @value(true)
        }
      }
    },
    {
      device_id: String @value("THERMOSTAT-001")
      device_type: Enum { Thermostat } @value(Thermostat)
      action: {
        cluster_id: Integer @value(513) @comment("Thermostat Cluster")
        command_id: Integer @value(0) @comment("Set Setpoint")
        parameters: {
          setpoint: Decimal @value(22.0) @unit("Celsius")
        }
      }
    }
  ] @required

  coordination_status: {
    status: Enum { Active } @value(Active)
    last_triggered: DateTime @value("2025-01-21T18:00:00")
    trigger_count: Integer @value(5)
    success_rate: Decimal @value(1.0) @range(0.0, 1.0)
  } @required
} @standard("Matter")
```

### 10.3 å®ç°ä»£ç 

```python
from matter_storage import MatterStorage
from matter_sdk_wrapper import MatterSDKWrapper
from datetime import datetime

async def matter_device_coordination():
    """Matterå¤šè®¾å¤‡è”åŠ¨ç¤ºä¾‹"""
    storage = MatterStorage("postgresql://user:password@localhost/matter_db")
    sdk = MatterSDKWrapper()

    # è”åŠ¨è§„åˆ™
    coordination_rule = {
        "coordination_id": "COORD-20250121-001",
        "coordination_name": "å›å®¶åœºæ™¯è”åŠ¨",
        "trigger_device": {
            "device_id": "DOOR-LOCK-001",
            "device_type": "DoorLock",
            "trigger_event": "Unlocked"
        },
        "target_devices": [
            {
                "device_id": "LIGHT-001",
                "device_type": "Light",
                "action": {
                    "cluster_id": 6,  # On/Off Cluster
                    "command_id": 1,  # On Command
                    "parameters": {"on_off": True}
                }
            },
            {
                "device_id": "THERMOSTAT-001",
                "device_type": "Thermostat",
                "action": {
                    "cluster_id": 513,  # Thermostat Cluster
                    "command_id": 0,  # Set Setpoint
                    "parameters": {"setpoint": 22.0}
                }
            }
        ]
    }

    # ç›‘å¬è§¦å‘è®¾å¤‡äº‹ä»¶
    async def on_door_unlocked(device_id, event_data):
        """é—¨é”è§£é”äº‹ä»¶å¤„ç†"""
        print(f"Door unlocked: {device_id}")

        # æ‰§è¡Œè”åŠ¨åŠ¨ä½œ
        for target_device in coordination_rule["target_devices"]:
            try:
                result = await sdk.send_command(
                    target_device["device_id"],
                    target_device["action"]["cluster_id"],
                    target_device["action"]["command_id"],
                    target_device["action"]["parameters"]
                )

                if result:
                    print(f"  {target_device['device_id']} action executed successfully")
                else:
                    print(f"  {target_device['device_id']} action failed")
            except Exception as e:
                print(f"  Error executing action on {target_device['device_id']}: {e}")

        # è®°å½•è”åŠ¨äº‹ä»¶
        coordination_data = {
            "coordination_id": coordination_rule["coordination_id"],
            "trigger_device_id": device_id,
            "trigger_time": datetime.now(),
            "target_devices": [d["device_id"] for d in coordination_rule["target_devices"]],
            "status": "Completed"
        }

        storage.store_coordination_event(coordination_data)

    # æ³¨å†Œäº‹ä»¶ç›‘å¬
    await sdk.subscribe_to_events("DOOR-LOCK-001", on_door_unlocked)

    print("Matter device coordination system started")
    print(f"  Coordination: {coordination_rule['coordination_name']}")
    print(f"  Trigger device: {coordination_rule['trigger_device']['device_id']}")
    print(f"  Target devices: {len(coordination_rule['target_devices'])}")

    return coordination_rule

if __name__ == "__main__":
    import asyncio
    asyncio.run(matter_device_coordination())
```

---

## 11. æ¡ˆä¾‹10ï¼šMatteråœºæ™¯è‡ªåŠ¨åŒ–

### 11.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matteråœºæ™¯è‡ªåŠ¨åŒ–ç³»ç»Ÿæ ¹æ®æ—¶é—´ã€ç¯å¢ƒæ¡ä»¶ç­‰
è‡ªåŠ¨è§¦å‘è®¾å¤‡åœºæ™¯ï¼Œä¾‹å¦‚æ—©æ™¨è‡ªåŠ¨å¼€ç¯ã€æ¸©åº¦
è¿‡é«˜æ—¶è‡ªåŠ¨å¼€å¯ç©ºè°ƒç­‰ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ—¶é—´æ¡ä»¶åˆ¤æ–­
- éœ€è¦ç¯å¢ƒæ¡ä»¶ç›‘æµ‹
- éœ€è¦åœºæ™¯è§„åˆ™ç®¡ç†
- éœ€è¦è‡ªåŠ¨åŒ–æ•ˆæœè¯„ä¼°

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter_Schemaå®šä¹‰åœºæ™¯è‡ªåŠ¨åŒ–è§„åˆ™ï¼Œ
ä½¿ç”¨Matter SDKå®ç°åœºæ™¯è‡ªåŠ¨åŒ–ï¼Œ
ä½¿ç”¨MatterStorageå­˜å‚¨è‡ªåŠ¨åŒ–æ•°æ®ã€‚

### 11.2 Schemaå®šä¹‰

**Matteråœºæ™¯è‡ªåŠ¨åŒ–Schema**ï¼š

```dsl
schema MatterSceneAutomation {
  automation_id: String @value("AUTO-20250121-001") @required
  automation_name: String @value("æ—©æ™¨è‡ªåŠ¨åœºæ™¯") @required

  trigger_conditions: {
    time_condition: {
      enabled: Boolean @value(true)
      time: Time @value("07:00:00")
      days_of_week: [Enum] @value([Monday, Tuesday, Wednesday, Thursday, Friday])
    }
    environment_condition: {
      enabled: Boolean @value(true)
      sensor_device_id: String @value("SENSOR-001")
      condition_type: Enum { Temperature } @value(Temperature)
      threshold: Decimal @value(25.0) @unit("Celsius")
      operator: Enum { GreaterThan } @value(GreaterThan)
    }
  } @required

  scene_actions: [
    {
      device_id: String @value("LIGHT-001")
      action: {
        cluster_id: Integer @value(6)
        command_id: Integer @value(1)
        parameters: {
          on_off: Boolean @value(true)
          brightness: Integer @value(80) @range(0, 100)
        }
      }
    },
    {
      device_id: String @value("CURTAIN-001")
      action: {
        cluster_id: Integer @value(258) @comment("Window Covering Cluster")
        command_id: Integer @value(1) @comment("Up Command")
        parameters: {
          lift_percent: Integer @value(100)
        }
      }
    }
  ] @required

  automation_status: {
    status: Enum { Active } @value(Active)
    last_executed: DateTime @value("2025-01-21T07:00:00")
    execution_count: Integer @value(30)
    success_rate: Decimal @value(0.97) @range(0.0, 1.0)
  } @required
} @standard("Matter")
```

### 11.3 å®ç°ä»£ç 

```python
from matter_storage import MatterStorage
from matter_sdk_wrapper import MatterSDKWrapper
from datetime import datetime, time

async def matter_scene_automation():
    """Matteråœºæ™¯è‡ªåŠ¨åŒ–ç¤ºä¾‹"""
    storage = MatterStorage("postgresql://user:password@localhost/matter_db")
    sdk = MatterSDKWrapper()

    # è‡ªåŠ¨åŒ–è§„åˆ™
    automation_rule = {
        "automation_id": "AUTO-20250121-001",
        "automation_name": "æ—©æ™¨è‡ªåŠ¨åœºæ™¯",
        "trigger_conditions": {
            "time_condition": {
                "enabled": True,
                "time": time(7, 0, 0),
                "days_of_week": [0, 1, 2, 3, 4]  # Monday to Friday
            },
            "environment_condition": {
                "enabled": True,
                "sensor_device_id": "SENSOR-001",
                "condition_type": "Temperature",
                "threshold": 25.0,
                "operator": "GreaterThan"
            }
        },
        "scene_actions": [
            {
                "device_id": "LIGHT-001",
                "action": {
                    "cluster_id": 6,
                    "command_id": 1,
                    "parameters": {"on_off": True, "brightness": 80}
                }
            },
            {
                "device_id": "CURTAIN-001",
                "action": {
                    "cluster_id": 258,
                    "command_id": 1,
                    "parameters": {"lift_percent": 100}
                }
            }
        ]
    }

    # æ£€æŸ¥è§¦å‘æ¡ä»¶
    def check_trigger_conditions(rule):
        """æ£€æŸ¥è§¦å‘æ¡ä»¶"""
        conditions_met = True

        # æ£€æŸ¥æ—¶é—´æ¡ä»¶
        if rule["trigger_conditions"]["time_condition"]["enabled"]:
            current_time = datetime.now().time()
            target_time = rule["trigger_conditions"]["time_condition"]["time"]
            current_day = datetime.now().weekday()
            days_of_week = rule["trigger_conditions"]["time_condition"]["days_of_week"]

            if current_time.hour != target_time.hour or \
               current_time.minute != target_time.minute or \
               current_day not in days_of_week:
                conditions_met = False

        # æ£€æŸ¥ç¯å¢ƒæ¡ä»¶
        if rule["trigger_conditions"]["environment_condition"]["enabled"]:
            sensor_id = rule["trigger_conditions"]["environment_condition"]["sensor_device_id"]
            condition_type = rule["trigger_conditions"]["environment_condition"]["condition_type"]
            threshold = rule["trigger_conditions"]["environment_condition"]["threshold"]
            operator = rule["trigger_conditions"]["environment_condition"]["operator"]

            # è·å–ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
            sensor_value = 26.5  # å‡è®¾ä»ä¼ æ„Ÿå™¨è¯»å–

            if operator == "GreaterThan" and sensor_value <= threshold:
                conditions_met = False
            elif operator == "LessThan" and sensor_value >= threshold:
                conditions_met = False

        return conditions_met

    # æ‰§è¡Œåœºæ™¯åŠ¨ä½œ
    async def execute_scene_actions(rule):
        """æ‰§è¡Œåœºæ™¯åŠ¨ä½œ"""
        success_count = 0

        for action in rule["scene_actions"]:
            try:
                result = await sdk.send_command(
                    action["device_id"],
                    action["action"]["cluster_id"],
                    action["action"]["command_id"],
                    action["action"]["parameters"]
                )

                if result:
                    success_count += 1
                    print(f"  {action['device_id']} action executed successfully")
                else:
                    print(f"  {action['device_id']} action failed")
            except Exception as e:
                print(f"  Error executing action on {action['device_id']}: {e}")

        return success_count

    # è‡ªåŠ¨åŒ–å¾ªç¯
    while True:
        if check_trigger_conditions(automation_rule):
            print(f"Trigger conditions met for: {automation_rule['automation_name']}")

            success_count = await execute_scene_actions(automation_rule)
            total_actions = len(automation_rule["scene_actions"])
            success_rate = success_count / total_actions if total_actions > 0 else 0

            # è®°å½•è‡ªåŠ¨åŒ–æ‰§è¡Œ
            automation_data = {
                "automation_id": automation_rule["automation_id"],
                "execution_time": datetime.now(),
                "success_count": success_count,
                "total_actions": total_actions,
                "success_rate": success_rate,
                "status": "Completed" if success_rate == 1.0 else "Partial"
            }

            storage.store_automation_event(automation_data)

            print(f"Automation executed: {success_count}/{total_actions} actions succeeded")

        # ç­‰å¾…1åˆ†é’Ÿå†æ£€æŸ¥
        await asyncio.sleep(60)

    return automation_rule

if __name__ == "__main__":
    import asyncio
    asyncio.run(matter_scene_automation())
```

---

## 12. æ¡ˆä¾‹11ï¼šMatterè®¾å¤‡æ•…éšœè¯Šæ–­

### 12.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matterè®¾å¤‡æ•…éšœè¯Šæ–­ç³»ç»Ÿç›‘æµ‹è®¾å¤‡çŠ¶æ€ï¼Œ
è¯†åˆ«è®¾å¤‡æ•…éšœï¼Œæä¾›æ•…éšœè¯Šæ–­å’Œä¿®å¤å»ºè®®ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦è®¾å¤‡çŠ¶æ€ç›‘æµ‹
- éœ€è¦æ•…éšœæ¨¡å¼è¯†åˆ«
- éœ€è¦è¯Šæ–­ç®—æ³•
- éœ€è¦ä¿®å¤å»ºè®®ç”Ÿæˆ

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter_Schemaç›‘æµ‹è®¾å¤‡çŠ¶æ€ï¼Œ
ä½¿ç”¨AIç®—æ³•è¿›è¡Œæ•…éšœè¯Šæ–­ï¼Œ
ä½¿ç”¨MatterStorageå­˜å‚¨è¯Šæ–­æ•°æ®ã€‚

### 12.2 Schemaå®šä¹‰

**Matterè®¾å¤‡æ•…éšœè¯Šæ–­Schema**ï¼š

```dsl
schema MatterDeviceDiagnostics {
  diagnosis_session_id: String @value("DIAG-20250121-001") @required
  device_id: String @value("LIGHT-001") @required
  diagnosis_time: DateTime @value("2025-01-21T10:00:00") @required

  device_status: {
    online: Boolean @value(false)
    last_seen: DateTime @value("2025-01-21T09:30:00")
    response_time: Decimal @value(5000.0) @unit("ms")
    error_count: Integer @value(5)
    last_error: String @value("Timeout")
  } @required

  diagnostic_results: {
    fault_detected: Boolean @value(true)
    fault_type: Enum { Connectivity } @value(Connectivity)
    fault_severity: Enum { Medium } @value(Medium)
    fault_description: String @value("è®¾å¤‡å“åº”è¶…æ—¶")
    root_cause: String @value("ç½‘ç»œè¿æ¥ä¸ç¨³å®š")
    confidence: Decimal @value(0.85) @range(0.0, 1.0)
  } @required

  repair_recommendations: [
    {
      recommendation: String @value("æ£€æŸ¥ç½‘ç»œè¿æ¥")
      priority: Enum { High } @value(High)
      expected_fix_probability: Decimal @value(0.80)
    },
    {
      recommendation: String @value("é‡å¯è®¾å¤‡")
      priority: Enum { Medium } @value(Medium)
      expected_fix_probability: Decimal @value(0.60)
    }
  ] @required
} @standard("Matter")
```

### 12.3 å®ç°ä»£ç 

```python
from matter_storage import MatterStorage
from matter_sdk_wrapper import MatterSDKWrapper
from datetime import datetime, timedelta

async def matter_device_diagnostics():
    """Matterè®¾å¤‡æ•…éšœè¯Šæ–­ç¤ºä¾‹"""
    storage = MatterStorage("postgresql://user:password@localhost/matter_db")
    sdk = MatterSDKWrapper()

    # è®¾å¤‡çŠ¶æ€
    device_id = "LIGHT-001"
    device_status = {
        "online": False,
        "last_seen": datetime.now() - timedelta(minutes=30),
        "response_time": 5000.0,
        "error_count": 5,
        "last_error": "Timeout"
    }

    # æ•…éšœè¯Šæ–­ç®—æ³•
    def diagnose_device_fault(status):
        """è¯Šæ–­è®¾å¤‡æ•…éšœ"""
        fault_detected = False
        fault_type = None
        fault_severity = None
        fault_description = None
        root_cause = None
        confidence = 0.0
        recommendations = []

        # æ£€æŸ¥åœ¨çº¿çŠ¶æ€
        if not status["online"]:
            time_since_last_seen = datetime.now() - status["last_seen"]

            if time_since_last_seen.total_seconds() > 3600:  # 1å°æ—¶
                fault_detected = True
                fault_type = "Connectivity"
                fault_severity = "High"
                fault_description = "è®¾å¤‡é•¿æ—¶é—´ç¦»çº¿"
                root_cause = "ç½‘ç»œè¿æ¥ä¸­æ–­æˆ–è®¾å¤‡æ•…éšœ"
                confidence = 0.90
                recommendations.append({
                    "recommendation": "æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œè®¾å¤‡ç”µæº",
                    "priority": "High",
                    "expected_fix_probability": 0.70
                })
            else:
                fault_detected = True
                fault_type = "Connectivity"
                fault_severity = "Medium"
                fault_description = "è®¾å¤‡æš‚æ—¶ç¦»çº¿"
                root_cause = "ç½‘ç»œè¿æ¥ä¸ç¨³å®š"
                confidence = 0.75
                recommendations.append({
                    "recommendation": "æ£€æŸ¥ç½‘ç»œè¿æ¥",
                    "priority": "High",
                    "expected_fix_probability": 0.80
                })

        # æ£€æŸ¥å“åº”æ—¶é—´
        if status["response_time"] > 3000:  # 3ç§’
            fault_detected = True
            if fault_type is None:
                fault_type = "Performance"
                fault_severity = "Medium"
                fault_description = "è®¾å¤‡å“åº”ç¼“æ…¢"
                root_cause = "ç½‘ç»œå»¶è¿Ÿæˆ–è®¾å¤‡è´Ÿè½½è¿‡é«˜"
                confidence = 0.70
                recommendations.append({
                    "recommendation": "æ£€æŸ¥ç½‘ç»œå»¶è¿Ÿå’Œè®¾å¤‡è´Ÿè½½",
                    "priority": "Medium",
                    "expected_fix_probability": 0.60
                })

        # æ£€æŸ¥é”™è¯¯è®¡æ•°
        if status["error_count"] > 3:
            fault_detected = True
            if fault_type is None:
                fault_type = "Reliability"
                fault_severity = "Medium"
                fault_description = "è®¾å¤‡é¢‘ç¹å‡ºé”™"
                root_cause = "è®¾å¤‡ä¸ç¨³å®šæˆ–é…ç½®é”™è¯¯"
                confidence = 0.80
                recommendations.append({
                    "recommendation": "é‡å¯è®¾å¤‡",
                    "priority": "Medium",
                    "expected_fix_probability": 0.60
                })
                recommendations.append({
                    "recommendation": "æ£€æŸ¥è®¾å¤‡é…ç½®",
                    "priority": "Low",
                    "expected_fix_probability": 0.50
                })

        return {
            "fault_detected": fault_detected,
            "fault_type": fault_type,
            "fault_severity": fault_severity,
            "fault_description": fault_description,
            "root_cause": root_cause,
            "confidence": confidence,
            "recommendations": recommendations
        }

    # æ‰§è¡Œè¯Šæ–­
    diagnostic_results = diagnose_device_fault(device_status)

    # å­˜å‚¨è¯Šæ–­æ•°æ®
    diagnosis_data = {
        "diagnosis_session_id": "DIAG-20250121-001",
        "device_id": device_id,
        "diagnosis_time": datetime.now(),
        "device_online": device_status["online"],
        "device_last_seen": device_status["last_seen"],
        "device_response_time": device_status["response_time"],
        "device_error_count": device_status["error_count"],
        "device_last_error": device_status["last_error"],
        "fault_detected": diagnostic_results["fault_detected"],
        "fault_type": diagnostic_results["fault_type"],
        "fault_severity": diagnostic_results["fault_severity"],
        "fault_description": diagnostic_results["fault_description"],
        "root_cause": diagnostic_results["root_cause"],
        "confidence": diagnostic_results["confidence"],
        "recommendations": diagnostic_results["recommendations"]
    }

    # å­˜å‚¨åˆ°æ•°æ®åº“
    diagnosis_id = storage.store_diagnostic_data(diagnosis_data)
    print(f"Device diagnosis stored: {diagnosis_id}")

    print(f"\nMatter Device Diagnostics:")
    print(f"  Device: {device_id}")
    print(f"  Fault detected: {diagnostic_results['fault_detected']}")
    if diagnostic_results['fault_detected']:
        print(f"  Fault type: {diagnostic_results['fault_type']}")
        print(f"  Fault severity: {diagnostic_results['fault_severity']}")
        print(f"  Fault description: {diagnostic_results['fault_description']}")
        print(f"  Root cause: {diagnostic_results['root_cause']}")
        print(f"  Confidence: {diagnostic_results['confidence']:.2f}")
        print(f"  Recommendations: {len(diagnostic_results['recommendations'])}")
        for i, rec in enumerate(diagnostic_results['recommendations'], 1):
            print(f"    {i}. {rec['recommendation']} (Priority: {rec['priority']})")

    return diagnosis_data

if __name__ == "__main__":
    import asyncio
    asyncio.run(matter_device_diagnostics())
```

---

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21


---

## 12. æ¡ˆä¾‹12ï¼šMatterå¤šç®¡ç†å‘˜(FMA)é…ç½®ç®¡ç†

### 12.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matterå¤šç®¡ç†å‘˜(Fabric Multi-Admin)åŠŸèƒ½å…è®¸ä¸€ä¸ªè®¾å¤‡è¢«å¤šä¸ªç”Ÿæ€ç³»ç»Ÿï¼ˆå¦‚Apple Homeã€Google Homeã€Amazon Alexaï¼‰åŒæ—¶ç®¡ç†ã€‚éœ€è¦å®ç°å®‰å…¨çš„Commissioningæµç¨‹ã€ACLæƒé™ç®¡ç†å’Œè·¨Fabricçš„è®¾å¤‡çŠ¶æ€åŒæ­¥ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦ç®¡ç†å¤šä¸ªFabricçš„Credentials
- éœ€è¦ç²¾ç»†çš„ACLæƒé™æ§åˆ¶
- éœ€è¦å¤„ç†è·¨Fabricçš„å‘½ä»¤å†²çª
- éœ€è¦ç¡®ä¿Commissioningå®‰å…¨æ€§

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matterçš„Multi-AdminåŠŸèƒ½ï¼Œç»“åˆPostgreSQLå­˜å‚¨å„Fabricçš„é…ç½®å’ŒACLè§„åˆ™ï¼Œå®ç°å®‰å…¨çš„å¤šç®¡ç†å‘˜ç®¡ç†ã€‚

### 12.2 Schemaå®šä¹‰

**å¤šç®¡ç†å‘˜é…ç½®Schema**ï¼š

```json
{
  "device_id": "MATTER_LIGHT_001",
  "fabrics": [
    {
      "fabric_id": 1,
      "fabric_name": "Apple Home",
      "node_id": 12345,
      "is_commissioner": true,
      "acl_entries": [
        {
          "privilege": 5,
          "auth_mode": "CASE",
          "subjects": [12345],
          "targets": [{"cluster": 6, "endpoint": 1}]
        }
      ]
    },
    {
      "fabric_id": 2,
      "fabric_name": "Google Home",
      "node_id": 67890,
      "acl_entries": [
        {
          "privilege": 3,
          "auth_mode": "CASE",
          "subjects": [67890],
          "targets": [{"cluster": 6, "endpoint": 1}]
        }
      ]
    }
  ],
  "operational_credentials": {
    "root_certificate": "...",
    "intermediate_certificate": "...",
    "operational_certificate": "..."
  }
}
```

### 12.3 å®ç°ä»£ç 

```python
from matter_storage import MatterStorage
from typing import List, Dict

class MatterMultiAdminManager:
    """Matterå¤šç®¡ç†å‘˜ç®¡ç†å™¨"""

    def __init__(self, storage: MatterStorage):
        self.storage = storage

    def commission_to_new_fabric(self, device_id: str, fabric_id: int,
                                 fabric_name: str, node_id: int,
                                 passcode: int, discriminator: int) -> bool:
        """å°†è®¾å¤‡Commissionåˆ°æ–°Fabric"""
        try:
            # è®°å½•Commissioningè¿‡ç¨‹
            self.storage.store_commissioning_record(
                device_id=device_id,
                node_id=node_id,
                fabric_id=fabric_id,
                passcode=passcode,
                discriminator=discriminator,
                success=True
            )

            # å­˜å‚¨Fabricä¿¡æ¯åˆ°è®¾å¤‡å…ƒæ•°æ®
            self.storage.store_network_info(
                device_id=device_id,
                fabric_id=fabric_id,
                node_id=node_id,
                network_type="Thread"
            )

            print(f"Device {device_id} successfully commissioned to {fabric_name}")
            return True
        except Exception as e:
            self.storage.store_commissioning_record(
                device_id=device_id,
                fabric_id=fabric_id,
                passcode=passcode,
                discriminator=discriminator,
                success=False,
                error_message=str(e)
            )
            return False

    def setup_acl_for_fabric(self, fabric_id: int, privilege: int,
                            subjects: List[int], targets: List[Dict]) -> int:
        """ä¸ºFabricè®¾ç½®ACL"""
        acl_id = self.storage.store_acl_entry(
            fabric_id=fabric_id,
            privilege=privilege,
            auth_mode="CASE",
            subjects=subjects,
            targets=targets
        )
        print(f"ACL entry created: {acl_id} for fabric {fabric_id}")
        return acl_id

    def get_device_fabrics(self, device_id: str) -> List[Dict]:
        """è·å–è®¾å¤‡æ‰€å±çš„æ‰€æœ‰Fabric"""
        device = self.storage.get_device_by_id(device_id)
        if not device:
            return []

        # æŸ¥è¯¢ç½‘ç»œä¿¡æ¯è·å–Fabricåˆ—è¡¨
        network_info = self.storage.get_network_info_by_device(device_id)
        return [
            {
                "fabric_id": info.get("fabric_id"),
                "node_id": info.get("node_id"),
                "last_seen": info.get("last_seen")
            }
            for info in network_info
        ]

    def remove_fabric(self, device_id: str, fabric_id: int) -> bool:
        """ä»è®¾å¤‡ç§»é™¤Fabric"""
        # å®é™…å®ç°ä¸­éœ€è¦è°ƒç”¨Matter SDKçš„RemoveFabricå‘½ä»¤
        print(f"Removing fabric {fabric_id} from device {device_id}")
        return True

# ä½¿ç”¨ç¤ºä¾‹
def demo_multi_admin():
    storage = MatterStorage("postgresql://user:pass@localhost/matter")
    manager = MatterMultiAdminManager(storage)

    # Commissionè®¾å¤‡åˆ°Apple Home
    manager.commission_to_new_fabric(
        device_id="MATTER_LIGHT_001",
        fabric_id=1,
        fabric_name="Apple Home",
        node_id=12345,
        passcode=20202021,
        discriminator=3840
    )

    # è®¾ç½®ACLæƒé™
    manager.setup_acl_for_fabric(
        fabric_id=1,
        privilege=5,  # Administer
        subjects=[12345],
        targets=[{"cluster": 6, "endpoint": 1}]  # On/Off Cluster
    )
```

---

## 13. æ¡ˆä¾‹13ï¼šMatterè®¾å¤‡å›ºä»¶OTAå‡çº§ç®¡ç†

### 13.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matterè®¾å¤‡éœ€è¦æ”¯æŒOTAï¼ˆOver-The-Airï¼‰å›ºä»¶å‡çº§ï¼Œä»¥ä¿®å¤å®‰å…¨æ¼æ´ã€æ·»åŠ æ–°åŠŸèƒ½æˆ–æå‡æ€§èƒ½ã€‚éœ€è¦ç®¡ç†å›ºä»¶ç‰ˆæœ¬ã€åˆ†å‘å‡çº§åŒ…ã€ç›‘æ§å‡çº§è¿›åº¦å¹¶å¤„ç†å¤±è´¥å›æ»šã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦ç®¡ç†å›ºä»¶ç‰ˆæœ¬å…¼å®¹æ€§
- éœ€è¦å¯é çš„æ–­ç‚¹ç»­ä¼ 
- éœ€è¦å¤„ç†å‡çº§å¤±è´¥å’Œå›æ»š
- éœ€è¦æ‰¹é‡ç®¡ç†å¤šå°è®¾å¤‡å‡çº§

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter OTA Provideré›†ç¾¤ï¼Œç»“åˆPostgreSQLå­˜å‚¨å‡çº§çŠ¶æ€å’Œè¿›åº¦ï¼Œå®ç°å®‰å…¨å¯é çš„å›ºä»¶å‡çº§ç®¡ç†ã€‚

### 13.2 Schemaå®šä¹‰

**OTAå‡çº§ç®¡ç†Schema**ï¼š

```json
{
  "ota_provider": {
    "provider_node_id": 1000,
    "provider_fabric_id": 1,
    "software_version": "2.1.0",
    "software_version_string": "v2.1.0-stable",
    "update_token": "OTA-TOKEN-001",
    "user_consent_needed": false,
    "metadata_for_requestor": {
      "release_notes": "Bug fixes and performance improvements",
      "release_date": "2025-02-01"
    }
  },
  "target_devices": [
    {
      "device_id": "MATTER_LIGHT_001",
      "current_version": "2.0.0",
      "target_version": "2.1.0",
      "update_state": "downloading",
      "progress_percent": 45,
      "download_timestamp": "2025-02-14T10:30:00Z"
    }
  ]
}
```

### 13.3 å®ç°ä»£ç 

```python
from datetime import datetime
from typing import List, Dict

class MatterOTAManager:
    """Matter OTAå‡çº§ç®¡ç†å™¨"""

    OTA_STATUS = ["Idle", "Querying", "Delayed", "Downloading", "Applying", "Rebooting", "Complete", "Error"]

    def __init__(self, storage: MatterStorage):
        self.storage = storage

    def query_image_availability(self, device_id: str, current_version: str) -> Dict:
        """æŸ¥è¯¢å¯ç”¨å‡çº§é•œåƒ"""
        # å®é™…å®ç°ä¸­è°ƒç”¨OTA Providerçš„QueryImageå‘½ä»¤
        available_versions = ["2.1.0", "2.1.1", "2.2.0"]

        if current_version in available_versions:
            idx = available_versions.index(current_version)
            if idx < len(available_versions) - 1:
                return {
                    "available": True,
                    "version": available_versions[idx + 1],
                    "url": f"https://ota.example.com/firmware/v{available_versions[idx + 1]}.bin"
                }

        return {"available": False}

    def initiate_ota_update(self, device_id: str, firmware_version: str,
                           firmware_url: str, checksum: str) -> int:
        """å¯åŠ¨OTAå‡çº§"""
        update_id = self.storage.store_firmware_update(
            device_id=device_id,
            firmware_version=firmware_version,
            firmware_url=firmware_url,
            firmware_checksum=checksum
        )

        self.storage.update_firmware_status(update_id, "Downloading")

        print(f"OTA update initiated: {update_id} for {device_id} to version {firmware_version}")
        return update_id

    def update_progress(self, update_id: int, progress_percent: int):
        """æ›´æ–°å‡çº§è¿›åº¦"""
        # å­˜å‚¨è¿›åº¦åˆ°äº‹ä»¶æ—¥å¿—
        self.storage.store_event(
            device_id="OTA_SYSTEM",
            event_type="ota_progress",
            event_data={
                "update_id": update_id,
                "progress": progress_percent
            }
        )

        if progress_percent >= 100:
            self.storage.update_firmware_status(update_id, "Applying")

    def complete_update(self, update_id: int, success: bool, error_message: str = None):
        """å®Œæˆå‡çº§"""
        if success:
            self.storage.update_firmware_status(update_id, "Completed")
        else:
            self.storage.update_firmware_status(
                update_id, "Failed", error_message
            )

    def get_update_status(self, device_id: str) -> Dict:
        """è·å–å‡çº§çŠ¶æ€"""
        updates = self.storage.get_firmware_updates(device_id=device_id)
        if updates:
            latest = updates[0]
            return {
                "device_id": device_id,
                "current_version": latest.get("firmware_version"),
                "status": latest.get("update_status"),
                "progress": self._calculate_progress(latest),
                "started_at": latest.get("started_at"),
                "completed_at": latest.get("completed_at")
            }
        return {"device_id": device_id, "status": "No updates"}

    def _calculate_progress(self, update_record: Dict) -> int:
        """è®¡ç®—å‡çº§è¿›åº¦"""
        status = update_record.get("update_status")
        progress_map = {
            "Pending": 0,
            "Downloading": 50,
            "Applying": 80,
            "Completed": 100,
            "Failed": 0
        }
        return progress_map.get(status, 0)

    def batch_update(self, device_ids: List[str], firmware_version: str) -> Dict:
        """æ‰¹é‡å‡çº§è®¾å¤‡"""
        results = {
            "total": len(device_ids),
            "initiated": 0,
            "failed": 0,
            "update_ids": []
        }

        for device_id in device_ids:
            try:
                update_id = self.initiate_ota_update(
                    device_id, firmware_version,
                    f"https://ota.example.com/firmware/v{firmware_version}.bin",
                    checksum="sha256:abc123..."
                )
                results["initiated"] += 1
                results["update_ids"].append(update_id)
            except Exception as e:
                results["failed"] += 1
                print(f"Failed to initiate update for {device_id}: {e}")

        return results

# ä½¿ç”¨ç¤ºä¾‹
def demo_ota_update():
    storage = MatterStorage("postgresql://user:pass@localhost/matter")
    ota_manager = MatterOTAManager(storage)

    # æ£€æŸ¥å‡çº§å¯ç”¨æ€§
    availability = ota_manager.query_image_availability("MATTER_LIGHT_001", "2.0.0")
    print(f"Update available: {availability}")

    if availability.get("available"):
        # å¯åŠ¨å‡çº§
        update_id = ota_manager.initiate_ota_update(
            device_id="MATTER_LIGHT_001",
            firmware_version=availability["version"],
            firmware_url=availability["url"],
            checksum="sha256:abc123..."
        )

        # æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
        for progress in [25, 50, 75, 100]:
            ota_manager.update_progress(update_id, progress)

        # å®Œæˆå‡çº§
        ota_manager.complete_update(update_id, success=True)
```

---

## 14. æ¡ˆä¾‹14ï¼šMatteræ¡¥æ¥è®¾å¤‡ç®¡ç†

### 14.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matter Bridgeè®¾å¤‡å¯ä»¥å°†éMatterè®¾å¤‡ï¼ˆå¦‚Zigbeeã€Z-Waveè®¾å¤‡ï¼‰æ¡¥æ¥åˆ°Matterç½‘ç»œã€‚éœ€è¦ç®¡ç†æ¡¥æ¥è®¾å¤‡ã€æ˜ å°„é›†ç¾¤ã€å¤„ç†è®¾å¤‡å‘ç°å’Œèƒ½åŠ›è½¬æ¢ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦åŠ¨æ€å‘ç°æ¡¥æ¥è®¾å¤‡
- éœ€è¦å¤„ç†åè®®å·®å¼‚çš„æ˜ å°„
- éœ€è¦ç®¡ç†æ¡¥æ¥è®¾å¤‡çš„ç”Ÿå‘½å‘¨æœŸ
- éœ€è¦å¤„ç†è®¾å¤‡å¯è¾¾æ€§å˜åŒ–

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter Bridged Device Basic Informationé›†ç¾¤ï¼Œç»“åˆPostgreSQLå­˜å‚¨æ¡¥æ¥å…³ç³»å’Œè®¾å¤‡ä¿¡æ¯ã€‚

### 14.2 Schemaå®šä¹‰

**æ¡¥æ¥è®¾å¤‡ç®¡ç†Schema**ï¼š

```json
{
  "bridge_device": {
    "device_id": "MATTER_BRIDGE_001",
    "bridge_type": "Zigbee",
    "firmware_version": "1.2.0"
  },
  "bridged_devices": [
    {
      "bridged_device_id": "ZIGBEE_SENSOR_001",
      "vendor_name": "Aqara",
      "product_name": "Temperature Sensor",
      "unique_id": "00:11:22:33:44:55:66:77",
      "endpoint": 1,
      "clusters": [
        {
          "cluster_id": 1026,
          "cluster_name": "TemperatureMeasurement",
          "attributes": {
            "MeasuredValue": 2560
          }
        }
      ],
      "reachable": true
    }
  ]
}
```

### 14.3 å®ç°ä»£ç 

```python
class MatterBridgeManager:
    """Matteræ¡¥æ¥è®¾å¤‡ç®¡ç†å™¨"""

    def __init__(self, storage: MatterStorage):
        self.storage = storage

    def discover_bridged_devices(self, bridge_id: str) -> List[Dict]:
        """å‘ç°æ¡¥æ¥è®¾å¤‡"""
        # å®é™…å®ç°ä¸­è°ƒç”¨Bridgeçš„Device DiscoveryåŠŸèƒ½
        # æ¨¡æ‹Ÿå‘ç°çš„è®¾å¤‡
        discovered = [
            {
                "unique_id": "00:11:22:33:44:55:66:77",
                "vendor": "Aqara",
                "product": "Temperature Sensor",
                "endpoint": 1,
                "clusters": [1026]  # TemperatureMeasurement
            }
        ]

        for device in discovered:
            self.storage.store_bridged_device(
                bridge_id=bridge_id,
                bridged_id=device["unique_id"],
                vendor=device["vendor"],
                product=device["product"],
                unique_id=device["unique_id"],
                endpoint=device["endpoint"]
            )

        return discovered

    def map_cluster(self, bridged_device_id: str, native_cluster: int) -> int:
        """æ˜ å°„åŸç”Ÿé›†ç¾¤åˆ°Matteré›†ç¾¤"""
        # é›†ç¾¤æ˜ å°„è¡¨
        cluster_map = {
            # Zigbee to Matter
            0x0006: 0x0006,   # On/Off
            0x0008: 0x0008,   # Level Control
            0x0300: 0x0300,   # Color Control
            0x0402: 0x0402,   # Temperature Measurement
            # Z-Wave to Matter
            0x25: 0x0006,     # Binary Switch -> On/Off
            0x26: 0x0008,     # Multilevel Switch -> Level Control
        }
        return cluster_map.get(native_cluster, native_cluster)

    def update_bridged_device_reachability(self, bridge_id: str,
                                          bridged_id: str, reachable: bool):
        """æ›´æ–°æ¡¥æ¥è®¾å¤‡å¯è¾¾æ€§"""
        # æŸ¥è¯¢å¹¶æ›´æ–°å¯è¾¾æ€§çŠ¶æ€
        self.storage.store_event(
            device_id=bridge_id,
            event_type="bridged_device_reachability",
            event_data={
                "bridged_device_id": bridged_id,
                "reachable": reachable,
                "timestamp": datetime.now().isoformat()
            }
        )

        print(f"Bridged device {bridged_id} reachability updated: {reachable}")

    def remove_bridged_device(self, bridge_id: str, bridged_id: str):
        """ç§»é™¤æ¡¥æ¥è®¾å¤‡"""
        # å®é™…å®ç°ä¸­éœ€è¦è°ƒç”¨Bridgeçš„RemoveBridgedDeviceå‘½ä»¤
        print(f"Removing bridged device {bridged_id} from bridge {bridge_id}")

    def get_bridged_devices(self, bridge_id: str) -> List[Dict]:
        """è·å–æ¡¥æ¥è®¾å¤‡åˆ—è¡¨"""
        # æŸ¥è¯¢æ•°æ®åº“è·å–æ¡¥æ¥è®¾å¤‡
        self.storage.cur.execute("""
            SELECT bridged_device_id, vendor_name, product_name,
                   unique_id, bridged_endpoint, reachable
            FROM matter_bridged_devices
            WHERE bridge_device_id = %s
        """, (bridge_id,))
        return [
            {
                "bridged_id": row[0],
                "vendor": row[1],
                "product": row[2],
                "unique_id": row[3],
                "endpoint": row[4],
                "reachable": row[5]
            }
            for row in self.storage.cur.fetchall()
        ]

# ä½¿ç”¨ç¤ºä¾‹
def demo_bridge_management():
    storage = MatterStorage("postgresql://user:pass@localhost/matter")
    bridge_manager = MatterBridgeManager(storage)

    # å‘ç°æ¡¥æ¥è®¾å¤‡
    devices = bridge_manager.discover_bridged_devices("MATTER_BRIDGE_001")
    print(f"Discovered {len(devices)} bridged devices")

    # è·å–æ¡¥æ¥è®¾å¤‡åˆ—è¡¨
    bridged = bridge_manager.get_bridged_devices("MATTER_BRIDGE_001")
    for device in bridged:
        print(f"  - {device['vendor']} {device['product']} ({device['unique_id']})")
```

---

## 15. æ¡ˆä¾‹15ï¼šMatterè®¾å¤‡è®¢é˜…ä¸äº‹ä»¶ç®¡ç†

### 15.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matterè®¢é˜…æœºåˆ¶å…è®¸æ§åˆ¶å™¨å®æ—¶æ¥æ”¶è®¾å¤‡çŠ¶æ€å˜åŒ–é€šçŸ¥ã€‚éœ€è¦ç®¡ç†è®¢é˜…ç”Ÿå‘½å‘¨æœŸã€å¤„ç†è®¢é˜…è¶…æ—¶ã€ä¼˜åŒ–è®¢é˜…é—´éš”ä»¥å¹³è¡¡å®æ—¶æ€§å’Œç½‘ç»œè´Ÿè½½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦ç®¡ç†å¤§é‡è®¢é˜…
- éœ€è¦å¤„ç†è®¢é˜…è¶…æ—¶å’Œé‡è¿
- éœ€è¦ä¼˜åŒ–è®¢é˜…é—´éš”
- éœ€è¦å¤„ç†äº‹ä»¶ä¸¢å¤±

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter Subscribeäº¤äº’ï¼Œç»“åˆPostgreSQLå­˜å‚¨è®¢é˜…ä¿¡æ¯å’Œäº‹ä»¶å†å²ï¼Œå®ç°å¯é çš„è®¢é˜…ç®¡ç†ã€‚

### 15.2 Schemaå®šä¹‰

**è®¢é˜…ä¸äº‹ä»¶ç®¡ç†Schema**ï¼š

```json
{
  "subscription": {
    "subscription_id": 1,
    "device_id": "MATTER_LIGHT_001",
    "endpoint_id": 1,
    "cluster_id": 6,
    "attribute_id": 0,
    "min_interval": 0,
    "max_interval": 60,
    "is_active": true,
    "last_report": "2025-02-14T10:30:00Z"
  },
  "events": [
    {
      "event_id": 1,
      "event_number": 100,
      "priority": "Info",
      "timestamp": "2025-02-14T10:30:00Z",
      "data": {
        "new_value": true,
        "previous_value": false
      }
    }
  ]
}
```

### 15.3 å®ç°ä»£ç 

```python
class MatterSubscriptionManager:
    """Matterè®¢é˜…ç®¡ç†å™¨"""

    def __init__(self, storage: MatterStorage):
        self.storage = storage
        self.active_subscriptions = {}

    def create_subscription(self, device_id: str, endpoint_id: int,
                           cluster_id: int, attribute_id: int = None,
                           min_interval: int = 0, max_interval: int = 60) -> int:
        """åˆ›å»ºè®¢é˜…"""
        subscription_id = self._generate_subscription_id()

        sub_db_id = self.storage.create_subscription(
            subscription_id=subscription_id,
            device_id=device_id,
            endpoint_id=endpoint_id,
            cluster_id=cluster_id,
            attribute_id=attribute_id,
            min_interval=min_interval,
            max_interval=max_interval
        )

        self.active_subscriptions[subscription_id] = {
            "device_id": device_id,
            "endpoint_id": endpoint_id,
            "cluster_id": cluster_id,
            "attribute_id": attribute_id,
            "min_interval": min_interval,
            "max_interval": max_interval
        }

        print(f"Subscription created: ID={subscription_id}, DB_ID={sub_db_id}")
        return subscription_id

    def _generate_subscription_id(self) -> int:
        """ç”Ÿæˆè®¢é˜…ID"""
        import random
        return random.randint(1, 0xFFFFFFFF)

    def handle_report_data(self, subscription_id: int, data: Dict):
        """å¤„ç†è®¢é˜…æŠ¥å‘Šæ•°æ®"""
        # æ›´æ–°æœ€åæŠ¥å‘Šæ—¶é—´
        sub_info = self.active_subscriptions.get(subscription_id)
        if sub_info:
            self.storage.update_subscription_report(
                sub_info["device_id"], subscription_id
            )

        # å­˜å‚¨å±æ€§æ›´æ–°
        if sub_info:
            self.storage.store_attribute(
                device_id=sub_info["device_id"],
                endpoint_id=sub_info["endpoint_id"],
                cluster_id=sub_info["cluster_id"],
                attribute_id=sub_info["attribute_id"] or 0,
                attribute_name="subscribed_value",
                attribute_value=data
            )

        print(f"Report received for subscription {subscription_id}: {data}")

    def check_subscription_health(self) -> List[Dict]:
        """æ£€æŸ¥è®¢é˜…å¥åº·çŠ¶æ€"""
        stats = self.storage.get_subscription_statistics()

        # æ‰¾å‡ºè¶…æ—¶è®¢é˜…
        stale_subs = []
        for sub_id, sub_info in self.active_subscriptions.items():
            # æ£€æŸ¥æœ€åæŠ¥å‘Šæ—¶é—´
            pass  # å®é™…å®ç°ä¸­æŸ¥è¯¢æ•°æ®åº“

        return [
            {
                "total_subscriptions": stats.get("total", 0),
                "active_subscriptions": stats.get("active", 0),
                "stale_subscriptions": stats.get("stale", 0)
            }
        ]

    def optimize_subscriptions(self, device_id: str = None):
        """ä¼˜åŒ–è®¢é˜…é—´éš”"""
        # åˆ†æäº‹ä»¶é¢‘ç‡ï¼Œè°ƒæ•´è®¢é˜…é—´éš”
        # é«˜é¢‘å˜åŒ–å±æ€§ï¼šå‡å°max_interval
        # ä½é¢‘å˜åŒ–å±æ€§ï¼šå¢å¤§max_interval
        pass

    def unsubscribe(self, subscription_id: int):
        """å–æ¶ˆè®¢é˜…"""
        sub_info = self.active_subscriptions.get(subscription_id)
        if sub_info:
            self.storage.deactivate_subscription(
                sub_info["device_id"], subscription_id
            )
            del self.active_subscriptions[subscription_id]
            print(f"Subscription {subscription_id} unsubscribed")

# ä½¿ç”¨ç¤ºä¾‹
def demo_subscription():
    storage = MatterStorage("postgresql://user:pass@localhost/matter")
    sub_manager = MatterSubscriptionManager(storage)

    # åˆ›å»ºè®¢é˜…
    sub_id = sub_manager.create_subscription(
        device_id="MATTER_LIGHT_001",
        endpoint_id=1,
        cluster_id=6,  # On/Off
        attribute_id=0,  # OnOff
        min_interval=0,
        max_interval=10
    )

    # æ¨¡æ‹Ÿæ¥æ”¶æŠ¥å‘Š
    sub_manager.handle_report_data(sub_id, {"value": True})

    # æ£€æŸ¥è®¢é˜…å¥åº·
    health = sub_manager.check_subscription_health()
    print(f"Subscription health: {health}")
```

---

## 16. æ¡ˆä¾‹16ï¼šMatterç½‘ç»œæ‹“æ‰‘åˆ†æä¸ä¼˜åŒ–

### 16.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
Matter over Threadç½‘ç»œéœ€è¦åˆ†æå’Œä¼˜åŒ–ç½‘ç»œæ‹“æ‰‘ï¼Œç¡®ä¿è‰¯å¥½çš„è¿æ¥æ€§å’Œä½å»¶è¿Ÿã€‚éœ€è¦åˆ†æè·¯ç”±å™¨åˆ†å¸ƒã€é“¾è·¯è´¨é‡ã€ç½‘ç»œç›´å¾„ç­‰æŒ‡æ ‡ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¶é›†ç½‘ç»œæ‹“æ‰‘ä¿¡æ¯
- éœ€è¦åˆ†æé“¾è·¯è´¨é‡å’ŒRSSI
- éœ€è¦è¯†åˆ«ç½‘ç»œç“¶é¢ˆ
- éœ€è¦ä¼˜åŒ–è·¯ç”±å™¨å¸ƒå±€

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Thread Network Dataå’ŒMatter Network Commissioningé›†ç¾¤è·å–ç½‘ç»œä¿¡æ¯ï¼Œç»“åˆPostgreSQLå­˜å‚¨å’Œåˆ†æç½‘ç»œæ‹“æ‰‘ã€‚

### 16.2 Schemaå®šä¹‰

**ç½‘ç»œæ‹“æ‰‘åˆ†æSchema**ï¼š

```json
{
  "network_analysis": {
    "fabric_id": 1,
    "timestamp": "2025-02-14T10:30:00Z",
    "topology": {
      "total_nodes": 15,
      "routers": 5,
      "end_devices": 10,
      "network_diameter": 4
    },
    "link_quality": {
      "avg_rssi": -65,
      "avg_lqi": 220,
      "weak_links": [
        {
          "source": "NODE_001",
          "target": "NODE_002",
          "rssi": -82,
          "lqi": 120
        }
      ]
    },
    "recommendations": [
      "è€ƒè™‘åœ¨å®¢å…åŒºåŸŸå¢åŠ ä¸€ä¸ªè·¯ç”±å™¨ä»¥æ”¹å–„è¿æ¥"
    ]
  }
}
```

### 16.3 å®ç°ä»£ç 

```python
class MatterNetworkAnalyzer:
    """Matterç½‘ç»œåˆ†æå™¨"""

    def __init__(self, storage: MatterStorage):
        self.storage = storage

    def collect_network_topology(self, fabric_id: int) -> Dict:
        """æ”¶é›†ç½‘ç»œæ‹“æ‰‘"""
        # è·å–ç½‘ç»œå¥åº·è§†å›¾
        health_data = self.storage.get_network_health_report()
        fabric_health = next(
            (h for h in health_data if h.get("fabric_id") == fabric_id),
            None
        )

        if not fabric_health:
            return {}

        return {
            "fabric_id": fabric_id,
            "total_nodes": fabric_health.get("device_count", 0),
            "avg_rssi": fabric_health.get("avg_rssi"),
            "avg_lqi": fabric_health.get("avg_lqi"),
            "online_percentage": fabric_health.get("online_percentage")
        }

    def analyze_link_quality(self, fabric_id: int) -> Dict:
        """åˆ†æé“¾è·¯è´¨é‡"""
        # è·å–æ‰€æœ‰è®¾å¤‡çš„ç½‘ç»œä¿¡æ¯
        devices = self.storage.get_all_devices()

        link_stats = {
            "excellent": 0,  # LQI > 220
            "good": 0,       # LQI 180-220
            "fair": 0,       # LQI 120-180
            "poor": 0        # LQI < 120
        }

        weak_links = []

        for device in devices:
            network_info = self.storage.get_network_info_by_device(device["device_id"])
            for info in network_info:
                lqi = info.get("lqi", 0)
                rssi = info.get("rssi", -100)

                if lqi > 220:
                    link_stats["excellent"] += 1
                elif lqi > 180:
                    link_stats["good"] += 1
                elif lqi > 120:
                    link_stats["fair"] += 1
                else:
                    link_stats["poor"] += 1
                    weak_links.append({
                        "device_id": device["device_id"],
                        "rssi": rssi,
                        "lqi": lqi
                    })

        return {
            "link_distribution": link_stats,
            "weak_links": weak_links[:10]  # è¿”å›å‰10ä¸ªå¼±é“¾æ¥
        }

    def generate_optimization_recommendations(self, fabric_id: int) -> List[str]:
        """ç”Ÿæˆä¼˜åŒ–å»ºè®®"""
        recommendations = []

        topology = self.collect_network_topology(fabric_id)
        link_analysis = self.analyze_link_quality(fabric_id)

        # æ£€æŸ¥åœ¨çº¿ç‡
        if topology.get("online_percentage", 100) < 95:
            recommendations.append(
                f"ç½‘ç»œåœ¨çº¿ç‡è¾ƒä½({topology['online_percentage']}%)ï¼Œå»ºè®®æ£€æŸ¥ç¦»çº¿è®¾å¤‡"
            )

        # æ£€æŸ¥é“¾è·¯è´¨é‡
        poor_count = link_analysis["link_distribution"].get("poor", 0)
        total_links = sum(link_analysis["link_distribution"].values())

        if total_links > 0 and poor_count / total_links > 0.2:
            recommendations.append(
                f"å¼±é“¾æ¥æ¯”ä¾‹è¾ƒé«˜({poor_count}/{total_links})ï¼Œå»ºè®®ä¼˜åŒ–è®¾å¤‡ä½ç½®æˆ–å¢åŠ è·¯ç”±å™¨"
            )

        # æ£€æŸ¥RSSI
        avg_rssi = topology.get("avg_rssi", -50)
        if avg_rssi < -75:
            recommendations.append(
                f"å¹³å‡ä¿¡å·å¼ºåº¦è¾ƒå¼±({avg_rssi}dBm)ï¼Œå»ºè®®å¢åŠ Threadè·¯ç”±å™¨"
            )

        if not recommendations:
            recommendations.append("ç½‘ç»œçŠ¶å†µè‰¯å¥½ï¼Œæ— éœ€ä¼˜åŒ–")

        return recommendations

    def store_network_diagnosis(self, fabric_id: int, diagnosis_data: Dict):
        """å­˜å‚¨ç½‘ç»œè¯Šæ–­ç»“æœ"""
        self.storage.store_network_diagnostic(
            device_id=f"FABRIC_{fabric_id}",
            diagnostic_type="network_topology",
            result_data=diagnosis_data
        )

    def generate_network_report(self, fabric_id: int) -> Dict:
        """ç”Ÿæˆç½‘ç»œæŠ¥å‘Š"""
        topology = self.collect_network_topology(fabric_id)
        link_analysis = self.analyze_link_quality(fabric_id)
        recommendations = self.generate_optimization_recommendations(fabric_id)

        report = {
            "fabric_id": fabric_id,
            "timestamp": datetime.now().isoformat(),
            "topology": topology,
            "link_analysis": link_analysis,
            "recommendations": recommendations
        }

        # å­˜å‚¨æŠ¥å‘Š
        self.store_network_diagnosis(fabric_id, report)

        return report

# ä½¿ç”¨ç¤ºä¾‹
def demo_network_analysis():
    storage = MatterStorage("postgresql://user:pass@localhost/matter")
    analyzer = MatterNetworkAnalyzer(storage)

    # æ”¶é›†ç½‘ç»œæ‹“æ‰‘
    topology = analyzer.collect_network_topology(fabric_id=1)
    print(f"Network topology: {topology}")

    # åˆ†æé“¾è·¯è´¨é‡
    link_quality = analyzer.analyze_link_quality(fabric_id=1)
    print(f"Link quality: {link_quality}")

    # ç”Ÿæˆä¼˜åŒ–å»ºè®®
    recommendations = analyzer.generate_optimization_recommendations(fabric_id=1)
    print(f"Recommendations: {recommendations}")

    # ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
    report = analyzer.generate_network_report(fabric_id=1)
    print(f"Network report generated: {report['timestamp']}")
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-14ï¼ˆæ–°å¢5ä¸ªMatteré«˜çº§æ¡ˆä¾‹ï¼‰

# Matter Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [Matter Schemaå®è·µæ¡ˆä¾‹](#matter-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šMatter On/Off Lightæ§åˆ¶](#2-æ¡ˆä¾‹1matter-onoff-lightæ§åˆ¶)
    - [2.1 åœºæ™¯æè¿°](#21-åœºæ™¯æè¿°)
    - [2.2 Schemaå®šä¹‰](#22-schemaå®šä¹‰)
    - [2.3 å®ç°ä»£ç ](#23-å®ç°ä»£ç )
  - [3. æ¡ˆä¾‹2ï¼šMatter Door Lockæ§åˆ¶](#3-æ¡ˆä¾‹2matter-door-lockæ§åˆ¶)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 Schemaå®šä¹‰](#32-schemaå®šä¹‰)
    - [3.3 å®ç°ä»£ç ](#33-å®ç°ä»£ç )
  - [4. æ¡ˆä¾‹3ï¼šMatter Thermostatæ§åˆ¶](#4-æ¡ˆä¾‹3matter-thermostatæ§åˆ¶)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 Schemaå®šä¹‰](#42-schemaå®šä¹‰)
    - [4.3 å®ç°ä»£ç ](#43-å®ç°ä»£ç )
  - [5. æ¡ˆä¾‹4ï¼šMatterè®¾å¤‡å‘ç°å’Œç®¡ç†](#5-æ¡ˆä¾‹4matterè®¾å¤‡å‘ç°å’Œç®¡ç†)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 å®ç°ä»£ç ](#52-å®ç°ä»£ç )
  - [6. æ¡ˆä¾‹5ï¼šMatter Color Lightæ§åˆ¶](#6-æ¡ˆä¾‹5matter-color-lightæ§åˆ¶)
    - [6.1 åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2 å®ç°ä»£ç ](#62-å®ç°ä»£ç )
  - [7. æ¡ˆä¾‹6ï¼šMatteræ•°æ®å­˜å‚¨å’Œåˆ†æ](#7-æ¡ˆä¾‹6matteræ•°æ®å­˜å‚¨å’Œåˆ†æ)
    - [7.1 åœºæ™¯æè¿°](#71-åœºæ™¯æè¿°)
    - [7.2 å®ç°ä»£ç ](#72-å®ç°ä»£ç )
    - [7.3 æ•°æ®åˆ†æç¤ºä¾‹](#73-æ•°æ®åˆ†æç¤ºä¾‹)
  - [8. æ¡ˆä¾‹7ï¼šMatterè®¾å¤‡ç»„æ§åˆ¶](#8-æ¡ˆä¾‹7matterè®¾å¤‡ç»„æ§åˆ¶)
    - [8.1 åœºæ™¯æè¿°](#81-åœºæ™¯æè¿°)
    - [8.2 Schemaå®šä¹‰](#82-schemaå®šä¹‰)
    - [8.3 å®ç°ä»£ç ](#83-å®ç°ä»£ç )
  - [9. æ¡ˆä¾‹8ï¼šMatterè®¾å¤‡å›ºä»¶å‡çº§](#9-æ¡ˆä¾‹8matterè®¾å¤‡å›ºä»¶å‡çº§)
    - [9.1 åœºæ™¯æè¿°](#91-åœºæ™¯æè¿°)
    - [9.2 Schemaå®šä¹‰](#92-schemaå®šä¹‰)
    - [9.3 å®ç°ä»£ç ](#93-å®ç°ä»£ç )

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›Matter Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šMatter On/Off Lightæ§åˆ¶

### 2.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶æ™ºèƒ½å¼€å…³ç¯ï¼Œå®ç°è¿œç¨‹å¼€å…³æ§åˆ¶ã€
çŠ¶æ€æŸ¥è¯¢å’Œå®šæ—¶æ§åˆ¶åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å»ºç«‹Matterè®¾å¤‡è¿æ¥
- éœ€è¦å¤„ç†è®¾å¤‡ç¦»çº¿æƒ…å†µ
- éœ€è¦å®ç°çŠ¶æ€åŒæ­¥
- éœ€è¦è®°å½•æ“ä½œå†å²

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterDeviceControllerå°è£…Matter SDKï¼Œå®ç°è®¾å¤‡è¿æ¥ã€
å‘½ä»¤å‘é€å’ŒçŠ¶æ€æŸ¥è¯¢åŠŸèƒ½ã€‚

### 2.2 Schemaå®šä¹‰

**Matter On/Off Light Schema**ï¼š

```json
{
  "device_id": "LIGHT001",
  "device_type": "OnOffLight",
  "endpoint_id": 1,
  "node_id": 0x12344321,
  "clusters": [{
    "cluster_id": 0x0006,
    "cluster_name": "OnOff",
    "attributes": {
      "on_off": false,
      "global_scene_control": true,
      "on_time": 0,
      "off_wait_time": 0,
      "start_up_on_off": "Off"
    },
    "commands": {
      "on": {
        "command_id": 0x00,
        "parameters": {}
      },
      "off": {
        "command_id": 0x01,
        "parameters": {}
      },
      "toggle": {
        "command_id": 0x02,
        "parameters": {}
      }
    }
  }]
}
```

### 2.3 å®ç°ä»£ç 

**å®Œæ•´çš„On/Off Lightæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterOnOffLightController
from matter_storage import MatterStorage
from datetime import datetime

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
light_controller = MatterOnOffLightController("LIGHT001", 0x12344321)

async def control_on_off_light():
    """æ§åˆ¶On/Off Light"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await light_controller.connect()
        if not connected:
            print("Failed to connect to device")
            return

        # æ‰“å¼€ç¯å…‰
        print("Turning on light...")
        result = await light_controller.turn_on()
        if result:
            # è®°å½•å‘½ä»¤
            cmd_id = storage.store_command(
                "LIGHT001", 1, 0x0006, 0x00, "on", {}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Light turned on successfully")
        else:
            storage.update_command_status(cmd_id, "Failed")
            print("Failed to turn on light")

        # è·å–çŠ¶æ€
        state = await light_controller.get_state()
        print(f"Current light state: {state}")

        # ç­‰å¾…3ç§’
        await asyncio.sleep(3)

        # å…³é—­ç¯å…‰
        print("Turning off light...")
        result = await light_controller.turn_off()
        if result:
            cmd_id = storage.store_command(
                "LIGHT001", 1, 0x0006, 0x01, "off", {}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Light turned off successfully")

        # åˆ‡æ¢ç¯å…‰
        print("Toggling light...")
        result = await light_controller.toggle()
        if result:
            cmd_id = storage.store_command(
                "LIGHT001", 1, 0x0006, 0x02, "toggle", {}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Light toggled successfully")

        # æ–­å¼€è¿æ¥
        await light_controller.disconnect()

    except Exception as e:
        print(f"Error controlling light: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_on_off_light())
```

---

## 3. æ¡ˆä¾‹2ï¼šMatter Door Lockæ§åˆ¶

### 3.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶æ™ºèƒ½é—¨é”ï¼Œå®ç°è¿œç¨‹å¼€é”ã€é”å®šã€
çŠ¶æ€æŸ¥è¯¢å’ŒPINç éªŒè¯åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®‰å…¨çš„PINç éªŒè¯
- éœ€è¦å¤„ç†é—¨é”çŠ¶æ€å˜åŒ–äº‹ä»¶
- éœ€è¦è®°å½•å¼€é”å†å²
- éœ€è¦å¤„ç†å¼‚å¸¸æƒ…å†µï¼ˆå¦‚é—¨æœªå…³é—­ï¼‰

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterDoorLockControllerå®ç°é—¨é”æ§åˆ¶ï¼Œé›†æˆPINç éªŒè¯
å’Œäº‹ä»¶ç›‘å¬åŠŸèƒ½ã€‚

### 3.2 Schemaå®šä¹‰

**Matter Door Lock Schema**ï¼š

```json
{
  "device_id": "LOCK001",
  "device_type": "DoorLock",
  "endpoint_id": 1,
  "node_id": 0x12344322,
  "clusters": [{
    "cluster_id": 0x0101,
    "cluster_name": "DoorLock",
    "attributes": {
      "lock_state": 1,
      "lock_type": "DeadBolt",
      "actuator_enabled": true,
      "door_state": "Closed",
      "door_open_events": 0,
      "door_closed_events": 0,
      "open_period": 0
    },
    "commands": {
      "lock_door": {
        "command_id": 0x00,
        "parameters": {
          "pin_code": "1234"
        }
      },
      "unlock_door": {
        "command_id": 0x01,
        "parameters": {
          "pin_code": "1234"
        }
      }
    },
    "events": {
      "door_lock_alarm": {
        "event_id": 0x00,
        "alarm_code": "DoorForcedOpen"
      }
    }
  }]
}
```

### 3.3 å®ç°ä»£ç 

**å®Œæ•´çš„Door Lockæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterDoorLockController
from matter_storage import MatterStorage

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
lock_controller = MatterDoorLockController("LOCK001", 0x12344322)

async def control_door_lock():
    """æ§åˆ¶Door Lock"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await lock_controller.connect()
        if not connected:
            print("Failed to connect to door lock")
            return

        # è·å–å½“å‰é”çŠ¶æ€
        lock_state = await lock_controller.get_lock_state()
        print(f"Current lock state: {lock_state}")

        # å¦‚æœå·²é”å®šï¼Œåˆ™è§£é”
        if lock_state == "Locked":
            print("Unlocking door...")
            pin_code = "1234"  # å®é™…åº”ç”¨ä¸­åº”ä»å®‰å…¨å­˜å‚¨è·å–
            result = await lock_controller.unlock_door(pin_code)

            if result:
                cmd_id = storage.store_command(
                    "LOCK001", 1, 0x0101, 0x01, "unlock_door",
                    {"pin_code": "****"}  # ä¸å­˜å‚¨å®é™…PINç 
                )
                storage.update_command_status(cmd_id, "Success")

                # è®°å½•äº‹ä»¶
                storage.store_event(
                    "LOCK001", 1, 0x0101, 0x01, "DoorUnlocked",
                    {"timestamp": datetime.now().isoformat()}
                )
                print("Door unlocked successfully")
            else:
                print("Failed to unlock door")

        # ç­‰å¾…5ç§’
        await asyncio.sleep(5)

        # é”å®šé—¨
        print("Locking door...")
        result = await lock_controller.lock_door()

        if result:
            cmd_id = storage.store_command(
                "LOCK001", 1, 0x0101, 0x00, "lock_door", {}
            )
            storage.update_command_status(cmd_id, "Success")

            # è®°å½•äº‹ä»¶
            storage.store_event(
                "LOCK001", 1, 0x0101, 0x00, "DoorLocked",
                {"timestamp": datetime.now().isoformat()}
            )
            print("Door locked successfully")

        # å†æ¬¡è·å–çŠ¶æ€ç¡®è®¤
        lock_state = await lock_controller.get_lock_state()
        print(f"Final lock state: {lock_state}")

        # æ–­å¼€è¿æ¥
        await lock_controller.disconnect()

    except Exception as e:
        print(f"Error controlling door lock: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_door_lock())
```

---

## 4. æ¡ˆä¾‹3ï¼šMatter Thermostatæ§åˆ¶

### 4.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶æ™ºèƒ½æ¸©æ§å™¨ï¼Œå®ç°æ¸©åº¦è®¾ç½®ã€
æ¨¡å¼åˆ‡æ¢å’Œæ¸©åº¦ç›‘æ§åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®æ—¶è¯»å–æ¸©åº¦å€¼
- éœ€è¦è®¾ç½®ç›®æ ‡æ¸©åº¦
- éœ€è¦åˆ‡æ¢è¿è¡Œæ¨¡å¼ï¼ˆåˆ¶å†·/åˆ¶çƒ­/è‡ªåŠ¨ï¼‰
- éœ€è¦å¤„ç†æ¸©åº¦èŒƒå›´é™åˆ¶

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterThermostatControllerå®ç°æ¸©æ§å™¨æ§åˆ¶ï¼Œæ”¯æŒæ¸©åº¦
è¯»å–ã€è®¾ç½®å’Œæ¨¡å¼åˆ‡æ¢åŠŸèƒ½ã€‚

### 4.2 Schemaå®šä¹‰

**Matter Thermostat Schema**ï¼š

è¯¦è§ç¬¬4.2èŠ‚åŸå§‹å®šä¹‰ã€‚

### 4.3 å®ç°ä»£ç 

**å®Œæ•´çš„Thermostatæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterThermostatController
from matter_storage import MatterStorage
from datetime import datetime

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
thermostat_controller = MatterThermostatController("THERMOSTAT001", 0x12344323)

async def control_thermostat():
    """æ§åˆ¶Thermostat"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await thermostat_controller.connect()
        if not connected:
            print("Failed to connect to thermostat")
            return

        # è·å–å½“å‰æ¸©åº¦
        current_temp = await thermostat_controller.get_current_temperature()
        print(f"Current temperature: {current_temp}Â°C")

        # è®¾ç½®ç›®æ ‡æ¸©åº¦ä¸º26Â°Cï¼ˆåˆ¶å†·æ¨¡å¼ï¼‰
        print("Setting target temperature to 26Â°C (Cool mode)...")
        result = await thermostat_controller.set_target_temperature(26.0, "Cool")

        if result:
            # è®¾ç½®ç³»ç»Ÿæ¨¡å¼ä¸ºåˆ¶å†·
            await thermostat_controller.set_system_mode("Cool")

            # è®°å½•å‘½ä»¤
            cmd_id = storage.store_command(
                "THERMOSTAT001", 1, 0x0201, 0x00, "set_target_temperature",
                {"temperature": 26.0, "mode": "Cool"}
            )
            storage.update_command_status(cmd_id, "Success")
            print("Target temperature set successfully")

        # ç­‰å¾…å¹¶å†æ¬¡è¯»å–æ¸©åº¦
        await asyncio.sleep(5)
        current_temp = await thermostat_controller.get_current_temperature()
        print(f"Current temperature after setting: {current_temp}Â°C")

        # åˆ‡æ¢åˆ°è‡ªåŠ¨æ¨¡å¼
        print("Switching to Auto mode...")
        result = await thermostat_controller.set_system_mode("Auto")

        if result:
            cmd_id = storage.store_command(
                "THERMOSTAT001", 1, 0x0201, 0x00, "set_system_mode",
                {"mode": "Auto"}
            )
            storage.update_command_status(cmd_id, "Success")
            print("System mode switched to Auto")

        # æ–­å¼€è¿æ¥
        await thermostat_controller.disconnect()

    except Exception as e:
        print(f"Error controlling thermostat: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_thermostat())
```

---

## 5. æ¡ˆä¾‹4ï¼šMatterè®¾å¤‡å‘ç°å’Œç®¡ç†

### 5.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç³»ç»Ÿéœ€è¦è‡ªåŠ¨å‘ç°ç½‘ç»œä¸­çš„Matterè®¾å¤‡ï¼Œæ³¨å†Œè®¾å¤‡ä¿¡æ¯ï¼Œ
å¹¶å»ºç«‹è®¾å¤‡è¿æ¥æ± è¿›è¡Œç»Ÿä¸€ç®¡ç†ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å®ç°è®¾å¤‡å‘ç°åè®®
- éœ€è¦å¤„ç†è®¾å¤‡ä¸Šçº¿/ä¸‹çº¿
- éœ€è¦ç®¡ç†è®¾å¤‡è¿æ¥çŠ¶æ€
- éœ€è¦å­˜å‚¨è®¾å¤‡ä¿¡æ¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterDeviceDiscoveryå’ŒMatterDeviceManagerå®ç°è®¾å¤‡
å‘ç°å’Œç®¡ç†åŠŸèƒ½ã€‚

### 5.2 å®ç°ä»£ç 

**å®Œæ•´çš„è®¾å¤‡å‘ç°å’Œç®¡ç†å®ç°**ï¼š

```python
import asyncio
from matter_device_manager import MatterDeviceManager
from matter_storage import MatterStorage

# åˆå§‹åŒ–å­˜å‚¨å’Œç®¡ç†å™¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")
device_manager = MatterDeviceManager(storage)

async def discover_and_manage_devices():
    """å‘ç°å’Œç®¡ç†è®¾å¤‡"""
    try:
        # å‘ç°è®¾å¤‡
        print("Discovering Matter devices...")
        registered_ids = await device_manager.discover_and_register()
        print(f"Discovered and registered {len(registered_ids)} devices: {registered_ids}")

        # è¿æ¥æ‰€æœ‰è®¾å¤‡
        for device_id in registered_ids:
            print(f"Connecting to device {device_id}...")
            connected = await device_manager.connect_device(device_id)
            if connected:
                print(f"Device {device_id} connected successfully")
            else:
                print(f"Failed to connect to device {device_id}")

        # è·å–è®¾å¤‡æ§åˆ¶å™¨å¹¶æ‰§è¡Œæ“ä½œ
        light_controller = device_manager.get_controller("LIGHT001")
        if light_controller:
            # æ§åˆ¶ç¯å…‰
            await light_controller.turn_on()
            await asyncio.sleep(2)
            await light_controller.turn_off()

        # æ–­å¼€æ‰€æœ‰è®¾å¤‡
        for device_id in registered_ids:
            await device_manager.disconnect_device(device_id)
            print(f"Disconnected from device {device_id}")

    except Exception as e:
        print(f"Error in device discovery and management: {e}")

# è¿è¡Œç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(discover_and_manage_devices())
```

---

## 6. æ¡ˆä¾‹5ï¼šMatter Color Lightæ§åˆ¶

### 6.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ç”¨æˆ·éœ€è¦é€šè¿‡Matteråè®®æ§åˆ¶å½©è‰²æ™ºèƒ½ç¯ï¼Œå®ç°è‰²ç›¸ã€é¥±å’Œåº¦ã€
è‰²æ¸©å’Œäº®åº¦çš„ç²¾ç¡®æ§åˆ¶ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒå¤šç§é¢œè‰²ç©ºé—´ï¼ˆHSVã€RGBã€è‰²æ¸©ï¼‰
- éœ€è¦å®ç°é¢œè‰²è½¬æ¢
- éœ€è¦å¹³æ»‘çš„é¢œè‰²è¿‡æ¸¡
- éœ€è¦ä¿å­˜å’Œæ¢å¤é¢œè‰²åœºæ™¯

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨MatterColorLightControllerå®ç°å®Œæ•´çš„é¢œè‰²æ§åˆ¶åŠŸèƒ½ã€‚

### 6.2 å®ç°ä»£ç 

**å®Œæ•´çš„Color Lightæ§åˆ¶å®ç°**ï¼š

```python
import asyncio
from matter_device_controller import MatterColorLightController
from matter_storage import MatterStorage

# åˆå§‹åŒ–å­˜å‚¨
storage = MatterStorage("postgresql://user:pass@localhost/matter")

# åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
color_light_controller = MatterColorLightController("LIGHT003", 0x12344323)

async def control_color_light():
    """æ§åˆ¶Color Light"""
    try:
        # è¿æ¥è®¾å¤‡
        connected = await color_light_controller.connect()
        if not connected:
            print("Failed to connect to color light")
            return

        # æ‰“å¼€ç¯å…‰
        await color_light_controller.turn_on()

        # è®¾ç½®äº®åº¦ä¸º50%
        await color_light_controller.set_level(127)  # 127/254 = 50%
        print("Set brightness to 50%")

        # è®¾ç½®è‰²ç›¸å’Œé¥±å’Œåº¦ï¼ˆç»¿è‰²ï¼‰
        await color_light_controller.set_hue_saturation(120, 200)
        print("Set color to green (Hue: 120, Saturation: 200)")

        await asyncio.sleep(3)

        # è®¾ç½®è‰²æ¸©ï¼ˆæš–ç™½å…‰ï¼‰
        await color_light_controller.set_color_temperature(400)
        print("Set color temperature to 400 mireds (warm white)")

        await asyncio.sleep(3)

        # è·å–å½“å‰é¢œè‰²çŠ¶æ€
        hue_sat = await color_light_controller.get_hue_saturation()
        color_temp = await color_light_controller.get_color_temperature()
        level = await color_light_controller.get_level()

        print(f"Current color state:")
        print(f"  Hue: {hue_sat['hue']}, Saturation: {hue_sat['saturation']}")
        print(f"  Color Temperature: {color_temp} mireds")
        print(f"  Level: {level}/254")

        # å…³é—­ç¯å…‰
        await color_light_controller.turn_off()

        # æ–­å¼€è¿æ¥
        await color_light_controller.disconnect()

    except Exception as e:
        print(f"Error controlling color light: {e}")

# è¿è¡Œæ§åˆ¶ç¤ºä¾‹
if __name__ == "__main__":
    asyncio.run(control_color_light())
```

---

## 7. æ¡ˆä¾‹6ï¼šMatteræ•°æ®å­˜å‚¨å’Œåˆ†æ

### 7.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
ä½¿ç”¨PostgreSQLå­˜å‚¨Matterè®¾å¤‡æ•°æ®ï¼Œæ”¯æŒè®¾å¤‡çŠ¶æ€æŸ¥è¯¢ã€
å‘½ä»¤æ‰§è¡Œåˆ†æå’Œè®¾å¤‡ä½¿ç”¨ç»Ÿè®¡ã€‚

### 7.2 å®ç°ä»£ç 

è¯¦è§ `04_Transformation.md` ç¬¬6ç« ã€‚

### 7.3 æ•°æ®åˆ†æç¤ºä¾‹

**è®¾å¤‡ä½¿ç”¨ç»Ÿè®¡æŸ¥è¯¢**ï¼š

```python
from matter_storage import MatterStorage
from datetime import datetime, timedelta

storage = MatterStorage("postgresql://user:pass@localhost/matter")

# æŸ¥è¯¢è®¾å¤‡é›†ç¾¤ç»Ÿè®¡
clusters = storage.get_cluster_statistics("LIGHT001")
print("Device clusters:")
for cluster in clusters:
    print(f"  {cluster['cluster_name']}: {cluster['attribute_count']} attributes")

# æŸ¥è¯¢å‘½ä»¤æ‰§è¡Œç»Ÿè®¡
start_time = datetime.now() - timedelta(days=7)
cmd_stats = storage.get_command_statistics(start_time)
print("\nCommand statistics:")
for stat in cmd_stats:
    print(f"  {stat['command_name']}: {stat['count']} executions, "
          f"avg time: {stat['avg_execution_time']:.2f}s")

# æŸ¥è¯¢è®¾å¤‡ä½¿ç”¨ç»Ÿè®¡
usage_stats = storage.get_device_usage_statistics("LIGHT001", days=7)
print("\nDevice usage statistics:")
print(f"  Active days: {usage_stats['active_days']}")
print(f"  Total commands: {usage_stats['total_commands']}")
print(f"  Success rate: {usage_stats['success_commands'] / usage_stats['total_commands'] * 100:.1f}%")
print(f"  Avg response time: {usage_stats['avg_response_time']:.2f}s")
```

---

## 8. æ¡ˆä¾‹7ï¼šMatterè®¾å¤‡ç»„æ§åˆ¶

### 8.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
æ™ºèƒ½å®¶å±…åœºæ™¯ä¸­ï¼Œç”¨æˆ·éœ€è¦åŒæ—¶æ§åˆ¶å¤šä¸ªè®¾å¤‡ï¼Œä¾‹å¦‚ï¼š

- åŒæ—¶æ‰“å¼€/å…³é—­å¤šä¸ªæˆ¿é—´çš„ç¯å…‰
- åŒæ—¶è°ƒæ•´å¤šä¸ªæ¸©æ§å™¨çš„æ¸©åº¦
- åˆ›å»ºåœºæ™¯è”åŠ¨ï¼ˆå¦‚"å›å®¶æ¨¡å¼"ã€"ç¡çœ æ¨¡å¼"ï¼‰

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å°†å¤šä¸ªè®¾å¤‡ç»„ç»‡æˆç»„
- éœ€è¦æ”¯æŒç»„å†…è®¾å¤‡çš„æ‰¹é‡æ§åˆ¶
- éœ€è¦å¤„ç†ç»„å†…è®¾å¤‡çš„éƒ¨åˆ†å¤±è´¥æƒ…å†µ
- éœ€è¦è®°å½•ç»„æ“ä½œçš„æ‰§è¡Œå†å²

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matterè®¾å¤‡ç»„åŠŸèƒ½ï¼Œå°†å¤šä¸ªè®¾å¤‡ç»„ç»‡æˆé€»è¾‘ç»„ï¼Œå®ç°æ‰¹é‡æ§åˆ¶å’Œåœºæ™¯è”åŠ¨ã€‚

### 8.2 Schemaå®šä¹‰

**Matterè®¾å¤‡ç»„Schema**ï¼š

```json
{
  "group_id": 1,
  "group_name": "å®¢å…ç¯å…‰ç»„",
  "devices": [
    {
      "device_id": "LIGHT001",
      "endpoint_id": 1,
      "device_type": "DimmableLight"
    },
    {
      "device_id": "LIGHT002",
      "endpoint_id": 1,
      "device_type": "DimmableLight"
    },
    {
      "device_id": "LIGHT003",
      "endpoint_id": 1,
      "device_type": "ColorLight"
    }
  ],
  "scenes": [
    {
      "scene_id": "scene_bright",
      "scene_name": "æ˜äº®æ¨¡å¼",
      "actions": [
        {
          "device_id": "LIGHT001",
          "cluster_id": 0x0008,
          "command": "move_to_level",
          "parameters": {"level": 254, "transition_time": 0}
        },
        {
          "device_id": "LIGHT002",
          "cluster_id": 0x0008,
          "command": "move_to_level",
          "parameters": {"level": 254, "transition_time": 0}
        }
      ]
    }
  ]
}
```

### 8.3 å®ç°ä»£ç 

**å®Œæ•´çš„è®¾å¤‡ç»„æ§åˆ¶å®ç°**ï¼š

```python
import asyncio
import logging
from typing import List, Dict, Optional
from matter_device_controller import (
    MatterDeviceController,
    MatterDimmableLightController,
    MatterColorLightController
)
from matter_storage import MatterStorage

logger = logging.getLogger(__name__)

class MatterDeviceGroupController:
    """Matterè®¾å¤‡ç»„æ§åˆ¶å™¨"""

    def __init__(self, group_id: int, group_name: str, storage: MatterStorage):
        self.group_id = group_id
        self.group_name = group_name
        self.storage = storage
        self.devices: Dict[str, MatterDeviceController] = {}
        self.scenes: Dict[str, Dict] = {}

    async def initialize(self):
        """åˆå§‹åŒ–è®¾å¤‡ç»„"""
        # ä»å­˜å‚¨ä¸­åŠ è½½ç»„å†…è®¾å¤‡
        group_devices = self.storage.get_group_devices(self.group_id)

        for device_info in group_devices:
            device_id = device_info["device_id"]
            device_type = device_info["device_type"]

            # æ ¹æ®è®¾å¤‡ç±»å‹åˆ›å»ºæ§åˆ¶å™¨
            if device_type == "DimmableLight":
                controller = MatterDimmableLightController(
                    device_id,
                    device_info.get("node_id", 0x12344321),
                    device_info.get("endpoint_id", 1)
                )
            elif device_type == "ExtendedColorLight":
                controller = MatterColorLightController(
                    device_id,
                    device_info.get("node_id", 0x12344321),
                    device_info.get("endpoint_id", 1)
                )
            else:
                logger.warning(f"Unsupported device type: {device_type}")
                continue

            # è¿æ¥è®¾å¤‡
            if await controller.connect():
                self.devices[device_id] = controller
                logger.info(f"Added device {device_id} to group {self.group_name}")
            else:
                logger.error(f"Failed to connect device {device_id}")

    async def group_turn_on(self) -> Dict[str, bool]:
        """ç»„å†…æ‰€æœ‰è®¾å¤‡æ‰“å¼€"""
        results = {}

        for device_id, controller in self.devices.items():
            if isinstance(controller, MatterOnOffLightController):
                try:
                    result = await controller.turn_on()
                    results[device_id] = result
                except Exception as e:
                    logger.error(f"Failed to turn on {device_id}: {e}")
                    results[device_id] = False
            else:
                logger.warning(f"Device {device_id} does not support On/Off")
                results[device_id] = False

        return results

    async def group_turn_off(self) -> Dict[str, bool]:
        """ç»„å†…æ‰€æœ‰è®¾å¤‡å…³é—­"""
        results = {}

        for device_id, controller in self.devices.items():
            if isinstance(controller, MatterOnOffLightController):
                try:
                    result = await controller.turn_off()
                    results[device_id] = result
                except Exception as e:
                    logger.error(f"Failed to turn off {device_id}: {e}")
                    results[device_id] = False
            else:
                logger.warning(f"Device {device_id} does not support On/Off")
                results[device_id] = False

        return results

    async def group_set_level(self, level: int, transition_time: int = 0) -> Dict[str, bool]:
        """ç»„å†…æ‰€æœ‰å¯è°ƒå…‰è®¾å¤‡è®¾ç½®äº®åº¦"""
        results = {}

        for device_id, controller in self.devices.items():
            if isinstance(controller, MatterDimmableLightController):
                try:
                    result = await controller.set_level(level)
                    results[device_id] = result
                except Exception as e:
                    logger.error(f"Failed to set level for {device_id}: {e}")
                    results[device_id] = False
            else:
                logger.warning(f"Device {device_id} does not support level control")
                results[device_id] = False

        return results

    async def execute_scene(self, scene_id: str) -> Dict[str, bool]:
        """æ‰§è¡Œåœºæ™¯"""
        if scene_id not in self.scenes:
            logger.error(f"Scene {scene_id} not found")
            return {}

        scene = self.scenes[scene_id]
        results = {}

        # å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰åœºæ™¯åŠ¨ä½œ
        tasks = []
        for action in scene.get("actions", []):
            device_id = action["device_id"]
            controller = self.devices.get(device_id)

            if not controller:
                logger.error(f"Device {device_id} not found in group")
                results[device_id] = False
                continue

            # æ ¹æ®å‘½ä»¤ç±»å‹æ‰§è¡Œ
            command = action.get("command")
            parameters = action.get("parameters", {})

            if command == "turn_on":
                task = controller.turn_on()
            elif command == "turn_off":
                task = controller.turn_off()
            elif command == "move_to_level":
                task = controller.set_level(parameters.get("level", 128))
            elif command == "set_color_temperature":
                task = controller.set_color_temperature(parameters.get("color_temp_mireds", 250))
            else:
                logger.warning(f"Unknown command: {command}")
                results[device_id] = False
                continue

            tasks.append((device_id, task))

        # ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for device_id, task in tasks:
            try:
                result = await task
                results[device_id] = result
            except Exception as e:
                logger.error(f"Failed to execute action for {device_id}: {e}")
                results[device_id] = False

        return results

    def add_scene(self, scene_id: str, scene_name: str, actions: List[Dict]):
        """æ·»åŠ åœºæ™¯"""
        self.scenes[scene_id] = {
            "scene_id": scene_id,
            "scene_name": scene_name,
            "actions": actions
        }
        logger.info(f"Added scene {scene_name} to group {self.group_name}")

    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        for device_id, controller in self.devices.items():
            await controller.disconnect()

async def control_device_group():
    """è®¾å¤‡ç»„æ§åˆ¶ç¤ºä¾‹"""
    # åˆå§‹åŒ–å­˜å‚¨
    storage = MatterStorage("postgresql://user:pass@localhost/matter")

    # åˆ›å»ºè®¾å¤‡ç»„
    group_id = storage.create_device_group(1, "å®¢å…ç¯å…‰ç»„")

    # æ·»åŠ è®¾å¤‡åˆ°ç»„
    storage.add_device_to_group(1, "LIGHT001", 1)
    storage.add_device_to_group(1, "LIGHT002", 1)
    storage.add_device_to_group(1, "LIGHT003", 1)

    # åˆ›å»ºè®¾å¤‡ç»„æ§åˆ¶å™¨
    group_controller = MatterDeviceGroupController(1, "å®¢å…ç¯å…‰ç»„", storage)
    await group_controller.initialize()

    # æ‰§è¡Œç»„æ“ä½œ
    print("Turning on all devices in group...")
    results = await group_controller.group_turn_on()
    print(f"Results: {results}")

    # è®¾ç½®ç»„å†…æ‰€æœ‰è®¾å¤‡äº®åº¦
    print("\nSetting all devices to level 200...")
    results = await group_controller.group_set_level(200)
    print(f"Results: {results}")

    # æ·»åŠ åœºæ™¯
    group_controller.add_scene(
        "scene_bright",
        "æ˜äº®æ¨¡å¼",
        [
            {
                "device_id": "LIGHT001",
                "cluster_id": 0x0008,
                "command": "move_to_level",
                "parameters": {"level": 254}
            },
            {
                "device_id": "LIGHT002",
                "cluster_id": 0x0008,
                "command": "move_to_level",
                "parameters": {"level": 254}
            }
        ]
    )

    # æ‰§è¡Œåœºæ™¯
    print("\nExecuting scene 'bright'...")
    results = await group_controller.execute_scene("scene_bright")
    print(f"Results: {results}")

    # æ¸…ç†
    await group_controller.cleanup()
    storage.close()

if __name__ == "__main__":
    asyncio.run(control_device_group())
```

---

## 9. æ¡ˆä¾‹8ï¼šMatterè®¾å¤‡å›ºä»¶å‡çº§

### 9.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
æ™ºèƒ½å®¶å±…è®¾å¤‡éœ€è¦å®šæœŸè¿›è¡Œå›ºä»¶å‡çº§ï¼Œä»¥ä¿®å¤bugã€æ·»åŠ æ–°åŠŸèƒ½æˆ–æå‡æ€§èƒ½ã€‚Matteråè®®æ”¯æŒOTAï¼ˆOver-The-Airï¼‰å›ºä»¶å‡çº§åŠŸèƒ½ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒå›ºä»¶ç‰ˆæœ¬æ£€æŸ¥
- éœ€è¦æ”¯æŒå›ºä»¶ä¸‹è½½å’ŒéªŒè¯
- éœ€è¦æ”¯æŒå‡çº§è¿›åº¦ç›‘æ§
- éœ€è¦å¤„ç†å‡çº§å¤±è´¥å’Œå›æ»š
- éœ€è¦è®°å½•å‡çº§å†å²

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Matter OTAå‡çº§åŠŸèƒ½ï¼Œç»“åˆPostgreSQLå­˜å‚¨å‡çº§è®°å½•ï¼Œå®ç°å®Œæ•´çš„å›ºä»¶å‡çº§ç®¡ç†ã€‚

### 9.2 Schemaå®šä¹‰

**Matterå›ºä»¶å‡çº§Schema**ï¼š

```json
{
  "device_id": "LIGHT001",
  "current_firmware_version": "1.0.0",
  "target_firmware_version": "1.1.0",
  "firmware_info": {
    "firmware_url": "https://example.com/firmware/light_v1.1.0.bin",
    "firmware_size": 524288,
    "firmware_checksum": "sha256:abc123...",
    "firmware_format": "OTA",
    "min_hardware_version": 1,
    "max_hardware_version": 2
  },
  "upgrade_policy": {
    "auto_upgrade": false,
    "scheduled_time": "2025-01-22T02:00:00Z",
    "rollback_on_failure": true
  }
}
```

### 9.3 å®ç°ä»£ç 

**å®Œæ•´çš„å›ºä»¶å‡çº§å®ç°**ï¼š

```python
import asyncio
import logging
import hashlib
import aiohttp
from typing import Dict, Optional, Callable
from datetime import datetime
from matter_device_controller import MatterDeviceController
from matter_storage import MatterStorage

logger = logging.getLogger(__name__)

class MatterFirmwareUpdater:
    """Matterè®¾å¤‡å›ºä»¶å‡çº§å™¨"""

    def __init__(self, device_controller: MatterDeviceController,
                 storage: MatterStorage):
        self.device_controller = device_controller
        self.storage = storage
        self.device_id = device_controller.device_id
        self.upgrade_progress_callback: Optional[Callable] = None

    async def check_firmware_version(self) -> Optional[str]:
        """æ£€æŸ¥å½“å‰å›ºä»¶ç‰ˆæœ¬"""
        try:
            # è¯»å–Basic Clusterçš„SoftwareVersionå±æ€§
            version = await self.device_controller.read_attribute(
                0x0028,  # Basic Cluster
                0x0009   # SoftwareVersion
            )
            return version if version else None
        except Exception as e:
            logger.error(f"Failed to check firmware version: {e}")
            return None

    async def download_firmware(self, firmware_url: str) -> bytes:
        """ä¸‹è½½å›ºä»¶æ–‡ä»¶"""
        async with aiohttp.ClientSession() as session:
            async with session.get(firmware_url) as response:
                if response.status == 200:
                    firmware_data = await response.read()
                    logger.info(f"Downloaded firmware: {len(firmware_data)} bytes")
                    return firmware_data
                else:
                    raise Exception(f"Failed to download firmware: HTTP {response.status}")

    def verify_firmware_checksum(self, firmware_data: bytes,
                                expected_checksum: str) -> bool:
        """éªŒè¯å›ºä»¶æ ¡éªŒå’Œ"""
        # æå–ç®—æ³•å’Œå“ˆå¸Œå€¼
        if expected_checksum.startswith("sha256:"):
            algorithm = "sha256"
            expected_hash = expected_checksum[7:]
        elif expected_checksum.startswith("sha1:"):
            algorithm = "sha1"
            expected_hash = expected_checksum[5:]
        else:
            logger.warning(f"Unknown checksum format: {expected_checksum}")
            return False

        # è®¡ç®—å®é™…å“ˆå¸Œå€¼
        if algorithm == "sha256":
            actual_hash = hashlib.sha256(firmware_data).hexdigest()
        elif algorithm == "sha1":
            actual_hash = hashlib.sha1(firmware_data).hexdigest()
        else:
            return False

        return actual_hash.lower() == expected_hash.lower()

    async def upgrade_firmware(self, firmware_url: str, firmware_version: str,
                              firmware_size: int = None,
                              firmware_checksum: str = None,
                              progress_callback: Callable = None) -> bool:
        """æ‰§è¡Œå›ºä»¶å‡çº§"""
        self.upgrade_progress_callback = progress_callback

        # è®°å½•å‡çº§å¼€å§‹
        update_id = self.storage.store_firmware_update(
            self.device_id,
            firmware_version,
            firmware_url,
            firmware_size,
            firmware_checksum
        )

        try:
            # æ£€æŸ¥å½“å‰ç‰ˆæœ¬
            current_version = await self.check_firmware_version()
            logger.info(f"Current firmware version: {current_version}")

            # ä¸‹è½½å›ºä»¶
            if progress_callback:
                progress_callback(0, "Downloading firmware...")

            firmware_data = await self.download_firmware(firmware_url)

            # éªŒè¯å›ºä»¶
            if firmware_checksum:
                if progress_callback:
                    progress_callback(10, "Verifying firmware...")

                if not self.verify_firmware_checksum(firmware_data, firmware_checksum):
                    raise Exception("Firmware checksum verification failed")

            # æ›´æ–°çŠ¶æ€ä¸ºè¿›è¡Œä¸­
            self.storage.update_firmware_status(update_id, "InProgress")

            # å‘é€å›ºä»¶åˆ°è®¾å¤‡ï¼ˆè¿™é‡Œéœ€è¦å®é™…çš„Matter OTAå‡çº§å‘½ä»¤ï¼‰
            if progress_callback:
                progress_callback(20, "Uploading firmware to device...")

            # æ¨¡æ‹Ÿå‡çº§è¿‡ç¨‹
            await self._simulate_firmware_upgrade(firmware_data, progress_callback)

            # éªŒè¯å‡çº§ç»“æœ
            if progress_callback:
                progress_callback(90, "Verifying upgrade...")

            new_version = await self.check_firmware_version()
            if new_version == firmware_version:
                self.storage.update_firmware_status(update_id, "Completed")
                logger.info(f"Firmware upgrade completed: {current_version} -> {new_version}")
                return True
            else:
                raise Exception(f"Version mismatch: expected {firmware_version}, got {new_version}")

        except Exception as e:
            logger.error(f"Firmware upgrade failed: {e}")
            self.storage.update_firmware_status(update_id, "Failed", str(e))
            return False

    async def _simulate_firmware_upgrade(self, firmware_data: bytes,
                                        progress_callback: Callable):
        """æ¨¡æ‹Ÿå›ºä»¶å‡çº§è¿‡ç¨‹"""
        # æ¨¡æ‹Ÿå‡çº§è¿›åº¦
        for progress in range(20, 90, 10):
            await asyncio.sleep(0.5)
            if progress_callback:
                progress_callback(progress, f"Upgrading... {progress}%")

    async def rollback_firmware(self, previous_version: str) -> bool:
        """å›æ»šåˆ°ä¹‹å‰çš„å›ºä»¶ç‰ˆæœ¬"""
        logger.info(f"Rolling back to version {previous_version}")
        # è¿™é‡Œéœ€è¦å®é™…çš„å›æ»šé€»è¾‘
        # Matteråè®®å¯èƒ½ä¸æ”¯æŒç›´æ¥å›æ»šï¼Œéœ€è¦é‡æ–°å‡çº§åˆ°ä¹‹å‰çš„ç‰ˆæœ¬
        return False

async def upgrade_device_firmware():
    """å›ºä»¶å‡çº§ç¤ºä¾‹"""
    # åˆå§‹åŒ–å­˜å‚¨
    storage = MatterStorage("postgresql://user:pass@localhost/matter")

    # åˆ›å»ºè®¾å¤‡æ§åˆ¶å™¨
    device_controller = MatterDeviceController("LIGHT001", 0x12344321)
    await device_controller.connect()

    # åˆ›å»ºå›ºä»¶å‡çº§å™¨
    updater = MatterFirmwareUpdater(device_controller, storage)

    # æ£€æŸ¥å½“å‰ç‰ˆæœ¬
    current_version = await updater.check_firmware_version()
    print(f"Current firmware version: {current_version}")

    # å®šä¹‰è¿›åº¦å›è°ƒ
    def progress_callback(progress: int, message: str):
        print(f"[{progress}%] {message}")

    # æ‰§è¡Œå‡çº§
    success = await updater.upgrade_firmware(
        firmware_url="https://example.com/firmware/light_v1.1.0.bin",
        firmware_version="1.1.0",
        firmware_size=524288,
        firmware_checksum="sha256:abc123def456...",
        progress_callback=progress_callback
    )

    if success:
        print("Firmware upgrade completed successfully!")
    else:
        print("Firmware upgrade failed!")

    # æŸ¥è¯¢å‡çº§å†å²
    updates = storage.get_firmware_updates(device_id="LIGHT001")
    print("\nFirmware update history:")
    for update in updates:
        print(f"  Version: {update['firmware_version']}, "
              f"Status: {update['update_status']}, "
              f"Time: {update['created_at']}")

    await device_controller.disconnect()
    storage.close()

if __name__ == "__main__":
    asyncio.run(upgrade_device_firmware())
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

# æ™ºèƒ½åº“å­˜ç®¡ç†æ¡ˆä¾‹ç ”ç©¶

## ğŸ“‘ ç›®å½•

- [æ™ºèƒ½åº“å­˜ç®¡ç†æ¡ˆä¾‹ç ”ç©¶](#æ™ºèƒ½åº“å­˜ç®¡ç†æ¡ˆä¾‹ç ”ç©¶)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. ä¼ä¸šèƒŒæ™¯](#1-ä¼ä¸šèƒŒæ™¯)
  - [2. ä¸šåŠ¡ç—›ç‚¹](#2-ä¸šåŠ¡ç—›ç‚¹)
  - [3. ä¸šåŠ¡ç›®æ ‡](#3-ä¸šåŠ¡ç›®æ ‡)
  - [4. æŠ€æœ¯æŒ‘æˆ˜](#4-æŠ€æœ¯æŒ‘æˆ˜)
  - [5. è§£å†³æ–¹æ¡ˆæ¶æ„](#5-è§£å†³æ–¹æ¡ˆæ¶æ„)
  - [6. æ ¸å¿ƒä»£ç å®ç°](#6-æ ¸å¿ƒä»£ç å®ç°)
  - [7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ](#7-æ•ˆæœè¯„ä¼°ä¸roiåˆ†æ)

---

## 1. ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šäº¬ä¸œç‰©æµé›†å›¢

**ä¼ä¸šè§„æ¨¡**ï¼š
- ä¸»è¥ä¸šåŠ¡ï¼šä»“å‚¨ç®¡ç†ã€é…é€æœåŠ¡ã€ä¾›åº”é“¾é‡‘èã€æ™ºèƒ½ç‰©æµ
- ä»“å‚¨ç½‘ç»œï¼šå…¨å›½è¿è¥è¶…1,600ä¸ªä»“åº“ï¼Œæ€»é¢ç§¯è¶…3,200ä¸‡å¹³æ–¹ç±³
- é…é€ç½‘ç»œï¼š28ä¸‡é…é€äººå‘˜ï¼Œè¦†ç›–å…¨å›½99%çš„äººå£
- æ™ºèƒ½ä»“æ•°é‡ï¼šäºšæ´²ä¸€å·æ™ºèƒ½ç‰©æµå›­åŒº43åº§ï¼Œå…¨è‡ªåŠ¨æ— äººä»“è¶…è¿‡100ä¸ª
- å¹´è¥æ”¶ï¼š1,666äº¿å…ƒï¼ˆ2024å¹´ï¼‰
- å‘˜å·¥æ€»æ•°ï¼šçº¦39ä¸‡äººï¼ˆå«é…é€å‘˜ï¼‰
- æ—¥å‡è®¢å•å¤„ç†é‡ï¼šè¶…1,500ä¸‡å•

**ä¸šåŠ¡æ¦‚å†µ**ï¼š
äº¬ä¸œç‰©æµæ˜¯ä¸­å›½é¢†å…ˆçš„æŠ€æœ¯é©±åŠ¨çš„ä¾›åº”é“¾è§£å†³æ–¹æ¡ˆåŠç‰©æµæœåŠ¡å•†ã€‚å…¬å¸æ‹¥æœ‰å…¨çƒæœ€å¤§çš„æ™ºèƒ½ä»“ç¾¤ï¼Œé€šè¿‡è‡ªåŠ¨åŒ–ã€æ•°å­—åŒ–ã€æ™ºèƒ½åŒ–æŠ€æœ¯å®ç°é«˜æ•ˆå±¥çº¦ã€‚éšç€ä¸šåŠ¡å¿«é€Ÿå‘å±•ï¼Œåº“å­˜ç®¡ç†é¢ä¸´SKUæ•°é‡æ¿€å¢ï¼ˆè¶…1,000ä¸‡SKUï¼‰ã€å¤šæ¸ é“åº“å­˜å…±äº«ã€å­£èŠ‚æ€§æ³¢åŠ¨å¤§ç­‰æŒ‘æˆ˜ï¼ŒäºŸéœ€æ„å»ºæ™ºèƒ½åº“å­˜ç®¡ç†ä½“ç³»ã€‚

**ç°æœ‰ç³»ç»Ÿ**ï¼š
- WMSä»“å‚¨ç®¡ç†ç³»ç»Ÿ - å„ä»“åº“ç‹¬ç«‹éƒ¨ç½²ï¼Œç‰ˆæœ¬ä¸ç»Ÿä¸€
- ERPç³»ç»Ÿ - SAPï¼Œç®¡ç†è´¢åŠ¡ä¸é‡‡è´­
- è®¢å•ç®¡ç†ç³»ç»Ÿï¼ˆOMSï¼‰- è‡ªç ”ï¼Œç®¡ç†å¤šæ¸ é“è®¢å•
- é¢„æµ‹è¡¥è´§ç³»ç»Ÿ - åŸºäºè§„åˆ™çš„ç®€å•é¢„æµ‹æ¨¡å‹
- è¿è¾“ç®¡ç†ç³»ç»Ÿï¼ˆTMSï¼‰- ç®¡ç†é…é€è°ƒåº¦

---

## 2. ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ç±»åˆ« | å…·ä½“é—®é¢˜æè¿° | ä¸šåŠ¡å½±å“ |
|------|----------|--------------|----------|
| 1 | **åº“å­˜åˆ†å¸ƒä¸å‡** | å„ä»“åº“åº“å­˜æ•°æ®ä¸äº’é€šï¼Œçƒ­é”€åŒºåŸŸç¼ºè´§ä¸æ»é”€åŒºåŸŸç§¯å‹å¹¶å­˜ï¼Œæ— æ³•æ™ºèƒ½è°ƒæ‹¨ | ç¼ºè´§ç‡8%ï¼Œæ»é”€åº“å­˜å æ¯”15%ï¼Œå¹´åº¦åº“å­˜æŸå¤±è¶…50äº¿å…ƒ |
| 2 | **é¢„æµ‹å‡†ç¡®æ€§ä½** | éœ€æ±‚é¢„æµ‹ä¾èµ–å†å²é”€é‡ç®€å•å¤–æ¨ï¼Œæ— æ³•æ•æ‰ä¿ƒé”€ã€å­£èŠ‚ã€èˆ†æƒ…ç­‰å› ç´ ï¼Œé¢„æµ‹å‡†ç¡®ç‡ä»…65% | è¿‡åº¦å¤‡è´§å¯¼è‡´èµ„é‡‘å ç”¨ï¼Œåº“å­˜å‘¨è½¬å¤©æ•°é•¿è¾¾45å¤© |
| 3 | **è¡¥è´§å†³ç­–æ»å** | è¡¥è´§ä¾èµ–äººå·¥åˆ¤æ–­ï¼Œä»å‘ç°ç¼ºè´§åˆ°è¡¥è´§åˆ°ä½å¹³å‡è€—æ—¶7å¤©ï¼Œæ— æ³•å“åº”çªå‘éœ€æ±‚ | å¤§ä¿ƒæœŸé—´ç¼ºè´§ç‡é«˜è¾¾20%ï¼Œé”™å¤±é”€å”®æœºä¼š |
| 4 | **å¤šæ¸ é“åº“å­˜å†²çª** | è‡ªè¥ã€POPã€çº¿ä¸‹é—¨åº—å…±äº«åº“å­˜ï¼Œè¶…å–ä¸é‡å¤å åº“é—®é¢˜é¢‘å‘ | è¶…å–æŠ•è¯‰ç‡1.5%ï¼Œå®¢æˆ·æ»¡æ„åº¦ä¸‹é™ |
| 5 | **æ•ˆæœŸç®¡ç†ç²—æ”¾** | ç”Ÿé²œã€åŒ»è¯ç­‰æœ‰ä¿è´¨æœŸå•†å“ç¼ºä¹å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰ç®¡æ§ï¼Œä¸´æœŸæŠ¥åºŸæŸå¤±å¤§ | ç”Ÿé²œæŸè€—ç‡12%ï¼Œå¹´åº¦æŠ¥åºŸæŸå¤±è¶…20äº¿å…ƒ |

---

## 3. ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ç±»åˆ« | å…·ä½“ç›®æ ‡ | é¢„æœŸæŒ‡æ ‡ |
|------|----------|----------|----------|
| 1 | **åº“å­˜å¯è§†åŒ–** | å»ºç«‹å…¨ç½‘åº“å­˜å®æ—¶å¯è§†åŒ–å¹³å°ï¼Œå®ç°1,600+ä»“åº“åº“å­˜å®æ—¶æ±‡èšä¸æŸ¥è¯¢ | åº“å­˜æ•°æ®å®æ—¶ç‡ä»70%æå‡è‡³99.5%ï¼Œåº“å­˜å‡†ç¡®ç‡99.9% |
| 2 | **éœ€æ±‚é¢„æµ‹ç²¾å‡†åŒ–** | æ„å»ºAIé©±åŠ¨çš„éœ€æ±‚é¢„æµ‹æ¨¡å‹ï¼Œèåˆå¤šç»´åº¦æ•°æ®æå‡é¢„æµ‹å‡†ç¡®åº¦ | é¢„æµ‹å‡†ç¡®ç‡ä»65%æå‡è‡³85%ï¼Œå¤§ä¿ƒé¢„æµ‹å‡†ç¡®ç‡90% |
| 3 | **æ™ºèƒ½è¡¥è´§** | å»ºç«‹è‡ªåŠ¨è¡¥è´§å†³ç­–ç³»ç»Ÿï¼Œå®ç°åŠ¨æ€å®‰å…¨åº“å­˜ä¸æ™ºèƒ½è¡¥è´§å»ºè®® | è¡¥è´§å†³ç­–æ—¶é—´ä»7å¤©ç¼©çŸ­è‡³1å¤©ï¼Œç¼ºè´§ç‡é™è‡³3% |
| 4 | **å¤šæ¸ é“åº“å­˜ååŒ** | æ„å»ºç»Ÿä¸€åº“å­˜æ± ï¼Œå®ç°è‡ªè¥ã€POPã€çº¿ä¸‹æ¸ é“åº“å­˜å…±äº«ä¸æ™ºèƒ½åˆ†é… | è¶…å–ç‡é™è‡³0.1%ä»¥ä¸‹ï¼Œåº“å­˜å‘¨è½¬å¤©æ•°é™è‡³30å¤© |
| 5 | **æ•ˆæœŸæ™ºèƒ½ç®¡ç†** | å»ºç«‹æ‰¹æ¬¡æ•ˆæœŸå…¨ç¨‹è¿½è¸ªä½“ç³»ï¼Œå®ç°ä¸´æœŸé¢„è­¦ä¸æ™ºèƒ½ä¿ƒé”€å»ºè®® | ç”Ÿé²œæŸè€—ç‡é™è‡³5%ï¼Œä¸´æœŸå•†å“ä¿ƒé”€è½¬åŒ–ç‡æå‡50% |

---

## 4. æŠ€æœ¯æŒ‘æˆ˜

### æŒ‘æˆ˜1ï¼šæµ·é‡åº“å­˜æ•°æ®å®æ—¶æ±‡èš
- **é—®é¢˜æè¿°**ï¼š1,600+ä»“åº“ï¼Œ1,000ä¸‡+SKUï¼Œæ—¥å‡åº“å­˜å˜åŠ¨è¶…10äº¿æ¬¡ï¼Œéœ€è¦å®æ—¶æ±‡èšä¸ä¸€è‡´æ€§ä¿éšœ
- **æŠ€æœ¯éš¾ç‚¹**ï¼šåˆ†å¸ƒå¼äº‹åŠ¡ä¸€è‡´æ€§ï¼›é«˜å¹¶å‘å†™å…¥æ€§èƒ½ï¼›æ•°æ®å»¶è¿Ÿæ§åˆ¶ï¼ˆ<5ç§’ï¼‰
- **è§£å†³æ–¹æ¡ˆ**ï¼šåŸºäºTiDBåˆ†å¸ƒå¼æ•°æ®åº“ï¼Œåˆ†åº“åˆ†è¡¨+çƒ­ç‚¹ç¼“å­˜ï¼Œå¼‚æ­¥æ¶ˆæ¯é˜Ÿåˆ—æœ€ç»ˆä¸€è‡´æ€§

### æŒ‘æˆ˜2ï¼šå¤æ‚éœ€æ±‚é¢„æµ‹æ¨¡å‹
- **é—®é¢˜æè¿°**ï¼šSKUç‰¹æ€§å·®å¼‚å¤§ï¼ˆå¿«æ¶ˆ/3C/ç”Ÿé²œï¼‰ï¼Œå½±å“å› ç´ å¤šï¼ˆä¿ƒé”€ã€å­£èŠ‚ã€å¤©æ°”ã€èˆ†æƒ…ï¼‰ï¼Œé¢„æµ‹éš¾åº¦å¤§
- **æŠ€æœ¯éš¾ç‚¹**ï¼šå¤šå±‚çº§é¢„æµ‹ï¼ˆé›†å›¢-å“ç±»-SKUï¼‰ï¼›å†·å¯åŠ¨é—®é¢˜ï¼›æ¦‚å¿µæ¼‚ç§»æ£€æµ‹ï¼›å¤§ä¿ƒåœºæ™¯é¢„æµ‹
- **è§£å†³æ–¹æ¡ˆ**ï¼šé‡‡ç”¨DeepAR+Prophetæ··åˆæ¨¡å‹ï¼Œç»“åˆNLPèˆ†æƒ…åˆ†æï¼Œå®ç°å¤šå±‚çº§ååŒé¢„æµ‹

### æŒ‘æˆ˜3ï¼šå¤§è§„æ¨¡åº“å­˜ä¼˜åŒ–æ±‚è§£
- **é—®é¢˜æè¿°**ï¼š1,600ä»“åº“ã€1,000ä¸‡SKUçš„åº“å­˜å¸ƒå±€ä¼˜åŒ–ï¼Œéœ€åœ¨æˆæœ¬ã€æ—¶æ•ˆã€æœåŠ¡æ°´å¹³çš„çº¦æŸä¸‹æ±‚è§£
- **æŠ€æœ¯éš¾ç‚¹**ï¼šè¶…å¤§è§„æ¨¡ç»„åˆä¼˜åŒ–ï¼›å¤šç›®æ ‡æƒè¡¡ï¼›åŠ¨æ€è°ƒæ•´ï¼›NP-hardé—®é¢˜è¿‘ä¼¼æ±‚è§£
- **è§£å†³æ–¹æ¡ˆ**ï¼šåŸºäºå¼ºåŒ–å­¦ä¹ çš„åº“å­˜ç­–ç•¥ä¼˜åŒ–ï¼Œç»“åˆè¿ç­¹å­¦å¯å‘å¼ç®—æ³•ï¼Œå®ç°è¿‘ä¼¼æœ€ä¼˜è§£

### æŒ‘æˆ˜4ï¼šå¤šæ¸ é“åº“å­˜å®æ—¶åˆ†é…
- **é—®é¢˜æè¿°**ï¼šè‡ªè¥ã€POPã€çº¿ä¸‹é—¨åº—ç­‰å¤šæ¸ é“å…±äº«åº“å­˜ï¼Œéœ€å®æ—¶å†³ç­–åº“å­˜åˆ†é…ç­–ç•¥
- **æŠ€æœ¯éš¾ç‚¹**ï¼šå¹¶å‘åº“å­˜æ‰£å‡ä¸€è‡´æ€§ï¼›æ¸ é“ä¼˜å…ˆçº§ç­–ç•¥ï¼›åŠ¨æ€åº“å­˜é¢„ç•™ï¼›è¶…å–é˜²æŠ¤
- **è§£å†³æ–¹æ¡ˆ**ï¼šRedisåˆ†å¸ƒå¼é”+åº“å­˜é¢„æ‰£æœºåˆ¶ï¼Œè§„åˆ™å¼•æ“åŠ¨æ€è°ƒæ•´æ¸ é“é…é¢

### æŒ‘æˆ˜5ï¼šç”Ÿé²œæ•ˆæœŸç²¾ç»†åŒ–ç®¡ç†
- **é—®é¢˜æè¿°**ï¼šç”Ÿé²œå•†å“ä¿è´¨æœŸçŸ­ï¼ˆ1-30å¤©ï¼‰ï¼Œéœ€ç²¾ç¡®åˆ°æ‰¹æ¬¡çš„æ•ˆæœŸè¿½è¸ªä¸å…ˆè¿›å…ˆå‡º
- **æŠ€æœ¯éš¾ç‚¹**ï¼šæ‰¹æ¬¡çº§åº“å­˜è¿½è¸ªï¼›åŠ¨æ€ä¿è´¨æœŸé¢„è­¦ï¼›ä¸´æœŸä¿ƒé”€ç­–ç•¥ï¼›æŸè€—é¢„æµ‹
- **è§£å†³æ–¹æ¡ˆ**ï¼šæ‰¹æ¬¡å·å…¨é“¾è·¯è¿½è¸ªï¼ŒåŸºäºå‰©ä½™ä¿è´¨æœŸçš„åŠ¨æ€å®šä»·ä¸ä¿ƒé”€å»ºè®®

---

## 5. è§£å†³æ–¹æ¡ˆæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         äº¬ä¸œæ™ºèƒ½åº“å­˜ç®¡ç†å¹³å°æ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         æ™ºèƒ½åº”ç”¨å±‚                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ éœ€æ±‚é¢„æµ‹ â”‚ â”‚ æ™ºèƒ½è¡¥è´§ â”‚ â”‚ åº“å­˜ä¼˜åŒ– â”‚ â”‚ æ•ˆæœŸç®¡ç† â”‚ â”‚ åº“å­˜å¤§å± â”‚  â”‚   â”‚
â”‚  â”‚  â”‚Forecast  â”‚ â”‚Replenish â”‚ â”‚ Optimize â”‚ â”‚   FEFO   â”‚ â”‚Dashboard â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         AI/ç®—æ³•å±‚                                    â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ æ·±åº¦å­¦ä¹  â”‚ â”‚ æ—¶é—´åºåˆ— â”‚ â”‚ å¼ºåŒ–å­¦ä¹  â”‚ â”‚ è¿ç­¹ä¼˜åŒ– â”‚ â”‚ ä»¿çœŸæ¨¡æ‹Ÿ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ DeepAR   â”‚ â”‚ Prophet  â”‚ â”‚   RL     â”‚ â”‚  Solver  â”‚ â”‚  Digital â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         æ ¸å¿ƒæœåŠ¡å±‚                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ åº“å­˜ä¸­å¿ƒ â”‚ â”‚ è®¢å•ä¸­å¿ƒ â”‚ â”‚ è°ƒåº¦ä¸­å¿ƒ â”‚ â”‚ ä»·æ ¼ä¸­å¿ƒ â”‚ â”‚ é¢„è­¦ä¸­å¿ƒ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚  Inventory         â”‚ â”‚  Order   â”‚ â”‚ Dispatch â”‚ â”‚  Price   â”‚ â”‚  Alert   â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         æ•°æ®å¹³å°å±‚                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ å®æ—¶è®¡ç®— â”‚ â”‚ æ•°æ®ä»“åº“ â”‚ â”‚ æ•°æ®æ¹–   â”‚ â”‚ ç‰¹å¾å¹³å° â”‚ â”‚ æ¨¡å‹ä»“åº“ â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ (Flink)  â”‚ â”‚(ClickHouâ”‚ â”‚(Iceberg) â”‚ â”‚(Feast)   â”‚ â”‚(MLflow)  â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                         ä»“å‚¨ç½‘ç»œå±‚                                   â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ äºšæ´²ä¸€å· â”‚ â”‚ åŸå¸‚ä»“   â”‚ â”‚ å‰ç½®ä»“   â”‚ â”‚ å†·é“¾ä»“   â”‚ â”‚ ä¿ç¨ä»“   â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ A1 Smart â”‚ â”‚ City Hub â”‚ â”‚ Front DC â”‚ â”‚ Cold DC  â”‚ â”‚ Bonded   â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 6. æ ¸å¿ƒä»£ç å®ç°

### 6.1 æ™ºèƒ½åº“å­˜é¢„æµ‹ä¸è¡¥è´§ç³»ç»Ÿ

```python
"""
äº¬ä¸œæ™ºèƒ½åº“å­˜ç®¡ç†ç³»ç»Ÿ
JD Intelligent Inventory Management System

åŠŸèƒ½ï¼š
1. å…¨ç½‘åº“å­˜å®æ—¶æ±‡èšä¸å¯è§†åŒ–
2. AIé©±åŠ¨çš„éœ€æ±‚é¢„æµ‹ï¼ˆDeepAR+Prophetï¼‰
3. æ™ºèƒ½è¡¥è´§å†³ç­–ä¸åŠ¨æ€å®‰å…¨åº“å­˜
4. å¤šæ¸ é“åº“å­˜åˆ†é…ä¸è¶…å–é˜²æŠ¤
5. ç”Ÿé²œæ•ˆæœŸç®¡ç†ä¸ä¸´æœŸé¢„è­¦
"""

import asyncio
import json
import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Tuple, Any
from collections import deque, defaultdict
import uuid
import hashlib

import numpy as np
import pandas as pd
from kafka import KafkaProducer

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ProductCategory(Enum):
    """å•†å“å“ç±»"""
    ELECTRONICS = "electronics"
    FRESH = "fresh"
    FASHION = "fashion"
    HOME = "home"
    FMCG = "fmcg"


class InventoryStatus(Enum):
    """åº“å­˜çŠ¶æ€"""
    IN_STOCK = "in_stock"
    LOW_STOCK = "low_stock"
    OUT_OF_STOCK = "out_of_stock"
    OVERSTOCK = "overstock"


class ChannelType(Enum):
    """æ¸ é“ç±»å‹"""
    SELF_OPERATED = "self_operated"
    POP = "pop"
    OFFLINE = "offline"
    WHOLESALE = "wholesale"


@dataclass
class SKU:
    """SKUä¿¡æ¯"""
    sku_id: str
    sku_name: str
    category: ProductCategory
    brand: str
    cost_price: float
    selling_price: float
    supplier_id: str
    lead_time_days: int
    shelf_life_days: Optional[int] = None  # ä¿è´¨æœŸï¼ˆç”Ÿé²œç±»ï¼‰
    
    def to_dict(self) -> Dict:
        data = asdict(self)
        data['category'] = self.category.value
        return data


@dataclass
class Warehouse:
    """ä»“åº“ä¿¡æ¯"""
    warehouse_id: str
    warehouse_name: str
    warehouse_type: str  # A1, city, front, cold
    region: str
    capacity: int  # åº“å®¹é‡ï¼ˆä»¶ï¼‰
    
    def to_dict(self) -> Dict:
        return asdict(self)


@dataclass
class InventoryRecord:
    """åº“å­˜è®°å½•"""
    record_id: str
    sku_id: str
    warehouse_id: str
    quantity_available: int
    quantity_reserved: int
    quantity_inbound: int  # åœ¨é€”
    batch_id: Optional[str] = None
    expiry_date: Optional[datetime] = None
    updated_at: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        data = asdict(self)
        data['updated_at'] = self.updated_at.isoformat()
        if self.expiry_date:
            data['expiry_date'] = self.expiry_date.isoformat()
        return data
    
    def total_quantity(self) -> int:
        """æ€»åº“å­˜"""
        return self.quantity_available + self.quantity_reserved + self.quantity_inbound
    
    def days_to_expiry(self) -> Optional[int]:
        """è·è¿‡æœŸå¤©æ•°"""
        if self.expiry_date:
            return (self.expiry_date - datetime.now()).days
        return None


@dataclass
class DemandForecast:
    """éœ€æ±‚é¢„æµ‹"""
    forecast_id: str
    sku_id: str
    warehouse_id: str
    forecast_date: datetime
    predicted_demand: int
    confidence_lower: int
    confidence_upper: int
    model_version: str
    features: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        data = asdict(self)
        data['forecast_date'] = self.forecast_date.isoformat()
        return data


@dataclass
class ReplenishmentOrder:
    """è¡¥è´§è®¢å•"""
    order_id: str
    sku_id: str
    warehouse_id: str
    supplier_id: str
    quantity: int
    suggested_order_date: datetime
    expected_delivery_date: datetime
    status: str  # pending, approved, ordered, in_transit, received
    priority: int  # 1-5
    
    def to_dict(self) -> Dict:
        data = asdict(self)
        data['suggested_order_date'] = self.suggested_order_date.isoformat()
        data['expected_delivery_date'] = self.expected_delivery_date.isoformat()
        return data


class InventorySchemaRegistry:
    """åº“å­˜æ•°æ®Schemaæ³¨å†Œä¸­å¿ƒ"""
    
    def __init__(self):
        self.schemas = self._init_schemas()
    
    def _init_schemas(self) -> Dict:
        """åˆå§‹åŒ–Schema"""
        return {
            "inventory_record": {
                "version": "1.0",
                "fields": {
                    "record_id": {"type": "string", "required": True},
                    "sku_id": {"type": "string", "required": True},
                    "warehouse_id": {"type": "string", "required": True},
                    "quantity_available": {"type": "integer", "required": True, "min": 0},
                    "quantity_reserved": {"type": "integer", "min": 0},
                    "quantity_inbound": {"type": "integer", "min": 0}
                }
            },
            "demand_forecast": {
                "version": "1.0",
                "fields": {
                    "forecast_id": {"type": "string", "required": True},
                    "sku_id": {"type": "string", "required": True},
                    "warehouse_id": {"type": "string", "required": True},
                    "forecast_date": {"type": "datetime", "required": True},
                    "predicted_demand": {"type": "integer", "required": True, "min": 0}
                }
            },
            "replenishment_order": {
                "version": "1.0",
                "fields": {
                    "order_id": {"type": "string", "required": True},
                    "sku_id": {"type": "string", "required": True},
                    "warehouse_id": {"type": "string", "required": True},
                    "quantity": {"type": "integer", "required": True, "min": 1},
                    "priority": {"type": "integer", "min": 1, "max": 5}
                }
            }
        }
    
    def validate_data(self, schema_name: str, data: Dict) -> Tuple[bool, List[str]]:
        """éªŒè¯æ•°æ®"""
        if schema_name not in self.schemas:
            return False, [f"Schema '{schema_name}' not found"]
        
        schema = self.schemas[schema_name]
        errors = []
        
        for field_name, field_def in schema.get("fields", {}).items():
            if field_def.get("required") and field_name not in data:
                errors.append(f"Required field '{field_name}' missing")
        
        return len(errors) == 0, errors


class DemandForecastingEngine:
    """éœ€æ±‚é¢„æµ‹å¼•æ“"""
    
    def __init__(self, schema_registry: InventorySchemaRegistry):
        self.schema_registry = schema_registry
        self.historical_sales: Dict[str, deque] = defaultdict(lambda: deque(maxlen=365))
        self.forecasts: Dict[str, DemandForecast] = {}
    
    def record_sale(self, sku_id: str, warehouse_id: str, quantity: int, timestamp: datetime):
        """è®°å½•é”€å”®"""
        key = f"{sku_id}:{warehouse_id}"
        self.historical_sales[key].append({
            "quantity": quantity,
            "timestamp": timestamp
        })
    
    def predict_demand(
        self,
        sku: SKU,
        warehouse: Warehouse,
        horizon_days: int = 14
    ) -> DemandForecast:
        """é¢„æµ‹éœ€æ±‚ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰"""
        key = f"{sku.sku_id}:{warehouse.warehouse_id}"
        history = list(self.historical_sales.get(key, []))
        
        if not history:
            # æ— å†å²æ•°æ®ï¼Œä½¿ç”¨é»˜è®¤å€¼
            base_demand = 10
        else:
            # åŸºäºå†å²å¹³å‡é”€é‡
            recent = [h["quantity"] for h in history[-30:]]
            base_demand = np.mean(recent)
        
        # å“ç±»è°ƒæ•´å› å­
        category_factor = {
            ProductCategory.ELECTRONICS: 1.0,
            ProductCategory.FRESH: 1.2,  # ç”Ÿé²œéœ€æ±‚æ³¢åŠ¨å¤§
            ProductCategory.FASHION: 0.9,
            ProductCategory.HOME: 0.8,
            ProductCategory.FMCG: 1.1
        }.get(sku.category, 1.0)
        
        predicted = int(base_demand * horizon_days * category_factor)
        
        # æ·»åŠ éšæœºæ³¢åŠ¨
        confidence_margin = int(predicted * 0.2)
        
        forecast = DemandForecast(
            forecast_id=f"FC_{uuid.uuid4().hex[:8].upper()}",
            sku_id=sku.sku_id,
            warehouse_id=warehouse.warehouse_id,
            forecast_date=datetime.now() + timedelta(days=horizon_days),
            predicted_demand=predicted,
            confidence_lower=max(0, predicted - confidence_margin),
            confidence_upper=predicted + confidence_margin,
            model_version="v1.0_simplified",
            features={
                "category_factor": category_factor,
                "history_days": len(history),
                "base_daily_demand": base_demand
            }
        )
        
        self.forecasts[key] = forecast
        return forecast


class SmartReplenishmentEngine:
    """æ™ºèƒ½è¡¥è´§å¼•æ“"""
    
    def __init__(self, schema_registry: InventorySchemaRegistry):
        self.schema_registry = schema_registry
        self.replenishment_orders: Dict[str, ReplenishmentOrder] = {}
    
    def calculate_safety_stock(
        self,
        sku: SKU,
        forecast: DemandForecast,
        service_level: float = 0.95
    ) -> int:
        """è®¡ç®—å®‰å…¨åº“å­˜"""
        # åŸºäºé¢„æµ‹éœ€æ±‚çš„å˜å¼‚ç³»æ•°è®¡ç®—å®‰å…¨åº“å­˜
        demand_std = (forecast.confidence_upper - forecast.confidence_lower) / 4
        z_score = 1.65  # 95%æœåŠ¡æ°´å¹³å¯¹åº”çš„Zå€¼
        
        safety_stock = int(z_score * demand_std * np.sqrt(sku.lead_time_days))
        return max(safety_stock, 7)  # æœ€å°å®‰å…¨åº“å­˜7å¤©
    
    def generate_replenishment_suggestion(
        self,
        sku: SKU,
        warehouse: Warehouse,
        inventory: InventoryRecord,
        forecast: DemandForecast
    ) -> Optional[ReplenishmentOrder]:
        """ç”Ÿæˆè¡¥è´§å»ºè®®"""
        # è®¡ç®—å®‰å…¨åº“å­˜
        safety_stock = self.calculate_safety_stock(sku, forecast)
        
        # è®¡ç®—éœ€æ±‚è¦†ç›–æœŸ
        cover_days = 14
        total_demand = forecast.predicted_demand
        
        # è®¡ç®—å»ºè®®è¡¥è´§é‡
        current_stock = inventory.total_quantity()
        suggested_qty = total_demand + safety_stock - current_stock
        
        if suggested_qty <= 0:
            return None
        
        # ç¡®å®šä¼˜å…ˆçº§
        if inventory.quantity_available == 0:
            priority = 1  # ç´§æ€¥è¡¥è´§
        elif inventory.quantity_available < safety_stock:
            priority = 2
        else:
            priority = 3
        
        order = ReplenishmentOrder(
            order_id=f"RO_{uuid.uuid4().hex[:8].upper()}",
            sku_id=sku.sku_id,
            warehouse_id=warehouse.warehouse_id,
            supplier_id=sku.supplier_id,
            quantity=suggested_qty,
            suggested_order_date=datetime.now(),
            expected_delivery_date=datetime.now() + timedelta(days=sku.lead_time_days),
            status="pending",
            priority=priority
        )
        
        self.replenishment_orders[order.order_id] = order
        return order


class MultiChannelInventoryManager:
    """å¤šæ¸ é“åº“å­˜ç®¡ç†"""
    
    def __init__(self):
        self.channel_quotas: Dict[str, Dict[ChannelType, int]] = defaultdict(dict)
        self.reservations: Dict[str, Dict[ChannelType, int]] = defaultdict(lambda: defaultdict(int))
    
    def set_channel_quota(
        self,
        sku_id: str,
        warehouse_id: str,
        quotas: Dict[ChannelType, int]
    ):
        """è®¾ç½®æ¸ é“é…é¢"""
        key = f"{sku_id}:{warehouse_id}"
        self.channel_quotas[key] = quotas
    
    def allocate_inventory(
        self,
        sku_id: str,
        warehouse_id: str,
        channel: ChannelType,
        quantity: int
    ) -> Tuple[bool, str]:
        """åˆ†é…åº“å­˜"""
        key = f"{sku_id}:{warehouse_id}"
        
        # æ£€æŸ¥æ¸ é“é…é¢
        quota = self.channel_quotas.get(key, {}).get(channel, 0)
        reserved = self.reservations[key][channel]
        
        available_for_channel = quota - reserved
        
        if quantity > available_for_channel:
            return False, f"Insufficient quota for channel {channel.value}. Available: {available_for_channel}"
        
        # é¢„ç•™åº“å­˜
        self.reservations[key][channel] += quantity
        return True, "Allocated successfully"
    
    def release_reservation(
        self,
        sku_id: str,
        warehouse_id: str,
        channel: ChannelType,
        quantity: int
    ):
        """é‡Šæ”¾é¢„ç•™"""
        key = f"{sku_id}:{warehouse_id}"
        self.reservations[key][channel] = max(0, self.reservations[key][channel] - quantity)


class FreshProductManager:
    """ç”Ÿé²œå•†å“ç®¡ç†"""
    
    def __init__(self):
        self.batch_inventory: Dict[str, List[InventoryRecord]] = defaultdict(list)
    
    def add_batch_inventory(self, record: InventoryRecord):
        """æ·»åŠ æ‰¹æ¬¡åº“å­˜"""
        if record.expiry_date:
            key = f"{record.sku_id}:{record.warehouse_id}"
            self.batch_inventory[key].append(record)
            # æŒ‰è¿‡æœŸæ—¥æœŸæ’åº
            self.batch_inventory[key].sort(key=lambda x: x.expiry_date)
    
    def get_fefo_suggestion(
        self,
        sku_id: str,
        warehouse_id: str,
        quantity: int
    ) -> List[Dict]:
        """è·å–å…ˆè¿›å…ˆå‡ºå»ºè®®"""
        key = f"{sku_id}:{warehouse_id}"
        batches = self.batch_inventory.get(key, [])
        
        suggestion = []
        remaining = quantity
        
        for batch in batches:
            if remaining <= 0:
                break
            
            days_to_expiry = batch.days_to_expiry()
            take_qty = min(remaining, batch.quantity_available)
            
            suggestion.append({
                "batch_id": batch.batch_id,
                "quantity": take_qty,
                "expiry_date": batch.expiry_date.isoformat() if batch.expiry_date else None,
                "days_to_expiry": days_to_expiry
            })
            
            remaining -= take_qty
        
        return suggestion
    
    def get_expiry_alerts(self, days_threshold: int = 3) -> List[Dict]:
        """è·å–ä¸´æœŸé¢„è­¦"""
        alerts = []
        
        for key, batches in self.batch_inventory.items():
            for batch in batches:
                days = batch.days_to_expiry()
                if days is not None and days <= days_threshold:
                    alerts.append({
                        "sku_id": batch.sku_id,
                        "warehouse_id": batch.warehouse_id,
                        "batch_id": batch.batch_id,
                        "quantity": batch.quantity_available,
                        "days_to_expiry": days,
                        "suggested_action": "markdown" if days > 0 else "dispose"
                    })
        
        return sorted(alerts, key=lambda x: x["days_to_expiry"])


class JDIntelligentInventorySystem:
    """äº¬ä¸œæ™ºèƒ½åº“å­˜ç®¡ç†ç³»ç»Ÿä¸»ç±»"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.schema_registry = InventorySchemaRegistry()
        self.forecasting_engine = DemandForecastingEngine(self.schema_registry)
        self.replenishment_engine = SmartReplenishmentEngine(self.schema_registry)
        self.channel_manager = MultiChannelInventoryManager()
        self.fresh_manager = FreshProductManager()
        self.skus: Dict[str, SKU] = {}
        self.warehouses: Dict[str, Warehouse] = {}
        self.inventory: Dict[str, InventoryRecord] = {}
        self.kafka_producer: Optional[KafkaProducer] = None
        self.stats = {
            "forecasts_generated": 0,
            "replenishment_orders": 0,
            "allocations": 0
        }
    
    async def initialize(self):
        """åˆå§‹åŒ–ç³»ç»Ÿ"""
        logger.info("Initializing JD Intelligent Inventory System...")
        
        try:
            self.kafka_producer = KafkaProducer(
                bootstrap_servers=self.config.get("kafka_servers", ["localhost:9092"]),
                value_serializer=lambda v: json.dumps(v, default=str).encode('utf-8')
            )
            logger.info("Kafka producer initialized")
        except Exception as e:
            logger.warning(f"Kafka not available: {e}")
        
        # åŠ è½½ç¤ºä¾‹æ•°æ®
        self._load_sample_data()
        
        logger.info("System initialization completed")
    
    def _load_sample_data(self):
        """åŠ è½½ç¤ºä¾‹æ•°æ®"""
        # SKUæ•°æ®
        skus = [
            SKU("SKU001", "iPhone 15 Pro", ProductCategory.ELECTRONICS, "Apple", 7500, 8999, "SUP001", 7),
            SKU("SKU002", "æ™ºåˆ©è½¦å˜å­JJJ 5kg", ProductCategory.FRESH, "FreshFarm", 120, 199, "SUP002", 3, 7),
            SKU("SKU003", "æŠ½çº¸3å±‚120æŠ½", ProductCategory.FMCG, "CleanBrand", 15, 29, "SUP003", 5),
            SKU("SKU004", "å¥³å£«ç¾½ç»’æœ", ProductCategory.FASHION, "FashionBrand", 200, 399, "SUP004", 14),
            SKU("SKU005", "æœ‰æœºç‰›å¥¶1L", ProductCategory.FRESH, "DairyFarm", 8, 15, "SUP005", 2, 15)
        ]
        
        for sku in skus:
            self.skus[sku.sku_id] = sku
        
        # ä»“åº“æ•°æ®
        warehouses = [
            Warehouse("WH001", "ä¸Šæµ·äºšæ´²ä¸€å·", "A1", "åä¸œ", 1000000),
            Warehouse("WH002", "åŒ—äº¬åŸå¸‚ä»“", "city", "ååŒ—", 500000),
            Warehouse("WH003", "å¹¿å·å†·é“¾ä»“", "cold", "åå—", 200000),
            Warehouse("WH004", "æˆéƒ½å‰ç½®ä»“", "front", "è¥¿å—", 50000)
        ]
        
        for wh in warehouses:
            self.warehouses[wh.warehouse_id] = wh
        
        # åº“å­˜æ•°æ®
        inventory_data = [
            ("SKU001", "WH001", 500, 50, 100),
            ("SKU002", "WH003", 200, 20, 0, "BATCH001", datetime.now() + timedelta(days=5)),
            ("SKU003", "WH001", 1000, 100, 500),
            ("SKU004", "WH002", 300, 30, 0),
            ("SKU005", "WH003", 500, 50, 200, "BATCH002", datetime.now() + timedelta(days=12))
        ]
        
        for data in inventory_data:
            record = InventoryRecord(
                record_id=f"INV_{uuid.uuid4().hex[:8].upper()}",
                sku_id=data[0],
                warehouse_id=data[1],
                quantity_available=data[2],
                quantity_reserved=data[3],
                quantity_inbound=data[4],
                batch_id=data[5] if len(data) > 5 else None,
                expiry_date=data[6] if len(data) > 6 else None
            )
            
            self.inventory[f"{data[0]}:{data[1]}"] = record
            
            if record.expiry_date:
                self.fresh_manager.add_batch_inventory(record)
    
    async def run_demand_forecasting(self):
        """è¿è¡Œéœ€æ±‚é¢„æµ‹"""
        logger.info("Running demand forecasting...")
        
        for sku in self.skus.values():
            for warehouse in self.warehouses.values():
                forecast = self.forecasting_engine.predict_demand(sku, warehouse, horizon_days=14)
                self.stats["forecasts_generated"] += 1
                
                logger.info(f"Forecast for {sku.sku_id} @ {warehouse.warehouse_id}: "
                           f"{forecast.predicted_demand} units (confidence: {forecast.confidence_lower}-{forecast.confidence_upper})")
    
    async def run_replenishment_planning(self):
        """è¿è¡Œè¡¥è´§è§„åˆ’"""
        logger.info("Running replenishment planning...")
        
        for sku in self.skus.values():
            for warehouse in self.warehouses.values():
                # å…ˆè¿è¡Œé¢„æµ‹
                forecast = self.forecasting_engine.predict_demand(sku, warehouse, horizon_days=14)
                
                # è·å–å½“å‰åº“å­˜
                inv_key = f"{sku.sku_id}:{warehouse.warehouse_id}"
                inventory = self.inventory.get(inv_key)
                
                if not inventory:
                    inventory = InventoryRecord(
                        record_id=f"INV_{uuid.uuid4().hex[:8].upper()}",
                        sku_id=sku.sku_id,
                        warehouse_id=warehouse.warehouse_id,
                        quantity_available=0,
                        quantity_reserved=0,
                        quantity_inbound=0
                    )
                
                # ç”Ÿæˆè¡¥è´§å»ºè®®
                order = self.replenishment_engine.generate_replenishment_suggestion(
                    sku, warehouse, inventory, forecast
                )
                
                if order:
                    self.stats["replenishment_orders"] += 1
                    logger.info(f"Replenishment suggestion for {sku.sku_id}: "
                               f"Qty={order.quantity}, Priority={order.priority}")
    
    async def run_channel_allocation(self):
        """è¿è¡Œæ¸ é“åº“å­˜åˆ†é…"""
        logger.info("Running channel allocation...")
        
        # è®¾ç½®æ¸ é“é…é¢
        for sku in self.skus.values():
            for warehouse in self.warehouses.values():
                key = f"{sku.sku_id}:{warehouse.warehouse_id}"
                inventory = self.inventory.get(key)
                
                if inventory:
                    total = inventory.quantity_available
                    # è®¾ç½®é…é¢ï¼šè‡ªè¥60%ï¼ŒPOP30%ï¼Œçº¿ä¸‹10%
                    quotas = {
                        ChannelType.SELF_OPERATED: int(total * 0.6),
                        ChannelType.POP: int(total * 0.3),
                        ChannelType.OFFLINE: int(total * 0.1)
                    }
                    self.channel_manager.set_channel_quota(sku.sku_id, warehouse.warehouse_id, quotas)
        
        # æ¨¡æ‹Ÿåº“å­˜åˆ†é…
        for i in range(10):
            sku_id = np.random.choice(list(self.skus.keys()))
            warehouse_id = np.random.choice(list(self.warehouses.keys()))
            channel = np.random.choice(list(ChannelType))
            quantity = np.random.randint(1, 20)
            
            success, message = self.channel_manager.allocate_inventory(
                sku_id, warehouse_id, channel, quantity
            )
            
            if success:
                self.stats["allocations"] += 1
            
            logger.info(f"Allocation attempt: {sku_id} -> {channel.value} x{quantity}: {message}")
    
    async def run_fresh_management(self):
        """è¿è¡Œç”Ÿé²œç®¡ç†"""
        logger.info("Running fresh product management...")
        
        # è·å–ä¸´æœŸé¢„è­¦
        alerts = self.fresh_manager.get_expiry_alerts(days_threshold=7)
        
        logger.info(f"Found {len(alerts)} products nearing expiry")
        
        for alert in alerts[:5]:
            logger.info(f"Expiry alert: {alert['sku_id']} batch {alert['batch_id']} "
                       f"expires in {alert['days_to_expiry']} days, qty={alert['quantity']}")
        
        # FEFOå‡ºåº“å»ºè®®
        for sku in self.skus.values():
            if sku.category == ProductCategory.FRESH:
                for warehouse in self.warehouses.values():
                    suggestion = self.fresh_manager.get_fefo_suggestion(
                        sku.sku_id, warehouse.warehouse_id, quantity=10
                    )
                    
                    if suggestion:
                        logger.info(f"FEFO suggestion for {sku.sku_id}: {len(suggestion)} batches")
    
    async def run_demo(self):
        """è¿è¡Œæ¼”ç¤º"""
        logger.info("Starting JD Intelligent Inventory Demo...")
        
        await self.run_demand_forecasting()
        await self.run_replenishment_planning()
        await self.run_channel_allocation()
        await self.run_fresh_management()
        
        logger.info(f"\n{'='*60}")
        logger.info("Final System Statistics")
        logger.info(f"{'='*60}")
        logger.info(f"Forecasts generated: {self.stats['forecasts_generated']}")
        logger.info(f"Replenishment orders: {self.stats['replenishment_orders']}")
        logger.info(f"Channel allocations: {self.stats['allocations']}")
        
        # è¡¥è´§è®¢å•æ±‡æ€»
        pending_orders = [o for o in self.replenishment_engine.replenishment_orders.values() if o.status == "pending"]
        logger.info(f"\nPending replenishment orders: {len(pending_orders)}")
        
        for order in sorted(pending_orders, key=lambda x: x.priority)[:5]:
            logger.info(f"  Priority {order.priority}: {order.sku_id} x{order.quantity}")


async def main():
    """ä¸»å‡½æ•°"""
    config = {
        "kafka_servers": ["localhost:9092"]
    }
    
    system = JDIntelligentInventorySystem(config)
    await system.initialize()
    await system.run_demo()


if __name__ == "__main__":
    asyncio.run(main())
```

---

## 7. æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ

### 7.1 å…³é”®æŒ‡æ ‡è¾¾æˆæƒ…å†µ

| æŒ‡æ ‡ç±»åˆ« | æŒ‡æ ‡åç§° | ç›®æ ‡å€¼ | å®é™…è¾¾æˆ | è¾¾æˆç‡ |
|----------|----------|--------|----------|--------|
| **åº“å­˜å¯è§†åŒ–** | åº“å­˜æ•°æ®å®æ—¶ç‡ | 99.5% | 99.7% | 100% |
| | åº“å­˜å‡†ç¡®ç‡ | 99.9% | 99.95% | 100% |
| **éœ€æ±‚é¢„æµ‹** | é¢„æµ‹å‡†ç¡®ç‡ | 85% | 87% | 102% |
| | å¤§ä¿ƒé¢„æµ‹å‡†ç¡®ç‡ | 90% | 92% | 102% |
| **æ™ºèƒ½è¡¥è´§** | è¡¥è´§å†³ç­–æ—¶é—´ | 1å¤© | 12å°æ—¶ | 200% |
| | ç¼ºè´§ç‡ | 3% | 2.5% | 120% |
| **å¤šæ¸ é“åº“å­˜** | è¶…å–ç‡ | <0.1% | 0.05% | 200% |
| | åº“å­˜å‘¨è½¬å¤©æ•° | 30å¤© | 28å¤© | 107% |
| **æ•ˆæœŸç®¡ç†** | ç”Ÿé²œæŸè€—ç‡ | 5% | 4.5% | 111% |
| | ä¸´æœŸä¿ƒé”€è½¬åŒ–ç‡ | 50% | 55% | 110% |

### 7.2 ç»æµæ•ˆç›Šåˆ†æï¼ˆå¹´åº¦ï¼‰

| æ”¶ç›Šç±»åˆ« | å…·ä½“å†…å®¹ | é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰ |
|----------|----------|--------------|
| **ç›´æ¥æ”¶ç›Š** | | |
| ç¼ºè´§æŸå¤±å‡å°‘ | ç¼ºè´§ç‡ä»8%é™è‡³2.5%ï¼Œé”€å”®æœºä¼šæŒ½å› | 85,000 |
| æ»é”€åº“å­˜å‡å°‘ | åº“å­˜å‘¨è½¬å¤©æ•°ä»45å¤©é™è‡³28å¤©ï¼Œèµ„é‡‘å ç”¨å‡å°‘ | 120,000 |
| ç”Ÿé²œæŸè€—é™ä½ | ç”Ÿé²œæŸè€—ç‡ä»12%é™è‡³4.5%ï¼ŒæŸå¤±å‡å°‘ | 95,000 |
| è¶…å–èµ”ä»˜å‡å°‘ | è¶…å–ç‡é™è‡³0.05%ï¼Œå®¢æˆ·èµ”ä»˜å‡å°‘ | 15,000 |
| ä»“å‚¨æˆæœ¬èŠ‚çº¦ | åº“å­˜ä¼˜åŒ–ï¼Œä»“å‚¨é¢ç§¯éœ€æ±‚å‡å°‘ | 25,000 |
| **é—´æ¥æ”¶ç›Š** | | |
| èµ„é‡‘æ•ˆç‡æå‡ | åº“å­˜å‘¨è½¬åŠ å¿«ï¼Œèµ„é‡‘æˆæœ¬èŠ‚çº¦ | 35,000 |
| å®¢æˆ·æ»¡æ„åº¦æå‡ | ç¼ºè´§å‡å°‘ï¼Œå®¢æˆ·ä½“éªŒæå‡ | 10,000 |
| è¿è¥æ•ˆç‡æå‡ | è‡ªåŠ¨åŒ–è¡¥è´§ï¼ŒäººåŠ›æˆæœ¬èŠ‚çº¦ | 12,000 |
| **å¹´åº¦æ€»æ”¶ç›Š** | | **397,000** |

### 7.3 æŠ•èµ„æˆæœ¬åˆ†æ

| æˆæœ¬ç±»åˆ« | å…·ä½“å†…å®¹ | é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰ |
|----------|----------|--------------|
| **ç¡¬ä»¶æŠ•èµ„** | | |
| æœåŠ¡å™¨é›†ç¾¤ | é¢„æµ‹è®¡ç®—ã€æ•°æ®åˆ†ææœåŠ¡å™¨ | 25,000 |
| è¾¹ç¼˜è®¡ç®—è®¾å¤‡ | ä»“åº“è¾¹ç¼˜è®¡ç®—èŠ‚ç‚¹ | 15,000 |
| ç½‘ç»œå‡çº§ | ä»“åº“ç½‘ç»œå¸¦å®½å‡çº§ | 5,000 |
| **è½¯ä»¶æŠ•èµ„** | | |
| å¹³å°è½¯ä»¶è®¸å¯ | AIå¹³å°ã€æ•°æ®åº“ã€ä¸­é—´ä»¶ | 20,000 |
| å®šåˆ¶å¼€å‘ | é¢„æµ‹ç³»ç»Ÿã€è¡¥è´§ç³»ç»Ÿã€æ•ˆæœŸç®¡ç†ç³»ç»Ÿ | 55,000 |
| **å®æ–½æœåŠ¡** | | |
| ç³»ç»Ÿé›†æˆ | 1,600+ä»“åº“ç³»ç»Ÿé›†æˆ | 30,000 |
| æ•°æ®è¿ç§» | å†å²åº“å­˜æ•°æ®æ¸…æ´— | 8,000 |
| **å¹´åº¦è¿ç»´** | | |
| äº‘æœåŠ¡/è¿ç»´ | å¹´åº¦äº‘æœåŠ¡åŠè¿ç»´è´¹ç”¨ | 12,000 |
| **æ€»æŠ•èµ„é¢** | | **170,000** |

### 7.4 ROIè®¡ç®—

```
æŠ•èµ„å›æŠ¥ç‡ (ROI) = (å¹´åº¦æ€»æ”¶ç›Š - å¹´åº¦è¿ç»´æˆæœ¬) / æ€»æŠ•èµ„é¢ Ã— 100%
                = (397,000 - 12,000) / 170,000 Ã— 100%
                = 226%

æŠ•èµ„å›æ”¶æœŸ = æ€»æŠ•èµ„é¢ / (å¹´åº¦æ€»æ”¶ç›Š - å¹´åº¦è¿ç»´æˆæœ¬)
          = 170,000 / 385,000
          â‰ˆ 0.44 å¹´ (çº¦ 5.3 ä¸ªæœˆ)

å‡€ç°å€¼ (NPV, 5å¹´, 8%æŠ˜ç°ç‡) = 154.8äº¿å…ƒ
å†…éƒ¨æ”¶ç›Šç‡ (IRR) = 222%
```

### 7.5 æˆ˜ç•¥ä»·å€¼

| ç»´åº¦ | ä»·å€¼æè¿° |
|------|----------|
| **ä¾›åº”é“¾éŸ§æ€§** | æ™ºèƒ½åº“å­˜ç½‘ç»œæå‡ä¾›åº”é“¾æŠ—é£é™©èƒ½åŠ›ï¼Œç–«æƒ…æœŸé—´ä¿éšœç‰©èµ„ä¾›åº” |
| **å®¢æˆ·ä½“éªŒ** | ç¼ºè´§ç‡å¤§å¹…ä¸‹é™ï¼Œ211é™æ—¶è¾¾å±¥çº¦ç‡æå‡è‡³98% |
| **è¡Œä¸šæ ‡æ†** | å…¥é€‰Gartnerä¾›åº”é“¾25å¼ºï¼Œæˆä¸ºå…¨çƒæ™ºæ…§ç‰©æµæ ‡æ† |
| **ç”Ÿæ€ååŒ** | å¼€æ”¾åº“å­˜èƒ½åŠ›ï¼Œèµ‹èƒ½ç¬¬ä¸‰æ–¹å•†å®¶ï¼Œæ„å»ºç‰©æµç”Ÿæ€ |
| **å¯æŒç»­å‘å±•** | ç”Ÿé²œæŸè€—å¤§å¹…é™ä½ï¼Œå‡å°‘é£Ÿç‰©æµªè´¹ï¼Œè·µè¡ŒESGç†å¿µ |

---

**å‚è€ƒæ–‡æ¡£**ï¼š
- `01_Overview.md` - åº“å­˜ç®¡ç†Schemaæ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡ï¼ˆGS1/EPCISï¼‰
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æœ€åæ›´æ–°**ï¼š2025-02-15

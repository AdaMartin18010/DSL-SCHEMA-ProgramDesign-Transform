# æµ·è¿ä¸èˆªè¿Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [æµ·è¿ä¸èˆªè¿Schemaå®è·µæ¡ˆä¾‹](#æµ·è¿ä¸èˆªè¿schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šGlobalShippingé›†å›¢èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ](#2-æ¡ˆä¾‹1globalshippingé›†å›¢èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´å®ç°ä»£ç ](#26-å®Œæ•´å®ç°ä»£ç )
    - [2.7 æ•ˆæœè¯„ä¼°ä¸ROI](#27-æ•ˆæœè¯„ä¼°ä¸roi)
  - [3. æ¡ˆä¾‹2ï¼šæ™ºèƒ½èˆªçº¿ä¼˜åŒ–ç³»ç»Ÿ](#3-æ¡ˆä¾‹2æ™ºèƒ½èˆªçº¿ä¼˜åŒ–ç³»ç»Ÿ)
    - [3.1 ä¼ä¸šèƒŒæ™¯](#31-ä¼ä¸šèƒŒæ™¯)
    - [3.2 ä¸šåŠ¡ç—›ç‚¹](#32-ä¸šåŠ¡ç—›ç‚¹)
    - [3.3 ä¸šåŠ¡ç›®æ ‡](#33-ä¸šåŠ¡ç›®æ ‡)
    - [3.4 æŠ€æœ¯æŒ‘æˆ˜](#34-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.5 å®Œæ•´å®ç°ä»£ç ](#35-å®Œæ•´å®ç°ä»£ç )
    - [3.6 æ•ˆæœè¯„ä¼°ä¸ROI](#36-æ•ˆæœè¯„ä¼°ä¸roi)
  - [4. æ¡ˆä¾‹3ï¼šæ¸¯å£æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ](#4-æ¡ˆä¾‹3æ¸¯å£æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ)
    - [4.1 ä¼ä¸šèƒŒæ™¯](#41-ä¼ä¸šèƒŒæ™¯)
    - [4.2 ä¸šåŠ¡ç—›ç‚¹](#42-ä¸šåŠ¡ç—›ç‚¹)
    - [4.3 ä¸šåŠ¡ç›®æ ‡](#43-ä¸šåŠ¡ç›®æ ‡)
    - [4.4 æŠ€æœ¯æŒ‘æˆ˜](#44-æŠ€æœ¯æŒ‘æˆ˜)
    - [4.5 å®Œæ•´å®ç°ä»£ç ](#45-å®Œæ•´å®ç°ä»£ç )
    - [4.6 æ•ˆæœè¯„ä¼°ä¸ROI](#46-æ•ˆæœè¯„ä¼°ä¸roi)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æµ·è¿ä¸èˆªè¿Schemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–èˆ¹èˆ¶è¿½è¸ªã€èˆªçº¿ä¼˜åŒ–ã€æ¸¯å£è°ƒåº¦ç­‰æ ¸å¿ƒåœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ**ï¼šå®æ—¶è¿½è¸ªå…¨çƒèˆ¹é˜Ÿä½ç½®å’ŒçŠ¶æ€
2. **æ™ºèƒ½èˆªçº¿ä¼˜åŒ–**ï¼šåŸºäºå¤©æ°”ã€ç‡ƒæ–™æˆæœ¬ä¼˜åŒ–èˆªçº¿
3. **æ¸¯å£æ™ºèƒ½è°ƒåº¦**ï¼šä¼˜åŒ–æ³Šä½åˆ†é…å’Œè£…å¸ä½œä¸š

**å‚è€ƒæ ‡å‡†**ï¼š

- **AISæ ‡å‡†**ï¼šè‡ªåŠ¨è¯†åˆ«ç³»ç»Ÿæ ‡å‡†
- **EDIFACTæ ‡å‡†**ï¼šç”µå­æ•°æ®äº¤æ¢æ ‡å‡†
- **IMOæ ‡å‡†**ï¼šå›½é™…æµ·äº‹ç»„ç»‡æ ‡å‡†

---

## 2. æ¡ˆä¾‹1ï¼šGlobalShippingé›†å›¢èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ

### 2.1 ä¼ä¸šèƒŒæ™¯

**GlobalShippingé›†å›¢**æ˜¯å…¨çƒå‰åå¤§èˆªè¿å…¬å¸ä¹‹ä¸€ï¼Œæ‹¥æœ‰é›†è£…ç®±èˆ¹ã€æ•£è´§èˆ¹ã€æ²¹è½®ç­‰å„ç±»èˆ¹èˆ¶280è‰˜ï¼Œèˆªçº¿è¦†ç›–å…¨çƒ150ä¸ªæ¸¯å£ï¼Œå¹´è´§è¿é‡è¶…è¿‡800ä¸‡TEUã€‚

- **æˆç«‹æ—¶é—´**ï¼š1985å¹´
- **å‘˜å·¥è§„æ¨¡**ï¼š15,000äººï¼ˆå²¸ä¸Šï¼‰+ 8,000äººï¼ˆèˆ¹å‘˜ï¼‰
- **èˆ¹é˜Ÿè§„æ¨¡**ï¼š280è‰˜
- **å¹´è´§è¿é‡**ï¼š800ä¸‡+ TEU
- **è¦†ç›–æ¸¯å£**ï¼š150ä¸ª
- **èˆªçº¿æ•°é‡**ï¼š80æ¡

### 2.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **ä½ç½®æ›´æ–°å»¶è¿Ÿ** | ä¸¥é‡ | AISæ•°æ®å»¶è¿Ÿ10-30åˆ†é’Ÿï¼Œæ— æ³•å®æ—¶æŒæ¡èˆ¹é˜Ÿä½ç½® |
| 2 | **ETAé¢„æµ‹ä¸å‡†** | ä¸¥é‡ | é¢„è®¡åˆ°æ¸¯æ—¶é—´è¯¯å·®å¹³å‡12å°æ—¶ï¼Œå½±å“æ¸¯å£é¢„çº¦å’Œè´§ç‰©äº¤æ¥ |
| 3 | **å¼‚å¸¸äº‹ä»¶å“åº”æ…¢** | ä¸¥é‡ | èˆ¹èˆ¶åèˆªã€æ•…éšœç­‰å¼‚å¸¸å‘ç°ä¸åŠæ—¶ï¼Œå¹´å‡æŸå¤±500ä¸‡ç¾å…ƒ |
| 4 | **æ•°æ®åˆ†æ•£** | é«˜ | èˆ¹ä½æ•°æ®åˆ†å¸ƒåœ¨5ä¸ªä¸åŒç³»ç»Ÿï¼ŒæŸ¥è¯¢å›°éš¾ |
| 5 | **å®¢æˆ·æŸ¥è¯¢ä½“éªŒå·®** | ä¸­ | å®¢æˆ·æŸ¥è¯¢è´§ç‰©ä½ç½®éœ€è¦ç­‰å¾…>30åˆ†é’Ÿ |

### 2.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | ä½ç½®æ›´æ–°é¢‘ç‡ | 30åˆ†é’Ÿ | <2åˆ†é’Ÿ | 9ä¸ªæœˆ |
| 2 | ETAé¢„æµ‹è¯¯å·® | 12å°æ—¶ | <2å°æ—¶ | 12ä¸ªæœˆ |
| 3 | å¼‚å¸¸äº‹ä»¶æ£€æµ‹æ—¶é—´ | 4å°æ—¶ | <15åˆ†é’Ÿ | 9ä¸ªæœˆ |
| 4 | æ•°æ®æ•´åˆè¦†ç›–ç‡ | 20% | 98% | 12ä¸ªæœˆ |
| 5 | å®¢æˆ·æŸ¥è¯¢å“åº”æ—¶é—´ | 30åˆ†é’Ÿ | <5ç§’ | 6ä¸ªæœˆ |

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å…¨çƒå«æ˜Ÿé€šä¿¡**ï¼šéœ€è¦åœ¨è¿œæ´‹åŒºåŸŸä¿æŒå«æ˜Ÿé€šä¿¡è¿æ¥ï¼Œå¤„ç†å«æ˜Ÿé“¾è·¯é«˜å»¶è¿Ÿï¼ˆ500-800msï¼‰å’Œé—´æ­‡æ€§ä¸­æ–­é—®é¢˜

2. **æµ·é‡AISæ•°æ®å¤„ç†**ï¼šå…¨çƒ280è‰˜èˆ¹èˆ¶æ¯åˆ†é’Ÿäº§ç”Ÿä½ç½®æ•°æ®ï¼Œæ—¥æ•°æ®é‡è¶…è¿‡4äº¿æ¡ï¼Œéœ€è¦é«˜æ•ˆå­˜å‚¨å’ŒæŸ¥è¯¢

3. **å¤šæºæ•°æ®èåˆ**ï¼šéœ€è¦èåˆAISã€Inmarsatã€VSATã€LRITç­‰å¤šç§å®šä½æ•°æ®æºï¼Œæé«˜å®šä½ç²¾åº¦å’Œå¯é æ€§

4. **å®æ—¶åœ°ç†å›´æ **ï¼šéœ€è¦å¯¹150ä¸ªæ¸¯å£ã€200ä¸ªå…³é”®æ°´é“è®¾ç½®åœ°ç†å›´æ ï¼Œå®æ—¶æ£€æµ‹è¿›å‡ºäº‹ä»¶

5. **ç¦»çº¿æ•°æ®å¤„ç†**ï¼šèˆ¹èˆ¶åœ¨å«æ˜Ÿç›²åŒºæ—¶æ•°æ®éœ€æœ¬åœ°ç¼“å­˜ï¼Œæ¢å¤é€šä¿¡åæ‰¹é‡åŒæ­¥ï¼Œè¦æ±‚æ•°æ®ä¸€è‡´æ€§å’Œæ—¶åºæ­£ç¡®

### 2.5 è§£å†³æ–¹æ¡ˆ

**èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿæ¶æ„**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ•°æ®å±•ç¤ºå±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ èˆ¹é˜Ÿç›‘æ§å¤§å± â”‚ â”‚ èˆ¹èˆ¶è¯¦æƒ…é¡µ  â”‚ â”‚ APIæœåŠ¡               â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ä¸šåŠ¡é€»è¾‘å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ä½ç½®è®¡ç®—    â”‚ â”‚ ETAé¢„æµ‹     â”‚ â”‚ å¼‚å¸¸æ£€æµ‹å¼•æ“          â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æ•°æ®æ¥å…¥å±‚                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ AISæ¥æ”¶ç«™   â”‚ â”‚ å«æ˜Ÿé€šä¿¡ç½‘å…³â”‚ â”‚ èˆ¹èˆ¶æœ¬åœ°ç¼“å­˜åŒæ­¥      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.6 å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
GlobalShippingé›†å›¢èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ - æ ¸å¿ƒå®ç°
å®æ—¶è¿½è¸ªå…¨çƒèˆ¹é˜Ÿä½ç½®ï¼Œæä¾›ETAé¢„æµ‹å’Œå¼‚å¸¸æ£€æµ‹
"""

import asyncio
import json
import logging
import math
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple, Set
from collections import defaultdict, deque

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class VesselType(Enum):
    """èˆ¹èˆ¶ç±»å‹"""
    CONTAINER = "container"
    BULK_CARRIER = "bulk_carrier"
    TANKER = "tanker"
    GENERAL_CARGO = "general_cargo"
    RORO = "roro"


class VesselStatus(Enum):
    """èˆ¹èˆ¶çŠ¶æ€"""
    AT_SEA = "at_sea"
    AT_ANCHOR = "at_anchor"
    IN_PORT = "in_port"
    MAINTENANCE = "maintenance"
    OFF_HIRE = "off_hire"


class AlertType(Enum):
    """å‘Šè­¦ç±»å‹"""
    DEVIATION = "deviation"           # åèˆª
    SPEED_ANOMALY = "speed_anomaly"   # é€Ÿåº¦å¼‚å¸¸
    ETA_CHANGE = "eta_change"         # ETAå˜åŒ–
    GEOFENCE = "geofence"             # åœ°ç†å›´æ 
    COMMUNICATION = "communication"   # é€šä¿¡ä¸­æ–­


@dataclass
class GeoPoint:
    """åœ°ç†åæ ‡ç‚¹"""
    latitude: float
    longitude: float
    
    def distance_to(self, other: 'GeoPoint') -> float:
        """è®¡ç®—ä¸å¦ä¸€ç‚¹çš„è·ç¦»ï¼ˆæµ·é‡Œï¼‰"""
        # Haversineå…¬å¼
        R = 3440.065  # åœ°çƒåŠå¾„ï¼ˆæµ·é‡Œï¼‰
        
        lat1, lon1 = math.radians(self.latitude), math.radians(self.longitude)
        lat2, lon2 = math.radians(other.latitude), math.radians(other.longitude)
        
        dlat = lat2 - lat1
        dlon = lon2 - lon1
        
        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return R * c
    
    def to_dict(self) -> Dict[str, float]:
        return {"latitude": self.latitude, "longitude": self.longitude}


@dataclass
class Vessel:
    """èˆ¹èˆ¶"""
    vessel_id: str
    imo: str
    name: str
    vessel_type: VesselType
    length_m: float
    width_m: float
    max_speed_knots: float
    
    # åŠ¨æ€ä¿¡æ¯
    current_position: Optional[GeoPoint] = None
    current_heading: float = 0.0
    current_speed_knots: float = 0.0
    current_status: VesselStatus = VesselStatus.AT_SEA
    last_update: datetime = field(default_factory=datetime.now)
    
    # èˆªçº¿ä¿¡æ¯
    destination: Optional[str] = None
    eta: Optional[datetime] = None
    planned_route: List[GeoPoint] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "vessel_id": self.vessel_id,
            "imo": self.imo,
            "name": self.name,
            "vessel_type": self.vessel_type.value,
            "dimensions": {
                "length_m": self.length_m,
                "width_m": self.width_m
            },
            "current": {
                "position": self.current_position.to_dict() if self.current_position else None,
                "heading": self.current_heading,
                "speed_knots": self.current_speed_knots,
                "status": self.current_status.value
            },
            "destination": self.destination,
            "eta": self.eta.isoformat() if self.eta else None,
            "last_update": self.last_update.isoformat()
        }


@dataclass
class PositionReport:
    """ä½ç½®æŠ¥å‘Š"""
    report_id: str
    vessel_id: str
    position: GeoPoint
    heading: float
    speed_knots: float
    timestamp: datetime
    source: str  # AIS, Inmarsat, VSAT
    accuracy_m: float = 10.0
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "report_id": self.report_id,
            "vessel_id": self.vessel_id,
            "position": self.position.to_dict(),
            "heading": self.heading,
            "speed_knots": self.speed_knots,
            "timestamp": self.timestamp.isoformat(),
            "source": self.source,
            "accuracy_m": self.accuracy_m
        }


@dataclass
class Port:
    """æ¸¯å£"""
    port_id: str
    unlocode: str
    name: str
    country: str
    position: GeoPoint
    anchorage_area: Optional[List[GeoPoint]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "port_id": self.port_id,
            "unlocode": self.unlocode,
            "name": self.name,
            "country": self.country,
            "position": self.position.to_dict()
        }


@dataclass
class Alert:
    """å‘Šè­¦"""
    alert_id: str
    vessel_id: str
    alert_type: AlertType
    severity: str  # critical, high, medium, low
    message: str
    timestamp: datetime
    acknowledged: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "alert_id": self.alert_id,
            "vessel_id": self.vessel_id,
            "alert_type": self.alert_type.value,
            "severity": self.severity,
            "message": self.message,
            "timestamp": self.timestamp.isoformat(),
            "acknowledged": self.acknowledged
        }


class VesselTrackingSystem:
    """èˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ"""
    
    def __init__(self):
        self.vessels: Dict[str, Vessel] = {}
        self.ports: Dict[str, Port] = {}
        self.position_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))
        self.alerts: Dict[str, Alert] = {}
        
        # åœ°ç†å›´æ 
        self.geofences: Dict[str, Dict] = {}
        
        # ç»Ÿè®¡
        self.stats = {
            "total_reports_processed": 0,
            "alerts_generated": 0,
            "avg_position_age_seconds": 0
        }
        
        logger.info("Vessel Tracking System initialized")
    
    def register_vessel(self, vessel: Vessel):
        """æ³¨å†Œèˆ¹èˆ¶"""
        self.vessels[vessel.vessel_id] = vessel
        logger.info(f"Registered vessel: {vessel.name} (IMO: {vessel.imo})")
    
    def register_port(self, port: Port):
        """æ³¨å†Œæ¸¯å£"""
        self.ports[port.port_id] = port
    
    def process_position_report(self, report: PositionReport) -> bool:
        """å¤„ç†ä½ç½®æŠ¥å‘Š"""
        if report.vessel_id not in self.vessels:
            logger.warning(f"Unknown vessel: {report.vessel_id}")
            return False
        
        vessel = self.vessels[report.vessel_id]
        
        # æ›´æ–°èˆ¹èˆ¶ä½ç½®
        vessel.current_position = report.position
        vessel.current_heading = report.heading
        vessel.current_speed_knots = report.speed_knots
        vessel.last_update = report.timestamp
        
        # ä¿å­˜å†å²
        self.position_history[report.vessel_id].append(report)
        self.stats["total_reports_processed"] += 1
        
        # æ›´æ–°ç»Ÿè®¡
        position_age = (datetime.now() - report.timestamp).total_seconds()
        n = self.stats["total_reports_processed"]
        self.stats["avg_position_age_seconds"] = (
            self.stats["avg_position_age_seconds"] * (n-1) + position_age
        ) / n
        
        # æ£€æŸ¥åèˆª
        self._check_deviation(vessel, report)
        
        # æ£€æŸ¥é€Ÿåº¦å¼‚å¸¸
        self._check_speed_anomaly(vessel, report)
        
        # æ£€æŸ¥åœ°ç†å›´æ 
        self._check_geofences(vessel, report)
        
        # æ›´æ–°ETA
        self._update_eta(vessel)
        
        return True
    
    def _check_deviation(self, vessel: Vessel, report: PositionReport):
        """æ£€æŸ¥æ˜¯å¦åèˆª"""
        if not vessel.planned_route or len(vessel.planned_route) < 2:
            return
        
        # æ‰¾åˆ°è®¡åˆ’èˆªçº¿ä¸Šæœ€è¿‘çš„ç‚¹
        min_distance = float('inf')
        for point in vessel.planned_route:
            dist = report.position.distance_to(point)
            min_distance = min(min_distance, dist)
        
        # å¦‚æœè·ç¦»è®¡åˆ’èˆªçº¿è¶…è¿‡5æµ·é‡Œï¼Œè§¦å‘åèˆªå‘Šè­¦
        if min_distance > 5:
            self._create_alert(
                vessel.vessel_id,
                AlertType.DEVIATION,
                "high",
                f"Vessel deviated from planned route by {min_distance:.1f} nautical miles"
            )
    
    def _check_speed_anomaly(self, vessel: Vessel, report: PositionReport):
        """æ£€æŸ¥é€Ÿåº¦å¼‚å¸¸"""
        if vessel.max_speed_knots <= 0:
            return
        
        # é€Ÿåº¦è¶…è¿‡æœ€å¤§é€Ÿåº¦çš„120%
        if report.speed_knots > vessel.max_speed_knots * 1.2:
            self._create_alert(
                vessel.vessel_id,
                AlertType.SPEED_ANOMALY,
                "medium",
                f"Speed {report.speed_knots:.1f} knots exceeds maximum {vessel.max_speed_knots:.1f} knots"
            )
        
        # åœ¨èˆªä½†é€Ÿåº¦æ¥è¿‘0
        if vessel.current_status == VesselStatus.AT_SEA and report.speed_knots < 1:
            self._create_alert(
                vessel.vessel_id,
                AlertType.SPEED_ANOMALY,
                "high",
                "Vessel at sea with near-zero speed - possible engine failure"
            )
    
    def _check_geofences(self, vessel: Vessel, report: PositionReport):
        """æ£€æŸ¥åœ°ç†å›´æ """
        for fence_id, fence in self.geofences.items():
            center = fence["center"]
            radius_nm = fence["radius_nm"]
            
            distance = report.position.distance_to(center)
            
            if distance <= radius_nm:
                # æ£€æŸ¥æ˜¯å¦åˆšåˆšè¿›å…¥
                if len(self.position_history[vessel.vessel_id]) >= 2:
                    prev_report = list(self.position_history[vessel.vessel_id])[-2]
                    prev_distance = prev_report.position.distance_to(center)
                    
                    if prev_distance > radius_nm:
                        self._create_alert(
                            vessel.vessel_id,
                            AlertType.GEOFENCE,
                            "medium",
                            f"Vessel entered geofence: {fence_id}"
                        )
    
    def _update_eta(self, vessel: Vessel):
        """æ›´æ–°é¢„è®¡åˆ°æ¸¯æ—¶é—´"""
        if not vessel.destination or not vessel.current_position:
            return
        
        # æŸ¥æ‰¾ç›®çš„æ¸¯
        dest_port = None
        for port in self.ports.values():
            if port.name == vessel.destination or port.unlocode == vessel.destination:
                dest_port = port
                break
        
        if not dest_port:
            return
        
        # è®¡ç®—è·ç¦»
        distance_nm = vessel.current_position.distance_to(dest_port.position)
        
        # ä¼°ç®—èˆªè¡Œæ—¶é—´ï¼ˆå‡è®¾å¹³å‡é€Ÿåº¦ä¸ºå½“å‰é€Ÿåº¦çš„80%ï¼‰
        avg_speed = max(5, vessel.current_speed_knots * 0.8)  # è‡³å°‘5èŠ‚
        hours_to_dest = distance_nm / avg_speed
        
        # æ›´æ–°ETA
        new_eta = datetime.now() + timedelta(hours=hours_to_dest)
        
        # å¦‚æœETAå˜åŒ–è¶…è¿‡2å°æ—¶ï¼Œè§¦å‘å‘Šè­¦
        if vessel.eta and abs((new_eta - vessel.eta).total_seconds()) > 7200:
            self._create_alert(
                vessel.vessel_id,
                AlertType.ETA_CHANGE,
                "medium",
                f"ETA changed from {vessel.eta.strftime('%Y-%m-%d %H:%M')} to {new_eta.strftime('%Y-%m-%d %H:%M')}"
            )
        
        vessel.eta = new_eta
    
    def _create_alert(self, vessel_id: str, alert_type: AlertType,
                     severity: str, message: str) -> str:
        """åˆ›å»ºå‘Šè­¦"""
        alert_id = f"ALT-{datetime.now().strftime('%Y%m%d%H%M%S')}-{vessel_id[:6]}"
        
        alert = Alert(
            alert_id=alert_id,
            vessel_id=vessel_id,
            alert_type=alert_type,
            severity=severity,
            message=message,
            timestamp=datetime.now()
        )
        
        self.alerts[alert_id] = alert
        self.stats["alerts_generated"] += 1
        
        logger.warning(f"Alert created: {message}")
        return alert_id
    
    def add_geofence(self, fence_id: str, center: GeoPoint, radius_nm: float,
                    fence_type: str = "circular"):
        """æ·»åŠ åœ°ç†å›´æ """
        self.geofences[fence_id] = {
            "center": center,
            "radius_nm": radius_nm,
            "type": fence_type
        }
    
    def get_fleet_status(self) -> Dict[str, Any]:
        """è·å–èˆ¹é˜ŸçŠ¶æ€"""
        status_count = defaultdict(int)
        for vessel in self.vessels.values():
            status_count[vessel.current_status.value] += 1
        
        # è®¡ç®—å¹³å‡ä½ç½®æ›´æ–°å»¶è¿Ÿ
        total_delay = 0
        count = 0
        for vessel in self.vessels.values():
            delay = (datetime.now() - vessel.last_update).total_seconds()
            total_delay += delay
            count += 1
        avg_delay = total_delay / count if count > 0 else 0
        
        return {
            "timestamp": datetime.now().isoformat(),
            "total_vessels": len(self.vessels),
            "status_distribution": dict(status_count),
            "avg_position_age_seconds": avg_delay,
            "active_alerts": len([a for a in self.alerts.values() if not a.acknowledged]),
            "total_reports_today": self.stats["total_reports_processed"]
        }
    
    def get_vessel_track(self, vessel_id: str, hours: int = 24) -> List[Dict]:
        """è·å–èˆ¹èˆ¶è½¨è¿¹"""
        if vessel_id not in self.position_history:
            return []
        
        cutoff = datetime.now() - timedelta(hours=hours)
        track = [
            report.to_dict()
            for report in self.position_history[vessel_id]
            if report.timestamp > cutoff
        ]
        
        return sorted(track, key=lambda x: x["timestamp"])


def main():
    """æ¼”ç¤ºèˆ¹èˆ¶è¿½è¸ªç³»ç»Ÿ"""
    system = VesselTrackingSystem()
    
    # æ³¨å†Œæ¸¯å£
    ports = [
        Port("PORT-SHA", "CNSHA", "Shanghai", "China", GeoPoint(31.2304, 121.4737)),
        Port("PORT-SIN", "SGSIN", "Singapore", "Singapore", GeoPoint(1.2897, 103.8501)),
        Port("PORT-RTM", "NLRTM", "Rotterdam", "Netherlands", GeoPoint(51.9244, 4.4777)),
        Port("PORT-LAX", "USLAX", "Los Angeles", "USA", GeoPoint(33.7362, -118.2922))
    ]
    for port in ports:
        system.register_port(port)
    
    # æ³¨å†Œèˆ¹èˆ¶
    vessels = [
        Vessel("VES-001", "1234567", "Pacific Star", VesselType.CONTAINER,
               300.0, 45.0, 25.0, destination="Singapore"),
        Vessel("VES-002", "2345678", "Atlantic Voyager", VesselType.TANKER,
               250.0, 40.0, 15.0, destination="Rotterdam"),
        Vessel("VES-003", "3456789", "Indian Trader", VesselType.BULK_CARRIER,
               280.0, 42.0, 14.0, destination="Shanghai")
    ]
    for vessel in vessels:
        system.register_vessel(vessel)
    
    # æ·»åŠ åœ°ç†å›´æ ï¼ˆä¸Šæµ·æ¸¯é™„è¿‘ï¼‰
    system.add_geofence("SHA-ANCHORAGE", GeoPoint(31.0, 122.0), 20.0)
    
    # æ¨¡æ‹Ÿä½ç½®æŠ¥å‘Š
    import random
    for i in range(100):
        vessel_id = f"VES-{(i % 3) + 1:03d}"
        vessel = system.vessels[vessel_id]
        
        # æ¨¡æ‹Ÿå‘ç›®çš„åœ°ç§»åŠ¨
        if vessel.destination == "Singapore":
            base_lat, base_lon = 25.0 + i*0.05, 115.0 + i*0.02
        elif vessel.destination == "Rotterdam":
            base_lat, base_lon = 40.0 + i*0.02, -30.0 + i*0.05
        else:
            base_lat, base_lon = 20.0 + i*0.03, 130.0 - i*0.03
        
        report = PositionReport(
            report_id=f"REP-{i:06d}",
            vessel_id=vessel_id,
            position=GeoPoint(base_lat + random.uniform(-0.1, 0.1),
                            base_lon + random.uniform(-0.1, 0.1)),
            heading=random.uniform(0, 360),
            speed_knots=random.uniform(10, 20),
            timestamp=datetime.now() - timedelta(minutes=i*2),
            source="AIS"
        )
        
        system.process_position_report(report)
    
    # è·å–èˆ¹é˜ŸçŠ¶æ€
    status = system.get_fleet_status()
    print("Fleet Status:")
    print(json.dumps(status, indent=2))
    
    # è·å–èˆ¹èˆ¶è½¨è¿¹
    track = system.get_vessel_track("VES-001", hours=24)
    print(f"\nVessel VES-001 track: {len(track)} points")
    
    # è·å–å‘Šè­¦
    alerts = [a.to_dict() for a in system.alerts.values()]
    print(f"\nActive Alerts: {len(alerts)}")
    for alert in alerts[:5]:
        print(f"  - {alert['alert_type']}: {alert['message']}")


if __name__ == "__main__":
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°ä¸ROI

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| ä½ç½®æ›´æ–°é¢‘ç‡ | 30åˆ†é’Ÿ | 90ç§’ | -95% |
| ETAé¢„æµ‹è¯¯å·® | 12å°æ—¶ | 1.5å°æ—¶ | -87% |
| å¼‚å¸¸æ£€æµ‹æ—¶é—´ | 4å°æ—¶ | 8åˆ†é’Ÿ | -97% |
| æ•°æ®æ•´åˆè¦†ç›–ç‡ | 20% | 97% | +77% |
| å®¢æˆ·æŸ¥è¯¢å“åº”æ—¶é—´ | 30åˆ†é’Ÿ | 2ç§’ | -99.9% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼ˆ18ä¸ªæœˆé¡¹ç›®å‘¨æœŸï¼‰ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š800ä¸‡ç¾å…ƒ
- å«æ˜Ÿé€šä¿¡å‡çº§ï¼š400ä¸‡ç¾å…ƒ
- èˆ¹è½½è®¾å¤‡æ”¹é€ ï¼š600ä¸‡ç¾å…ƒ
- **æ€»æŠ•èµ„**ï¼š1,800ä¸‡ç¾å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- èˆªçº¿ä¼˜åŒ–èŠ‚çœï¼š1,200ä¸‡ç¾å…ƒ
- å¼‚å¸¸å“åº”å‡å°‘æŸå¤±ï¼š500ä¸‡ç¾å…ƒ
- å®¢æˆ·æ»¡æ„åº¦æå‡ï¼š300ä¸‡ç¾å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š2,000ä¸‡ç¾å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š10.8ä¸ªæœˆ
- 3å¹´ROIï¼š233%

---

## 3. æ¡ˆä¾‹2ï¼šæ™ºèƒ½èˆªçº¿ä¼˜åŒ–ç³»ç»Ÿ

### 3.1 ä¼ä¸šèƒŒæ™¯

**BlueOceanèˆªè¿å…¬å¸**è¿è¥120è‰˜è¿œæ´‹èˆ¹èˆ¶ï¼Œå¹´ç‡ƒæ²¹æˆæœ¬è¶…è¿‡3äº¿ç¾å…ƒï¼Œå è¿è¥æˆæœ¬40%ã€‚å…¬å¸è¿«åˆ‡éœ€è¦ä¼˜åŒ–èˆªçº¿è§„åˆ’ä»¥é™ä½ç‡ƒæ²¹æ¶ˆè€—å’Œç¢³æ’æ”¾ã€‚

- **èˆ¹é˜Ÿè§„æ¨¡**ï¼š120è‰˜
- **å¹´ç‡ƒæ²¹æˆæœ¬**ï¼š3äº¿ç¾å…ƒ
- **èˆªçº¿è¦†ç›–**ï¼šå…¨çƒä¸»è¦è´¸æ˜“èˆªçº¿
- **å¹´èˆªè¡Œé‡Œç¨‹**ï¼š600ä¸‡æµ·é‡Œ

### 3.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **èˆªçº¿è§„åˆ’ä¾èµ–ç»éªŒ** | ä¸¥é‡ | èˆªçº¿è§„åˆ’ä¸»è¦ä¾èµ–èˆ¹é•¿ç»éªŒï¼Œç¼ºä¹æ•°æ®é©±åŠ¨ä¼˜åŒ– |
| 2 | **å¤©æ°”åˆ©ç”¨ä¸è¶³** | ä¸¥é‡ | æœªèƒ½å……åˆ†åˆ©ç”¨æ°”è±¡ routingï¼Œå¹´æŸå¤±ç‡ƒæ²¹10% |
| 3 | **å¤šç›®æ ‡ä¼˜åŒ–éš¾** | é«˜ | ç‡ƒæ²¹æˆæœ¬vsèˆªè¡Œæ—¶é—´vså®‰å…¨éš¾ä»¥å¹³è¡¡ |
| 4 | **åŠ¨æ€è°ƒæ•´æ»å** | é«˜ | é‡åˆ°æ¶åŠ£å¤©æ°”è¢«åŠ¨åº”å¯¹ï¼Œæ— æ³•æå‰48å°æ—¶è°ƒæ•´ |
| 5 | **ç¢³æ’æ”¾è¶…æ ‡** | ä¸­ | ç¢³æ’æ”¾å¼ºåº¦é«˜äºè¡Œä¸šå¹³å‡15%ï¼Œé¢ä¸´ç¯ä¿å‹åŠ› |

### 3.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | ç‡ƒæ²¹æ¶ˆè€—é™ä½ | åŸºå‡† | -12% | 12ä¸ªæœˆ |
| 2 | èˆªçº¿è§„åˆ’æ—¶é—´ | 8å°æ—¶ | <30åˆ†é’Ÿ | 6ä¸ªæœˆ |
| 3 | æ¶åŠ£å¤©æ°”é¢„è­¦æ—¶é—´ | 12å°æ—¶ | 72å°æ—¶ | 9ä¸ªæœˆ |
| 4 | ç¢³æ’æ”¾å¼ºåº¦ | åŸºå‡† | -15% | 18ä¸ªæœˆ |
| 5 | å‡†ç­ç‡ | 78% | 92% | 12ä¸ªæœˆ |

### 3.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šç›®æ ‡ä¼˜åŒ–ç®—æ³•**ï¼šéœ€è¦åœ¨ç‡ƒæ²¹æˆæœ¬ã€èˆªè¡Œæ—¶é—´ã€å®‰å…¨é£é™©ã€ç¢³æ’æ”¾ä¹‹é—´æ‰¾åˆ°Paretoæœ€ä¼˜è§£

2. **å…¨çƒæ°”è±¡æ•°æ®é›†æˆ**ï¼šéœ€è¦å®æ—¶è·å–å’Œå¤„ç†å…¨çƒæµ·æ´‹æ°”è±¡æ•°æ®ï¼ˆé£æµªã€æ´‹æµã€æ°”å‹ï¼‰ï¼Œæ—¥æ•°æ®é‡50GB+

3. **åŠ¨æ€èˆªçº¿é‡è§„åˆ’**ï¼šéœ€è¦åœ¨èˆªè¡Œä¸­æ ¹æ®å¤©æ°”å˜åŒ–åŠ¨æ€è°ƒæ•´èˆªçº¿ï¼Œè¦æ±‚ç®—æ³•å“åº”æ—¶é—´<5åˆ†é’Ÿ

4. **èˆ¹èˆ¶æ€§èƒ½å»ºæ¨¡**ï¼šéœ€è¦å»ºç«‹æ¯è‰˜èˆ¹èˆ¶çš„å‡†ç¡®æ€§èƒ½æ¨¡å‹ï¼ˆä¸»æœºåŠŸç‡æ›²çº¿ã€é˜»åŠ›ç‰¹æ€§ï¼‰ï¼Œç”¨äºç²¾ç¡®é¢„æµ‹ç‡ƒæ²¹æ¶ˆè€—

5. **åˆè§„æ€§çº¦æŸ**ï¼šéœ€è¦æ»¡è¶³ECAï¼ˆæ’æ”¾æ§åˆ¶åŒºï¼‰ã€ç¡«æ’æ”¾é™åˆ¶ã€å‹è½½æ°´ç®¡ç†ç­‰å¤šç§æ³•è§„çº¦æŸ

### 3.5 å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
æ™ºèƒ½èˆªçº¿ä¼˜åŒ–ç³»ç»Ÿ - æ ¸å¿ƒå®ç°
åŸºäºæ°”è±¡æ•°æ®å’Œèˆ¹èˆ¶æ€§èƒ½æ¨¡å‹ä¼˜åŒ–èˆªçº¿
"""

import json
import logging
import math
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from enum import Enum

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class WeatherCondition(Enum):
    """å¤©æ°”æ¡ä»¶"""
    CALM = "calm"
    MODERATE = "moderate"
    ROUGH = "rough"
    SEVERE = "severe"


@dataclass
class WeatherData:
    """æ°”è±¡æ•°æ®"""
    position: Tuple[float, float]
    wind_speed_knots: float
    wind_direction_deg: float
    wave_height_m: float
    wave_direction_deg: float
    current_speed_knots: float
    current_direction_deg: float
    timestamp: datetime
    
    def get_severity(self) -> WeatherCondition:
        """è·å–å¤©æ°”ä¸¥é‡ç¨‹åº¦"""
        if self.wave_height_m < 2 and self.wind_speed_knots < 20:
            return WeatherCondition.CALM
        elif self.wave_height_m < 4 and self.wind_speed_knots < 30:
            return WeatherCondition.MODERATE
        elif self.wave_height_m < 6 and self.wind_speed_knots < 40:
            return WeatherCondition.ROUGH
        else:
            return WeatherCondition.SEVERE


@dataclass
class Waypoint:
    """èˆªè·¯ç‚¹"""
    latitude: float
    longitude: float
    timestamp: Optional[datetime] = None
    speed_knots: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        result = {
            "latitude": self.latitude,
            "longitude": self.longitude
        }
        if self.timestamp:
            result["timestamp"] = self.timestamp.isoformat()
        if self.speed_knots:
            result["speed_knots"] = self.speed_knots
        return result


@dataclass
class VesselProfile:
    """èˆ¹èˆ¶æ€§èƒ½æ¡£æ¡ˆ"""
    vessel_id: str
    max_speed_knots: float
    optimal_speed_knots: float
    fuel_consumption_tons_per_day: Dict[float, float]  # é€Ÿåº¦ -> æ—¥æ²¹è€—
    
    def get_fuel_consumption(self, speed_knots: float) -> float:
        """è·å–ç»™å®šé€Ÿåº¦ä¸‹çš„æ²¹è€—ï¼ˆå¨/å¤©ï¼‰"""
        if speed_knots in self.fuel_consumption_tons_per_day:
            return self.fuel_consumption_tons_per_day[speed_knots]
        
        # æ’å€¼è®¡ç®—
        speeds = sorted(self.fuel_consumption_tons_per_day.keys())
        if speed_knots <= speeds[0]:
            return self.fuel_consumption_tons_per_day[speeds[0]]
        if speed_knots >= speeds[-1]:
            return self.fuel_consumption_tons_per_day[speeds[-1]]
        
        for i in range(len(speeds) - 1):
            if speeds[i] <= speed_knots <= speeds[i+1]:
                ratio = (speed_knots - speeds[i]) / (speeds[i+1] - speeds[i])
                f1 = self.fuel_consumption_tons_per_day[speeds[i]]
                f2 = self.fuel_consumption_tons_per_day[speeds[i+1]]
                return f1 + ratio * (f2 - f1)
        
        return self.fuel_consumption_tons_per_day[speeds[0]]


@dataclass
class Route:
    """èˆªçº¿"""
    route_id: str
    vessel_id: str
    departure_port: str
    arrival_port: str
    waypoints: List[Waypoint]
    total_distance_nm: float
    estimated_duration_hours: float
    estimated_fuel_tons: float
    weather_factor: float = 1.0  # å¤©æ°”å½±å“ç³»æ•°
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "route_id": self.route_id,
            "vessel_id": self.vessel_id,
            "departure_port": self.departure_port,
            "arrival_port": self.arrival_port,
            "waypoints": [wp.to_dict() for wp in self.waypoints],
            "total_distance_nm": self.total_distance_nm,
            "estimated_duration_hours": self.estimated_duration_hours,
            "estimated_fuel_tons": self.estimated_fuel_tons,
            "weather_factor": self.weather_factor
        }


class RouteOptimizer:
    """èˆªçº¿ä¼˜åŒ–å™¨"""
    
    def __init__(self):
        self.weather_grid: Dict[Tuple[int, int, int], WeatherData] = {}
        self.vessel_profiles: Dict[str, VesselProfile] = {}
        self.ports: Dict[str, Tuple[float, float]] = {}
        
        logger.info("Route Optimizer initialized")
    
    def add_weather_data(self, weather: WeatherData):
        """æ·»åŠ æ°”è±¡æ•°æ®"""
        # ç½‘æ ¼åŒ–å­˜å‚¨ï¼ˆ1åº¦ x 1åº¦ x 6å°æ—¶ï¼‰
        grid_key = (
            int(weather.position[0]),
            int(weather.position[1]),
            int(weather.timestamp.timestamp() / 21600)
        )
        self.weather_grid[grid_key] = weather
    
    def register_vessel_profile(self, profile: VesselProfile):
        """æ³¨å†Œèˆ¹èˆ¶æ€§èƒ½æ¡£æ¡ˆ"""
        self.vessel_profiles[profile.vessel_id] = profile
    
    def register_port(self, port_id: str, lat: float, lon: float):
        """æ³¨å†Œæ¸¯å£"""
        self.ports[port_id] = (lat, lon)
    
    def calculate_distance_nm(self, lat1: float, lon1: float,
                             lat2: float, lon2: float) -> float:
        """è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»ï¼ˆæµ·é‡Œï¼‰"""
        R = 3440.065  # åœ°çƒåŠå¾„ï¼ˆæµ·é‡Œï¼‰
        
        lat1_rad, lon1_rad = math.radians(lat1), math.radians(lon1)
        lat2_rad, lon2_rad = math.radians(lat2), math.radians(lon2)
        
        dlat = lat2_rad - lat1_rad
        dlon = lon2_rad - lon1_rad
        
        a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        return R * c
    
    def optimize_route(self, vessel_id: str, departure: str,
                      destination: str, departure_time: datetime,
                      optimization_goal: str = "balanced") -> Route:
        """ä¼˜åŒ–èˆªçº¿"""
        if vessel_id not in self.vessel_profiles:
            raise ValueError(f"Unknown vessel: {vessel_id}")
        
        if departure not in self.ports or destination not in self.ports:
            raise ValueError("Unknown port")
        
        vessel = self.vessel_profiles[vessel_id]
        start_pos = self.ports[departure]
        end_pos = self.ports[destination]
        
        # ç®€åŒ–çš„èˆªçº¿ä¼˜åŒ–ï¼šç”Ÿæˆå¤§åœ†èˆªçº¿çš„è‹¥å¹²å˜ä½“
        routes = self._generate_route_variants(
            start_pos, end_pos, vessel, departure_time
        )
        
        # è¯„ä¼°æ¯æ¡èˆªçº¿
        best_route = None
        best_score = float('-inf')
        
        for route in routes:
            score = self._evaluate_route(route, optimization_goal)
            if score > best_score:
                best_score = score
                best_route = route
        
        return best_route
    
    def _generate_route_variants(self, start: Tuple[float, float],
                                end: Tuple[float, float],
                                vessel: VesselProfile,
                                departure_time: datetime) -> List[Route]:
        """ç”Ÿæˆèˆªçº¿å˜ä½“"""
        routes = []
        
        # å¤§åœ†èˆªçº¿ï¼ˆç›´æ¥è¿çº¿ï¼‰
        direct_waypoints = self._generate_great_circle_route(start, end, 20)
        
        for offset in [-2, -1, 0, 1, 2]:  # å—åŒ—åç§»
            waypoints = []
            for i, wp in enumerate(direct_waypoints):
                # åœ¨ä¸­é—´æ®µæ·»åŠ åç§»
                if 5 < i < len(direct_waypoints) - 5:
                    lat = wp[0] + offset * 2
                else:
                    lat = wp[0]
                lon = wp[1]
                waypoints.append(Waypoint(lat, lon))
            
            route = self._calculate_route_metrics(
                waypoints, vessel, departure_time
            )
            routes.append(route)
        
        return routes
    
    def _generate_great_circle_route(self, start: Tuple[float, float],
                                    end: Tuple[float, float],
                                    num_points: int) -> List[Tuple[float, float]]:
        """ç”Ÿæˆå¤§åœ†èˆªçº¿ç‚¹"""
        points = [start]
        
        for i in range(1, num_points):
            ratio = i / num_points
            lat = start[0] + (end[0] - start[0]) * ratio
            lon = start[1] + (end[1] - start[1]) * ratio
            points.append((lat, lon))
        
        points.append(end)
        return points
    
    def _calculate_route_metrics(self, waypoints: List[Waypoint],
                                vessel: VesselProfile,
                                departure_time: datetime) -> Route:
        """è®¡ç®—èˆªçº¿æŒ‡æ ‡"""
        total_distance = 0
        total_duration = 0
        total_fuel = 0
        weather_penalty = 0
        
        current_time = departure_time
        
        for i in range(len(waypoints) - 1):
            wp1 = waypoints[i]
            wp2 = waypoints[i + 1]
            
            # è·ç¦»
            distance = self.calculate_distance_nm(wp1.latitude, wp1.longitude,
                                                 wp2.latitude, wp2.longitude)
            total_distance += distance
            
            # è·å–è¯¥æ®µå¤©æ°”
            weather = self._get_weather_at(
                (wp1.latitude + wp2.latitude) / 2,
                (wp1.longitude + wp2.longitude) / 2,
                current_time
            )
            
            # è®¡ç®—é€Ÿåº¦ï¼ˆè€ƒè™‘å¤©æ°”ï¼‰
            base_speed = vessel.optimal_speed_knots
            if weather:
                if weather.get_severity() == WeatherCondition.SEVERE:
                    speed = base_speed * 0.5
                    weather_penalty += 0.3
                elif weather.get_severity() == WeatherCondition.ROUGH:
                    speed = base_speed * 0.7
                    weather_penalty += 0.1
                else:
                    speed = base_speed
            else:
                speed = base_speed
            
            # æ—¶é—´
            duration = distance / speed if speed > 0 else 0
            total_duration += duration
            
            # æ²¹è€—
            fuel_rate = vessel.get_fuel_consumption(speed)  # å¨/å¤©
            fuel = fuel_rate * (duration / 24)
            total_fuel += fuel
            
            # æ›´æ–°æ—¶é—´
            current_time += timedelta(hours=duration)
            wp2.timestamp = current_time
        
        route_id = f"ROUTE-{datetime.now().strftime('%Y%m%d%H%M%S')}"
        
        return Route(
            route_id=route_id,
            vessel_id="",
            departure_port="",
            arrival_port="",
            waypoints=waypoints,
            total_distance_nm=total_distance,
            estimated_duration_hours=total_duration,
            estimated_fuel_tons=total_fuel,
            weather_factor=1 + weather_penalty
        )
    
    def _get_weather_at(self, lat: float, lon: float,
                       time: datetime) -> Optional[WeatherData]:
        """è·å–æŒ‡å®šä½ç½®å’Œæ—¶é—´çš„æ°”è±¡æ•°æ®"""
        grid_key = (int(lat), int(lon), int(time.timestamp() / 21600))
        return self.weather_grid.get(grid_key)
    
    def _evaluate_route(self, route: Route, goal: str) -> float:
        """è¯„ä¼°èˆªçº¿"""
        if goal == "fuel":
            # æœ€å°åŒ–ç‡ƒæ²¹
            return -route.estimated_fuel_tons
        elif goal == "time":
            # æœ€å°åŒ–æ—¶é—´
            return -route.estimated_duration_hours
        else:  # balanced
            # å¹³è¡¡ç‡ƒæ²¹å’Œæ—¶é—´
            fuel_score = -route.estimated_fuel_tons * 1000  # æ¯å¨ç‡ƒæ²¹1000åˆ†
            time_score = -route.estimated_duration_hours * 50  # æ¯å°æ—¶50åˆ†
            weather_score = -route.weather_factor * 100  # å¤©æ°”æƒ©ç½š
            return fuel_score + time_score + weather_score


def main():
    """æ¼”ç¤ºèˆªçº¿ä¼˜åŒ–"""
    optimizer = RouteOptimizer()
    
    # æ³¨å†Œæ¸¯å£
    optimizer.register_port("Shanghai", 31.2304, 121.4737)
    optimizer.register_port("Singapore", 1.2897, 103.8501)
    optimizer.register_port("Rotterdam", 51.9244, 4.4777)
    
    # æ³¨å†Œèˆ¹èˆ¶æ€§èƒ½
    fuel_curve = {
        10.0: 30.0,
        12.0: 45.0,
        14.0: 65.0,
        16.0: 90.0,
        18.0: 120.0,
        20.0: 155.0
    }
    
    vessel = VesselProfile(
        vessel_id="VESSEL-001",
        max_speed_knots=22.0,
        optimal_speed_knots=16.0,
        fuel_consumption_tons_per_day=fuel_curve
    )
    optimizer.register_vessel_profile(vessel)
    
    # æ·»åŠ æ°”è±¡æ•°æ®
    import random
    for lat in range(0, 55, 5):
        for lon in range(100, 125, 5):
            weather = WeatherData(
                position=(lat + random.uniform(-2, 2), lon + random.uniform(-2, 2)),
                wind_speed_knots=random.uniform(10, 35),
                wind_direction_deg=random.uniform(0, 360),
                wave_height_m=random.uniform(1, 4),
                wave_direction_deg=random.uniform(0, 360),
                current_speed_knots=random.uniform(0.5, 2),
                current_direction_deg=random.uniform(0, 360),
                timestamp=datetime.now()
            )
            optimizer.add_weather_data(weather)
    
    # ä¼˜åŒ–èˆªçº¿
    route = optimizer.optimize_route(
        vessel_id="VESSEL-001",
        departure="Shanghai",
        destination="Singapore",
        departure_time=datetime.now(),
        optimization_goal="balanced"
    )
    
    print("Optimized Route:")
    print(json.dumps(route.to_dict(), indent=2, default=str))


if __name__ == "__main__":
    main()
```

### 3.6 æ•ˆæœè¯„ä¼°ä¸ROI

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| ç‡ƒæ²¹æ¶ˆè€— | åŸºå‡† | -14% | -14% |
| èˆªçº¿è§„åˆ’æ—¶é—´ | 8å°æ—¶ | 15åˆ†é’Ÿ | -97% |
| æ¶åŠ£å¤©æ°”é¢„è­¦æ—¶é—´ | 12å°æ—¶ | 84å°æ—¶ | +600% |
| ç¢³æ’æ”¾å¼ºåº¦ | åŸºå‡† | -16% | -16% |
| å‡†ç­ç‡ | 78% | 94% | +21% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š500ä¸‡ç¾å…ƒ
- æ°”è±¡æ•°æ®è®¢é˜…ï¼š100ä¸‡ç¾å…ƒ/å¹´
- **æ€»æŠ•èµ„**ï¼š600ä¸‡ç¾å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- ç‡ƒæ²¹èŠ‚çœï¼š4,200ä¸‡ç¾å…ƒ
- å‡†ç­ç‡æå‡ï¼š800ä¸‡ç¾å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š5,000ä¸‡ç¾å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š1.4ä¸ªæœˆ
- 3å¹´ROIï¼š2,400%

---

## 4. æ¡ˆä¾‹3ï¼šæ¸¯å£æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ

### 4.1 ä¼ä¸šèƒŒæ™¯

**æŸå¤§å‹æ¸¯å£é›†å›¢**ç®¡ç†10ä¸ªæ¸¯åŒºï¼Œå¹´ååé‡è¶…è¿‡5000ä¸‡TEUï¼Œæ³Šä½èµ„æºç´§å¼ ï¼Œèˆ¹èˆ¶å¹³å‡ç­‰å¾…æ—¶é—´è¶…è¿‡12å°æ—¶ã€‚

- **æ¸¯åŒºæ•°é‡**ï¼š10ä¸ª
- **å¹´ååé‡**ï¼š5000ä¸‡TEU
- **æ³Šä½æ•°é‡**ï¼š80ä¸ª
- **æ—¥å‡åˆ°æ¸¯èˆ¹èˆ¶**ï¼š150è‰˜

### 4.2 ä¸šåŠ¡ç—›ç‚¹

| åºå· | ç—›ç‚¹ | å½±å“ç¨‹åº¦ | ä¸šåŠ¡å½±å“ |
|------|------|----------|----------|
| 1 | **æ³Šä½åˆ©ç”¨ç‡ä½** | ä¸¥é‡ | å¹³å‡åˆ©ç”¨ç‡ä»…65%ï¼Œé«˜å³°æœŸæ‹¥æŒ¤ï¼Œä½è°·æœŸç©ºé—² |
| 2 | **èˆ¹èˆ¶ç­‰å¾…æ—¶é—´é•¿** | ä¸¥é‡ | å¹³å‡ç­‰å¾…12å°æ—¶ï¼Œæ¯å¹´é¢å¤–æˆæœ¬3000ä¸‡å…ƒ |
| 3 | **è°ƒåº¦ä¾èµ–äººå·¥** | é«˜ | è°ƒåº¦å‘˜å‡­ç»éªŒæ’ç­ï¼Œéš¾ä»¥åº”å¯¹çªå‘æƒ…å†µ |
| 4 | **èµ„æºå†²çªé¢‘ç¹** | é«˜ | æ¡¥åŠã€å †åœºèµ„æºåˆ†é…ä¸å½“ï¼Œä½œä¸šæ•ˆç‡ä½ |
| 5 | **ä¿¡æ¯ä¸é€æ˜** | ä¸­ | èˆ¹å…¬å¸æ— æ³•å®æ—¶äº†è§£æ³Šä½çŠ¶æ€ |

### 4.3 ä¸šåŠ¡ç›®æ ‡

| åºå· | ç›®æ ‡ | å½“å‰å€¼ | ç›®æ ‡å€¼ | æ—¶é—´æ¡†æ¶ |
|------|------|--------|--------|----------|
| 1 | æ³Šä½åˆ©ç”¨ç‡ | 65% | 85% | 12ä¸ªæœˆ |
| 2 | èˆ¹èˆ¶å¹³å‡ç­‰å¾…æ—¶é—´ | 12å°æ—¶ | <3å°æ—¶ | 9ä¸ªæœˆ |
| 3 | è°ƒåº¦è‡ªåŠ¨åŒ–ç‡ | 10% | 80% | 12ä¸ªæœˆ |
| 4 | èµ„æºå†²çªç‡ | 15% | <2% | 9ä¸ªæœˆ |
| 5 | èˆ¹èˆ¶å‡†ç‚¹é æ³Šç‡ | 70% | 95% | 12ä¸ªæœˆ |

### 4.4 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šçº¦æŸä¼˜åŒ–**ï¼šéœ€è¦åŒæ—¶è€ƒè™‘æ³Šä½ç±»å‹ã€æ°´æ·±ã€æ½®æ±ã€èˆ¹èˆ¶å°ºå¯¸ã€è´§ç‰©ç±»å‹ã€è®¾å¤‡å¯ç”¨æ€§ç­‰å¤šç§çº¦æŸ

2. **å®æ—¶åŠ¨æ€è°ƒæ•´**ï¼šéœ€è¦åœ¨15åˆ†é’Ÿå†…å“åº”èˆ¹èˆ¶å»¶è¯¯ã€è®¾å¤‡æ•…éšœç­‰çªå‘äº‹ä»¶ï¼Œé‡æ–°ä¼˜åŒ–è°ƒåº¦æ–¹æ¡ˆ

3. **å¤šæ¸¯åŒºååŒ**ï¼šéœ€è¦åœ¨10ä¸ªæ¸¯åŒºä¹‹é—´åè°ƒèµ„æºï¼Œå®ç°æ•´ä½“æœ€ä¼˜è€Œéå±€éƒ¨æœ€ä¼˜

4. **ä¸ç¡®å®šæ€§å»ºæ¨¡**ï¼šéœ€è¦å¤„ç†èˆ¹èˆ¶ETAä¸ç¡®å®šæ€§ï¼ˆå¤©æ°”ã€æœºæ¢°æ•…éšœï¼‰ï¼Œè¦æ±‚é²æ£’æ€§è°ƒåº¦æ–¹æ¡ˆ

5. **å¤šæ–¹åˆ©ç›Šå¹³è¡¡**ï¼šéœ€è¦å¹³è¡¡èˆ¹å…¬å¸ã€è´§ä¸»ã€æ¸¯å£ã€ç‰©æµå…¬å¸çš„ä¸åŒåˆ©ç›Šè¯‰æ±‚

### 4.5 å®Œæ•´å®ç°ä»£ç 

```python
#!/usr/bin/env python3
"""
æ¸¯å£æ™ºèƒ½è°ƒåº¦ç³»ç»Ÿ - æ ¸å¿ƒå®ç°
ä¼˜åŒ–æ³Šä½åˆ†é…å’Œèµ„æºè°ƒåº¦
"""

import json
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Set, Tuple
from enum import Enum
from heapq import heappush, heappop

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class VesselSize(Enum):
    """èˆ¹èˆ¶å°ºå¯¸ç­‰çº§"""
    SMALL = "small"      # < 200m
    MEDIUM = "medium"    # 200-300m
    LARGE = "large"      # 300-400m
    ULTRA = "ultra"      # > 400m


class BerthType(Enum):
    """æ³Šä½ç±»å‹"""
    CONTAINER = "container"
    BULK = "bulk"
    TANKER = "tanker"
    GENERAL = "general"
    RORO = "roro"


class BerthStatus(Enum):
    """æ³Šä½çŠ¶æ€"""
    AVAILABLE = "available"
    OCCUPIED = "occupied"
    RESERVED = "reserved"
    MAINTENANCE = "maintenance"


@dataclass
class Berth:
    """æ³Šä½"""
    berth_id: str
    terminal_id: str
    berth_type: BerthType
    length_m: float
    depth_m: float
    crane_count: int
    status: BerthStatus = BerthStatus.AVAILABLE
    current_vessel: Optional[str] = None
    
    def can_accommodate(self, vessel_length: float, vessel_draft: float) -> bool:
        """æ˜¯å¦èƒ½å®¹çº³èˆ¹èˆ¶"""
        return (self.length_m >= vessel_length * 1.1 and  # 10%ä½™é‡
                self.depth_m >= vessel_draft + 2.0 and     # 2ç±³å¯Œä½™æ°´æ·±
                self.status in [BerthStatus.AVAILABLE, BerthStatus.RESERVED])
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "berth_id": self.berth_id,
            "terminal_id": self.terminal_id,
            "type": self.berth_type.value,
            "length_m": self.length_m,
            "depth_m": self.depth_m,
            "crane_count": self.crane_count,
            "status": self.status.value
        }


@dataclass
class VesselCall:
    """èˆ¹èˆ¶åˆ°æ¸¯è®¡åˆ’"""
    call_id: str
    vessel_id: str
    vessel_name: str
    vessel_length: float
    vessel_draft: float
    vessel_type: BerthType
    eta: datetime
    etd: datetime  # é¢„è®¡ç¦»æ¸¯æ—¶é—´
    cargo_teus: int
    priority: int = 5  # 1-10, æ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜
    assigned_berth: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "call_id": self.call_id,
            "vessel_id": self.vessel_id,
            "vessel_name": self.vessel_name,
            "vessel_length": self.vessel_length,
            "vessel_draft": self.vessel_draft,
            "vessel_type": self.vessel_type.value,
            "eta": self.eta.isoformat(),
            "etd": self.etd.isoformat(),
            "cargo_teus": self.cargo_teus,
            "priority": self.priority,
            "assigned_berth": self.assigned_berth
        }


@dataclass
class Crane:
    """æ¡¥åŠ"""
    crane_id: str
    terminal_id: str
    berth_id: Optional[str]
    moves_per_hour: int
    available_from: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "crane_id": self.crane_id,
            "terminal_id": self.terminal_id,
            "berth_id": self.berth_id,
            "moves_per_hour": self.moves_per_hour
        }


class PortScheduler:
    """æ¸¯å£è°ƒåº¦å™¨"""
    
    def __init__(self):
        self.berths: Dict[str, Berth] = {}
        self.vessel_calls: Dict[str, VesselCall] = {}
        self.cranes: Dict[str, Crane] = {}
        
        # æ³Šä½å ç”¨æ—¶é—´è¡¨: berth_id -> [(start, end, call_id)]
        self.berth_schedule: Dict[str, List[Tuple[datetime, datetime, str]]] = defaultdict(list)
        
        # ç»Ÿè®¡
        self.stats = {
            "total_assignments": 0,
            "avg_waiting_hours": 0,
            "conflicts_resolved": 0
        }
        
        logger.info("Port Scheduler initialized")
    
    def add_berth(self, berth: Berth):
        """æ·»åŠ æ³Šä½"""
        self.berths[berth.berth_id] = berth
    
    def add_vessel_call(self, call: VesselCall):
        """æ·»åŠ èˆ¹èˆ¶åˆ°æ¸¯è®¡åˆ’"""
        self.vessel_calls[call.call_id] = call
    
    def add_crane(self, crane: Crane):
        """æ·»åŠ æ¡¥åŠ"""
        self.cranes[crane.crane_id] = crane
    
    def schedule_vessel(self, call_id: str) -> Optional[str]:
        """ä¸ºèˆ¹èˆ¶åˆ†é…æ³Šä½"""
        if call_id not in self.vessel_calls:
            return None
        
        call = self.vessel_calls[call_id]
        
        # æ‰¾åˆ°åˆé€‚çš„æ³Šä½
        suitable_berths = [
            b for b in self.berths.values()
            if b.berth_type == call.vessel_type
            and b.can_accommodate(call.vessel_length, call.vessel_draft)
        ]
        
        if not suitable_berths:
            logger.warning(f"No suitable berth for vessel {call.vessel_name}")
            return None
        
        # æ£€æŸ¥æ¯ä¸ªæ³Šä½çš„å¯ç”¨æ—¶é—´æ®µ
        best_berth = None
        best_start = None
        min_wait = timedelta(hours=999)
        
        for berth in suitable_berths:
            available_start = self._find_earliest_available_slot(
                berth.berth_id, call.eta, call.etd
            )
            
            wait_time = available_start - call.eta
            if wait_time < min_wait:
                min_wait = wait_time
                best_berth = berth
                best_start = available_start
        
        if best_berth:
            # åˆ†é…æ³Šä½
            call.assigned_berth = best_berth.berth_id
            
            # æ›´æ–°æ³Šä½æ—¶é—´è¡¨
            actual_start = max(call.eta, best_start)
            self.berth_schedule[best_berth.berth_id].append(
                (actual_start, call.etd, call_id)
            )
            
            # æ›´æ–°ç»Ÿè®¡
            self.stats["total_assignments"] += 1
            wait_hours = min_wait.total_seconds() / 3600
            n = self.stats["total_assignments"]
            self.stats["avg_waiting_hours"] = (
                self.stats["avg_waiting_hours"] * (n-1) + wait_hours
            ) / n
            
            logger.info(f"Scheduled {call.vessel_name} at berth {best_berth.berth_id}, "
                       f"wait: {wait_hours:.1f} hours")
            
            return best_berth.berth_id
        
        return None
    
    def _find_earliest_available_slot(self, berth_id: str,
                                     desired_start: datetime,
                                     desired_end: datetime) -> datetime:
        """æ‰¾åˆ°æ³Šä½æœ€æ—©å¯ç”¨æ—¶é—´"""
        schedule = sorted(self.berth_schedule.get(berth_id, []))
        
        # å¦‚æœæ²¡æœ‰å®‰æ’ï¼Œç«‹å³å¯ç”¨
        if not schedule:
            return desired_start
        
        # æ£€æŸ¥desired_startæ˜¯å¦å¯ç”¨
        can_start_at_desired = True
        for start, end, _ in schedule:
            if start <= desired_start < end:
                can_start_at_desired = False
                break
            if desired_start <= start < desired_end:
                can_start_at_desired = False
                break
        
        if can_start_at_desired:
            return desired_start
        
        # æ‰¾åˆ°å†²çªç»“æŸåæœ€æ—©çš„æ—¶é—´
        earliest = desired_start
        for start, end, _ in schedule:
            if start <= earliest < end:
                earliest = end
        
        return earliest
    
    def reschedule_delayed_vessel(self, call_id: str, new_eta: datetime) -> Optional[str]:
        """é‡æ–°è°ƒåº¦å»¶è¯¯çš„èˆ¹èˆ¶"""
        if call_id not in self.vessel_calls:
            return None
        
        call = self.vessel_calls[call_id]
        
        # é‡Šæ”¾åŸæ³Šä½
        if call.assigned_berth:
            self.berth_schedule[call.assigned_berth] = [
                slot for slot in self.berth_schedule[call.assigned_berth]
                if slot[2] != call_id
            ]
            call.assigned_berth = None
        
        # æ›´æ–°ETA
        delay = new_eta - call.eta
        call.eta = new_eta
        call.etd = call.etd + delay
        
        # é‡æ–°åˆ†é…
        return self.schedule_vessel(call_id)
    
    def get_terminal_status(self, terminal_id: str) -> Dict[str, Any]:
        """è·å–æ¸¯åŒºçŠ¶æ€"""
        terminal_berths = [b for b in self.berths.values() if b.terminal_id == terminal_id]
        
        status = {
            "terminal_id": terminal_id,
            "timestamp": datetime.now().isoformat(),
            "total_berths": len(terminal_berths),
            "available_berths": sum(1 for b in terminal_berths if b.status == BerthStatus.AVAILABLE),
            "occupied_berths": sum(1 for b in terminal_berths if b.status == BerthStatus.OCCUPIED),
            "scheduled_calls": []
        }
        
        for call in self.vessel_calls.values():
            if call.assigned_berth:
                berth = self.berths.get(call.assigned_berth)
                if berth and berth.terminal_id == terminal_id:
                    status["scheduled_calls"].append({
                        "vessel_name": call.vessel_name,
                        "berth_id": call.assigned_berth,
                        "eta": call.eta.isoformat(),
                        "etd": call.etd.isoformat()
                    })
        
        return status
    
    def get_port_overview(self) -> Dict[str, Any]:
        """è·å–æ¸¯å£æ¦‚è§ˆ"""
        return {
            "timestamp": datetime.now().isoformat(),
            "total_berths": len(self.berths),
            "total_vessel_calls": len(self.vessel_calls),
            "assigned_calls": sum(1 for c in self.vessel_calls.values() if c.assigned_berth),
            "avg_waiting_hours": self.stats["avg_waiting_hours"],
            "berth_utilization": self._calculate_berth_utilization()
        }
    
    def _calculate_berth_utilization(self) -> float:
        """è®¡ç®—æ³Šä½åˆ©ç”¨ç‡"""
        total_berth_hours = len(self.berths) * 24  # è¿‡å»24å°æ—¶
        occupied_hours = 0
        
        cutoff = datetime.now() - timedelta(hours=24)
        for berth_id, schedule in self.berth_schedule.items():
            for start, end, _ in schedule:
                if end > cutoff:
                    actual_start = max(start, cutoff)
                    occupied_hours += (end - actual_start).total_seconds() / 3600
        
        return occupied_hours / total_berth_hours if total_berth_hours > 0 else 0


def main():
    """æ¼”ç¤ºæ¸¯å£è°ƒåº¦ç³»ç»Ÿ"""
    scheduler = PortScheduler()
    
    # æ·»åŠ æ³Šä½
    for i in range(20):
        berth = Berth(
            berth_id=f"BERTH-{i:03d}",
            terminal_id=f"TERM-{(i // 5):02d}",
            berth_type=BerthType.CONTAINER,
            length_m=300 + (i % 4) * 100,
            depth_m=14.0 + (i % 3) * 2,
            crane_count=3 + (i % 3)
        )
        scheduler.add_berth(berth)
    
    # æ·»åŠ èˆ¹èˆ¶åˆ°æ¸¯è®¡åˆ’
    import random
    vessel_names = ["Pacific Star", "Atlantic Voyager", "Indian Trader",
                   "Mediterranean Queen", "Arctic Explorer"]
    
    for i in range(50):
        eta = datetime.now() + timedelta(hours=random.uniform(0, 72))
        call = VesselCall(
            call_id=f"CALL-{i:04d}",
            vessel_id=f"VES-{i:04d}",
            vessel_name=f"{random.choice(vessel_names)}-{i}",
            vessel_length=200 + random.uniform(0, 200),
            vessel_draft=10 + random.uniform(0, 8),
            vessel_type=BerthType.CONTAINER,
            eta=eta,
            etd=eta + timedelta(hours=random.uniform(12, 48)),
            cargo_teus=random.randint(1000, 15000),
            priority=random.randint(1, 10)
        )
        scheduler.add_vessel_call(call)
        
        # è°ƒåº¦èˆ¹èˆ¶
        assigned = scheduler.schedule_vessel(call.call_id)
        if assigned:
            print(f"Assigned {call.vessel_name} to {assigned}")
    
    # æ¸¯å£æ¦‚è§ˆ
    overview = scheduler.get_port_overview()
    print("\nPort Overview:")
    print(json.dumps(overview, indent=2))


if __name__ == "__main__":
    main()
```

### 4.6 æ•ˆæœè¯„ä¼°ä¸ROI

#### æ€§èƒ½æŒ‡æ ‡å¯¹æ¯”

| æŒ‡æ ‡ | æ”¹é€ å‰ | æ”¹é€ å | æ”¹å–„å¹…åº¦ |
|------|--------|--------|----------|
| æ³Šä½åˆ©ç”¨ç‡ | 65% | 87% | +22% |
| èˆ¹èˆ¶å¹³å‡ç­‰å¾…æ—¶é—´ | 12å°æ—¶ | 2.5å°æ—¶ | -79% |
| è°ƒåº¦è‡ªåŠ¨åŒ–ç‡ | 10% | 85% | +75% |
| èµ„æºå†²çªç‡ | 15% | 1.5% | -90% |
| èˆ¹èˆ¶å‡†ç‚¹é æ³Šç‡ | 70% | 96% | +37% |

#### ROIè®¡ç®—

**æŠ•èµ„æˆæœ¬**ï¼š
- ç³»ç»Ÿå¼€å‘ï¼š1,200ä¸‡å…ƒ
- ç¡¬ä»¶å‡çº§ï¼š800ä¸‡å…ƒ
- **æ€»æŠ•èµ„**ï¼š2,000ä¸‡å…ƒ

**å¹´åº¦æ”¶ç›Š**ï¼š
- æ³Šä½æ•ˆç‡æå‡ï¼š5,000ä¸‡å…ƒ
- èˆ¹èˆ¶ç­‰å¾…å‡å°‘ï¼š3,000ä¸‡å…ƒ
- èµ„æºå†²çªé¿å…ï¼š1,000ä¸‡å…ƒ
- **å¹´åº¦æ€»æ”¶ç›Š**ï¼š9,000ä¸‡å…ƒ

**ROIåˆ†æ**ï¼š
- æŠ•èµ„å›æ”¶æœŸï¼š2.7ä¸ªæœˆ
- 3å¹´ROIï¼š1,250%

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

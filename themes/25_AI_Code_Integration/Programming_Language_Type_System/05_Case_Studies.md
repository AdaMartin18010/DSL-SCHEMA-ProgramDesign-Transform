# ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿå®è·µæ¡ˆä¾‹](#ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šé‡‘èç§‘æŠ€ä¼ä¸šç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ](#2-æ¡ˆä¾‹1é‡‘èç§‘æŠ€ä¼ä¸šç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 æŠ€æœ¯æŒ‘æˆ˜](#22-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.3 è§£å†³æ–¹æ¡ˆ](#23-è§£å†³æ–¹æ¡ˆ)
    - [2.4 å®Œæ•´ä»£ç å®ç°](#24-å®Œæ•´ä»£ç å®ç°)
    - [2.5 æ•ˆæœè¯„ä¼°](#25-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šç”µå•†å¹³å°ç±»å‹æ¨æ–­ä¸éªŒè¯ç³»ç»Ÿ](#3-æ¡ˆä¾‹2ç”µå•†å¹³å°ç±»å‹æ¨æ–­ä¸éªŒè¯ç³»ç»Ÿ)
    - [3.1 ä¸šåŠ¡èƒŒæ™¯](#31-ä¸šåŠ¡èƒŒæ™¯)
    - [3.2 æŠ€æœ¯æŒ‘æˆ˜](#32-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.3 è§£å†³æ–¹æ¡ˆ](#33-è§£å†³æ–¹æ¡ˆ)
    - [3.4 å®Œæ•´ä»£ç å®ç°](#34-å®Œæ•´ä»£ç å®ç°)
    - [3.5 æ•ˆæœè¯„ä¼°](#35-æ•ˆæœè¯„ä¼°)
  - [4. æ¡ˆä¾‹3ï¼šåˆ¶é€ ä¼ä¸šæ³›å‹ç±»å‹è½¬æ¢ç³»ç»Ÿ](#4-æ¡ˆä¾‹3åˆ¶é€ ä¼ä¸šæ³›å‹ç±»å‹è½¬æ¢ç³»ç»Ÿ)
    - [4.1 ä¸šåŠ¡èƒŒæ™¯](#41-ä¸šåŠ¡èƒŒæ™¯)
    - [4.2 æŠ€æœ¯æŒ‘æˆ˜](#42-æŠ€æœ¯æŒ‘æˆ˜)
    - [4.3 è§£å†³æ–¹æ¡ˆ](#43-è§£å†³æ–¹æ¡ˆ)
    - [4.4 å®Œæ•´ä»£ç å®ç°](#44-å®Œæ•´ä»£ç å®ç°)
    - [4.5 æ•ˆæœè¯„ä¼°](#45-æ•ˆæœè¯„ä¼°)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿåœ¨Schemaè½¬æ¢ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ç±»å‹å®‰å…¨è½¬æ¢ã€ç±»å‹æ¨æ–­ä¸éªŒè¯ã€æ³›å‹ç±»å‹è½¬æ¢ç­‰çœŸå®åœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **ç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ**ï¼šç±»å‹å®‰å…¨çš„Schemaè½¬æ¢
2. **ç±»å‹æ¨æ–­ä¸éªŒè¯ç³»ç»Ÿ**ï¼šåŸºäºAIçš„ç±»å‹æ¨æ–­å’ŒéªŒè¯
3. **æ³›å‹ç±»å‹è½¬æ¢ç³»ç»Ÿ**ï¼šæ³›å‹ç±»å‹åˆ°å…·ä½“ç±»å‹çš„è½¬æ¢
4. **ç±»å‹çº¦æŸéªŒè¯ç³»ç»Ÿ**ï¼šå¤æ‚ç±»å‹çº¦æŸçš„éªŒè¯
5. **ç±»å‹å®‰å…¨Schemaæ˜ å°„ç³»ç»Ÿ**ï¼šç±»å‹å®‰å…¨çš„è·¨Schemaæ˜ å°„

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **TypeScriptç±»å‹ç³»ç»Ÿ**ï¼šTypeScriptå®˜æ–¹æ–‡æ¡£
- **Haskellç±»å‹ç³»ç»Ÿ**ï¼šHaskellç±»å‹ç³»ç»Ÿæœ€ä½³å®è·µ
- **Rustç±»å‹ç³»ç»Ÿ**ï¼šRustæ‰€æœ‰æƒå’Œç±»å‹ç³»ç»Ÿ

---

## 2. æ¡ˆä¾‹1ï¼šé‡‘èç§‘æŠ€ä¼ä¸šç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå¤§å‹é‡‘èç§‘æŠ€ä¼ä¸šï¼ˆæ ¸å¿ƒäº¤æ˜“ç³»ç»Ÿæ—¥å‡å¤„ç†10äº¿+äº¤æ˜“ï¼‰éœ€è¦æ„å»ºç±»å‹å®‰å…¨çš„Schemaè½¬æ¢ç³»ç»Ÿã€‚ä¼ä¸šç³»ç»Ÿä½¿ç”¨å¤šç§ç¼–ç¨‹è¯­è¨€ï¼ˆJavaã€Pythonã€TypeScriptï¼‰å’ŒæŠ€æœ¯æ ˆï¼Œæ•°æ®åœ¨ä¸åŒç³»ç»Ÿé—´æµè½¬æ—¶é¢‘ç¹å‡ºç°ç±»å‹é”™è¯¯ï¼Œå¯¼è‡´ç”Ÿäº§äº‹æ•…ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **ç±»å‹é”™è¯¯é¢‘å‘**ï¼šè·¨ç³»ç»Ÿæ•°æ®æµè½¬ä¸­ï¼Œç±»å‹ä¸åŒ¹é…å¯¼è‡´çš„è¿è¡Œæ—¶é”™è¯¯å æ€»é”™è¯¯çš„40%
2. **æ•°æ®ä¸¢å¤±é£é™©**ï¼šå¼±ç±»å‹è½¬æ¢å¯¼è‡´æ•°å€¼ç²¾åº¦ä¸¢å¤±ï¼Œå½±å“é‡‘èè®¡ç®—å‡†ç¡®æ€§
3. **ç©ºæŒ‡é’ˆå¼‚å¸¸**ï¼šç¼ºä¹ç©ºå€¼æ£€æŸ¥å¯¼è‡´é¢‘ç¹çš„NPEï¼Œå½±å“ç³»ç»Ÿç¨³å®šæ€§
4. **ç±»å‹è½¬æ¢ä¸ä¸€è‡´**ï¼šåŒä¸€æ•°æ®åœ¨ä¸åŒç³»ç»Ÿä¸­çš„è¡¨ç¤ºä¸ä¸€è‡´ï¼Œå¯¼è‡´ä¸šåŠ¡é€»è¾‘é”™è¯¯
5. **éªŒè¯æ»å**ï¼šç±»å‹é”™è¯¯åœ¨è¿è¡Œæ—¶æ‰è¢«å‘ç°ï¼Œä¿®å¤æˆæœ¬é«˜æ˜‚

**ä¸šåŠ¡ç›®æ ‡**ï¼š

1. **æ¶ˆé™¤è¿è¡Œæ—¶ç±»å‹é”™è¯¯**ï¼šé€šè¿‡ç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥ï¼Œæ¶ˆé™¤99%çš„è¿è¡Œæ—¶ç±»å‹é”™è¯¯
2. **ä¿è¯æ•°å€¼ç²¾åº¦**ï¼šç¡®ä¿é‡‘èè®¡ç®—çš„ç±»å‹è½¬æ¢ä¿æŒç²¾åº¦ï¼Œé›¶ç²¾åº¦ä¸¢å¤±
3. **ç©ºå€¼å®‰å…¨**ï¼šå®ç°ç©ºå€¼ç±»å‹çš„æ˜¾å¼å¤„ç†ï¼ŒNPEå‡å°‘95%
4. **ç»Ÿä¸€ç±»å‹ç³»ç»Ÿ**ï¼šå»ºç«‹è·¨è¯­è¨€çš„ç»Ÿä¸€ç±»å‹æè¿°å’ŒéªŒè¯æœºåˆ¶
5. **æå‰é”™è¯¯å‘ç°**ï¼šå°†ç±»å‹é”™è¯¯å‘ç°æå‰åˆ°å¼€å‘é˜¶æ®µï¼Œé™ä½ä¿®å¤æˆæœ¬

### 2.2 æŠ€æœ¯æŒ‘æˆ˜

1. **è·¨è¯­è¨€ç±»å‹æ˜ å°„**ï¼šå¤„ç†Javaã€Pythonã€TypeScriptä¹‹é—´çš„ç±»å‹ç³»ç»Ÿå·®å¼‚
2. **æ³›å‹ç±»å‹å¤„ç†**ï¼šå¤„ç†å¤æ‚çš„æ³›å‹ç±»å‹ï¼ˆListã€Mapã€Optionalï¼‰çš„å®‰å…¨è½¬æ¢
3. **ç©ºå€¼å®‰å…¨**ï¼šè®¾è®¡ç©ºå€¼ç±»å‹ç³»ç»Ÿï¼ŒåŒºåˆ†å¯ç©ºå’Œéç©ºç±»å‹
4. **æ•°å€¼ç²¾åº¦ä¿æŒ**ï¼šå¤„ç†Decimalã€Moneyç­‰é‡‘èç±»å‹çš„ç²¾åº¦ä¿æŒ
5. **ç±»å‹æ¨æ–­**ï¼šåŸºäºæ•°æ®æ ·æœ¬è‡ªåŠ¨æ¨æ–­ç±»å‹çº¦æŸ

### 2.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨ç±»å‹ç†è®ºå’Œå½¢å¼åŒ–éªŒè¯ï¼Œæ„å»ºç±»å‹å®‰å…¨çš„Schemaè½¬æ¢ç³»ç»Ÿ**ï¼š

é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š
- **ç±»å‹å®šä¹‰å±‚**ï¼šå®šä¹‰ç»Ÿä¸€çš„ç±»å‹æè¿°è¯­è¨€
- **ç±»å‹æ¨æ–­å±‚**ï¼šåŸºäºæ•°æ®æ ·æœ¬æ¨æ–­ç±»å‹çº¦æŸ
- **ç±»å‹æ£€æŸ¥å±‚**ï¼šç¼–è¯‘æ—¶ç±»å‹æ£€æŸ¥å’ŒéªŒè¯
- **ä»£ç ç”Ÿæˆå±‚**ï¼šç”Ÿæˆç±»å‹å®‰å…¨çš„è½¬æ¢ä»£ç 
- **è¿è¡Œæ—¶ç›‘æ§å±‚**ï¼šè¿è¡Œæ—¶ç±»å‹éªŒè¯å’Œç›‘æ§

### 2.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿ - ç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ
æ”¯æŒè·¨è¯­è¨€ç±»å‹æ˜ å°„ã€æ³›å‹å¤„ç†ã€ç©ºå€¼å®‰å…¨
"""

from typing import Dict, List, Optional, Any, TypeVar, Generic, Callable, Union
from dataclasses import dataclass, field
from enum import Enum, auto
from abc import ABC, abstractmethod
import json
from decimal import Decimal, InvalidOperation
from datetime import datetime, date

# ç±»å‹å˜é‡å®šä¹‰
T = TypeVar('T')
U = TypeVar('U')

class TypeKind(Enum):
    """ç±»å‹ç§ç±»"""
    PRIMITIVE = auto()
    OPTIONAL = auto()
    LIST = auto()
    MAP = auto()
    OBJECT = auto()
    UNION = auto()
    INTERSECTION = auto()
    FUNCTION = auto()

class PrimitiveType(Enum):
    """åŸºæœ¬ç±»å‹"""
    STRING = "string"
    INTEGER = "integer"
    NUMBER = "number"
    BOOLEAN = "boolean"
    DECIMAL = "decimal"
    DATETIME = "datetime"
    DATE = "date"
    ANY = "any"

@dataclass
class TypeConstraint:
    """ç±»å‹çº¦æŸ"""
    min_value: Optional[float] = None
    max_value: Optional[float] = None
    min_length: Optional[int] = None
    max_length: Optional[int] = None
    pattern: Optional[str] = None
    format: Optional[str] = None
    nullable: bool = False
    precision: Optional[int] = None  # å°æ•°ç²¾åº¦
    scale: Optional[int] = None

@dataclass
class TypeDescriptor:
    """ç±»å‹æè¿°ç¬¦"""
    name: str
    kind: TypeKind
    primitive: Optional[PrimitiveType] = None
    element_type: Optional['TypeDescriptor'] = None  # ç”¨äºList/Optional
    key_type: Optional['TypeDescriptor'] = None      # ç”¨äºMap
    value_type: Optional['TypeDescriptor'] = None    # ç”¨äºMap/Object
    fields: Dict[str, 'TypeDescriptor'] = field(default_factory=dict)  # ç”¨äºObject
    union_types: List['TypeDescriptor'] = field(default_factory=list)  # ç”¨äºUnion
    constraints: TypeConstraint = field(default_factory=TypeConstraint)
    
    def __str__(self) -> str:
        if self.kind == TypeKind.PRIMITIVE:
            return self.primitive.value if self.primitive else "unknown"
        elif self.kind == TypeKind.OPTIONAL:
            return f"Optional[{self.element_type}]"
        elif self.kind == TypeKind.LIST:
            return f"List[{self.element_type}]"
        elif self.kind == TypeKind.MAP:
            return f"Map[{self.key_type}, {self.value_type}]"
        elif self.kind == TypeKind.OBJECT:
            return f"Object[{', '.join(self.fields.keys())}]"
        elif self.kind == TypeKind.UNION:
            return f"Union[{', '.join(str(t) for t in self.union_types)}]"
        return self.name

# é¢„å®šä¹‰å¸¸ç”¨ç±»å‹
def StringType(nullable: bool = False, min_len: int = None, max_len: int = None, 
               pattern: str = None) -> TypeDescriptor:
    return TypeDescriptor(
        name="string", kind=TypeKind.PRIMITIVE, primitive=PrimitiveType.STRING,
        constraints=TypeConstraint(nullable=nullable, min_length=min_len, 
                                  max_length=max_len, pattern=pattern)
    )

def IntType(nullable: bool = False, min_val: int = None, max_val: int = None) -> TypeDescriptor:
    return TypeDescriptor(
        name="integer", kind=TypeKind.PRIMITIVE, primitive=PrimitiveType.INTEGER,
        constraints=TypeConstraint(nullable=nullable, min_value=min_val, max_value=max_val)
    )

def DecimalType(nullable: bool = False, precision: int = 28, scale: int = 8) -> TypeDescriptor:
    return TypeDescriptor(
        name="decimal", kind=TypeKind.PRIMITIVE, primitive=PrimitiveType.DECIMAL,
        constraints=TypeConstraint(nullable=nullable, precision=precision, scale=scale)
    )

def OptionalType(element_type: TypeDescriptor) -> TypeDescriptor:
    return TypeDescriptor(
        name=f"Optional[{element_type.name}]",
        kind=TypeKind.OPTIONAL,
        element_type=element_type,
        constraints=TypeConstraint(nullable=True)
    )

def ListType(element_type: TypeDescriptor) -> TypeDescriptor:
    return TypeDescriptor(
        name=f"List[{element_type.name}]",
        kind=TypeKind.LIST,
        element_type=element_type
    )

class TypeSafeConverter(Generic[T, U]):
    """ç±»å‹å®‰å…¨è½¬æ¢å™¨åŸºç±»"""
    
    def __init__(self, source_type: TypeDescriptor, target_type: TypeDescriptor):
        self.source_type = source_type
        self.target_type = target_type
        self.validation_errors: List[str] = []
    
    def convert(self, source: T) -> U:
        """ç±»å‹å®‰å…¨è½¬æ¢"""
        self.validation_errors = []
        
        # 1. æºç±»å‹æ£€æŸ¥
        if not self._check_source_type(source):
            raise TypeError(f"Source value does not match type {self.source_type}")
        
        # 2. çº¦æŸéªŒè¯
        if not self._validate_constraints(source, self.source_type):
            raise ValueError(f"Constraint validation failed: {self.validation_errors}")
        
        # 3. æ‰§è¡Œè½¬æ¢
        try:
            result = self._convert_impl(source)
        except Exception as e:
            raise RuntimeError(f"Conversion failed: {e}") from e
        
        # 4. ç›®æ ‡ç±»å‹éªŒè¯
        if not self._check_target_type(result):
            raise TypeError(f"Conversion result does not match target type {self.target_type}")
        
        return result
    
    def _check_source_type(self, value: Any) -> bool:
        """æ£€æŸ¥æºç±»å‹"""
        return self._check_type(value, self.source_type)
    
    def _check_target_type(self, value: Any) -> bool:
        """æ£€æŸ¥ç›®æ ‡ç±»å‹"""
        return self._check_type(value, self.target_type)
    
    def _check_type(self, value: Any, type_desc: TypeDescriptor) -> bool:
        """ç±»å‹æ£€æŸ¥å®ç°"""
        if type_desc.kind == TypeKind.PRIMITIVE:
            return self._check_primitive_type(value, type_desc.primitive)
        elif type_desc.kind == TypeKind.OPTIONAL:
            return value is None or self._check_type(value, type_desc.element_type)
        elif type_desc.kind == TypeKind.LIST:
            return isinstance(value, list) and all(
                self._check_type(item, type_desc.element_type) for item in value
            )
        elif type_desc.kind == TypeKind.MAP:
            return isinstance(value, dict) and all(
                self._check_type(k, type_desc.key_type) and 
                self._check_type(v, type_desc.value_type)
                for k, v in value.items()
            )
        elif type_desc.kind == TypeKind.OBJECT:
            return isinstance(value, dict) and all(
                key in value and self._check_type(value[key], field_type)
                for key, field_type in type_desc.fields.items()
            )
        return True
    
    def _check_primitive_type(self, value: Any, primitive: PrimitiveType) -> bool:
        """æ£€æŸ¥åŸºæœ¬ç±»å‹"""
        if primitive == PrimitiveType.STRING:
            return isinstance(value, str)
        elif primitive == PrimitiveType.INTEGER:
            return isinstance(value, int) and not isinstance(value, bool)
        elif primitive == PrimitiveType.NUMBER:
            return isinstance(value, (int, float)) and not isinstance(value, bool)
        elif primitive == PrimitiveType.BOOLEAN:
            return isinstance(value, bool)
        elif primitive == PrimitiveType.DECIMAL:
            return isinstance(value, (Decimal, int, float, str))
        elif primitive == PrimitiveType.DATETIME:
            return isinstance(value, (datetime, str))
        elif primitive == PrimitiveType.DATE:
            return isinstance(value, (date, datetime, str))
        elif primitive == PrimitiveType.ANY:
            return True
        return False
    
    def _validate_constraints(self, value: Any, type_desc: TypeDescriptor) -> bool:
        """éªŒè¯çº¦æŸ"""
        constraints = type_desc.constraints
        
        if value is None:
            if not constraints.nullable:
                self.validation_errors.append("Value is None but not nullable")
                return False
            return True
        
        # æ•°å€¼çº¦æŸ
        if isinstance(value, (int, float, Decimal)):
            if constraints.min_value is not None and value < constraints.min_value:
                self.validation_errors.append(f"Value {value} < min {constraints.min_value}")
                return False
            if constraints.max_value is not None and value > constraints.max_value:
                self.validation_errors.append(f"Value {value} > max {constraints.max_value}")
                return False
        
        # å­—ç¬¦ä¸²çº¦æŸ
        if isinstance(value, str):
            if constraints.min_length is not None and len(value) < constraints.min_length:
                self.validation_errors.append(f"Length {len(value)} < min {constraints.min_length}")
                return False
            if constraints.max_length is not None and len(value) > constraints.max_length:
                self.validation_errors.append(f"Length {len(value)} > max {constraints.max_length}")
                return False
            if constraints.pattern is not None and not re.match(constraints.pattern, value):
                self.validation_errors.append(f"Value does not match pattern {constraints.pattern}")
                return False
        
        # é€’å½’éªŒè¯å®¹å™¨ç±»å‹
        if type_desc.kind == TypeKind.LIST and isinstance(value, list):
            for i, item in enumerate(value):
                if not self._validate_constraints(item, type_desc.element_type):
                    self.validation_errors.append(f"Item at index {i} failed validation")
                    return False
        
        if type_desc.kind == TypeKind.MAP and isinstance(value, dict):
            for k, v in value.items():
                if not self._validate_constraints(k, type_desc.key_type):
                    self.validation_errors.append(f"Key {k} failed validation")
                    return False
                if not self._validate_constraints(v, type_desc.value_type):
                    self.validation_errors.append(f"Value for key {k} failed validation")
                    return False
        
        return True
    
    @abstractmethod
    def _convert_impl(self, source: T) -> U:
        """å…·ä½“çš„è½¬æ¢å®ç°ï¼ˆå­ç±»å¿…é¡»å®ç°ï¼‰"""
        pass

# å…·ä½“è½¬æ¢å™¨å®ç°
class StringToDecimalConverter(TypeSafeConverter[str, Decimal]):
    """å­—ç¬¦ä¸²åˆ°Decimalè½¬æ¢å™¨"""
    
    def __init__(self):
        super().__init__(
            StringType(pattern=r'^-?\d+\.?\d*$'),
            DecimalType()
        )
    
    def _convert_impl(self, source: str) -> Decimal:
        """è½¬æ¢å®ç°"""
        try:
            return Decimal(source)
        except InvalidOperation as e:
            raise ValueError(f"Cannot convert '{source}' to Decimal: {e}")

class DictToTypedDictConverter(TypeSafeConverter[Dict, Dict]):
    """å­—å…¸åˆ°ç±»å‹åŒ–å­—å…¸è½¬æ¢å™¨"""
    
    def __init__(self, field_types: Dict[str, TypeDescriptor]):
        source_type = TypeDescriptor(
            name="Dict", kind=TypeKind.MAP,
            key_type=StringType(),
            value_type=TypeDescriptor("Any", TypeKind.PRIMITIVE, PrimitiveType.ANY)
        )
        target_type = TypeDescriptor(
            name="TypedDict", kind=TypeKind.OBJECT,
            fields=field_types
        )
        super().__init__(source_type, target_type)
        self.field_types = field_types
    
    def _convert_impl(self, source: Dict) -> Dict:
        """è½¬æ¢å®ç°"""
        result = {}
        for field_name, field_type in self.field_types.items():
            if field_name in source:
                result[field_name] = source[field_name]
            elif not field_type.constraints.nullable:
                raise ValueError(f"Required field '{field_name}' is missing")
        return result

# é‡‘èç±»å‹è½¬æ¢å™¨
class MoneyAmount:
    """è´§å¸é‡‘é¢ç±»å‹"""
    def __init__(self, amount: Decimal, currency: str):
        self.amount = amount
        self.currency = currency
    
    def __str__(self) -> str:
        return f"{self.amount} {self.currency}"

class StringToMoneyConverter(TypeSafeConverter[str, MoneyAmount]):
    """å­—ç¬¦ä¸²åˆ°Moneyè½¬æ¢å™¨"""
    
    def __init__(self, currency: str = "USD"):
        super().__init__(
            StringType(pattern=r'^-?\d+\.?\d*\s*[A-Z]{3}?$'),
            TypeDescriptor("Money", TypeKind.OBJECT)
        )
        self.currency = currency
    
    def _convert_impl(self, source: str) -> MoneyAmount:
        """è½¬æ¢å®ç°"""
        parts = source.strip().split()
        if len(parts) == 2:
            amount = Decimal(parts[0])
            currency = parts[1]
        elif len(parts) == 1:
            amount = Decimal(parts[0])
            currency = self.currency
        else:
            raise ValueError(f"Invalid money format: {source}")
        
        return MoneyAmount(amount, currency)

# ç±»å‹æ¨æ–­å¼•æ“
class TypeInferenceEngine:
    """ç±»å‹æ¨æ–­å¼•æ“"""
    
    def infer_type(self, value: Any, field_name: str = None) -> TypeDescriptor:
        """ä»å€¼æ¨æ–­ç±»å‹"""
        if value is None:
            return TypeDescriptor("None", TypeKind.PRIMITIVE, PrimitiveType.ANY,
                                 constraints=TypeConstraint(nullable=True))
        
        if isinstance(value, bool):
            return TypeDescriptor("boolean", TypeKind.PRIMITIVE, PrimitiveType.BOOLEAN)
        
        if isinstance(value, int):
            return IntType()
        
        if isinstance(value, float):
            return TypeDescriptor("number", TypeKind.PRIMITIVE, PrimitiveType.NUMBER)
        
        if isinstance(value, Decimal):
            return DecimalType(precision=value.as_tuple().exponent)
        
        if isinstance(value, str):
            # å°è¯•æ¨æ–­æ›´å…·ä½“çš„å­—ç¬¦ä¸²ç±»å‹
            if self._is_datetime_string(value):
                return TypeDescriptor("datetime", TypeKind.PRIMITIVE, PrimitiveType.DATETIME)
            if self._is_date_string(value):
                return TypeDescriptor("date", TypeKind.PRIMITIVE, PrimitiveType.DATE)
            if self._is_money_string(value):
                return TypeDescriptor("money_string", TypeKind.PRIMITIVE, PrimitiveType.STRING,
                                     constraints=TypeConstraint(pattern=r'^\d+\.\d{2}$'))
            
            # åŸºäºå­—æ®µåæ¨æ–­
            if field_name:
                return self._infer_string_type_from_field_name(field_name, value)
            
            return StringType()
        
        if isinstance(value, list):
            if value:
                element_type = self.infer_type(value[0])
                return ListType(element_type)
            return ListType(TypeDescriptor("Any", TypeKind.PRIMITIVE, PrimitiveType.ANY))
        
        if isinstance(value, dict):
            fields = {}
            for key, val in value.items():
                fields[key] = self.infer_type(val, key)
            return TypeDescriptor("Object", TypeKind.OBJECT, fields=fields)
        
        return TypeDescriptor("Any", TypeKind.PRIMITIVE, PrimitiveType.ANY)
    
    def _is_datetime_string(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ—¥æœŸæ—¶é—´å­—ç¬¦ä¸²"""
        patterns = [
            r'^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}',
            r'^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}',
            r'^\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}'
        ]
        return any(re.match(p, value) for p in patterns)
    
    def _is_date_string(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ—¥æœŸå­—ç¬¦ä¸²"""
        patterns = [
            r'^\d{4}-\d{2}-\d{2}$',
            r'^\d{4}/\d{2}/\d{2}$',
            r'^\d{2}/\d{2}/\d{4}$'
        ]
        return any(re.match(p, value) for p in patterns)
    
    def _is_money_string(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé‡‘é¢å­—ç¬¦ä¸²"""
        return bool(re.match(r'^-?\d+\.\d{2}$', value))
    
    def _infer_string_type_from_field_name(self, field_name: str, value: str) -> TypeDescriptor:
        """åŸºäºå­—æ®µåæ¨æ–­å­—ç¬¦ä¸²ç±»å‹"""
        field_lower = field_name.lower()
        
        if any(kw in field_lower for kw in ["email", "mail"]):
            return StringType(pattern=r'^[\w\.-]+@[\w\.-]+\.\w+$')
        
        if any(kw in field_lower for kw in ["phone", "tel", "mobile"]):
            return StringType(pattern=r'^\+?\d{10,15}$')
        
        if any(kw in field_lower for kw in ["id", "uuid"]):
            return StringType(min_len=1, max_len=64)
        
        if any(kw in field_lower for kw in ["name", "title"]):
            return StringType(min_len=1, max_len=100)
        
        if any(kw in field_lower for kw in ["description", "comment", "note"]):
            return StringType(max_length=5000)
        
        return StringType()

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    # æµ‹è¯•ç±»å‹å®‰å…¨è½¬æ¢å™¨
    print("=== ç±»å‹å®‰å…¨è½¬æ¢æµ‹è¯• ===")
    
    # å­—ç¬¦ä¸²åˆ°Decimalè½¬æ¢
    decimal_converter = StringToDecimalConverter()
    try:
        result = decimal_converter.convert("1234.5678")
        print(f"âœ“ Decimalè½¬æ¢: {result}")
    except Exception as e:
        print(f"âœ— Decimalè½¬æ¢å¤±è´¥: {e}")
    
    # æ— æ•ˆDecimalæ ¼å¼
    try:
        result = decimal_converter.convert("not_a_number")
        print(f"âœ— åº”è¯¥å¤±è´¥çš„Decimalè½¬æ¢å´æˆåŠŸäº†: {result}")
    except (TypeError, ValueError) as e:
        print(f"âœ“ æ­£ç¡®æ•è·é”™è¯¯: {type(e).__name__}: {e}")
    
    # Moneyè½¬æ¢
    money_converter = StringToMoneyConverter("CNY")
    try:
        result = money_converter.convert("1000.50 CNY")
        print(f"âœ“ Moneyè½¬æ¢: {result}")
    except Exception as e:
        print(f"âœ— Moneyè½¬æ¢å¤±è´¥: {e}")
    
    # ç±»å‹æ¨æ–­æµ‹è¯•
    print("\n=== ç±»å‹æ¨æ–­æµ‹è¯• ===")
    inference_engine = TypeInferenceEngine()
    
    test_values = [
        42,
        3.14,
        "hello",
        "2025-02-15T10:30:00",
        "john@example.com",
        [1, 2, 3],
        {"name": "John", "age": 30, "email": "john@example.com"},
        None
    ]
    
    for value in test_values:
        inferred = inference_engine.infer_type(value)
        print(f"å€¼: {str(value)[:30]:30} -> æ¨æ–­ç±»å‹: {inferred}")
```

### 2.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| è¿è¡Œæ—¶ç±»å‹é”™è¯¯ | 500+/æœˆ | 5/æœˆ | 99%å‡å°‘ |
| ç©ºæŒ‡é’ˆå¼‚å¸¸ | 300+/æœˆ | 10/æœˆ | 97%å‡å°‘ |
| æ•°å€¼ç²¾åº¦ä¸¢å¤± | 50+/æœˆ | 0 | 100%æ¶ˆé™¤ |
| ç±»å‹é”™è¯¯å‘ç°æ—¶é—´ | è¿è¡Œæ—¶ | ç¼–è¯‘æ—¶ | æ˜¾è‘—æå‰ |
| ç±»å‹å®‰å…¨è¦†ç›–ç‡ | 40% | 95% | 138%æå‡ |

**ä¸šåŠ¡ä»·å€¼ï¼ˆROIåˆ†æï¼‰**ï¼š

1. **è´¨é‡æå‡**ï¼š
   - ç”Ÿäº§äº‹æ•…å‡å°‘99%
   - å¹´åº¦è´¨é‡æŸå¤±å‡å°‘ï¼šçº¦800ä¸‡å…ƒ

2. **å¼€å‘æ•ˆç‡**ï¼š
   - è°ƒè¯•æ—¶é—´å‡å°‘80%
   - å¹´åº¦å¼€å‘æˆæœ¬èŠ‚çº¦ï¼šçº¦300ä¸‡å…ƒ

3. **ç»´æŠ¤æˆæœ¬**ï¼š
   - ç±»å‹ç›¸å…³bugä¿®å¤æˆæœ¬é™ä½90%
   - å¹´åº¦ç»´æŠ¤æˆæœ¬èŠ‚çº¦ï¼šçº¦200ä¸‡å…ƒ

4. **æŠ•èµ„å›æŠ¥ç‡**ï¼š
   - ç³»ç»Ÿå¼€å‘æŠ•å…¥ï¼šçº¦150ä¸‡å…ƒ
   - å¹´åº¦æ€»æ”¶ç›Šï¼šçº¦1300ä¸‡å…ƒ
   - **ROI = 767%**

---

## 3. æ¡ˆä¾‹2ï¼šç”µå•†å¹³å°ç±»å‹æ¨æ–­ä¸éªŒè¯ç³»ç»Ÿ

### 3.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå¤´éƒ¨ç”µå•†å¹³å°ï¼ˆæ—¥å‡è®¢å•500ä¸‡ï¼ŒSKUæ•°é‡è¿‡äº¿ï¼‰éœ€è¦å¤„ç†æ¥è‡ªæ•°åƒä¸ªä¾›åº”å•†çš„å•†å“æ•°æ®ã€‚ä¾›åº”å•†æäº¤çš„æ•°æ®æ ¼å¼å„å¼‚ï¼Œç¼ºä¹ç»Ÿä¸€ç±»å‹å®šä¹‰ï¼Œå¯¼è‡´æ•°æ®è´¨é‡é—®é¢˜é¢‘å‘ï¼Œå½±å“æœç´¢ã€æ¨èå’Œä»·æ ¼è®¡ç®—ç­‰æ ¸å¿ƒä¸šåŠ¡ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **æ•°æ®è´¨é‡å·®**ï¼šä¾›åº”å•†æäº¤çš„æ•°æ®ç±»å‹æ··ä¹±ï¼ˆä»·æ ¼å­—æ®µæœ‰æ—¶æ˜¯æ•°å­—æœ‰æ—¶æ˜¯å­—ç¬¦ä¸²ï¼‰ï¼Œæ•°æ®é”™è¯¯ç‡è¾¾15%
2. **äººå·¥å®¡æ ¸æˆæœ¬é«˜**ï¼šéœ€è¦å¤§é‡äººå·¥å®¡æ ¸å’Œæ¸…æ´—æ•°æ®ï¼ŒäººåŠ›æˆæœ¬é«˜
3. **åŠ¨æ€Schemaå˜åŒ–**ï¼šå•†å“å±æ€§é¢‘ç¹å˜åŒ–ï¼Œé™æ€Schemaéš¾ä»¥é€‚åº”
4. **ç±»å‹æ¨æ–­å›°éš¾**ï¼šéç»“æ„åŒ–æ•°æ®ï¼ˆå¦‚æè¿°æ–‡æœ¬ï¼‰çš„ç±»å‹æ¨æ–­å›°éš¾
5. **éªŒè¯è§„åˆ™ç¼ºå¤±**ï¼šç¼ºä¹åŸºäºAIçš„æ•°æ®éªŒè¯è§„åˆ™ï¼Œæ— æ³•æ™ºèƒ½è¯†åˆ«å¼‚å¸¸æ•°æ®

**ä¸šåŠ¡ç›®æ ‡**ï¼š

1. **æ™ºèƒ½ç±»å‹æ¨æ–­**ï¼šåŸºäºAIè‡ªåŠ¨æ¨æ–­æ•°æ®ç±»å‹ï¼Œå‡†ç¡®ç‡è¾¾95%
2. **åŠ¨æ€Schemaé€‚é…**ï¼šæ”¯æŒSchemaçš„åŠ¨æ€æ¼”è¿›å’Œç‰ˆæœ¬ç®¡ç†
3. **æ™ºèƒ½æ•°æ®éªŒè¯**ï¼šåŸºäºæœºå™¨å­¦ä¹ çš„æ•°æ®éªŒè¯ï¼Œå¼‚å¸¸è¯†åˆ«ç‡è¾¾90%
4. **è‡ªåŠ¨åŒ–æ•°æ®æ¸…æ´—**ï¼šå®ç°80%çš„æ•°æ®æ¸…æ´—è‡ªåŠ¨åŒ–
5. **å®æ—¶éªŒè¯èƒ½åŠ›**ï¼šå®ç°æ¯«ç§’çº§çš„æ•°æ®éªŒè¯å“åº”

### 3.2 æŠ€æœ¯æŒ‘æˆ˜

1. **å¤šæºå¼‚æ„æ•°æ®**ï¼šå¤„ç†æ¥è‡ªä¸åŒä¾›åº”å•†çš„å¼‚æ„æ•°æ®æ ¼å¼
2. **åŠ¨æ€ç±»å‹æ¨æ–­**ï¼šåŸºäºæ ·æœ¬æ•°æ®åŠ¨æ€æ¨æ–­ç±»å‹çº¦æŸ
3. **å¼‚å¸¸æ£€æµ‹æ¨¡å‹**ï¼šè®­ç»ƒMLæ¨¡å‹è¯†åˆ«å¼‚å¸¸æ•°æ®
4. **Schemaæ¼”è¿›**ï¼šæ”¯æŒSchemaçš„ç‰ˆæœ¬ç®¡ç†å’Œè¿ç§»
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤„ç†æµ·é‡æ•°æ®çš„å®æ—¶ç±»å‹éªŒè¯

### 3.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨æœºå™¨å­¦ä¹ é©±åŠ¨çš„ç±»å‹æ¨æ–­å’ŒéªŒè¯ï¼Œæ„å»ºæ™ºèƒ½æ•°æ®éªŒè¯ç³»ç»Ÿ**ï¼š

é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š
- **æ•°æ®é‡‡é›†å±‚**ï¼šæ”¶é›†ä¾›åº”å•†æ•°æ®æ ·æœ¬
- **ç±»å‹æ¨æ–­å±‚**ï¼šä½¿ç”¨MLæ¨¡å‹æ¨æ–­æ•°æ®ç±»å‹
- **è§„åˆ™ç”Ÿæˆå±‚**ï¼šåŸºäºæ•°æ®åˆ†å¸ƒç”ŸæˆéªŒè¯è§„åˆ™
- **å®æ—¶éªŒè¯å±‚**ï¼šå®æ—¶éªŒè¯æ•°æ®è´¨é‡å’Œç±»å‹
- **åé¦ˆä¼˜åŒ–å±‚**ï¼šåŸºäºéªŒè¯ç»“æœæŒç»­ä¼˜åŒ–æ¨¡å‹

### 3.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
ç±»å‹æ¨æ–­ä¸éªŒè¯ç³»ç»Ÿ
æ”¯æŒAIé©±åŠ¨çš„ç±»å‹æ¨æ–­ã€å¼‚å¸¸æ£€æµ‹ã€åŠ¨æ€Schema
"""

from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import json
import re
from collections import Counter
from datetime import datetime
import statistics

class DataQualityLevel(Enum):
    """æ•°æ®è´¨é‡ç­‰çº§"""
    EXCELLENT = "excellent"
    GOOD = "good"
    FAIR = "fair"
    POOR = "poor"
    INVALID = "invalid"

@dataclass
class FieldStatistics:
    """å­—æ®µç»Ÿè®¡ä¿¡æ¯"""
    field_name: str
    total_count: int = 0
    null_count: int = 0
    unique_count: int = 0
    type_distribution: Dict[str, int] = field(default_factory=dict)
    length_stats: Dict[str, float] = field(default_factory=dict)
    numeric_stats: Dict[str, float] = field(default_factory=dict)
    sample_values: List[Any] = field(default_factory=list)
    common_patterns: List[str] = field(default_factory=list)

@dataclass
class ValidationRule:
    """éªŒè¯è§„åˆ™"""
    field_name: str
    rule_type: str
    condition: Any
    severity: str = "error"  # error, warning
    message: str = ""
    confidence: float = 1.0

@dataclass
class ValidationResult:
    """éªŒè¯ç»“æœ"""
    is_valid: bool
    quality_level: DataQualityLevel
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    field_results: Dict[str, Dict] = field(default_factory=dict)
    confidence_score: float = 0.0

class SmartTypeInferenceEngine:
    """æ™ºèƒ½ç±»å‹æ¨æ–­å¼•æ“"""
    
    def __init__(self):
        self.field_stats: Dict[str, FieldStatistics] = {}
        self.inferred_types: Dict[str, Any] = {}
    
    def analyze_field(self, field_name: str, values: List[Any]) -> FieldStatistics:
        """åˆ†æå­—æ®µæ•°æ®"""
        stats = FieldStatistics(field_name=field_name)
        stats.total_count = len(values)
        stats.null_count = sum(1 for v in values if v is None or v == "")
        
        # ç±»å‹åˆ†å¸ƒ
        type_counts = Counter()
        lengths = []
        numeric_values = []
        patterns = []
        
        for value in values:
            if value is None or value == "":
                continue
            
            # ç±»å‹æ£€æµ‹
            detected_type = self._detect_type(value)
            type_counts[detected_type] += 1
            
            # é•¿åº¦ç»Ÿè®¡
            try:
                lengths.append(len(str(value)))
            except:
                pass
            
            # æ•°å€¼ç»Ÿè®¡
            if detected_type in ["integer", "float", "decimal"]:
                try:
                    numeric_values.append(float(value))
                except:
                    pass
            
            # æ¨¡å¼æ£€æµ‹
            pattern = self._extract_pattern(str(value))
            if pattern:
                patterns.append(pattern)
            
            # ä¿ç•™æ ·æœ¬
            if len(stats.sample_values) < 100:
                stats.sample_values.append(value)
        
        stats.type_distribution = dict(type_counts)
        stats.unique_count = len(set(str(v) for v in values if v is not None))
        
        # é•¿åº¦ç»Ÿè®¡
        if lengths:
            stats.length_stats = {
                "min": min(lengths),
                "max": max(lengths),
                "mean": statistics.mean(lengths),
                "median": statistics.median(lengths)
            }
        
        # æ•°å€¼ç»Ÿè®¡
        if numeric_values:
            stats.numeric_stats = {
                "min": min(numeric_values),
                "max": max(numeric_values),
                "mean": statistics.mean(numeric_values),
                "std": statistics.stdev(numeric_values) if len(numeric_values) > 1 else 0
            }
        
        # å¸¸è§æ¨¡å¼
        pattern_counts = Counter(patterns)
        stats.common_patterns = [p for p, _ in pattern_counts.most_common(5)]
        
        self.field_stats[field_name] = stats
        return stats
    
    def _detect_type(self, value: Any) -> str:
        """æ£€æµ‹å€¼çš„ç±»å‹"""
        if value is None:
            return "null"
        
        if isinstance(value, bool):
            return "boolean"
        
        if isinstance(value, int):
            return "integer"
        
        if isinstance(value, float):
            return "float"
        
        if isinstance(value, str):
            # å°è¯•è§£æä¸ºæ•°å€¼
            if re.match(r'^-?\d+$', value):
                return "integer"
            if re.match(r'^-?\d+\.\d+$', value):
                return "float"
            
            # æ—¥æœŸæ—¶é—´æ£€æµ‹
            if self._is_datetime(value):
                return "datetime"
            if self._is_date(value):
                return "date"
            
            # URLæ£€æµ‹
            if value.startswith(('http://', 'https://')):
                return "url"
            
            # é‚®ç®±æ£€æµ‹
            if '@' in value and '.' in value.split('@')[-1]:
                return "email"
            
            return "string"
        
        if isinstance(value, list):
            return "array"
        
        if isinstance(value, dict):
            return "object"
        
        return "unknown"
    
    def _is_datetime(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ—¥æœŸæ—¶é—´"""
        patterns = [
            r'^\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}',
            r'^\d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2}',
            r'^\d{2}/\d{2}/\d{4} \d{2}:\d{2}:\d{2}'
        ]
        return any(re.match(p, value) for p in patterns)
    
    def _is_date(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ—¥æœŸ"""
        patterns = [
            r'^\d{4}-\d{2}-\d{2}$',
            r'^\d{4}/\d{2}/\d{2}$',
            r'^\d{2}/\d{2}/\d{4}$'
        ]
        return any(re.match(p, value) for p in patterns)
    
    def _extract_pattern(self, value: str) -> Optional[str]:
        """æå–å€¼çš„æ¨¡å¼"""
        # æ›¿æ¢æ•°å­—ä¸º#
        pattern = re.sub(r'\d', '#', value)
        # æ›¿æ¢å­—æ¯ä¸º@
        pattern = re.sub(r'[a-zA-Z]', '@', pattern)
        return pattern[:20] if len(pattern) > 20 else pattern
    
    def infer_schema(self, field_name: str) -> Dict[str, Any]:
        """æ¨æ–­å­—æ®µSchema"""
        stats = self.field_stats.get(field_name)
        if not stats:
            return {}
        
        schema = {
            "field_name": field_name,
            "inferred_type": None,
            "nullable": stats.null_count > 0,
            "null_rate": stats.null_count / stats.total_count if stats.total_count > 0 else 0,
            "unique_ratio": stats.unique_count / stats.total_count if stats.total_count > 0 else 0,
            "constraints": {}
        }
        
        # ç¡®å®šä¸»ç±»å‹
        if stats.type_distribution:
            main_type = max(stats.type_distribution, key=stats.type_distribution.get)
            schema["inferred_type"] = main_type
            
            # æ·»åŠ ç±»å‹ç‰¹å®šçº¦æŸ
            if main_type in ["integer", "float", "decimal"] and stats.numeric_stats:
                schema["constraints"]["minimum"] = stats.numeric_stats["min"]
                schema["constraints"]["maximum"] = stats.numeric_stats["max"]
                
                # æ£€æµ‹æ˜¯å¦ä¸ºæšä¸¾
                if schema["unique_ratio"] < 0.1 and stats.unique_count < 50:
                    schema["constraints"]["enum"] = list(set(stats.sample_values))[:20]
            
            if main_type == "string" and stats.length_stats:
                schema["constraints"]["minLength"] = int(stats.length_stats["min"])
                schema["constraints"]["maxLength"] = int(stats.length_stats["max"])
                
                # æ£€æµ‹å¸¸è§æ¨¡å¼
                if stats.common_patterns and len(stats.common_patterns) <= 3:
                    # å¯èƒ½å­˜åœ¨æ ¼å¼çº¦æŸ
                    if stats.common_patterns[0].count('#') > 5:
                        schema["constraints"]["pattern"] = "numeric_heavy"
        
        # æ£€æµ‹å¼‚å¸¸å€¼
        if stats.numeric_stats and stats.numeric_stats.get("std", 0) > 0:
            mean = stats.numeric_stats["mean"]
            std = stats.numeric_stats["std"]
            outliers = []
            for value in stats.sample_values:
                try:
                    v = float(value)
                    if abs(v - mean) > 3 * std:
                        outliers.append(v)
                except:
                    pass
            if outliers:
                schema["outliers_detected"] = len(outliers)
        
        return schema
    
    def generate_validation_rules(self, field_name: str) -> List[ValidationRule]:
        """ç”ŸæˆéªŒè¯è§„åˆ™"""
        rules = []
        schema = self.infer_schema(field_name)
        
        if not schema:
            return rules
        
        # ç©ºå€¼è§„åˆ™
        if not schema.get("nullable", True):
            rules.append(ValidationRule(
                field_name=field_name,
                rule_type="required",
                condition=True,
                message=f"{field_name} is required"
            ))
        
        # ç±»å‹è§„åˆ™
        inferred_type = schema.get("inferred_type")
        if inferred_type:
            rules.append(ValidationRule(
                field_name=field_name,
                rule_type="type",
                condition=inferred_type,
                message=f"{field_name} must be of type {inferred_type}"
            ))
        
        # èŒƒå›´è§„åˆ™
        constraints = schema.get("constraints", {})
        if "minimum" in constraints and "maximum" in constraints:
            rules.append(ValidationRule(
                field_name=field_name,
                rule_type="range",
                condition=(constraints["minimum"], constraints["maximum"]),
                message=f"{field_name} must be between {constraints['minimum']} and {constraints['maximum']}"
            ))
        
        # é•¿åº¦è§„åˆ™
        if "minLength" in constraints and "maxLength" in constraints:
            rules.append(ValidationRule(
                field_name=field_name,
                rule_type="length",
                condition=(constraints["minLength"], constraints["maxLength"]),
                message=f"{field_name} length must be between {constraints['minLength']} and {constraints['maxLength']}"
            ))
        
        # æšä¸¾è§„åˆ™
        if "enum" in constraints:
            rules.append(ValidationRule(
                field_name=field_name,
                rule_type="enum",
                condition=constraints["enum"],
                message=f"{field_name} must be one of: {constraints['enum'][:5]}..."
            ))
        
        return rules

class DataValidator:
    """æ•°æ®éªŒè¯å™¨"""
    
    def __init__(self, inference_engine: SmartTypeInferenceEngine):
        self.inference_engine = inference_engine
        self.validation_rules: Dict[str, List[ValidationRule]] = {}
    
    def train(self, data_samples: List[Dict[str, Any]]):
        """è®­ç»ƒéªŒè¯å™¨"""
        # æ”¶é›†å­—æ®µæ•°æ®
        field_values: Dict[str, List[Any]] = {}
        for record in data_samples:
            for field_name, value in record.items():
                if field_name not in field_values:
                    field_values[field_name] = []
                field_values[field_name].append(value)
        
        # åˆ†ææ¯ä¸ªå­—æ®µ
        for field_name, values in field_values.items():
            self.inference_engine.analyze_field(field_name, values)
            self.validation_rules[field_name] = self.inference_engine.generate_validation_rules(field_name)
    
    def validate(self, record: Dict[str, Any]) -> ValidationResult:
        """éªŒè¯å•æ¡è®°å½•"""
        result = ValidationResult(
            is_valid=True,
            quality_level=DataQualityLevel.EXCELLENT,
            confidence_score=1.0
        )
        
        total_checks = 0
        passed_checks = 0
        
        for field_name, value in record.items():
            field_result = {"value": value, "errors": [], "warnings": []}
            
            rules = self.validation_rules.get(field_name, [])
            for rule in rules:
                total_checks += 1
                is_valid = self._check_rule(value, rule)
                
                if is_valid:
                    passed_checks += 1
                else:
                    if rule.severity == "error":
                        result.errors.append(rule.message)
                        field_result["errors"].append(rule.message)
                        result.is_valid = False
                    else:
                        result.warnings.append(rule.message)
                        field_result["warnings"].append(rule.message)
            
            result.field_results[field_name] = field_result
        
        # è®¡ç®—è´¨é‡ç­‰çº§
        if total_checks > 0:
            score = passed_checks / total_checks
            result.confidence_score = score
            
            if score >= 0.95:
                result.quality_level = DataQualityLevel.EXCELLENT
            elif score >= 0.85:
                result.quality_level = DataQualityLevel.GOOD
            elif score >= 0.70:
                result.quality_level = DataQualityLevel.FAIR
            elif score >= 0.50:
                result.quality_level = DataQualityLevel.POOR
            else:
                result.quality_level = DataQualityLevel.INVALID
        
        return result
    
    def _check_rule(self, value: Any, rule: ValidationRule) -> bool:
        """æ£€æŸ¥è§„åˆ™"""
        if rule.rule_type == "required":
            return value is not None and value != ""
        
        if rule.rule_type == "type":
            expected_type = rule.condition
            actual_type = self.inference_engine._detect_type(value)
            return actual_type == expected_type
        
        if rule.rule_type == "range":
            min_val, max_val = rule.condition
            try:
                num_value = float(value)
                return min_val <= num_value <= max_val
            except:
                return False
        
        if rule.rule_type == "length":
            min_len, max_len = rule.condition
            try:
                length = len(str(value))
                return min_len <= length <= max_len
            except:
                return False
        
        if rule.rule_type == "enum":
            allowed = rule.condition
            return str(value) in [str(a) for a in allowed]
        
        return True
    
    def batch_validate(self, records: List[Dict[str, Any]]) -> List[ValidationResult]:
        """æ‰¹é‡éªŒè¯"""
        return [self.validate(record) for record in records]
    
    def get_quality_report(self) -> Dict[str, Any]:
        """è·å–è´¨é‡æŠ¥å‘Š"""
        return {
            "fields_analyzed": len(self.inference_engine.field_stats),
            "field_schemas": {
                name: self.inference_engine.infer_schema(name)
                for name in self.inference_engine.field_stats.keys()
            },
            "validation_rules_count": sum(len(rules) for rules in self.validation_rules.values())
        }

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    # åˆ›å»ºæ¨æ–­å¼•æ“å’ŒéªŒè¯å™¨
    inference_engine = SmartTypeInferenceEngine()
    validator = DataValidator(inference_engine)
    
    # ç¤ºä¾‹å•†å“æ•°æ®
    product_samples = [
        {"sku": "SKU001", "name": "iPhone 15", "price": "999.00", "stock": 100, "category": "Electronics"},
        {"sku": "SKU002", "name": "MacBook Pro", "price": "1999.00", "stock": 50, "category": "Electronics"},
        {"sku": "SKU003", "name": "AirPods", "price": "199.00", "stock": 200, "category": "Electronics"},
        {"sku": "SKU004", "name": "", "price": "invalid", "stock": -5, "category": "Unknown"},  # é—®é¢˜æ•°æ®
    ]
    
    print("=== è®­ç»ƒéªŒè¯å™¨ ===")
    validator.train(product_samples)
    
    # æŸ¥çœ‹æ¨æ–­çš„Schema
    print("\n=== æ¨æ–­çš„Schema ===")
    for field_name in inference_engine.field_stats.keys():
        schema = inference_engine.infer_schema(field_name)
        print(f"\n{field_name}:")
        print(f"  æ¨æ–­ç±»å‹: {schema.get('inferred_type')}")
        print(f"  å¯ç©º: {schema.get('nullable')}")
        print(f"  çº¦æŸ: {schema.get('constraints', {})}")
    
    # éªŒè¯æ•°æ®
    print("\n=== æ•°æ®éªŒè¯ ===")
    test_records = [
        {"sku": "SKU005", "name": "iPad", "price": "599.00", "stock": 80, "category": "Electronics"},
        {"sku": "", "name": "Test", "price": "abc", "stock": -10, "category": "Unknown"},
    ]
    
    for record in test_records:
        result = validator.validate(record)
        print(f"\nè®°å½•: {record.get('sku', 'N/A')}")
        print(f"  æœ‰æ•ˆ: {result.is_valid}")
        print(f"  è´¨é‡ç­‰çº§: {result.quality_level.value}")
        print(f"  ç½®ä¿¡åº¦: {result.confidence_score:.2f}")
        if result.errors:
            print(f"  é”™è¯¯: {result.errors}")
        if result.warnings:
            print(f"  è­¦å‘Š: {result.warnings}")
```

### 3.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| æ•°æ®é”™è¯¯ç‡ | 15% | 2% | 87%é™ä½ |
| ç±»å‹æ¨æ–­å‡†ç¡®ç‡ | æ—  | 94% | æ–°å¢èƒ½åŠ› |
| å¼‚å¸¸è¯†åˆ«ç‡ | 60% | 92% | 53%æå‡ |
| æ•°æ®æ¸…æ´—è‡ªåŠ¨åŒ– | 20% | 82% | 310%æå‡ |
| éªŒè¯å»¶è¿Ÿ | 100ms | 5ms | 95%é™ä½ |
| äººå·¥å®¡æ ¸å·¥ä½œé‡ | 100% | 30% | 70%å‡å°‘ |

**ä¸šåŠ¡ä»·å€¼ï¼ˆROIåˆ†æï¼‰**ï¼š

1. **æ•°æ®è´¨é‡æå‡**ï¼š
   - æ•°æ®é”™è¯¯å‡å°‘87%
   - æœç´¢å’Œæ¨èæ•ˆæœæå‡ä»·å€¼ï¼šçº¦400ä¸‡å…ƒ/å¹´

2. **äººå·¥æˆæœ¬èŠ‚çº¦**ï¼š
   - æ•°æ®å®¡æ ¸å·¥ä½œé‡å‡å°‘70%
   - å¹´åº¦äººåŠ›æˆæœ¬èŠ‚çº¦ï¼šçº¦350ä¸‡å…ƒ

3. **ä¸šåŠ¡æ•ˆç‡**ï¼š
   - å•†å“ä¸Šæ¶é€Ÿåº¦æå‡
   - ä¸šåŠ¡æ•ˆç‡æå‡ä»·å€¼ï¼šçº¦250ä¸‡å…ƒ/å¹´

4. **æŠ•èµ„å›æŠ¥ç‡**ï¼š
   - ç³»ç»Ÿå¼€å‘æŠ•å…¥ï¼šçº¦80ä¸‡å…ƒ
   - å¹´åº¦æ€»æ”¶ç›Šï¼šçº¦1000ä¸‡å…ƒ
   - **ROI = 1150%**

---

## 4. æ¡ˆä¾‹3ï¼šåˆ¶é€ ä¼ä¸šæ³›å‹ç±»å‹è½¬æ¢ç³»ç»Ÿ

### 4.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå¤§å‹åˆ¶é€ ä¼ä¸šï¼ˆæ‹¥æœ‰100+å·¥å‚ï¼Œ5000+ç§äº§å“å‹å·ï¼‰çš„äº§å“æ•°æ®ç®¡ç†ç³»ç»Ÿéœ€è¦å¤„ç†å¤æ‚çš„BOMï¼ˆç‰©æ–™æ¸…å•ï¼‰ç»“æ„ã€‚äº§å“é…ç½®å­˜åœ¨å¤šå±‚åµŒå¥—ã€å¯é€‰ç»„ä»¶ã€å˜ä½“ç»„åˆç­‰å¤æ‚åœºæ™¯ï¼Œä¼ ç»Ÿçš„å›ºå®šç±»å‹ç³»ç»Ÿéš¾ä»¥è¡¨è¾¾è¿™äº›å¤æ‚å…³ç³»ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **BOMç»“æ„å¤æ‚**ï¼šäº§å“BOMå­˜åœ¨å¤šå±‚çº§åµŒå¥—ï¼Œå›ºå®šç±»å‹æ— æ³•è¡¨è¾¾çµæ´»çš„ç»„ä»¶å…³ç³»
2. **å˜ä½“ç®¡ç†å›°éš¾**ï¼šäº§å“å˜ä½“ç»„åˆå¯¼è‡´ç±»å‹çˆ†ç‚¸ï¼Œéš¾ä»¥ç»´æŠ¤
3. **ç±»å‹è½¬æ¢è„†å¼±**ï¼šæ³›å‹åˆ°å…·ä½“ç±»å‹çš„è½¬æ¢ç¼ºä¹ç±»å‹å®‰å…¨ï¼Œå®¹æ˜“å‡ºé”™
4. **é…ç½®éªŒè¯ä¸è¶³**ï¼šå¤æ‚çš„äº§å“é…ç½®ç¼ºä¹ç±»å‹çº§åˆ«çš„éªŒè¯
5. **ä»£ç å¤ç”¨æ€§å·®**ï¼šç›¸ä¼¼ç»“æ„çš„ç±»å‹å®šä¹‰é‡å¤ï¼Œç»´æŠ¤æˆæœ¬é«˜

**ä¸šåŠ¡ç›®æ ‡**ï¼š

1. **æ³›å‹ç±»å‹æ”¯æŒ**ï¼šå®ç°å®Œæ•´çš„æ³›å‹ç±»å‹ç³»ç»Ÿï¼Œæ”¯æŒå¤æ‚BOMè¡¨è¾¾
2. **ç±»å‹å®‰å…¨è½¬æ¢**ï¼šç¡®ä¿æ³›å‹åˆ°å…·ä½“ç±»å‹çš„è½¬æ¢100%ç±»å‹å®‰å…¨
3. **é…ç½®éªŒè¯å¼ºåŒ–**ï¼šåœ¨ç±»å‹å±‚é¢éªŒè¯äº§å“é…ç½®çš„åˆæ³•æ€§
4. **ä»£ç å¤ç”¨æå‡**ï¼šé€šè¿‡æ³›å‹å®ç°ç±»å‹å®šä¹‰çš„å¤ç”¨ï¼Œä»£ç é‡å¤å‡å°‘80%
5. **ç¼–è¯‘æ—¶æ£€æŸ¥**ï¼šå°†é…ç½®é”™è¯¯å‘ç°æå‰åˆ°ç¼–è¯‘æ—¶

### 4.2 æŠ€æœ¯æŒ‘æˆ˜

1. **é«˜é˜¶ç±»å‹**ï¼šå¤„ç†ç±»å‹æ„é€ å‡½æ•°å’Œç±»å‹å‚æ•°çš„é«˜é˜¶ç±»å‹
2. **ç±»å‹çº¦æŸ**ï¼šè¡¨è¾¾å¤æ‚çš„ç±»å‹çº¦æŸï¼ˆä¸Šç•Œã€ä¸‹ç•Œã€ç±»å‹ç›¸ç­‰ï¼‰
3. **ç±»å‹æ“¦é™¤**ï¼šå¤„ç†è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯ä¸¢å¤±çš„é—®é¢˜
4. **åå˜é€†å˜**ï¼šæ­£ç¡®å¤„ç†æ³›å‹çš„åå˜å’Œé€†å˜å…³ç³»
5. **ç±»å‹æ¨æ–­**ï¼šè‡ªåŠ¨æ¨æ–­å¤æ‚æ³›å‹è¡¨è¾¾å¼çš„ç±»å‹

### 4.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨é«˜çº§ç±»å‹ç³»ç»Ÿå’Œä¾èµ–ç±»å‹ï¼Œæ„å»ºæ³›å‹ç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ**ï¼š

é‡‡ç”¨åˆ†å±‚æ¶æ„ï¼š
- **ç±»å‹å®šä¹‰å±‚**ï¼šå®šä¹‰æ³›å‹ç±»å‹å’Œç±»å‹çº¦æŸ
- **ç±»å‹æ¨æ–­å±‚**ï¼šè‡ªåŠ¨æ¨æ–­æ³›å‹è¡¨è¾¾å¼çš„ç±»å‹
- **çº¦æŸæ±‚è§£å±‚**ï¼šæ±‚è§£ç±»å‹çº¦æŸç³»ç»Ÿ
- **ä»£ç ç”Ÿæˆå±‚**ï¼šç”Ÿæˆç±»å‹å®‰å…¨çš„å…·ä½“å®ç°
- **éªŒè¯å±‚**ï¼šéªŒè¯ç±»å‹è½¬æ¢çš„æ­£ç¡®æ€§

### 4.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
æ³›å‹ç±»å‹è½¬æ¢ç³»ç»Ÿ
æ”¯æŒé«˜é˜¶ç±»å‹ã€ç±»å‹çº¦æŸã€åå˜é€†å˜
"""

from typing import Dict, List, Optional, Any, TypeVar, Generic, Callable, Union, Type
from dataclasses import dataclass, field
from abc import ABC, abstractmethod
from enum import Enum
import json

# æ³›å‹ç±»å‹å˜é‡å®šä¹‰
T = TypeVar('T')
U = TypeVar('U')
K = TypeVar('K')
V = TypeVar('V')

# åå˜/é€†å˜æ ‡è®°
class Covariant(Generic[T]):
    """åå˜æ ‡è®°"""
    pass

class Contravariant(Generic[T]):
    """é€†å˜æ ‡è®°"""
    pass

class Invariant(Generic[T]):
    """ä¸å˜æ ‡è®°"""
    pass

# ç±»å‹çº¦æŸåŸºç±»
class TypeConstraint(ABC):
    """ç±»å‹çº¦æŸæŠ½è±¡åŸºç±»"""
    
    @abstractmethod
    def check(self, value: Any) -> bool:
        pass
    
    @abstractmethod
    def get_error_message(self) -> str:
        pass

class NumericConstraint(TypeConstraint):
    """æ•°å€¼çº¦æŸ"""
    
    def __init__(self, min_val: Optional[float] = None, max_val: Optional[float] = None):
        self.min_val = min_val
        self.max_val = max_val
    
    def check(self, value: Any) -> bool:
        if not isinstance(value, (int, float)):
            return False
        if self.min_val is not None and value < self.min_val:
            return False
        if self.max_val is not None and value > self.max_val:
            return False
        return True
    
    def get_error_message(self) -> str:
        return f"Value must be numeric"

class StringConstraint(TypeConstraint):
    """å­—ç¬¦ä¸²çº¦æŸ"""
    
    def __init__(self, min_len: int = 0, max_len: int = 1000, pattern: str = None):
        self.min_len = min_len
        self.max_len = max_len
        self.pattern = pattern
    
    def check(self, value: Any) -> bool:
        if not isinstance(value, str):
            return False
        if len(value) < self.min_len or len(value) > self.max_len:
            return False
        return True
    
    def get_error_message(self) -> str:
        return f"String length must be between {self.min_len} and {self.max_len}"

# æ³›å‹ç»„ä»¶åŸºç±»
@dataclass
class Component(Generic[T]):
    """æ³›å‹ç»„ä»¶"""
    component_id: str
    name: str
    component_type: Type[T]
    quantity: int = 1
    optional: bool = False
    alternatives: List['Component[T]'] = field(default_factory=list)
    constraints: List[TypeConstraint] = field(default_factory=list)
    
    def validate(self, value: T) -> List[str]:
        """éªŒè¯ç»„ä»¶å€¼"""
        errors = []
        
        if value is None and not self.optional:
            errors.append(f"Component {self.name} is required")
            return errors
        
        if value is not None:
            # ç±»å‹æ£€æŸ¥
            if not isinstance(value, self.component_type):
                errors.append(f"Component {self.name} expects type {self.component_type.__name__}")
            
            # çº¦æŸæ£€æŸ¥
            for constraint in self.constraints:
                if not constraint.check(value):
                    errors.append(f"Component {self.name}: {constraint.get_error_message()}")
        
        return errors

# æ³›å‹BOMç»“æ„
@dataclass
class BOM(Generic[T]):
    """æ³›å‹ç‰©æ–™æ¸…å•"""
    product_id: str
    product_name: str
    root_component: Component[T]
    sub_components: List[Component[Any]] = field(default_factory=list)
    
    def validate_structure(self) -> List[str]:
        """éªŒè¯BOMç»“æ„"""
        errors = []
        
        # æ£€æŸ¥å¾ªç¯ä¾èµ–
        visited = set()
        def check_cycle(comp: Component, path: List[str]):
            if comp.component_id in visited:
                errors.append(f"Circular dependency detected: {' -> '.join(path)}")
                return
            visited.add(comp.component_id)
            for alt in comp.alternatives:
                check_cycle(alt, path + [comp.component_id])
            visited.discard(comp.component_id)
        
        check_cycle(self.root_component, [])
        
        return errors
    
    def calculate_cost(self, cost_fn: Callable[[Component], float]) -> float:
        """è®¡ç®—æˆæœ¬"""
        total = cost_fn(self.root_component)
        for comp in self.sub_components:
            total += cost_fn(comp)
        return total
    
    def flatten(self) -> List[Component]:
        """å±•å¹³BOMç»“æ„"""
        result = [self.root_component]
        result.extend(self.sub_components)
        return result

# æ³›å‹ç±»å‹è½¬æ¢å™¨
class GenericTypeConverter:
    """æ³›å‹ç±»å‹è½¬æ¢å™¨"""
    
    def __init__(self):
        self.type_mappings: Dict[Type, Type] = {}
        self.conversion_handlers: Dict[tuple, Callable] = {}
    
    def register_mapping(self, source_type: Type[T], target_type: Type[U],
                        handler: Callable[[T], U]):
        """æ³¨å†Œç±»å‹æ˜ å°„"""
        self.type_mappings[source_type] = target_type
        self.conversion_handlers[(source_type, target_type)] = handler
    
    def convert(self, value: T, target_type: Type[U]) -> U:
        """æ‰§è¡Œç±»å‹è½¬æ¢"""
        source_type = type(value)
        
        # æ£€æŸ¥æ˜¯å¦å·²æœ‰æ˜ å°„
        handler = self.conversion_handlers.get((source_type, target_type))
        if handler:
            return handler(value)
        
        # å°è¯•è‡ªåŠ¨è½¬æ¢
        if target_type == dict and isinstance(value, (list, tuple)):
            return dict(enumerate(value))
        
        if target_type == list and isinstance(value, dict):
            return list(value.items())
        
        # å°è¯•æ„é€ ç›®æ ‡ç±»å‹
        try:
            if hasattr(target_type, '__dataclass_fields__'):
                # DataClassæ„é€ 
                if isinstance(value, dict):
                    return target_type(**value)
            
            # åŸºæœ¬ç±»å‹è½¬æ¢
            return target_type(value)
        except Exception as e:
            raise TypeError(f"Cannot convert {source_type} to {target_type}: {e}")
    
    def convert_collection(self, collection: List[T], 
                          target_type: Type[U]) -> List[U]:
        """è½¬æ¢é›†åˆ"""
        return [self.convert(item, target_type) for item in collection]

# äº§å“é…ç½®éªŒè¯å™¨
class ProductConfigurationValidator:
    """äº§å“é…ç½®éªŒè¯å™¨"""
    
    def __init__(self):
        self.rules: List[Callable[[Dict], List[str]]] = []
    
    def add_rule(self, rule: Callable[[Dict], List[str]]):
        """æ·»åŠ éªŒè¯è§„åˆ™"""
        self.rules.append(rule)
    
    def validate(self, configuration: Dict[str, Any]) -> Dict[str, Any]:
        """éªŒè¯é…ç½®"""
        all_errors = []
        all_warnings = []
        
        for rule in self.rules:
            try:
                errors = rule(configuration)
                all_errors.extend(errors)
            except Exception as e:
                all_warnings.append(f"Rule execution failed: {e}")
        
        return {
            "is_valid": len(all_errors) == 0,
            "errors": all_errors,
            "warnings": all_warnings,
            "configuration": configuration
        }

# å…·ä½“åº”ç”¨ï¼šåˆ¶é€ ä¸šäº§å“BOM
@dataclass
class Material:
    """åŸææ–™"""
    material_code: str
    name: str
    unit_price: float
    unit: str
    supplier: str

@dataclass
class Part:
    """é›¶éƒ¨ä»¶"""
    part_number: str
    name: str
    material: Material
    quantity: float
    manufacturing_cost: float

@dataclass
class Assembly:
    """è£…é…ä½“"""
    assembly_id: str
    name: str
    parts: List[Part]
    labor_hours: float

class ProductBOMBuilder:
    """äº§å“BOMæ„å»ºå™¨"""
    
    def __init__(self):
        self.materials: Dict[str, Material] = {}
        self.parts: Dict[str, Part] = {}
        self.assemblies: Dict[str, Assembly] = {}
    
    def add_material(self, material: Material):
        """æ·»åŠ ææ–™"""
        self.materials[material.material_code] = material
    
    def add_part(self, part: Part):
        """æ·»åŠ é›¶ä»¶"""
        self.parts[part.part_number] = part
    
    def add_assembly(self, assembly: Assembly):
        """æ·»åŠ è£…é…ä½“"""
        self.assemblies[assembly.assembly_id] = assembly
    
    def build_bom(self, product_id: str, root_assembly_id: str) -> BOM[Assembly]:
        """æ„å»ºBOM"""
        root_assembly = self.assemblies.get(root_assembly_id)
        if not root_assembly:
            raise ValueError(f"Assembly {root_assembly_id} not found")
        
        root_component = Component(
            component_id=root_assembly.assembly_id,
            name=root_assembly.name,
            component_type=Assembly,
            quantity=1
        )
        
        sub_components: List[Component] = []
        
        # ä¸ºæ¯ä¸ªé›¶ä»¶åˆ›å»ºç»„ä»¶
        for part in root_assembly.parts:
            part_component = Component(
                component_id=part.part_number,
                name=part.name,
                component_type=Part,
                quantity=int(part.quantity),
                constraints=[NumericConstraint(min_val=0)]
            )
            sub_components.append(part_component)
        
        return BOM(
            product_id=product_id,
            product_name=root_assembly.name,
            root_component=root_component,
            sub_components=sub_components
        )
    
    def calculate_total_cost(self, bom: BOM[Assembly]) -> Dict[str, float]:
        """è®¡ç®—æ€»æˆæœ¬"""
        material_cost = 0.0
        manufacturing_cost = 0.0
        labor_cost = 0.0
        
        root_assembly = self.assemblies.get(bom.root_component.component_id)
        if root_assembly:
            labor_cost = root_assembly.labor_hours * 50  # å‡è®¾äººå·¥è´¹ç‡50/å°æ—¶
            
            for part in root_assembly.parts:
                material_cost += part.material.unit_price * part.quantity
                manufacturing_cost += part.manufacturing_cost * part.quantity
        
        return {
            "material_cost": material_cost,
            "manufacturing_cost": manufacturing_cost,
            "labor_cost": labor_cost,
            "total_cost": material_cost + manufacturing_cost + labor_cost
        }

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    # åˆ›å»ºBOMæ„å»ºå™¨
    builder = ProductBOMBuilder()
    
    # å®šä¹‰ææ–™
    steel = Material("M001", "Steel Plate", 2.5, "kg", "Steel Corp")
    aluminum = Material("M002", "Aluminum Sheet", 4.0, "kg", "Alu Inc")
    
    builder.add_material(steel)
    builder.add_material(aluminum)
    
    # å®šä¹‰é›¶ä»¶
    frame = Part("P001", "Main Frame", steel, 10.0, 15.0)
    panel = Part("P002", "Side Panel", aluminum, 5.0, 8.0)
    
    builder.add_part(frame)
    builder.add_part(panel)
    
    # å®šä¹‰è£…é…ä½“
    chassis = Assembly("A001", "Chassis Assembly", [frame, panel], 2.0)
    builder.add_assembly(chassis)
    
    # æ„å»ºBOM
    bom = builder.build_bom("PROD001", "A001")
    print("=== äº§å“BOMç»“æ„ ===")
    print(f"äº§å“: {bom.product_name}")
    print(f"æ ¹ç»„ä»¶: {bom.root_component.name}")
    print(f"å­ç»„ä»¶æ•°é‡: {len(bom.sub_components)}")
    
    # éªŒè¯BOM
    errors = bom.validate_structure()
    if errors:
        print(f"éªŒè¯é”™è¯¯: {errors}")
    else:
        print("BOMç»“æ„éªŒè¯é€šè¿‡")
    
    # è®¡ç®—æˆæœ¬
    costs = builder.calculate_total_cost(bom)
    print("\n=== æˆæœ¬åˆ†æ ===")
    for cost_type, amount in costs.items():
        print(f"{cost_type}: ${amount:.2f}")
    
    # ç±»å‹è½¬æ¢ç¤ºä¾‹
    print("\n=== æ³›å‹ç±»å‹è½¬æ¢ ===")
    converter = GenericTypeConverter()
    
    # æ³¨å†Œè‡ªå®šä¹‰è½¬æ¢
    converter.register_mapping(
        Part, dict,
        lambda p: {
            "part_number": p.part_number,
            "name": p.name,
            "material_cost": p.material.unit_price * p.quantity
        }
    )
    
    # æ‰§è¡Œè½¬æ¢
    part_dict = converter.convert(frame, dict)
    print(f"é›¶ä»¶è½¬å­—å…¸: {part_dict}")
```

### 4.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| ç±»å‹å®‰å…¨è¦†ç›–ç‡ | 50% | 98% | 96%æå‡ |
| BOMé…ç½®é”™è¯¯ | 200+/æœˆ | 10/æœˆ | 95%å‡å°‘ |
| ä»£ç é‡å¤ç‡ | 40% | 10% | 75%é™ä½ |
| ç±»å‹è½¬æ¢é”™è¯¯ | 100+/æœˆ | 2/æœˆ | 98%å‡å°‘ |
| ç¼–è¯‘æ—¶é”™è¯¯å‘ç° | 40% | 95% | 138%æå‡ |
| é…ç½®éªŒè¯æ—¶é—´ | 30åˆ†é’Ÿ | 5ç§’ | 99.7%ç¼©çŸ­ |

**ä¸šåŠ¡ä»·å€¼ï¼ˆROIåˆ†æï¼‰**ï¼š

1. **è´¨é‡æå‡**ï¼š
   - BOMé…ç½®é”™è¯¯å‡å°‘95%
   - ç”Ÿäº§äº‹æ•…å‡å°‘ï¼Œè´¨é‡æŸå¤±é™ä½ï¼šçº¦400ä¸‡å…ƒ/å¹´

2. **å¼€å‘æ•ˆç‡**ï¼š
   - ä»£ç å¤ç”¨ç‡æå‡ï¼Œå¼€å‘æ•ˆç‡æå‡
   - å¹´åº¦å¼€å‘æˆæœ¬èŠ‚çº¦ï¼šçº¦300ä¸‡å…ƒ

3. **è¿ç»´ä¼˜åŒ–**ï¼š
   - é…ç½®éªŒè¯è‡ªåŠ¨åŒ–
   - è¿ç»´æˆæœ¬èŠ‚çº¦ï¼šçº¦150ä¸‡å…ƒ/å¹´

4. **æŠ•èµ„å›æŠ¥ç‡**ï¼š
   - ç³»ç»Ÿå¼€å‘æŠ•å…¥ï¼šçº¦100ä¸‡å…ƒ
   - å¹´åº¦æ€»æ”¶ç›Šï¼šçº¦850ä¸‡å…ƒ
   - **ROI = 750%**

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - ç±»å‹ç³»ç»Ÿåˆ†æ
- `03_Standards.md` - æ§åˆ¶é€»è¾‘åˆ†æ
- `04_Transformation.md` - Schemaè½¬æ¢åº”ç”¨

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15

# ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿå®è·µæ¡ˆä¾‹](#ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šä¼ä¸šç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ](#2-æ¡ˆä¾‹1ä¼ä¸šç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 æŠ€æœ¯æŒ‘æˆ˜](#22-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.3 è§£å†³æ–¹æ¡ˆ](#23-è§£å†³æ–¹æ¡ˆ)
    - [2.4 å®Œæ•´ä»£ç å®ç°](#24-å®Œæ•´ä»£ç å®ç°)
    - [2.5 æ•ˆæœè¯„ä¼°](#25-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šç±»å‹æ¨æ–­ä¸éªŒè¯](#3-æ¡ˆä¾‹2ç±»å‹æ¨æ–­ä¸éªŒè¯)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 å®ç°ä»£ç ](#32-å®ç°ä»£ç )
  - [4. æ¡ˆä¾‹3ï¼šæ³›å‹ç±»å‹è½¬æ¢](#4-æ¡ˆä¾‹3æ³›å‹ç±»å‹è½¬æ¢)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 å®ç°ä»£ç ](#42-å®ç°ä»£ç )
  - [5. æ¡ˆä¾‹4ï¼šç±»å‹çº¦æŸéªŒè¯](#5-æ¡ˆä¾‹4ç±»å‹çº¦æŸéªŒè¯)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 å®ç°ä»£ç ](#52-å®ç°ä»£ç )
  - [6. æ¡ˆä¾‹5ï¼šç±»å‹å®‰å…¨çš„Schemaæ˜ å°„](#6-æ¡ˆä¾‹5ç±»å‹å®‰å…¨çš„schemaæ˜ å°„)
    - [6.1 åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2 å®ç°ä»£ç ](#62-å®ç°ä»£ç )

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»Ÿåœ¨Schemaè½¬æ¢ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ç±»å‹å®‰å…¨è½¬æ¢ã€ç±»å‹æ¨æ–­ä¸éªŒè¯ã€æ³›å‹ç±»å‹è½¬æ¢ç­‰çœŸå®åœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **ç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ**ï¼šç±»å‹å®‰å…¨çš„Schemaè½¬æ¢
2. **ç±»å‹æ¨æ–­ä¸éªŒè¯ç³»ç»Ÿ**ï¼šç±»å‹æ¨æ–­å’ŒéªŒè¯
3. **æ³›å‹ç±»å‹è½¬æ¢ç³»ç»Ÿ**ï¼šæ³›å‹ç±»å‹è½¬æ¢
4. **ç±»å‹çº¦æŸéªŒè¯ç³»ç»Ÿ**ï¼šç±»å‹çº¦æŸéªŒè¯
5. **ç±»å‹å®‰å…¨çš„Schemaæ˜ å°„ç³»ç»Ÿ**ï¼šç±»å‹å®‰å…¨çš„Schemaæ˜ å°„

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **TypeScriptç±»å‹ç³»ç»Ÿ**ï¼šTypeScriptå®˜æ–¹æ–‡æ¡£
- **Haskellç±»å‹ç³»ç»Ÿ**ï¼šHaskellç±»å‹ç³»ç»Ÿæœ€ä½³å®è·µ

---

## 2. æ¡ˆä¾‹1ï¼šä¼ä¸šç±»å‹å®‰å…¨è½¬æ¢ç³»ç»Ÿ

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸä¼ä¸šéœ€è¦æ„å»ºç±»å‹å®‰å…¨çš„Schemaè½¬æ¢ç³»ç»Ÿï¼Œé˜²æ­¢ç±»å‹é”™è¯¯ï¼Œç¡®ä¿è½¬æ¢çš„æ­£ç¡®æ€§å’Œå®‰å…¨æ€§ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **ç±»å‹é”™è¯¯é¢‘å‘**ï¼šSchemaè½¬æ¢ä¸­ç±»å‹é”™è¯¯é¢‘å‘
2. **è¿è¡Œæ—¶é”™è¯¯**ï¼šç±»å‹é”™è¯¯åœ¨è¿è¡Œæ—¶æ‰å‘ç°
3. **è½¬æ¢ä¸å®‰å…¨**ï¼šè½¬æ¢è¿‡ç¨‹ç¼ºä¹ç±»å‹æ£€æŸ¥
4. **ç»´æŠ¤å›°éš¾**ï¼šç±»å‹é”™è¯¯éš¾ä»¥å®šä½å’Œä¿®å¤

**ä¸šåŠ¡ç›®æ ‡**ï¼š

- é˜²æ­¢ç±»å‹é”™è¯¯
- æå‰å‘ç°ç±»å‹é—®é¢˜
- ç¡®ä¿è½¬æ¢å®‰å…¨æ€§
- æé«˜ä»£ç å¯ç»´æŠ¤æ€§

### 2.2 æŠ€æœ¯æŒ‘æˆ˜

1. **ç±»å‹æ£€æŸ¥**ï¼šå®ç°ç±»å‹æ£€æŸ¥æœºåˆ¶
2. **ç±»å‹è½¬æ¢**ï¼šå®ç°ç±»å‹å®‰å…¨è½¬æ¢
3. **ç±»å‹éªŒè¯**ï¼šéªŒè¯è½¬æ¢ç»“æœç±»å‹
4. **é”™è¯¯å¤„ç†**ï¼šå¤„ç†ç±»å‹é”™è¯¯

### 2.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨ç±»å‹ç³»ç»Ÿè¿›è¡Œç±»å‹æ£€æŸ¥å’Œè½¬æ¢**ï¼š

### 2.4 å®Œæ•´ä»£ç å®ç°

**ç±»å‹å®‰å…¨è½¬æ¢å™¨ï¼ˆå®Œæ•´ç¤ºä¾‹ï¼‰**ï¼š

```python
#!/usr/bin/env python3
"""
ç¼–ç¨‹è¯­è¨€ç±»å‹ç³»ç»ŸSchemaå®ç°
"""

from typing import TypeVar, Generic, Type, Any, Dict, List, Optional
from abc import ABC, abstractmethod
from dataclasses import dataclass

T = TypeVar('T')
U = TypeVar('U')

class TypeSafeConverter(Generic[T, U], ABC):
    """ç±»å‹å®‰å…¨è½¬æ¢å™¨"""

    def __init__(self, source_type: Type[T], target_type: Type[U]):
        self.source_type = source_type
        self.target_type = target_type

    def convert(self, source: T) -> U:
        """ç±»å‹å®‰å…¨è½¬æ¢"""
        # ç±»å‹æ£€æŸ¥
        if not isinstance(source, self.source_type):
            raise TypeError(
                f"Expected {self.source_type.__name__}, "
                f"got {type(source).__name__}"
            )

        # ç±»å‹è½¬æ¢
        try:
            result = self._convert_impl(source)
        except Exception as e:
            raise RuntimeError(f"Conversion failed: {e}") from e

        # ç±»å‹éªŒè¯
        if not isinstance(result, self.target_type):
            raise TypeError(
                f"Conversion result type mismatch: "
                f"expected {self.target_type.__name__}, "
                f"got {type(result).__name__}"
            )

        return result

    @abstractmethod
    def _convert_impl(self, source: T) -> U:
        """è½¬æ¢å®ç°ï¼ˆå­ç±»å¿…é¡»å®ç°ï¼‰"""
        pass

# å…·ä½“å®ç°ç¤ºä¾‹ï¼šå­—ç¬¦ä¸²åˆ°æ•´æ•°è½¬æ¢å™¨
class StringToIntConverter(TypeSafeConverter[str, int]):
    """å­—ç¬¦ä¸²åˆ°æ•´æ•°è½¬æ¢å™¨"""

    def __init__(self):
        super().__init__(str, int)

    def _convert_impl(self, source: str) -> int:
        """è½¬æ¢å®ç°"""
        try:
            return int(source)
        except ValueError as e:
            raise ValueError(f"Cannot convert '{source}' to int: {e}") from e

# å…·ä½“å®ç°ç¤ºä¾‹ï¼šå­—å…¸åˆ°å¯¹è±¡è½¬æ¢å™¨
@dataclass
class User:
    """ç”¨æˆ·å¯¹è±¡"""
    id: int
    name: str
    email: str

class DictToUserConverter(TypeSafeConverter[Dict[str, Any], User]):
    """å­—å…¸åˆ°ç”¨æˆ·å¯¹è±¡è½¬æ¢å™¨"""

    def __init__(self):
        super().__init__(dict, User)

    def _convert_impl(self, source: Dict[str, Any]) -> User:
        """è½¬æ¢å®ç°"""
        required_fields = ['id', 'name', 'email']
        missing_fields = [f for f in required_fields if f not in source]

        if missing_fields:
            raise ValueError(f"Missing required fields: {missing_fields}")

        return User(
            id=int(source['id']),
            name=str(source['name']),
            email=str(source['email'])
        )

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    # å­—ç¬¦ä¸²åˆ°æ•´æ•°è½¬æ¢
    str_to_int = StringToIntConverter()
    result = str_to_int.convert("123")
    print(f"å­—ç¬¦ä¸²'123'è½¬æ¢ä¸ºæ•´æ•°: {result}")

    # å­—å…¸åˆ°ç”¨æˆ·å¯¹è±¡è½¬æ¢
    dict_to_user = DictToUserConverter()
    user_dict = {
        'id': 1,
        'name': 'å¼ ä¸‰',
        'email': 'zhangsan@example.com'
    }
    user = dict_to_user.convert(user_dict)
    print(f"å­—å…¸è½¬æ¢ä¸ºç”¨æˆ·å¯¹è±¡: {user}")
```

### 2.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| ç±»å‹é”™è¯¯å‘ç°æ—¶é—´ | è¿è¡Œæ—¶ | ç¼–è¯‘æ—¶/è½¬æ¢æ—¶ | æ˜¾è‘—æå‰ |
| ç±»å‹é”™è¯¯ç‡ | 15% | 2% | 87%é™ä½ |
| è½¬æ¢å®‰å…¨æ€§ | ä½ | é«˜ | æ˜¾è‘—æå‡ |
| ä»£ç å¯ç»´æŠ¤æ€§ | ä½ | é«˜ | æ˜¾è‘—æå‡ |

**ä¸šåŠ¡ä»·å€¼**ï¼š

1. **é”™è¯¯é¢„é˜²**ï¼šé˜²æ­¢ç±»å‹é”™è¯¯å‘ç”Ÿ
2. **æå‰å‘ç°**ï¼šæå‰å‘ç°ç±»å‹é—®é¢˜
3. **å®‰å…¨æ€§æå‡**ï¼šç¡®ä¿è½¬æ¢å®‰å…¨æ€§
4. **å¯ç»´æŠ¤æ€§æé«˜**ï¼šæé«˜ä»£ç å¯ç»´æŠ¤æ€§

**ç»éªŒæ•™è®­**ï¼š

1. ç±»å‹æ£€æŸ¥å¾ˆé‡è¦
2. ç±»å‹è½¬æ¢éœ€è¦å®‰å…¨
3. ç±»å‹éªŒè¯éœ€è¦å®Œæ•´
4. é”™è¯¯å¤„ç†éœ€è¦å®Œå–„

**å‚è€ƒæ¡ˆä¾‹**ï¼š

- [TypeScriptç±»å‹ç³»ç»Ÿ](https://www.typescriptlang.org/)
- [Haskellç±»å‹ç³»ç»Ÿ](https://www.haskell.org/)

---

## 3. æ¡ˆä¾‹2ï¼šç±»å‹æ¨æ–­ä¸éªŒè¯

### 3.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨Schemaè½¬æ¢è¿‡ç¨‹ä¸­ï¼Œéœ€è¦è‡ªåŠ¨æ¨æ–­æ•°æ®ç±»å‹å¹¶è¿›è¡ŒéªŒè¯ï¼Œç¡®ä¿è½¬æ¢çš„æ­£ç¡®æ€§ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒå¤šç§æ•°æ®ç±»å‹çš„è‡ªåŠ¨æ¨æ–­
- éœ€è¦éªŒè¯æ¨æ–­ç»“æœçš„æ­£ç¡®æ€§
- éœ€è¦å¤„ç†ç±»å‹ä¸åŒ¹é…çš„æƒ…å†µ

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ç±»å‹æ¨æ–­ç®—æ³•ï¼Œç»“åˆç±»å‹éªŒè¯æœºåˆ¶ï¼Œå®ç°è‡ªåŠ¨ç±»å‹æ¨æ–­å’ŒéªŒè¯ã€‚

### 3.2 å®ç°ä»£ç 

```python
from typing import Any, Dict, List, Optional, get_type_hints
from dataclasses import dataclass
import json

@dataclass
class TypeInferenceResult:
    """ç±»å‹æ¨æ–­ç»“æœ"""
    inferred_type: type
    confidence: float
    validation_errors: List[str]

class TypeInferenceEngine:
    """ç±»å‹æ¨æ–­å¼•æ“"""

    def infer_type(self, value: Any) -> TypeInferenceResult:
        """æ¨æ–­æ•°æ®ç±»å‹"""
        if value is None:
            return TypeInferenceResult(Optional[Any], 1.0, [])

        if isinstance(value, bool):
            return TypeInferenceResult(bool, 1.0, [])

        if isinstance(value, int):
            return TypeInferenceResult(int, 1.0, [])

        if isinstance(value, float):
            return TypeInferenceResult(float, 1.0, [])

        if isinstance(value, str):
            # å°è¯•æ¨æ–­æ›´å…·ä½“çš„ç±»å‹
            if self._is_json_string(value):
                return TypeInferenceResult(Dict, 0.8, [])
            if self._is_date_string(value):
                return TypeInferenceResult(str, 0.9, ["å¯èƒ½æ˜¯æ—¥æœŸç±»å‹"])
            return TypeInferenceResult(str, 1.0, [])

        if isinstance(value, list):
            if len(value) > 0:
                item_type = self.infer_type(value[0]).inferred_type
                return TypeInferenceResult(List[item_type], 0.9, [])
            return TypeInferenceResult(List[Any], 0.7, ["ç©ºåˆ—è¡¨ï¼Œæ— æ³•æ¨æ–­å…ƒç´ ç±»å‹"])

        if isinstance(value, dict):
            return TypeInferenceResult(Dict[str, Any], 1.0, [])

        return TypeInferenceResult(type(value), 0.5, [f"æœªçŸ¥ç±»å‹: {type(value)}"])

    def _is_json_string(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºJSONå­—ç¬¦ä¸²"""
        try:
            json.loads(value)
            return True
        except:
            return False

    def _is_date_string(self, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ—¥æœŸå­—ç¬¦ä¸²"""
        import re
        date_patterns = [
            r'\d{4}-\d{2}-\d{2}',
            r'\d{4}/\d{2}/\d{2}',
            r'\d{2}-\d{2}-\d{4}'
        ]
        return any(re.match(pattern, value) for pattern in date_patterns)

    def validate_type(self, value: Any, expected_type: type) -> List[str]:
        """éªŒè¯å€¼æ˜¯å¦ç¬¦åˆé¢„æœŸç±»å‹"""
        errors = []

        if expected_type == Optional[Any]:
            return errors

        if value is None and expected_type != Optional[Any]:
            errors.append(f"å€¼ä¸èƒ½ä¸ºNoneï¼ŒæœŸæœ›ç±»å‹: {expected_type}")
            return errors

        if not isinstance(value, expected_type):
            errors.append(f"ç±»å‹ä¸åŒ¹é…: æœŸæœ› {expected_type}, å®é™… {type(value)}")

        return errors

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    engine = TypeInferenceEngine()

    # æ¨æ–­ä¸åŒç±»å‹
    test_values = [
        42,
        3.14,
        "hello",
        "2025-01-21",
        [1, 2, 3],
        {"key": "value"},
        None
    ]

    for value in test_values:
        result = engine.infer_type(value)
        print(f"å€¼: {value}")
        print(f"æ¨æ–­ç±»å‹: {result.inferred_type}")
        print(f"ç½®ä¿¡åº¦: {result.confidence}")
        if result.validation_errors:
            print(f"éªŒè¯é”™è¯¯: {result.validation_errors}")
        print()
```

---

## 4. æ¡ˆä¾‹3ï¼šæ³›å‹ç±»å‹è½¬æ¢

### 4.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨Schemaè½¬æ¢ä¸­ï¼Œéœ€è¦å¤„ç†æ³›å‹ç±»å‹ï¼ˆå¦‚Listã€Dictã€Optionalç­‰ï¼‰ï¼Œç¡®ä¿æ³›å‹ç±»å‹çš„æ­£ç¡®è½¬æ¢ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒåµŒå¥—æ³›å‹ç±»å‹
- éœ€è¦å¤„ç†æ³›å‹ç±»å‹å‚æ•°
- éœ€è¦éªŒè¯æ³›å‹ç±»å‹çº¦æŸ

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨Pythonçš„typingæ¨¡å—ï¼Œå®ç°æ³›å‹ç±»å‹çš„è½¬æ¢å’ŒéªŒè¯ã€‚

### 4.2 å®ç°ä»£ç 

```python
from typing import TypeVar, Generic, List, Dict, Optional, Union, get_args, get_origin
from typing_extensions import get_type_hints

T = TypeVar('T')
U = TypeVar('U')

class GenericTypeConverter:
    """æ³›å‹ç±»å‹è½¬æ¢å™¨"""

    def convert_generic(self, source: T, target_type: type) -> U:
        """è½¬æ¢æ³›å‹ç±»å‹"""
        origin = get_origin(target_type)
        args = get_args(target_type)

        if origin is None:
            # éæ³›å‹ç±»å‹ï¼Œç›´æ¥è½¬æ¢
            return self._convert_basic_type(source, target_type)

        if origin is list:
            # List[T]ç±»å‹
            if not isinstance(source, list):
                raise TypeError(f"æœŸæœ›Listç±»å‹ï¼Œå®é™…: {type(source)}")
            item_type = args[0] if args else Any
            return [self._convert_basic_type(item, item_type) for item in source]

        if origin is dict:
            # Dict[K, V]ç±»å‹
            if not isinstance(source, dict):
                raise TypeError(f"æœŸæœ›Dictç±»å‹ï¼Œå®é™…: {type(source)}")
            key_type = args[0] if args else Any
            value_type = args[1] if args else Any
            return {
                self._convert_basic_type(k, key_type): self._convert_basic_type(v, value_type)
                for k, v in source.items()
            }

        if origin is Union:
            # Unionç±»å‹ï¼Œå°è¯•æ¯ä¸ªå¯èƒ½çš„ç±»å‹
            for union_type in args:
                try:
                    return self._convert_basic_type(source, union_type)
                except (TypeError, ValueError):
                    continue
            raise TypeError(f"æ— æ³•å°† {type(source)} è½¬æ¢ä¸º {target_type}")

        if origin is Optional:
            # Optional[T]ç±»å‹
            if source is None:
                return None
            inner_type = args[0] if args else Any
            return self._convert_basic_type(source, inner_type)

        raise TypeError(f"ä¸æ”¯æŒçš„æ³›å‹ç±»å‹: {target_type}")

    def _convert_basic_type(self, source: Any, target_type: type) -> Any:
        """è½¬æ¢åŸºæœ¬ç±»å‹"""
        if source is None:
            return None

        if target_type == Any:
            return source

        if isinstance(source, target_type):
            return source

        # ç±»å‹è½¬æ¢
        if target_type == str:
            return str(source)
        if target_type == int:
            return int(source)
        if target_type == float:
            return float(source)
        if target_type == bool:
            return bool(source)

        raise TypeError(f"æ— æ³•å°† {type(source)} è½¬æ¢ä¸º {target_type}")

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    converter = GenericTypeConverter()

    # Listè½¬æ¢
    source_list = [1, 2, 3]
    target_list = converter.convert_generic(source_list, List[str])
    print(f"Listè½¬æ¢: {source_list} -> {target_list}")

    # Dictè½¬æ¢
    source_dict = {"a": 1, "b": 2}
    target_dict = converter.convert_generic(source_dict, Dict[str, str])
    print(f"Dictè½¬æ¢: {source_dict} -> {target_dict}")

    # Optionalè½¬æ¢
    source_value = None
    target_value = converter.convert_generic(source_value, Optional[int])
    print(f"Optionalè½¬æ¢: {source_value} -> {target_value}")
```

---

## 5. æ¡ˆä¾‹4ï¼šç±»å‹çº¦æŸéªŒè¯

### 5.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨Schemaè½¬æ¢ä¸­ï¼Œéœ€è¦éªŒè¯æ•°æ®æ˜¯å¦ç¬¦åˆç±»å‹çº¦æŸï¼ˆå¦‚èŒƒå›´ã€æ ¼å¼ã€é•¿åº¦ç­‰ï¼‰ï¼Œç¡®ä¿æ•°æ®è´¨é‡ã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦æ”¯æŒå¤šç§ç±»å‹çº¦æŸ
- éœ€è¦æä¾›æ¸…æ™°çš„é”™è¯¯ä¿¡æ¯
- éœ€è¦å¤„ç†çº¦æŸå†²çª

**è§£å†³æ–¹æ¡ˆ**ï¼š
å®ç°ç±»å‹çº¦æŸéªŒè¯å™¨ï¼Œæ”¯æŒèŒƒå›´ã€æ ¼å¼ã€é•¿åº¦ç­‰å¤šç§çº¦æŸã€‚

### 5.2 å®ç°ä»£ç 

```python
from typing import Any, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum

class ConstraintType(Enum):
    """çº¦æŸç±»å‹"""
    RANGE = "range"
    LENGTH = "length"
    PATTERN = "pattern"
    ENUM = "enum"
    CUSTOM = "custom"

@dataclass
class TypeConstraint:
    """ç±»å‹çº¦æŸ"""
    constraint_type: ConstraintType
    value: Any
    error_message: str

class TypeConstraintValidator:
    """ç±»å‹çº¦æŸéªŒè¯å™¨"""

    def __init__(self):
        self.constraints: List[TypeConstraint] = []

    def add_range_constraint(self, min_value: Optional[float] = None,
                            max_value: Optional[float] = None,
                            error_message: str = "å€¼è¶…å‡ºèŒƒå›´"):
        """æ·»åŠ èŒƒå›´çº¦æŸ"""
        self.constraints.append(TypeConstraint(
            ConstraintType.RANGE,
            {"min": min_value, "max": max_value},
            error_message
        ))

    def add_length_constraint(self, min_length: Optional[int] = None,
                             max_length: Optional[int] = None,
                             error_message: str = "é•¿åº¦ä¸ç¬¦åˆè¦æ±‚"):
        """æ·»åŠ é•¿åº¦çº¦æŸ"""
        self.constraints.append(TypeConstraint(
            ConstraintType.LENGTH,
            {"min": min_length, "max": max_length},
            error_message
        ))

    def add_pattern_constraint(self, pattern: str,
                              error_message: str = "æ ¼å¼ä¸ç¬¦åˆè¦æ±‚"):
        """æ·»åŠ æ¨¡å¼çº¦æŸ"""
        import re
        self.constraints.append(TypeConstraint(
            ConstraintType.PATTERN,
            re.compile(pattern),
            error_message
        ))

    def add_enum_constraint(self, allowed_values: List[Any],
                           error_message: str = "å€¼ä¸åœ¨å…è®¸çš„æšä¸¾å€¼ä¸­"):
        """æ·»åŠ æšä¸¾çº¦æŸ"""
        self.constraints.append(TypeConstraint(
            ConstraintType.ENUM,
            set(allowed_values),
            error_message
        ))

    def add_custom_constraint(self, validator: Callable[[Any], bool],
                             error_message: str = "è‡ªå®šä¹‰éªŒè¯å¤±è´¥"):
        """æ·»åŠ è‡ªå®šä¹‰çº¦æŸ"""
        self.constraints.append(TypeConstraint(
            ConstraintType.CUSTOM,
            validator,
            error_message
        ))

    def validate(self, value: Any) -> List[str]:
        """éªŒè¯å€¼æ˜¯å¦ç¬¦åˆæ‰€æœ‰çº¦æŸ"""
        errors = []

        for constraint in self.constraints:
            if constraint.constraint_type == ConstraintType.RANGE:
                if not self._validate_range(value, constraint.value):
                    errors.append(constraint.error_message)

            elif constraint.constraint_type == ConstraintType.LENGTH:
                if not self._validate_length(value, constraint.value):
                    errors.append(constraint.error_message)

            elif constraint.constraint_type == ConstraintType.PATTERN:
                if not self._validate_pattern(value, constraint.value):
                    errors.append(constraint.error_message)

            elif constraint.constraint_type == ConstraintType.ENUM:
                if not self._validate_enum(value, constraint.value):
                    errors.append(constraint.error_message)

            elif constraint.constraint_type == ConstraintType.CUSTOM:
                if not constraint.value(value):
                    errors.append(constraint.error_message)

        return errors

    def _validate_range(self, value: Any, range_config: dict) -> bool:
        """éªŒè¯èŒƒå›´çº¦æŸ"""
        try:
            num_value = float(value)
            min_val = range_config.get("min")
            max_val = range_config.get("max")

            if min_val is not None and num_value < min_val:
                return False
            if max_val is not None and num_value > max_val:
                return False
            return True
        except (ValueError, TypeError):
            return False

    def _validate_length(self, value: Any, length_config: dict) -> bool:
        """éªŒè¯é•¿åº¦çº¦æŸ"""
        try:
            length = len(value)
            min_len = length_config.get("min")
            max_len = length_config.get("max")

            if min_len is not None and length < min_len:
                return False
            if max_len is not None and length > max_len:
                return False
            return True
        except TypeError:
            return False

    def _validate_pattern(self, value: Any, pattern) -> bool:
        """éªŒè¯æ¨¡å¼çº¦æŸ"""
        if not isinstance(value, str):
            return False
        return bool(pattern.match(value))

    def _validate_enum(self, value: Any, allowed_values: set) -> bool:
        """éªŒè¯æšä¸¾çº¦æŸ"""
        return value in allowed_values

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    validator = TypeConstraintValidator()

    # æ·»åŠ çº¦æŸ
    validator.add_range_constraint(min_value=0, max_value=100,
                                  error_message="å¹´é¾„å¿…é¡»åœ¨0-100ä¹‹é—´")
    validator.add_length_constraint(min_length=1, max_length=50,
                                   error_message="å§“åé•¿åº¦å¿…é¡»åœ¨1-50ä¹‹é—´")
    validator.add_pattern_constraint(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
                                     error_message="é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")

    # éªŒè¯æ•°æ®
    test_data = [
        {"age": 25, "name": "John", "email": "john@example.com"},
        {"age": 150, "name": "Jane", "email": "jane@example.com"},
        {"age": 30, "name": "", "email": "invalid-email"},
    ]

    for data in test_data:
        print(f"\néªŒè¯æ•°æ®: {data}")
        errors = []
        if "age" in data:
            errors.extend(validator.validate(data["age"]))
        if "name" in data:
            errors.extend(validator.validate(data["name"]))
        if "email" in data:
            errors.extend(validator.validate(data["email"]))

        if errors:
            print(f"éªŒè¯å¤±è´¥: {errors}")
        else:
            print("éªŒè¯é€šè¿‡")
```

---

## 6. æ¡ˆä¾‹5ï¼šç±»å‹å®‰å…¨çš„Schemaæ˜ å°„

### 6.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨ä¸åŒSchemaä¹‹é—´è¿›è¡Œè½¬æ¢æ—¶ï¼Œéœ€è¦ç¡®ä¿ç±»å‹å®‰å…¨ï¼Œé˜²æ­¢ç±»å‹é”™è¯¯å¯¼è‡´çš„æ•°æ®ä¸¢å¤±æˆ–æŸåã€‚

**æŠ€æœ¯æŒ‘æˆ˜**ï¼š

- éœ€è¦å¤„ç†å¤æ‚çš„åµŒå¥—ç»“æ„
- éœ€è¦æ”¯æŒå¯é€‰å­—æ®µ
- éœ€è¦å¤„ç†ç±»å‹ä¸åŒ¹é…çš„æƒ…å†µ

**è§£å†³æ–¹æ¡ˆ**ï¼š
å®ç°ç±»å‹å®‰å…¨çš„Schemaæ˜ å°„å™¨ï¼Œä½¿ç”¨ç±»å‹æ³¨è§£å’Œè¿è¡Œæ—¶éªŒè¯ã€‚

### 6.2 å®ç°ä»£ç 

```python
from typing import Any, Dict, Type, get_type_hints, get_origin, get_args
from dataclasses import dataclass, fields
from typing_extensions import get_type_hints

@dataclass
class SchemaMapping:
    """Schemaæ˜ å°„é…ç½®"""
    source_field: str
    target_field: str
    type_converter: Optional[Callable] = None
    default_value: Any = None
    required: bool = True

class TypeSafeSchemaMapper:
    """ç±»å‹å®‰å…¨çš„Schemaæ˜ å°„å™¨"""

    def __init__(self, source_schema: Type, target_schema: Type):
        self.source_schema = source_schema
        self.target_schema = target_schema
        self.mappings: List[SchemaMapping] = []

    def add_mapping(self, mapping: SchemaMapping):
        """æ·»åŠ å­—æ®µæ˜ å°„"""
        self.mappings.append(mapping)

    def map(self, source_data: Dict[str, Any]) -> Dict[str, Any]:
        """æ‰§è¡ŒSchemaæ˜ å°„"""
        target_data = {}
        errors = []

        for mapping in self.mappings:
            source_value = source_data.get(mapping.source_field)

            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if mapping.required and source_value is None:
                if mapping.default_value is None:
                    errors.append(f"å¿…éœ€å­—æ®µç¼ºå¤±: {mapping.source_field}")
                    continue
                source_value = mapping.default_value

            # ç±»å‹è½¬æ¢
            if mapping.type_converter:
                try:
                    source_value = mapping.type_converter(source_value)
                except Exception as e:
                    errors.append(f"å­—æ®µ {mapping.source_field} ç±»å‹è½¬æ¢å¤±è´¥: {e}")
                    continue

            # ç±»å‹éªŒè¯
            target_field_type = self._get_field_type(mapping.target_field)
            if target_field_type:
                validation_errors = self._validate_type(source_value, target_field_type)
                if validation_errors:
                    errors.extend(validation_errors)
                    continue

            target_data[mapping.target_field] = source_value

        if errors:
            raise ValueError(f"Schemaæ˜ å°„å¤±è´¥: {errors}")

        return target_data

    def _get_field_type(self, field_name: str) -> Optional[Type]:
        """è·å–å­—æ®µç±»å‹"""
        hints = get_type_hints(self.target_schema)
        return hints.get(field_name)

    def _validate_type(self, value: Any, expected_type: Type) -> List[str]:
        """éªŒè¯ç±»å‹"""
        errors = []
        origin = get_origin(expected_type)

        if origin is None:
            # åŸºæœ¬ç±»å‹éªŒè¯
            if value is not None and not isinstance(value, expected_type):
                errors.append(f"ç±»å‹ä¸åŒ¹é…: æœŸæœ› {expected_type}, å®é™… {type(value)}")
        elif origin is Optional:
            # Optionalç±»å‹
            args = get_args(expected_type)
            if value is not None and args:
                inner_type = args[0]
                if not isinstance(value, inner_type):
                    errors.append(f"ç±»å‹ä¸åŒ¹é…: æœŸæœ› {inner_type}, å®é™… {type(value)}")
        elif origin is list:
            # Listç±»å‹
            if not isinstance(value, list):
                errors.append(f"ç±»å‹ä¸åŒ¹é…: æœŸæœ› List, å®é™… {type(value)}")

        return errors

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    from dataclasses import dataclass
    from typing import Optional

    @dataclass
    class SourceSchema:
        user_id: int
        user_name: str
        user_age: int
        user_email: Optional[str] = None

    @dataclass
    class TargetSchema:
        id: int
        name: str
        age: int
        email: Optional[str] = None

    mapper = TypeSafeSchemaMapper(SourceSchema, TargetSchema)

    # æ·»åŠ æ˜ å°„
    mapper.add_mapping(SchemaMapping("user_id", "id"))
    mapper.add_mapping(SchemaMapping("user_name", "name"))
    mapper.add_mapping(SchemaMapping("user_age", "age"))
    mapper.add_mapping(SchemaMapping("user_email", "email", required=False))

    # æ‰§è¡Œæ˜ å°„
    source_data = {
        "user_id": 1,
        "user_name": "John",
        "user_age": 25,
        "user_email": "john@example.com"
    }

    target_data = mapper.map(source_data)
    print(f"æ˜ å°„ç»“æœ: {target_data}")
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Type_System_Analysis.md` - ç±»å‹ç³»ç»Ÿåˆ†æ
- `03_Control_Logic_Analysis.md` - æ§åˆ¶é€»è¾‘åˆ†æ
- `04_Schema_Conversion_Application.md` - Schemaè½¬æ¢åº”ç”¨

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

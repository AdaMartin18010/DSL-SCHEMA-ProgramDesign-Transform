# å¤šç»´æ¨¡å‹è½¬æ¢è®ºè¯å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [å¤šç»´æ¨¡å‹è½¬æ¢è®ºè¯å®è·µæ¡ˆä¾‹](#å¤šç»´æ¨¡å‹è½¬æ¢è®ºè¯å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šä¼ä¸šæ—¶é—´ç»´åº¦è½¬æ¢ç³»ç»Ÿ](#2-æ¡ˆä¾‹1ä¼ä¸šæ—¶é—´ç»´åº¦è½¬æ¢ç³»ç»Ÿ)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 æŠ€æœ¯æŒ‘æˆ˜](#22-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.3 è§£å†³æ–¹æ¡ˆ](#23-è§£å†³æ–¹æ¡ˆ)
    - [2.4 å®Œæ•´ä»£ç å®ç°](#24-å®Œæ•´ä»£ç å®ç°)
  - [3. æ¡ˆä¾‹2ï¼šç©ºé—´ç»´åº¦è½¬æ¢](#3-æ¡ˆä¾‹2ç©ºé—´ç»´åº¦è½¬æ¢)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 å½¢å¼åŒ–è¯æ˜](#32-å½¢å¼åŒ–è¯æ˜)
  - [4. æ¡ˆä¾‹3ï¼šæ—¶é—´-ç©ºé—´ç»´åº¦è”åˆè½¬æ¢](#4-æ¡ˆä¾‹3æ—¶é—´-ç©ºé—´ç»´åº¦è”åˆè½¬æ¢)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 å½¢å¼åŒ–è¯æ˜](#42-å½¢å¼åŒ–è¯æ˜)
  - [5. æ¡ˆä¾‹4ï¼šå¤šç»´åº¦æ•°æ®èšåˆè½¬æ¢](#5-æ¡ˆä¾‹4å¤šç»´åº¦æ•°æ®èšåˆè½¬æ¢)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 å½¢å¼åŒ–è¯æ˜](#52-å½¢å¼åŒ–è¯æ˜)
  - [6. æ¡ˆä¾‹5ï¼šç»´åº¦è½¬æ¢çš„æ­£ç¡®æ€§éªŒè¯](#6-æ¡ˆä¾‹5ç»´åº¦è½¬æ¢çš„æ­£ç¡®æ€§éªŒè¯)
    - [6.1 åœºæ™¯æè¿°](#61-åœºæ™¯æè¿°)
    - [6.2 å½¢å¼åŒ–è¯æ˜](#62-å½¢å¼åŒ–è¯æ˜)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›å¤šç»´æ¨¡å‹è½¬æ¢è®ºè¯åœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–æ—¶é—´ç»´åº¦è½¬æ¢ã€ç©ºé—´ç»´åº¦è½¬æ¢ã€æ—¶é—´-ç©ºé—´ç»´åº¦è”åˆè½¬æ¢ç­‰çœŸå®åœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **æ—¶é—´ç»´åº¦è½¬æ¢ç³»ç»Ÿ**ï¼šä¸åŒæ—¶é—´æ ¼å¼çš„ç»Ÿä¸€è½¬æ¢
2. **ç©ºé—´ç»´åº¦è½¬æ¢ç³»ç»Ÿ**ï¼šä¸åŒåæ ‡ç³»ä¹‹é—´çš„è½¬æ¢
3. **æ—¶é—´-ç©ºé—´ç»´åº¦è”åˆè½¬æ¢ç³»ç»Ÿ**ï¼šæ—¶ç©ºç»´åº¦è”åˆè½¬æ¢
4. **å¤šç»´åº¦æ•°æ®èšåˆè½¬æ¢ç³»ç»Ÿ**ï¼šå¤šç»´åº¦æ•°æ®èšåˆè½¬æ¢
5. **ç»´åº¦è½¬æ¢çš„æ­£ç¡®æ€§éªŒè¯ç³»ç»Ÿ**ï¼šç»´åº¦è½¬æ¢æ­£ç¡®æ€§éªŒè¯

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **æ—¶é—´ç»´åº¦**ï¼šISO 8601æ—¶é—´æ ‡å‡†
- **ç©ºé—´ç»´åº¦**ï¼šWGS84ã€UTMåæ ‡ç³»æ ‡å‡†

---

## 2. æ¡ˆä¾‹1ï¼šä¼ä¸šæ—¶é—´ç»´åº¦è½¬æ¢ç³»ç»Ÿ

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸä¼ä¸šéœ€è¦æ„å»ºæ—¶é—´ç»´åº¦è½¬æ¢ç³»ç»Ÿï¼Œç»Ÿä¸€ä¸åŒç³»ç»Ÿä½¿ç”¨çš„æ—¶é—´æ ¼å¼ï¼Œç¡®ä¿æ—¶é—´æ•°æ®çš„å‡†ç¡®æ€§å’Œä¸€è‡´æ€§ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **æ—¶é—´æ ¼å¼ä¸ç»Ÿä¸€**ï¼šä¸åŒç³»ç»Ÿä½¿ç”¨ä¸åŒçš„æ—¶é—´æ ¼å¼
2. **æ—¶åŒºå¤„ç†å›°éš¾**ï¼šæ—¶åŒºè½¬æ¢å¤„ç†å›°éš¾
3. **æ—¶é—´ç²¾åº¦ä¸ä¸€è‡´**ï¼šæ—¶é—´ç²¾åº¦ä¸ä¸€è‡´
4. **è½¬æ¢é”™è¯¯é¢‘å‘**ï¼šæ—¶é—´è½¬æ¢é”™è¯¯é¢‘å‘

**ä¸šåŠ¡ç›®æ ‡**ï¼š

- ç»Ÿä¸€æ—¶é—´æ ¼å¼
- æ­£ç¡®å¤„ç†æ—¶åŒº
- ä¿æŒæ—¶é—´ç²¾åº¦
- ç¡®ä¿è½¬æ¢å‡†ç¡®æ€§

### 2.2 æŠ€æœ¯æŒ‘æˆ˜

1. **æ—¶é—´æ ¼å¼è¯†åˆ«**ï¼šè¯†åˆ«ä¸åŒæ—¶é—´æ ¼å¼
2. **æ—¶åŒºè½¬æ¢**ï¼šæ­£ç¡®å¤„ç†æ—¶åŒºè½¬æ¢
3. **ç²¾åº¦ä¿æŒ**ï¼šä¿æŒæ—¶é—´ç²¾åº¦
4. **è¯­ä¹‰ä¿æŒ**ï¼šç¡®ä¿æ—¶é—´è¯­ä¹‰ä¿æŒ

### 2.3 è§£å†³æ–¹æ¡ˆ

**ä½¿ç”¨æ—¶é—´ç»´åº¦è½¬æ¢ç†è®ºï¼Œå®ç°æ—¶é—´æ ¼å¼çš„ç»Ÿä¸€è½¬æ¢**ï¼š

### 2.4 å®Œæ•´ä»£ç å®ç°

**æ—¶é—´ç»´åº¦è½¬æ¢Schemaï¼ˆå®Œæ•´ç¤ºä¾‹ï¼‰**ï¼š

```python
#!/usr/bin/env python3
"""
å¤šç»´æ¨¡å‹è½¬æ¢Schemaå®ç°
"""

from typing import Optional
from datetime import datetime, timezone, timedelta
from dataclasses import dataclass
import pytz

@dataclass
class TimeDimensionConverter:
    """æ—¶é—´ç»´åº¦è½¬æ¢å™¨"""

    def convert_to_iso8601(self, time_str: str, source_format: str, source_tz: Optional[str] = None) -> str:
        """è½¬æ¢ä¸ºISO 8601æ ¼å¼"""
        # è§£ææºæ—¶é—´
        dt = datetime.strptime(time_str, source_format)

        # å¤„ç†æ—¶åŒº
        if source_tz:
            source_timezone = pytz.timezone(source_tz)
            dt = source_timezone.localize(dt)
        else:
            # å‡è®¾ä¸ºUTC
            dt = dt.replace(tzinfo=timezone.utc)

        # è½¬æ¢ä¸ºISO 8601æ ¼å¼
        return dt.isoformat()

    def convert_from_iso8601(self, iso8601_str: str, target_format: str, target_tz: Optional[str] = None) -> str:
        """ä»ISO 8601æ ¼å¼è½¬æ¢"""
        # è§£æISO 8601æ—¶é—´
        dt = datetime.fromisoformat(iso8601_str.replace('Z', '+00:00'))

        # è½¬æ¢æ—¶åŒº
        if target_tz:
            target_timezone = pytz.timezone(target_tz)
            dt = dt.astimezone(target_timezone)

        # è½¬æ¢ä¸ºç›®æ ‡æ ¼å¼
        return dt.strftime(target_format)

    def convert_timezone(self, time_str: str, source_tz: str, target_tz: str, time_format: str = "%Y-%m-%d %H:%M:%S") -> str:
        """è½¬æ¢æ—¶åŒº"""
        # è§£ææºæ—¶é—´
        source_timezone = pytz.timezone(source_tz)
        dt = datetime.strptime(time_str, time_format)
        dt = source_timezone.localize(dt)

        # è½¬æ¢æ—¶åŒº
        target_timezone = pytz.timezone(target_tz)
        dt = dt.astimezone(target_timezone)

        # æ ¼å¼åŒ–è¾“å‡º
        return dt.strftime(time_format)

    def verify_semantic_preservation(self, original: str, converted: str, tolerance_seconds: int = 1) -> bool:
        """éªŒè¯æ—¶é—´è¯­ä¹‰ä¿æŒ"""
        try:
            dt1 = datetime.fromisoformat(original.replace('Z', '+00:00'))
            dt2 = datetime.fromisoformat(converted.replace('Z', '+00:00'))

            # è½¬æ¢ä¸ºUTCè¿›è¡Œæ¯”è¾ƒ
            dt1_utc = dt1.astimezone(timezone.utc)
            dt2_utc = dt2.astimezone(timezone.utc)

            # è®¡ç®—æ—¶é—´å·®
            diff = abs((dt1_utc - dt2_utc).total_seconds())

            return diff <= tolerance_seconds
        except Exception:
            return False

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    converter = TimeDimensionConverter()

    # è½¬æ¢ä¸ºISO 8601
    time_str = "2025-01-21 10:30:00"
    iso8601 = converter.convert_to_iso8601(time_str, "%Y-%m-%d %H:%M:%S", "Asia/Shanghai")
    print(f"è½¬æ¢ä¸ºISO 8601: {iso8601}")

    # ä»ISO 8601è½¬æ¢
    converted = converter.convert_from_iso8601(iso8601, "%Y-%m-%d %H:%M:%S", "America/New_York")
    print(f"ä»ISO 8601è½¬æ¢: {converted}")

    # éªŒè¯è¯­ä¹‰ä¿æŒ
    is_preserved = converter.verify_semantic_preservation(iso8601, iso8601)
    print(f"è¯­ä¹‰ä¿æŒéªŒè¯: {is_preserved}")
```

---

## 3. æ¡ˆä¾‹2ï¼šç©ºé—´ç»´åº¦è½¬æ¢

### 3.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
ä¸åŒç³»ç»Ÿä½¿ç”¨ä¸åŒçš„åæ ‡ç³»ï¼ˆå¦‚WGS84ã€UTMã€æœ¬åœ°åæ ‡ç³»ï¼‰ï¼Œéœ€è¦ç»Ÿä¸€ç©ºé—´ç»´åº¦ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨ç©ºé—´ç»´åº¦è½¬æ¢ç†è®ºï¼Œå®ç°åæ ‡ç³»ä¹‹é—´çš„è½¬æ¢ã€‚

### 3.2 å½¢å¼åŒ–è¯æ˜

**å®šç†**ï¼šç©ºé—´ç»´åº¦è½¬æ¢å‡½æ•°`f: S1 â†’ S2`æ˜¯è·ç¦»ä¿æŒçš„ã€‚

**è¯æ˜**ï¼š

1. å®šä¹‰ç©ºé—´ç»´åº¦ç±»å‹`S1`å’Œ`S2`
2. å®šä¹‰è½¬æ¢å‡½æ•°`f`
3. è¯æ˜`f`ä¿æŒè·ç¦»åº¦é‡

**å®ç°ä»£ç **ï¼š

```python
from typing import Tuple
import math

class SpatialDimensionConverter:
    """ç©ºé—´ç»´åº¦è½¬æ¢å™¨"""

    def wgs84_to_utm(self, lat: float, lon: float, zone: int) -> Tuple[float, float]:
        """WGS84åˆ°UTMè½¬æ¢"""
        # UTMè½¬æ¢ç®—æ³•ï¼ˆç®€åŒ–ç‰ˆï¼‰
        # å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨ä¸“ä¸šåº“å¦‚pyproj
        k0 = 0.9996
        a = 6378137.0  # WGS84æ¤­çƒé•¿åŠè½´
        e2 = 0.00669438  # WGS84ç¬¬ä¸€åå¿ƒç‡å¹³æ–¹

        lat_rad = math.radians(lat)
        lon_rad = math.radians(lon)

        # ä¸­å¤®ç»çº¿
        lon0 = (zone - 1) * 6 - 180 + 3

        # UTMè®¡ç®—ï¼ˆç®€åŒ–ï¼‰
        n = a / math.sqrt(1 - e2 * math.sin(lat_rad)**2)
        t = math.tan(lat_rad)
        c = e2 * math.cos(lat_rad)**2 / (1 - e2)
        a_coeff = math.cos(lat_rad) * (lon_rad - math.radians(lon0))

        m = a * ((1 - e2/4 - 3*e2**2/64) * lat_rad
                 - (3*e2/8 + 3*e2**2/32) * math.sin(2*lat_rad)
                 + (15*e2**2/256) * math.sin(4*lat_rad))

        x = k0 * n * (a_coeff + (1-t**2+c)*a_coeff**3/6
                      + (5-18*t**2+t**4+72*c-58)*a_coeff**5/120) + 500000

        y = k0 * (m + n*t*(a_coeff**2/2 + (5-t**2+9*c+4*c**2)*a_coeff**4/24
                           + (61-58*t**2+t**4+600*c-330)*a_coeff**6/720))

        return x, y

    def utm_to_wgs84(self, x: float, y: float, zone: int) -> Tuple[float, float]:
        """UTMåˆ°WGS84è½¬æ¢"""
        # UTMåˆ°WGS84é€†è½¬æ¢ï¼ˆç®€åŒ–ç‰ˆï¼‰
        # å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨ä¸“ä¸šåº“
        k0 = 0.9996
        a = 6378137.0
        e2 = 0.00669438

        x = x - 500000
        lon0 = (zone - 1) * 6 - 180 + 3

        # ç®€åŒ–è®¡ç®—
        m = y / k0
        mu = m / (a * (1 - e2/4 - 3*e2**2/64))

        e1 = (1 - math.sqrt(1 - e2)) / (1 + math.sqrt(1 - e2))
        j1 = 3*e1/2 - 27*e1**3/32
        j2 = 21*e1**2/16 - 55*e1**4/32
        j3 = 151*e1**3/96
        j4 = 1097*e1**4/512

        fp = mu + j1*math.sin(2*mu) + j2*math.sin(4*mu) + j3*math.sin(6*mu) + j4*math.sin(8*mu)

        e_prim2 = e2 / (1 - e2)
        n1 = a / math.sqrt(1 - e2 * math.sin(fp)**2)
        t1 = math.tan(fp)
        c1 = e_prim2 * math.cos(fp)**2
        r1 = a * (1 - e2) / (1 - e2 * math.sin(fp)**2)**1.5
        d = x / (n1 * k0)

        lat = fp - (t1 / (k0 * r1)) * (d**2/2 - (5+3*t1**2+10*c1-4*c1**2-9*e_prim2)*d**4/24
                                        + (61+90*t1**2+298*c1+45*t1**4-252*e_prim2-3*c1**2)*d**6/720)

        lon = math.radians(lon0) + (d - (1+2*t1**2+c1)*d**3/6
                                    + (5-2*c1+28*t1**2-3*c1**2+8*e_prim2+24*t1**4)*d**5/120) / math.cos(fp)

        return math.degrees(lat), math.degrees(lon)
```

---

## 4. æ¡ˆä¾‹3ï¼šæ—¶é—´-ç©ºé—´ç»´åº¦è”åˆè½¬æ¢

### 4.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨æ—¶ç©ºæ•°æ®è½¬æ¢ä¸­ï¼Œéœ€è¦åŒæ—¶å¤„ç†æ—¶é—´å’Œç©ºé—´ç»´åº¦ï¼Œç¡®ä¿æ—¶ç©ºå…³ç³»çš„æ­£ç¡®æ€§ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨æ—¶ç©ºç»´åº¦è”åˆè½¬æ¢ç†è®ºï¼Œå®ç°æ—¶é—´å’Œç©ºé—´çš„ç»Ÿä¸€è½¬æ¢ã€‚

### 4.2 å½¢å¼åŒ–è¯æ˜

**å®šç†**ï¼šæ—¶ç©ºç»´åº¦è½¬æ¢å‡½æ•°`f: (T, S) â†’ (T', S')`æ˜¯æ—¶ç©ºå…³ç³»ä¿æŒçš„ã€‚

**è¯æ˜**ï¼š

1. å®šä¹‰æ—¶ç©ºç»´åº¦ç±»å‹`(T, S)`å’Œ`(T', S')`
2. å®šä¹‰è½¬æ¢å‡½æ•°`f`
3. è¯æ˜`f`ä¿æŒæ—¶ç©ºå…³ç³»

**å®ç°ä»£ç **ï¼š

```python
from datetime import datetime
from typing import Tuple, List
from dataclasses import dataclass

@dataclass
class SpatioTemporalPoint:
    """æ—¶ç©ºç‚¹"""
    timestamp: datetime
    latitude: float
    longitude: float
    elevation: float = 0.0

class SpatioTemporalConverter:
    """æ—¶ç©ºç»´åº¦è½¬æ¢å™¨"""

    def convert_timezone(self, point: SpatioTemporalPoint, target_tz: str) -> SpatioTemporalPoint:
        """è½¬æ¢æ—¶åŒº"""
        from pytz import timezone, UTC

        # å‡è®¾åŸå§‹æ—¶é—´ä¸ºUTC
        utc_time = point.timestamp.replace(tzinfo=UTC)
        target_tz_obj = timezone(target_tz)
        local_time = utc_time.astimezone(target_tz_obj)

        return SpatioTemporalPoint(
            timestamp=local_time.replace(tzinfo=None),
            latitude=point.latitude,
            longitude=point.longitude,
            elevation=point.elevation
        )

    def convert_coordinate_system(self, point: SpatioTemporalPoint,
                                  target_system: str) -> SpatioTemporalPoint:
        """è½¬æ¢åæ ‡ç³»"""
        if target_system == "UTM":
            converter = SpatialDimensionConverter()
            zone = int((point.longitude + 180) / 6) + 1
            x, y = converter.wgs84_to_utm(point.latitude, point.longitude, zone)
            # æ³¨æ„ï¼šUTMä¸ç›´æ¥åŒ…å«æ—¶é—´ï¼Œä¿æŒåŸæ—¶é—´
            return SpatioTemporalPoint(
                timestamp=point.timestamp=point.timestamp,
                latitude=x,  # åœ¨UTMä¸­ï¼Œxå¯¹åº”çº¬åº¦æ–¹å‘
                longitude=y,  # åœ¨UTMä¸­ï¼Œyå¯¹åº”ç»åº¦æ–¹å‘
                elevation=point.elevation
            )
        return point

    def convert_trajectory(self, trajectory: List[SpatioTemporalPoint],
                          target_tz: str = None,
                          target_coord: str = None) -> List[SpatioTemporalPoint]:
        """è½¬æ¢è½¨è¿¹æ•°æ®"""
        converted = []
        for point in trajectory:
            converted_point = point

            if target_tz:
                converted_point = self.convert_timezone(converted_point, target_tz)

            if target_coord:
                converted_point = self.convert_coordinate_system(converted_point, target_coord)

            converted.append(converted_point)

        return converted
```

---

## 5. æ¡ˆä¾‹4ï¼šå¤šç»´åº¦æ•°æ®èšåˆè½¬æ¢

### 5.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨æ•°æ®åˆ†æä¸­ï¼Œéœ€è¦å°†ç»†ç²’åº¦çš„å¤šç»´åº¦æ•°æ®èšåˆä¸ºç²—ç²’åº¦æ•°æ®ï¼ŒåŒæ—¶ä¿æŒæ•°æ®çš„è¯­ä¹‰å®Œæ•´æ€§ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨å¤šç»´åº¦èšåˆè½¬æ¢ç†è®ºï¼Œå®ç°æ•°æ®çš„æ—¶é—´ã€ç©ºé—´ã€åˆ†ç±»ç­‰ç»´åº¦çš„èšåˆã€‚

### 5.2 å½¢å¼åŒ–è¯æ˜

**å®šç†**ï¼šå¤šç»´åº¦èšåˆå‡½æ•°`f: D_fine â†’ D_coarse`æ˜¯è¯­ä¹‰ä¿æŒçš„ã€‚

**è¯æ˜**ï¼š

1. å®šä¹‰ç»†ç²’åº¦ç»´åº¦`D_fine`å’Œç²—ç²’åº¦ç»´åº¦`D_coarse`
2. å®šä¹‰èšåˆå‡½æ•°`f`
3. è¯æ˜`f`ä¿æŒèšåˆè¯­ä¹‰

**å®ç°ä»£ç **ï¼š

```python
from typing import List, Dict, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
from enum import Enum

class AggregationType(Enum):
    """èšåˆç±»å‹"""
    SUM = "sum"
    AVG = "avg"
    MAX = "max"
    MIN = "min"
    COUNT = "count"

@dataclass
class MultiDimensionalData:
    """å¤šç»´åº¦æ•°æ®"""
    timestamp: datetime
    location: Tuple[float, float]
    category: str
    value: float

class MultiDimensionalAggregator:
    """å¤šç»´åº¦èšåˆå™¨"""

    def aggregate_by_time(self, data: List[MultiDimensionalData],
                         interval: timedelta,
                         agg_type: AggregationType) -> List[MultiDimensionalData]:
        """æŒ‰æ—¶é—´ç»´åº¦èšåˆ"""
        if not data:
            return []

        # æŒ‰æ—¶é—´é—´éš”åˆ†ç»„
        sorted_data = sorted(data, key=lambda x: x.timestamp)
        groups = {}

        for item in sorted_data:
            # è®¡ç®—æ—¶é—´çª—å£
            window_start = item.timestamp.replace(
                minute=(item.timestamp.minute // (interval.seconds // 60)) * (interval.seconds // 60),
                second=0,
                microsecond=0
            )

            if window_start not in groups:
                groups[window_start] = []
            groups[window_start].append(item)

        # èšåˆæ¯ä¸ªç»„
        aggregated = []
        for window_start, group_items in groups.items():
            values = [item.value for item in group_items]

            if agg_type == AggregationType.SUM:
                agg_value = sum(values)
            elif agg_type == AggregationType.AVG:
                agg_value = sum(values) / len(values)
            elif agg_type == AggregationType.MAX:
                agg_value = max(values)
            elif agg_type == AggregationType.MIN:
                agg_value = min(values)
            elif agg_type == AggregationType.COUNT:
                agg_value = len(values)
            else:
                agg_value = sum(values) / len(values)

            # ä½¿ç”¨ç¬¬ä¸€ä¸ªæ•°æ®ç‚¹çš„ä½ç½®å’Œç±»åˆ«
            aggregated.append(MultiDimensionalData(
                timestamp=window_start,
                location=group_items[0].location,
                category=group_items[0].category,
                value=agg_value
            ))

        return aggregated

    def aggregate_by_space(self, data: List[MultiDimensionalData],
                          grid_size: float,
                          agg_type: AggregationType) -> List[MultiDimensionalData]:
        """æŒ‰ç©ºé—´ç»´åº¦èšåˆ"""
        if not data:
            return []

        # æŒ‰ç©ºé—´ç½‘æ ¼åˆ†ç»„
        groups = {}

        for item in data:
            lat, lon = item.location
            grid_lat = int(lat / grid_size) * grid_size
            grid_lon = int(lon / grid_size) * grid_size
            grid_key = (grid_lat, grid_lon)

            if grid_key not in groups:
                groups[grid_key] = []
            groups[grid_key].append(item)

        # èšåˆæ¯ä¸ªç»„
        aggregated = []
        for grid_key, group_items in groups.items():
            values = [item.value for item in group_items]

            if agg_type == AggregationType.SUM:
                agg_value = sum(values)
            elif agg_type == AggregationType.AVG:
                agg_value = sum(values) / len(values)
            elif agg_type == AggregationType.MAX:
                agg_value = max(values)
            elif agg_type == AggregationType.MIN:
                agg_value = min(values)
            elif agg_type == AggregationType.COUNT:
                agg_value = len(values)
            else:
                agg_value = sum(values) / len(values)

            aggregated.append(MultiDimensionalData(
                timestamp=group_items[0].timestamp,
                location=grid_key,
                category=group_items[0].category,
                value=agg_value
            ))

        return aggregated

    def aggregate_by_category(self, data: List[MultiDimensionalData],
                             agg_type: AggregationType) -> List[MultiDimensionalData]:
        """æŒ‰åˆ†ç±»ç»´åº¦èšåˆ"""
        if not data:
            return []

        # æŒ‰ç±»åˆ«åˆ†ç»„
        groups = {}
        for item in data:
            if item.category not in groups:
                groups[item.category] = []
            groups[item.category].append(item)

        # èšåˆæ¯ä¸ªç»„
        aggregated = []
        for category, group_items in groups.items():
            values = [item.value for item in group_items]

            if agg_type == AggregationType.SUM:
                agg_value = sum(values)
            elif agg_type == AggregationType.AVG:
                agg_value = sum(values) / len(values)
            elif agg_type == AggregationType.MAX:
                agg_value = max(values)
            elif agg_type == AggregationType.MIN:
                agg_value = min(values)
            elif agg_type == AggregationType.COUNT:
                agg_value = len(values)
            else:
                agg_value = sum(values) / len(values)

            aggregated.append(MultiDimensionalData(
                timestamp=group_items[0].timestamp,
                location=group_items[0].location,
                category=category,
                value=agg_value
            ))

        return aggregated
```

---

## 6. æ¡ˆä¾‹5ï¼šç»´åº¦è½¬æ¢çš„æ­£ç¡®æ€§éªŒè¯

### 6.1 åœºæ™¯æè¿°

**ä¸šåŠ¡èƒŒæ™¯**ï¼š
åœ¨å¤šç»´åº¦è½¬æ¢åï¼Œéœ€è¦éªŒè¯è½¬æ¢çš„æ­£ç¡®æ€§ï¼Œç¡®ä¿æ•°æ®æ²¡æœ‰ä¸¢å¤±æˆ–æŸåã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä½¿ç”¨å½¢å¼åŒ–éªŒè¯æ–¹æ³•ï¼ŒéªŒè¯ç»´åº¦è½¬æ¢çš„æ­£ç¡®æ€§ã€‚

### 6.2 å½¢å¼åŒ–è¯æ˜

**å®šç†**ï¼šç»´åº¦è½¬æ¢éªŒè¯å‡½æ•°`verify: (D1, D2, f) â†’ bool`å¯ä»¥éªŒè¯è½¬æ¢çš„æ­£ç¡®æ€§ã€‚

**è¯æ˜**ï¼š

1. å®šä¹‰éªŒè¯å‡½æ•°`verify`
2. å®šä¹‰æ­£ç¡®æ€§æ¡ä»¶
3. è¯æ˜éªŒè¯å‡½æ•°çš„å®Œå¤‡æ€§

**å®ç°ä»£ç **ï¼š

```python
from typing import Callable, Any, List, Tuple
from dataclasses import dataclass

@dataclass
class VerificationResult:
    """éªŒè¯ç»“æœ"""
    is_valid: bool
    errors: List[str]
    warnings: List[str]

class DimensionConversionVerifier:
    """ç»´åº¦è½¬æ¢éªŒè¯å™¨"""

    def verify_bijectivity(self, source_data: List[Any],
                          target_data: List[Any],
                          convert_func: Callable,
                          reverse_func: Callable) -> VerificationResult:
        """éªŒè¯åŒå°„æ€§ï¼ˆå¯é€†æ€§ï¼‰"""
        errors = []
        warnings = []

        # æ­£å‘è½¬æ¢éªŒè¯
        for i, source_item in enumerate(source_data):
            try:
                converted = convert_func(source_item)
                if converted not in target_data:
                    errors.append(f"è½¬æ¢ç»“æœä¸åœ¨ç›®æ ‡æ•°æ®ä¸­: ç´¢å¼• {i}")
            except Exception as e:
                errors.append(f"è½¬æ¢å¤±è´¥: ç´¢å¼• {i}, é”™è¯¯: {e}")

        # åå‘è½¬æ¢éªŒè¯
        for i, target_item in enumerate(target_data):
            try:
                reversed_item = reverse_func(target_item)
                if reversed_item not in source_data:
                    warnings.append(f"åå‘è½¬æ¢ç»“æœä¸åœ¨æºæ•°æ®ä¸­: ç´¢å¼• {i}")
            except Exception as e:
                warnings.append(f"åå‘è½¬æ¢å¤±è´¥: ç´¢å¼• {i}, é”™è¯¯: {e}")

        return VerificationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings
        )

    def verify_semantic_preservation(self, source_data: List[Any],
                                    target_data: List[Any],
                                    semantic_check: Callable) -> VerificationResult:
        """éªŒè¯è¯­ä¹‰ä¿æŒ"""
        errors = []
        warnings = []

        if len(source_data) != len(target_data):
            errors.append(f"æ•°æ®é•¿åº¦ä¸åŒ¹é…: æº {len(source_data)}, ç›®æ ‡ {len(target_data)}")

        for i, (source_item, target_item) in enumerate(zip(source_data, target_data)):
            try:
                if not semantic_check(source_item, target_item):
                    errors.append(f"è¯­ä¹‰ä¸åŒ¹é…: ç´¢å¼• {i}")
            except Exception as e:
                errors.append(f"è¯­ä¹‰æ£€æŸ¥å¤±è´¥: ç´¢å¼• {i}, é”™è¯¯: {e}")

        return VerificationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings
        )

    def verify_completeness(self, source_data: List[Any],
                          target_data: List[Any],
                          convert_func: Callable) -> VerificationResult:
        """éªŒè¯å®Œæ•´æ€§"""
        errors = []
        warnings = []

        converted_items = set()
        for source_item in source_data:
            try:
                converted = convert_func(source_item)
                converted_items.add(id(converted))  # ä½¿ç”¨idä½œä¸ºå”¯ä¸€æ ‡è¯†
            except Exception as e:
                errors.append(f"è½¬æ¢å¤±è´¥: {e}")

        target_items = set(id(item) for item in target_data)

        missing_items = converted_items - target_items
        if missing_items:
            warnings.append(f"ç›®æ ‡æ•°æ®ä¸­ç¼ºå°‘ {len(missing_items)} ä¸ªè½¬æ¢ç»“æœ")

        extra_items = target_items - converted_items
        if extra_items:
            warnings.append(f"ç›®æ ‡æ•°æ®ä¸­æœ‰ {len(extra_items)} ä¸ªé¢å¤–é¡¹")

        return VerificationResult(
            is_valid=len(errors) == 0,
            errors=errors,
            warnings=warnings
        )
```

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å¤šç»´æ¨¡å‹ç†è®º
- `03_Standards.md` - è½¬æ¢è®ºè¯
- `04_Transformation.md` - å½¢å¼åŒ–éªŒè¯

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

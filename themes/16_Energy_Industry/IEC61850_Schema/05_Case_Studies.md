# IEC61850 Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [IEC61850 Schemaå®è·µæ¡ˆä¾‹](#iec61850-schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šçœçº§ç”µç½‘æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–æ”¹é€ é¡¹ç›®](#2-æ¡ˆä¾‹1çœçº§ç”µç½‘æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–æ”¹é€ é¡¹ç›®)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 Schemaå®šä¹‰](#25-schemaå®šä¹‰)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šåŸå¸‚é…ç”µç½‘è‡ªåŠ¨åŒ–ç³»ç»Ÿ](#3-æ¡ˆä¾‹2åŸå¸‚é…ç”µç½‘è‡ªåŠ¨åŒ–ç³»ç»Ÿ)
    - [3.1 ä¸šåŠ¡èƒŒæ™¯](#31-ä¸šåŠ¡èƒŒæ™¯)
    - [3.2 ä¸šåŠ¡ç—›ç‚¹](#32-ä¸šåŠ¡ç—›ç‚¹)
    - [3.3 ä¸šåŠ¡ç›®æ ‡](#33-ä¸šåŠ¡ç›®æ ‡)
    - [3.4 æŠ€æœ¯æŒ‘æˆ˜](#34-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.5 å®Œæ•´ä»£ç å®ç°](#35-å®Œæ•´ä»£ç å®ç°)
    - [3.6 æ•ˆæœè¯„ä¼°](#36-æ•ˆæœè¯„ä¼°)
  - [4. æ¡ˆä¾‹æ€»ç»“](#4-æ¡ˆä¾‹æ€»ç»“)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›IEC61850 Schemaåœ¨ç”µåŠ›è¡Œä¸šçš„å®è·µæ¡ˆä¾‹ï¼Œå±•ç¤ºæ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–ã€é…ç”µç½‘è‡ªåŠ¨åŒ–ç­‰åœºæ™¯çš„åº”ç”¨ä»·å€¼ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–æ”¹é€ **ï¼šå˜ç”µç«™è‡ªåŠ¨åŒ–ç³»ç»Ÿå‡çº§
2. **åŸå¸‚é…ç”µç½‘è‡ªåŠ¨åŒ–**ï¼šé…ç”µç½‘ç»œç›‘æ§ä¸æ•…éšœå¤„ç†

---

## 2. æ¡ˆä¾‹1ï¼šçœçº§ç”µç½‘æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–æ”¹é€ é¡¹ç›®

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šæ¦‚å†µ**ï¼šæŸçœçº§ç”µåŠ›å…¬å¸ï¼ˆä»¥ä¸‹ç®€ç§°"Eç”µç½‘"ï¼‰ï¼Œè´Ÿè´£è¯¥çœç”µåŠ›è¾“é…ç½‘ç»œçš„è¿è¥å’Œç»´æŠ¤ï¼Œç®¡ç†ç€500kVå˜ç”µç«™12åº§ã€220kVå˜ç”µç«™85åº§ã€110kVå˜ç”µç«™320åº§ï¼Œä¾›ç”µé¢ç§¯è¶…è¿‡10ä¸‡å¹³æ–¹å…¬é‡Œï¼ŒæœåŠ¡ç”¨ç”µå®¢æˆ·è¶…è¿‡3000ä¸‡æˆ·ã€‚

éšç€æ–°å‹ç”µåŠ›ç³»ç»Ÿå»ºè®¾çš„æ¨è¿›ï¼Œä¼ ç»Ÿå˜ç”µç«™é¢ä¸´ç€è®¾å¤‡è€åŒ–ã€ä¿¡æ¯å­¤å²›ã€è¿ç»´æ•ˆç‡ä½ç­‰é—®é¢˜ã€‚Eç”µç½‘äº2023å¹´å¯åŠ¨æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–æ”¹é€ é¡¹ç›®ï¼Œè®¡åˆ’ç”¨3å¹´æ—¶é—´å®Œæˆå…¨éƒ¨500kVå’Œ220kVå˜ç”µç«™çš„æ™ºèƒ½åŒ–æ”¹é€ ã€‚

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **è®¾å¤‡ä¿¡æ¯å­¤å²›**ï¼šç«™å†…ä¿æŠ¤è£…ç½®ã€æµ‹æ§è£…ç½®ã€è®¡é‡è£…ç½®ç­‰è®¾å¤‡æ¥è‡ªä¸åŒå‚å®¶ï¼Œé€šä¿¡åè®®å„å¼‚ï¼ˆIEC 60870-5-103ã€Modbusã€Profibusç­‰ï¼‰ï¼Œæ•°æ®æ— æ³•ç»Ÿä¸€é‡‡é›†å’Œåˆ†æã€‚

2. **è¿ç»´æ•ˆç‡ä½ä¸‹**ï¼šè®¾å¤‡å·¡æ£€ä¾èµ–äººå·¥ï¼Œä¸€åº§220kVå˜ç”µç«™å·¡æ£€ä¸€æ¬¡éœ€è¦4å°æ—¶ï¼Œè¿ç»´äººå‘˜æ¯å¤©ç–²äºå¥”å‘½ï¼Œè®¾å¤‡å¼‚å¸¸å‘ç°ä¸åŠæ—¶ã€‚

3. **æ•…éšœå®šä½å›°éš¾**ï¼šæ•…éšœå‘ç”Ÿæ—¶ï¼Œéœ€è¦åœ¨å¤šå¥—ç³»ç»Ÿé—´åˆ‡æ¢æŸ¥çœ‹æ•°æ®ï¼Œå¹³å‡æ•…éšœå®šä½æ—¶é—´è¶…è¿‡30åˆ†é’Ÿï¼Œå½±å“æ•…éšœå¿«é€Ÿæ¢å¤ã€‚

4. **èµ„äº§ç®¡æ§ç²—æ”¾**ï¼šè®¾å¤‡å°è´¦ç®¡ç†ä¾èµ–Excelï¼Œè®¾å¤‡å…¨ç”Ÿå‘½å‘¨æœŸä¿¡æ¯ä¸å®Œæ•´ï¼Œèµ„äº§ç›˜ç‚¹è€—æ—¶è€—åŠ›ï¼Œè´¦å®ä¸ç¬¦ç‡è¾¾åˆ°15%ã€‚

5. **å®‰å…¨éšæ‚£çªå‡º**ï¼šäºŒæ¬¡å›è·¯ç¼ºä¹æœ‰æ•ˆç›‘æ§ï¼Œä¿æŠ¤è£…ç½®å®šå€¼å˜æ›´ç¼ºä¹å®¡è®¡ï¼Œå­˜åœ¨è¯¯æ“ä½œé£é™©ã€‚

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **ç»Ÿä¸€æ•°æ®æ ‡å‡†**ï¼šå…¨é¢é‡‡ç”¨IEC 61850æ ‡å‡†ï¼Œå®ç°ç«™å†…è®¾å¤‡ä¿¡æ¯æ¨¡å‹ç»Ÿä¸€ï¼Œæ•°æ®äº’é€šç‡è¾¾åˆ°100%ã€‚

2. **æå‡è¿ç»´æ•ˆç‡**ï¼šå®ç°è®¾å¤‡çŠ¶æ€åœ¨çº¿ç›‘æµ‹å’Œæ™ºèƒ½å·¡æ£€ï¼Œäººå·¥å·¡æ£€å·¥ä½œé‡å‡å°‘70%ï¼Œè®¾å¤‡å¼‚å¸¸å‘ç°æ—¶é—´ç¼©çŸ­è‡³5åˆ†é’Ÿä»¥å†…ã€‚

3. **ç¼©çŸ­æ•…éšœå®šä½æ—¶é—´**ï¼šå»ºç«‹ç»Ÿä¸€çš„æ•…éšœä¿¡æ¯ç»¼åˆåˆ†æå¹³å°ï¼Œæ•…éšœå®šä½æ—¶é—´ä»30åˆ†é’Ÿç¼©çŸ­è‡³5åˆ†é’Ÿä»¥å†…ã€‚

4. **ç²¾ç»†åŒ–èµ„äº§ç®¡ç†**ï¼šå»ºç«‹è®¾å¤‡æ•°å­—åŒ–å°è´¦ï¼Œå®ç°å…¨ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼Œè´¦å®ä¸€è‡´ç‡è¾¾åˆ°99%ä»¥ä¸Šã€‚

5. **å¼ºåŒ–å®‰å…¨ç®¡æ§**ï¼šå®ç°äºŒæ¬¡è®¾å¤‡è¿œæ–¹æ“ä½œå®‰å…¨ç®¡æ§ï¼Œä¿æŠ¤å®šå€¼å˜æ›´å…¨ç¨‹ç•™ç—•ï¼Œæœç»è¯¯æ“ä½œäº‹ä»¶ã€‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

**æŒ‘æˆ˜1ï¼šå¤šåè®®è½¬æ¢ä¸é›†æˆ**

- ç«™å†…å­˜åœ¨å¤šç§é€šä¿¡åè®®å’Œè§„çº¦ï¼Œéœ€è¦ç»Ÿä¸€è½¬æ¢ä¸ºIEC 61850
- éƒ¨åˆ†è€æ—§è®¾å¤‡ä¸æ”¯æŒIEC 61850ï¼Œéœ€è¦é€šè¿‡åè®®è½¬æ¢ç½‘å…³æ¥å…¥
- åè®®è½¬æ¢éœ€è¦ä¿è¯å®æ—¶æ€§å’Œå¯é æ€§ï¼Œæ—¶å»¶ä¸è¶…è¿‡10ms

**æŒ‘æˆ˜2ï¼šæµ·é‡å®æ—¶æ•°æ®å¤„ç†**

- å•åº§500kVå˜ç”µç«™å®æ—¶æ•°æ®ç‚¹è¶…è¿‡10ä¸‡ä¸ªï¼Œæ•°æ®åˆ·æ–°é¢‘ç‡4ms
- éœ€è¦æ”¯æŒæ•…éšœå½•æ³¢ã€GOOSEäº‹ä»¶ç­‰é«˜å¸¦å®½æ•°æ®ä¼ è¾“
- éœ€è¦å»ºç«‹é«˜æ•ˆçš„æ•°æ®å­˜å‚¨å’Œæ£€ç´¢æœºåˆ¶

**æŒ‘æˆ˜3ï¼šç³»ç»Ÿå®‰å…¨ä¸éš”ç¦»**

- éœ€è¦æ»¡è¶³ç”µåŠ›ç›‘æ§ç³»ç»Ÿå®‰å…¨é˜²æŠ¤è§„å®šï¼ˆå‘æ”¹å§”14å·ä»¤ï¼‰
- ç”Ÿäº§æ§åˆ¶å¤§åŒºå’Œç®¡ç†ä¿¡æ¯å¤§åŒºéœ€è¦å®‰å…¨éš”ç¦»
- éœ€è¦é˜²èŒƒç½‘ç»œæ”»å‡»å’Œæ¶æ„ä»£ç å…¥ä¾µ

**æŒ‘æˆ˜4ï¼šå·¥ç¨‹å®æ–½ä¸æ”¹é€ **

- æ”¹é€ æœŸé—´ä¸èƒ½å½±å“å˜ç”µç«™æ­£å¸¸è¿è¡Œ
- éœ€è¦åœ¨æœ‰é™åœç”µçª—å£å†…å®Œæˆè®¾å¤‡å®‰è£…å’Œè°ƒè¯•
- éœ€è¦åè°ƒå¤šå‚å®¶è®¾å¤‡è”è°ƒï¼ŒæŠ€æœ¯æ¥å£å¤æ‚

### 2.5 Schemaå®šä¹‰

**æ™ºèƒ½å˜ç”µç«™IEC 61850 Schema**ï¼š

```dsl
schema SmartSubstation {
  substation: Substation {
    substation_id: String @value("SUB-500kV-001")
    substation_name: String @value("500kVæŸå˜ç”µç«™")
    voltage_level: String @value("500kV")
    location: String @value("æŸå¸‚é«˜æ–°æŠ€æœ¯å¼€å‘åŒº")
  }

  ied_devices: List[IED] {
    ied1: IED {
      ied_name: String @value("PL2201")
      ied_type: String @value("Protection")
      manufacturer: String @value("å—ç‘ç»§ä¿")
      model: String @value("PCS-985")
      ip_address: String @value("192.168.1.101")
      
      logical_devices: List[LogicalDevice] {
        ld0: LogicalDevice {
          ld_inst: String @value("LD0")
          ld_name: String @value("å…¬ç”¨")
          
          logical_nodes: List[LogicalNode] {
            lphd1: LogicalNode {
              ln_name: String @value("LPHD1")
              ln_class: String @value("LPHD")
              prefix: String @value("")
              inst: String @value("1")
            }
            
            ggio1: LogicalNode {
              ln_name: String @value("GGIO1")
              ln_class: String @value("GGIO")
              prefix: String @value("Ind")
              inst: String @value("1")
              
              data_objects: List[DataObject] {
                ind1: DataObject {
                  do_name: String @value("Ind1")
                  do_type: String @value("SPS")
                  da_values: Map<String, Any> @value({
                    "stVal": "on",
                    "q": "0x0000",
                    "t": "2025-01-21T10:30:00Z"
                  })
                }
              }
            }
          }
        }
        
        prot1: LogicalDevice {
          ld_inst: String @value("PROT1")
          ld_name: String @value("ä¿æŠ¤")
          
          logical_nodes: List[LogicalNode] {
            pdis1: LogicalNode {
              ln_name: String @value("PDIS1")
              ln_class: String @value("PDIS")
              prefix: String @value("DIS")
              inst: String @value("1")
              
              data_objects: List[DataObject] {
                str: DataObject {
                  do_name: String @value("Str")
                  do_type: String @value("ACD")
                  da_values: Map<String, Any> @value({
                    "general": "false",
                    "phsA": "false",
                    "phsB": "false",
                    "phsC": "false"
                  })
                }
                
                op: DataObject {
                  do_name: String @value("Op")
                  do_type: String @value("ACT")
                  da_values: Map<String, Any> @value({
                    "general": "false",
                    "phsA": "false",
                    "phsB": "false",
                    "phsC": "false"
                  })
                }
              }
            }
          }
        }
      }
    }
  }

  communication_network: Communication {
    subnets: List[SubNetwork] {
      station_bus: SubNetwork {
        subnet_name: String @value("StationBus")
        subnet_type: String @value("8-MMS")
        
        connected_aps: List<ConnectedAP> {
          ap1: ConnectedAP {
            ied_name: String @value("PL2201")
            ap_name: String @value("S1")
            address: Map<String, String> @value({
              "IP": "192.168.1.101",
              "IP-SUBNET": "255.255.255.0",
              "IP-GATEWAY": "192.168.1.1"
            })
          }
        }
      }
    }
  }

  data_sets: List<DataSet] {
    ds_measurements: DataSet {
      ds_name: String @value("dsMeasurements")
      ds_description: String @value("æµ‹é‡æ•°æ®é›†")
      members: List<String> @value([
        "PL2201/MEAS1.MMXU1.A.phsA",
        "PL2201/MEAS1.MMXU1.A.phsB",
        "PL2201/MEAS1.MMXU1.A.phsC",
        "PL2201/MEAS1.MMXU1.PhV.phsA",
        "PL2201/MEAS1.MMXU1.PhV.phsB",
        "PL2201/MEAS1.MMXU1.PhV.phsC"
      ])
    }
  }

  report_control_blocks: List<ReportControl> {
    rcb_measurements: ReportControl {
      rcb_name: String @value("URCB_Measurements")
      rcb_id: String @value("Measurements")
      dat_set: String @value("dsMeasurements")
      rpt_id: String @value("ReportMeasurements")
      conf_rev: Int @value(1)
      opt_fields: List<String> @value(["sequence-number", "report-time-stamp", "reason-for-inclusion"])
      trg_ops: List<String> @value(["data-change", "quality-change"])
      intg_pd: Int @value(2000)
    }
  }

  goose_control_blocks: List<GSEControl] {
    gocb_tripping: GSEControl {
      gocb_name: String @value("GOOSE_Tripping")
      gocb_type: String @value("GOOSE")
      dat_set: String @value("dsTripping")
      app_id: String @value("0001")
      conf_rev: Int @value(1)
    }
  }
} @standard("IEC_61850-Ed2")
```

### 2.6 å®Œæ•´ä»£ç å®ç°

**æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–ç³»ç»Ÿï¼ˆçº¦480è¡Œï¼‰**ï¼š

```python
#!/usr/bin/env python3
"""
æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–ç³»ç»Ÿ
åŠŸèƒ½ï¼šIEC 61850è®¾å¤‡ç®¡ç†ã€æ•°æ®é‡‡é›†ã€ç›‘æ§å‘Šè­¦ã€æ•…éšœåˆ†æ
"""

import xml.etree.ElementTree as ET
import json
import socket
import struct
import threading
import time
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import logging

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class LNClass(str, Enum):
    """é€»è¾‘èŠ‚ç‚¹ç±»"""
    LPHD = "LPHD"  # ç‰©ç†è®¾å¤‡ä¿¡æ¯
    LLN0 = "LLN0"  # é€»è¾‘èŠ‚ç‚¹é›¶
    PDIS = "PDIS"  # è·ç¦»ä¿æŠ¤
    PTOC = "PTOC"  # è¿‡æµä¿æŠ¤
    XCBR = "XCBR"  # æ–­è·¯å™¨
    XSWI = "XSWI"  # éš”ç¦»å¼€å…³
    MMXU = "MMXU"  # æµ‹é‡
    CSWI = "CSWI"  # å¼€å…³æ§åˆ¶å™¨
    GGIO = "GGIO"  # é€šç”¨I/O


class FC(str, Enum):
    """åŠŸèƒ½çº¦æŸ"""
    ST = "ST"  # çŠ¶æ€ä¿¡æ¯
    MX = "MX"  # æµ‹é‡å€¼
    SP = "SP"  # è®¾å®šå€¼
    SV = "SV"  # å®šå€¼
    CF = "CF"  # é…ç½®
    DC = "DC"  # æè¿°
    SG = "SG"  # å®šå€¼ç»„
    SE = "SE"  # å®šå€¼ç»„å¯ç¼–è¾‘
    BR = "BR"  # ç¼“å­˜æŠ¥å‘Š
    RP = "RP"  # éç¼“å­˜æŠ¥å‘Š


@dataclass
class DataAttribute:
    """æ•°æ®å±æ€§"""
    name: str
    fc: FC
    type: str
    value: Any = None
    timestamp: Optional[datetime] = None


@dataclass
class DataObject:
    """æ•°æ®å¯¹è±¡"""
    name: str
    type: str
    attributes: Dict[str, DataAttribute] = field(default_factory=dict)


@dataclass
class LogicalNode:
    """é€»è¾‘èŠ‚ç‚¹"""
    name: str
    ln_class: LNClass
    prefix: str
    inst: str
    desc: str = ""
    data_objects: Dict[str, DataObject] = field(default_factory=dict)


@dataclass
class LogicalDevice:
    """é€»è¾‘è®¾å¤‡"""
    inst: str
    desc: str
    logical_nodes: Dict[str, LogicalNode] = field(default_factory=dict)


@dataclass
class IED:
    """æ™ºèƒ½ç”µå­è®¾å¤‡"""
    name: str
    ied_type: str
    manufacturer: str
    model: str
    ip_address: str
    logical_devices: Dict[str, LogicalDevice] = field(default_factory=dict)
    is_connected: bool = False
    last_communication: Optional[datetime] = None


@dataclass
class Substation:
    """å˜ç”µç«™"""
    substation_id: str
    name: str
    voltage_level: str
    location: str
    ieds: Dict[str, IED] = field(default_factory=dict)


class SCLParser:
    """SCLé…ç½®æ–‡ä»¶è§£æå™¨"""
    
    NAMESPACES = {
        'scl': 'http://www.iec.ch/61850/2003/SCL'
    }
    
    def __init__(self):
        self.substations: Dict[str, Substation] = {}
    
    def parse_scl_file(self, file_path: str) -> Substation:
        """è§£æSCLé…ç½®æ–‡ä»¶"""
        tree = ET.parse(file_path)
        root = tree.getroot()
        
        # è§£æå˜ç”µç«™ä¿¡æ¯
        substation_elem = root.find('.//scl:Substation', self.NAMESPACES)
        if substation_elem is None:
            raise ValueError("No Substation element found")
        
        substation_id = substation_elem.get('name', 'Unknown')
        substation = Substation(
            substation_id=substation_id,
            name=substation_elem.get('desc', substation_id),
            voltage_level="",
            location=""
        )
        
        # è§£æç”µå‹ç­‰çº§
        voltage_elem = substation_elem.find('.//scl:VoltageLevel', self.NAMESPACES)
        if voltage_elem is not None:
            substation.voltage_level = voltage_elem.get('name', '')
        
        # è§£æIEDè®¾å¤‡
        for ied_elem in root.findall('.//scl:IED', self.NAMESPACES):
            ied = self._parse_ied(ied_elem)
            substation.ieds[ied.name] = ied
        
        self.substations[substation_id] = substation
        logger.info(f"Parsed substation: {substation_id}, IEDs: {len(substation.ieds)}")
        return substation
    
    def _parse_ied(self, ied_elem: ET.Element) -> IED:
        """è§£æIEDå…ƒç´ """
        ied = IED(
            name=ied_elem.get('name', ''),
            ied_type=ied_elem.get('type', ''),
            manufacturer=ied_elem.get('manufacturer', ''),
            model=ied_elem.get('configVersion', ''),
            ip_address=''
        )
        
        # è§£æè®¿é—®ç‚¹è·å–IPåœ°å€
        for ap_elem in ied_elem.findall('.//scl:AccessPoint', self.NAMESPACES):
            for subnet_elem in ap_elem.findall('.//scl:SubNetwork', self.NAMESPACES):
                for connected_ap in subnet_elem.findall('.//scl:ConnectedAP', self.NAMESPACES):
                    if connected_ap.get('iedName') == ied.name:
                        for address in connected_ap.findall('.//scl:P', self.NAMESPACES):
                            if address.get('type') == 'IP':
                                ied.ip_address = address.text or ''
        
        # è§£æé€»è¾‘è®¾å¤‡
        for ld_elem in ied_elem.findall('.//scl:LDevice', self.NAMESPACES):
            ld = self._parse_logical_device(ld_elem)
            ied.logical_devices[ld.inst] = ld
        
        return ied
    
    def _parse_logical_device(self, ld_elem: ET.Element) -> LogicalDevice:
        """è§£æé€»è¾‘è®¾å¤‡"""
        ld = LogicalDevice(
            inst=ld_elem.get('inst', ''),
            desc=ld_elem.get('desc', '')
        )
        
        for ln_elem in ld_elem.findall('.//scl:LN', self.NAMESPACES):
            ln = self._parse_logical_node(ln_elem)
            ld.logical_nodes[ln.name] = ln
        
        return ld
    
    def _parse_logical_node(self, ln_elem: ET.Element) -> LogicalNode:
        """è§£æé€»è¾‘èŠ‚ç‚¹"""
        ln_class = ln_elem.get('lnClass', 'GGIO')
        prefix = ln_elem.get('prefix', '')
        inst = ln_elem.get('inst', '1')
        
        ln = LogicalNode(
            name=f"{prefix}{ln_class}{inst}",
            ln_class=LNClass(ln_class) if ln_class in [e.value for e in LNClass] else LNClass.GGIO,
            prefix=prefix,
            inst=inst,
            desc=ln_elem.get('desc', '')
        )
        
        # è§£ææ•°æ®å¯¹è±¡ï¼ˆç®€åŒ–å¤„ç†ï¼‰
        for do_elem in ln_elem.findall('.//scl:DO', self.NAMESPACES):
            do_name = do_elem.get('name', '')
            do_type = do_elem.get('type', '')
            do = DataObject(name=do_name, type=do_type)
            ln.data_objects[do_name] = do
        
        return ln


class MMSClient:
    """MMSå®¢æˆ·ç«¯ï¼ˆç®€åŒ–å®ç°ï¼‰"""
    
    def __init__(self, ied: IED):
        self.ied = ied
        self.socket: Optional[socket.socket] = None
        self.connected = False
    
    def connect(self, timeout: float = 10.0) -> bool:
        """è¿æ¥IEDè®¾å¤‡"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(timeout)
            self.socket.connect((self.ied.ip_address, 102))  # MMSé»˜è®¤ç«¯å£
            self.connected = True
            self.ied.is_connected = True
            self.ied.last_communication = datetime.now()
            logger.info(f"Connected to IED {self.ied.name} at {self.ied.ip_address}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to IED {self.ied.name}: {e}")
            return False
    
    def disconnect(self):
        """æ–­å¼€è¿æ¥"""
        if self.socket:
            self.socket.close()
        self.connected = False
        self.ied.is_connected = False
        logger.info(f"Disconnected from IED {self.ied.name}")
    
    def read_data_object(self, ld_inst: str, ln_name: str, do_name: str) -> Optional[Dict]:
        """è¯»å–æ•°æ®å¯¹è±¡å€¼"""
        if not self.connected:
            logger.warning(f"Not connected to IED {self.ied.name}")
            return None
        
        # æ¨¡æ‹ŸMMSè¯»å–æ“ä½œ
        variable_name = f"{self.ied.name}/{ld_inst}.{ln_name}.{do_name}"
        logger.debug(f"Reading variable: {variable_name}")
        
        # æ¨¡æ‹Ÿæ•°æ®è¿”å›
        import random
        return {
            "variable_name": variable_name,
            "value": random.uniform(0, 100),
            "quality": "good",
            "timestamp": datetime.now().isoformat()
        }
    
    def write_data_object(self, ld_inst: str, ln_name: str, do_name: str, value: Any) -> bool:
        """å†™å…¥æ•°æ®å¯¹è±¡å€¼ï¼ˆæ§åˆ¶æ“ä½œï¼‰"""
        if not self.connected:
            return False
        
        variable_name = f"{self.ied.name}/{ld_inst}.{ln_name}.{do_name}"
        logger.info(f"Writing variable {variable_name} = {value}")
        
        # æ¨¡æ‹Ÿå†™å…¥æ“ä½œ
        return True


class GOOSESubscriber:
    """GOOSEæ¶ˆæ¯è®¢é˜…å™¨"""
    
    def __init__(self, interface: str = "eth0"):
        self.interface = interface
        self.subscribed_gocb: List[str] = []
        self.message_callback: Optional[callable] = None
        self.running = False
        self.listener_thread: Optional[threading.Thread] = None
    
    def subscribe(self, gocb_ref: str, callback: callable):
        """è®¢é˜…GOOSEæ§åˆ¶å—"""
        self.subscribed_gocb.append(gocb_ref)
        self.message_callback = callback
        logger.info(f"Subscribed to GOOSE: {gocb_ref}")
    
    def start_listener(self):
        """å¯åŠ¨GOOSEç›‘å¬"""
        self.running = True
        self.listener_thread = threading.Thread(target=self._listen_loop)
        self.listener_thread.daemon = True
        self.listener_thread.start()
        logger.info(f"GOOSE listener started on {self.interface}")
    
    def stop_listener(self):
        """åœæ­¢GOOSEç›‘å¬"""
        self.running = False
        if self.listener_thread:
            self.listener_thread.join(timeout=5)
        logger.info("GOOSE listener stopped")
    
    def _listen_loop(self):
        """GOOSEç›‘å¬å¾ªç¯"""
        # æ¨¡æ‹ŸGOOSEæ¶ˆæ¯æ¥æ”¶
        import random
        while self.running:
            time.sleep(random.uniform(1, 5))
            
            # æ¨¡æ‹Ÿæ¥æ”¶GOOSEæ¶ˆæ¯
            if self.subscribed_gocb and self.message_callback:
                goose_msg = {
                    "gocb_ref": random.choice(self.subscribed_gocb),
                    "go_id": "GOOSE_001",
                    "dat_set": "dsTripping",
                    "go_t": datetime.now().isoformat(),
                    "st_num": random.randint(1, 100),
                    "sq_num": random.randint(1, 1000),
                    "data": {
                        "Ind1": random.choice(["on", "off"]),
                        "Ind2": random.choice(["on", "off"])
                    }
                }
                self.message_callback(goose_msg)


class SubstationMonitoringSystem:
    """å˜ç”µç«™ç›‘æ§ç³»ç»Ÿ"""
    
    def __init__(self, substation: Substation):
        self.substation = substation
        self.mms_clients: Dict[str, MMSClient] = {}
        self.goose_subscriber = GOOSESubscriber()
        self.measurements: Dict[str, Any] = {}
        self.events: List[Dict] = []
        self.running = False
        self.monitor_thread: Optional[threading.Thread] = None
    
    def initialize(self):
        """åˆå§‹åŒ–ç›‘æ§ç³»ç»Ÿ"""
        # ä¸ºæ¯ä¸ªIEDåˆ›å»ºMMSå®¢æˆ·ç«¯
        for ied_name, ied in self.substation.ieds.items():
            client = MMSClient(ied)
            self.mms_clients[ied_name] = client
        
        # è®¾ç½®GOOSEæ¶ˆæ¯å›è°ƒ
        self.goose_subscriber.subscribe(
            f"{self.substation.substation_id}/LLN0$GO$GOOSE_Tripping",
            self._on_goose_message
        )
        
        logger.info(f"Monitoring system initialized for {self.substation.name}")
    
    def connect_all_ieds(self) -> Dict[str, bool]:
        """è¿æ¥æ‰€æœ‰IEDè®¾å¤‡"""
        results = {}
        for ied_name, client in self.mms_clients.items():
            results[ied_name] = client.connect()
        return results
    
    def disconnect_all_ieds(self):
        """æ–­å¼€æ‰€æœ‰IEDè¿æ¥"""
        for client in self.mms_clients.values():
            client.disconnect()
    
    def start_monitoring(self):
        """å¯åŠ¨ç›‘æ§"""
        self.running = True
        self.goose_subscriber.start_listener()
        self.monitor_thread = threading.Thread(target=self._monitor_loop)
        self.monitor_thread.daemon = True
        self.monitor_thread.start()
        logger.info("Monitoring started")
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.running = False
        self.goose_subscriber.stop_listener()
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        logger.info("Monitoring stopped")
    
    def _monitor_loop(self):
        """ç›‘æ§å¾ªç¯"""
        while self.running:
            try:
                # å‘¨æœŸæ€§é‡‡é›†æµ‹é‡æ•°æ®
                for ied_name, client in self.mms_clients.items():
                    if client.connected:
                        self._collect_measurements(ied_name, client)
                
                time.sleep(2)  # 2ç§’é‡‡é›†å‘¨æœŸ
            except Exception as e:
                logger.error(f"Monitor loop error: {e}")
    
    def _collect_measurements(self, ied_name: str, client: MMSClient):
        """é‡‡é›†æµ‹é‡æ•°æ®"""
        ied = self.substation.ieds.get(ied_name)
        if not ied:
            return
        
        # éå†é€»è¾‘è®¾å¤‡å’Œé€»è¾‘èŠ‚ç‚¹é‡‡é›†æ•°æ®
        for ld_inst, ld in ied.logical_devices.items():
            for ln_name, ln in ld.logical_nodes.items():
                if ln.ln_class == LNClass.MMXU:  # æµ‹é‡é€»è¾‘èŠ‚ç‚¹
                    # é‡‡é›†ä¸‰ç›¸ç”µæµ
                    for phase in ['phsA', 'phsB', 'phsC']:
                        key = f"{ied_name}/{ld_inst}.{ln_name}.A.{phase}"
                        value = client.read_data_object(ld_inst, ln_name, f"A.{phase}")
                        if value:
                            self.measurements[key] = value
    
    def _on_goose_message(self, message: Dict):
        """å¤„ç†GOOSEæ¶ˆæ¯"""
        self.events.append({
            "type": "GOOSE",
            "timestamp": datetime.now().isoformat(),
            "data": message
        })
        logger.info(f"Received GOOSE message: {message.get('gocb_ref')}")
    
    def get_realtime_data(self) -> Dict[str, Any]:
        """è·å–å®æ—¶æ•°æ®"""
        return {
            "substation_id": self.substation.substation_id,
            "timestamp": datetime.now().isoformat(),
            "measurements": self.measurements,
            "ied_status": {
                name: {"connected": client.connected}
                for name, client in self.mms_clients.items()
            }
        }
    
    def get_events(self, limit: int = 100) -> List[Dict]:
        """è·å–äº‹ä»¶åˆ—è¡¨"""
        return self.events[-limit:]


def main():
    """ä¸»å‡½æ•° - æ¼”ç¤ºæ™ºèƒ½å˜ç”µç«™ç›‘æ§ç³»ç»Ÿ"""
    
    print("=" * 60)
    print("æ™ºèƒ½å˜ç”µç«™æ•°å­—åŒ–ç³»ç»Ÿæ¼”ç¤º")
    print("=" * 60)
    
    # 1. è§£æSCLé…ç½®
    print("\n[1] è§£æSCLé…ç½®æ–‡ä»¶")
    parser = SCLParser()
    
    # åˆ›å»ºç¤ºä¾‹å˜ç”µç«™ï¼ˆå®é™…åº”ä»æ–‡ä»¶è§£æï¼‰
    substation = Substation(
        substation_id="SUB-500kV-001",
        name="500kVæŸå˜ç”µç«™",
        voltage_level="500kV",
        location="æŸå¸‚é«˜æ–°æŠ€æœ¯å¼€å‘åŒº"
    )
    
    # æ·»åŠ IEDè®¾å¤‡
    ied1 = IED(
        name="PL2201",
        ied_type="Protection",
        manufacturer="å—ç‘ç»§ä¿",
        model="PCS-985",
        ip_address="192.168.1.101"
    )
    
    # æ·»åŠ é€»è¾‘è®¾å¤‡
    ld_meas = LogicalDevice(inst="MEAS1", desc="æµ‹é‡")
    ln_mx = LogicalNode(name="MMXU1", ln_class=LNClass.MMXU, prefix="", inst="1")
    ld_meas.logical_nodes["MMXU1"] = ln_mx
    ied1.logical_devices["MEAS1"] = ld_meas
    
    ld_prot = LogicalDevice(inst="PROT1", desc="ä¿æŠ¤")
    ln_prot = LogicalNode(name="PDIS1", ln_class=LNClass.PDIS, prefix="DIS", inst="1")
    ld_prot.logical_nodes["PDIS1"] = ln_prot
    ied1.logical_devices["PROT1"] = ld_prot
    
    substation.ieds["PL2201"] = ied1
    
    print(f"å˜ç”µç«™: {substation.name}")
    print(f"IEDè®¾å¤‡æ•°é‡: {len(substation.ieds)}")
    
    # 2. åˆå§‹åŒ–ç›‘æ§ç³»ç»Ÿ
    print("\n[2] åˆå§‹åŒ–ç›‘æ§ç³»ç»Ÿ")
    monitoring = SubstationMonitoringSystem(substation)
    monitoring.initialize()
    
    # 3. è¿æ¥IEDè®¾å¤‡
    print("\n[3] è¿æ¥IEDè®¾å¤‡")
    results = monitoring.connect_all_ieds()
    for ied_name, success in results.items():
        print(f"  {ied_name}: {'å·²è¿æ¥' if success else 'è¿æ¥å¤±è´¥'}")
    
    # 4. å¯åŠ¨ç›‘æ§
    print("\n[4] å¯åŠ¨å®æ—¶ç›‘æµ‹")
    monitoring.start_monitoring()
    
    # æ¨¡æ‹Ÿè¿è¡Œ
    import time
    time.sleep(5)
    
    # 5. è·å–å®æ—¶æ•°æ®
    print("\n[5] å®æ—¶æ•°æ®")
    data = monitoring.get_realtime_data()
    print(f"æµ‹é‡æ•°æ®ç‚¹æ•°: {len(data['measurements'])}")
    print(f"IEDè¿æ¥çŠ¶æ€: {data['ied_status']}")
    
    # 6. è·å–äº‹ä»¶
    print("\n[6] äº‹ä»¶è®°å½•")
    events = monitoring.get_events()
    print(f"äº‹ä»¶æ•°é‡: {len(events)}")
    
    # åœæ­¢ç›‘æ§
    monitoring.stop_monitoring()
    monitoring.disconnect_all_ieds()
    
    print("\n" + "=" * 60)
    print("æ¼”ç¤ºå®Œæˆ")
    print("=" * 60)


if __name__ == "__main__":
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | åŸºçº¿å€¼ | ç›®æ ‡å€¼ | å®é™…å€¼ | è¾¾æˆç‡ |
|------|--------|--------|--------|--------|
| æ•°æ®äº’é€šç‡ | 35% | 100% | 100% | 100% |
| äººå·¥å·¡æ£€å·¥ä½œé‡ | 100% | å‡å°‘70% | å‡å°‘75% | 107% |
| æ•…éšœå®šä½æ—¶é—´ | 30åˆ†é’Ÿ | â‰¤5åˆ†é’Ÿ | 3åˆ†é’Ÿ | 167% |
| è´¦å®ä¸€è‡´ç‡ | 85% | â‰¥99% | 99.2% | 100% |
| è¯¯æ“ä½œäº‹ä»¶ | å¹´å‡3èµ· | 0èµ· | 0èµ· | 100% |

**ROIåˆ†æ**ï¼š

1. **ç›´æ¥æˆæœ¬èŠ‚çº¦**
   - è¿ç»´äººåŠ›æˆæœ¬ï¼šè‡ªåŠ¨åŒ–å·¡æ£€å¹´èŠ‚çº¦äººåŠ›æˆæœ¬1200ä¸‡å…ƒ
   - æ•…éšœæŸå¤±å‡å°‘ï¼šæ•…éšœå¿«é€Ÿå®šä½å¹´å‡å°‘åœç”µæŸå¤±5000ä¸‡å…ƒ
   - èµ„äº§ç®¡ç†ä¼˜åŒ–ï¼šè´¦å®ä¸€è‡´åŒ–å¹´é™ä½èµ„äº§æµå¤±2000ä¸‡å…ƒ
   - **å¹´åº¦ç›´æ¥æ”¶ç›Šåˆè®¡ï¼š8200ä¸‡å…ƒ**

2. **é—´æ¥æ”¶ç›Š**
   - ä¾›ç”µå¯é æ€§æå‡ï¼šå°‘åœç”µå¸¦æ¥ç¤¾ä¼šç»æµæ•ˆç›Šä¼°ç®—2äº¿å…ƒ/å¹´
   - **å¹´åº¦é—´æ¥æ”¶ç›Šåˆè®¡ï¼š2äº¿å…ƒ**

3. **æŠ•èµ„å›æŠ¥**
   - é¡¹ç›®æ€»æŠ•èµ„ï¼š1.5äº¿å…ƒ
   - å¹´åº¦æ€»æ”¶ç›Šï¼š2.82äº¿å…ƒ
   - **æŠ•èµ„å›æ”¶æœŸï¼š6.4ä¸ªæœˆ**
   - **3å¹´ROIï¼š464%**

---

## 3. æ¡ˆä¾‹2ï¼šåŸå¸‚é…ç”µç½‘è‡ªåŠ¨åŒ–ç³»ç»Ÿ

### 3.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šæ¦‚å†µ**ï¼šæŸåŸå¸‚ä¾›ç”µå…¬å¸ï¼ˆä»¥ä¸‹ç®€ç§°"Fä¾›ç”µ"ï¼‰ï¼Œè´Ÿè´£æŸçœä¼šåŸå¸‚çš„ç”µåŠ›ä¾›åº”ï¼Œç®¡ç†ç€10kVé…ç”µçº¿è·¯è¶…è¿‡2000æ¡ï¼Œé…ç”µå˜å‹å™¨è¶…è¿‡15000å°ï¼ŒæœåŠ¡ç”¨ç”µå®¢æˆ·è¶…è¿‡200ä¸‡æˆ·ã€‚

### 3.2 ä¸šåŠ¡ç—›ç‚¹

1. **æ•…éšœå¤„ç†æ…¢**ï¼šé…ç”µç½‘æ•…éšœå®šä½ä¾èµ–å®¢æˆ·æŠ¥ä¿®ï¼Œå¹³å‡æ•…éšœå¤„ç†æ—¶é—´è¶…è¿‡2å°æ—¶ï¼Œå®¢æˆ·æŠ•è¯‰ç‡é«˜ã€‚

2. **è´Ÿè·ç®¡ç†ç²—æ”¾**ï¼šç¼ºä¹å®æ—¶è´Ÿè·ç›‘æµ‹æ‰‹æ®µï¼Œé«˜å³°æ—¶æ®µé¢‘ç¹å‡ºç°å˜å‹å™¨è¿‡è½½ï¼Œè®¾å¤‡å¯¿å‘½ç¼©çŸ­ã€‚

3. **çº¿æŸç»Ÿè®¡å›°éš¾**ï¼šé…ç”µç½‘æ‹“æ‰‘å…³ç³»å¤æ‚ï¼Œçº¿æŸè®¡ç®—è¯¯å·®å¤§ï¼Œçº¿æŸç‡é«˜è¾¾12%ï¼Œè¿œé«˜äºç†è®ºå€¼ã€‚

4. **åˆ†å¸ƒå¼ç”µæºæ¥å…¥éš¾**ï¼šå…‰ä¼ã€é£ç”µç­‰åˆ†å¸ƒå¼ç”µæºå¤§é‡æ¥å…¥ï¼Œå¯¹é…ç”µç½‘è¿è¡Œé€ æˆå†²å‡»ï¼Œç¼ºä¹æœ‰æ•ˆç®¡æ§æ‰‹æ®µã€‚

5. **æŠ¢ä¿®è°ƒåº¦ä½æ•ˆ**ï¼šæŠ¢ä¿®èµ„æºåˆ†æ•£ï¼Œç¼ºä¹ç»Ÿä¸€è°ƒåº¦å¹³å°ï¼ŒæŠ¢ä¿®è½¦è¾†ç©ºé©¶ç‡é«˜è¾¾30%ã€‚

### 3.3 ä¸šåŠ¡ç›®æ ‡

1. **æå‡æ•…éšœå¤„ç†æ•ˆç‡**ï¼šå®ç°æ•…éšœè‡ªåŠ¨å®šä½ã€éš”ç¦»å’Œæ¢å¤ï¼Œéæ•…éšœåŒºåŸŸæ¢å¤æ—¶é—´ç¼©çŸ­è‡³1åˆ†é’Ÿä»¥å†…ã€‚

2. **ç²¾ç»†åŒ–è´Ÿè·ç®¡ç†**ï¼šå®ç°é…ç”µå˜å‹å™¨è´Ÿè·å®æ—¶ç›‘æµ‹å’Œé¢„è­¦ï¼Œè¿‡è½½äº‹ä»¶å‡å°‘80%ã€‚

3. **é™ä½çº¿æŸç‡**ï¼šé€šè¿‡æ‹“æ‰‘åˆ†æå’Œæ•°æ®æ²»ç†ï¼Œçº¿æŸç‡é™ä½è‡³6%ä»¥å†…ã€‚

4. **æ”¯æ’‘åˆ†å¸ƒå¼èƒ½æºæ¥å…¥**ï¼šå»ºç«‹åˆ†å¸ƒå¼èƒ½æºç›‘æ§å¹³å°ï¼Œå®ç°å¯è§‚ã€å¯æµ‹ã€å¯æ§ã€‚

5. **ä¼˜åŒ–æŠ¢ä¿®è°ƒåº¦**ï¼šå»ºç«‹æ™ºèƒ½æŠ¢ä¿®è°ƒåº¦ç³»ç»Ÿï¼ŒæŠ¢ä¿®æ•ˆç‡æå‡50%ã€‚

### 3.4 æŠ€æœ¯æŒ‘æˆ˜

**æŒ‘æˆ˜1ï¼šå¤§è§„æ¨¡æ•°æ®é‡‡é›†**

- éœ€è¦é‡‡é›†è¶…è¿‡15000å°é…ç”µå˜å‹å™¨çš„è¿è¡Œæ•°æ®
- æ•°æ®åŒ…æ‹¬ç”µå‹ã€ç”µæµã€åŠŸç‡ã€æ¸©åº¦ç­‰å¤šç»´åº¦ä¿¡æ¯
- éœ€è¦æ”¯æŒåˆ†é’Ÿçº§ç”šè‡³ç§’çº§æ•°æ®é‡‡é›†é¢‘ç‡

**æŒ‘æˆ˜2ï¼šæ•…éšœå¿«é€Ÿå®šä½**

- é…ç”µç½‘ç»“æ„å¤æ‚ï¼Œéœ€è¦å¿«é€Ÿå‡†ç¡®åˆ¤æ–­æ•…éšœåŒºæ®µ
- éœ€è¦åè°ƒä¿æŠ¤è£…ç½®ã€å¼€å…³è®¾å¤‡çš„è”åŠ¨
- éœ€è¦è€ƒè™‘åˆ†å¸ƒå¼ç”µæºæ¥å…¥å¯¹æ•…éšœåˆ¤æ–­çš„å½±å“

**æŒ‘æˆ˜3ï¼šå®æ—¶æ‹“æ‰‘åˆ†æ**

- é…ç”µç½‘æ‹“æ‰‘ç»å¸¸å˜åŒ–ï¼ˆå¼€å…³çŠ¶æ€å˜åŒ–ï¼‰
- éœ€è¦å®æ—¶è·Ÿè¸ªç½‘ç»œæ‹“æ‰‘ï¼Œæ”¯æ’‘æ½®æµè®¡ç®—å’Œæ•…éšœåˆ†æ
- æ‹“æ‰‘åˆ†æç®—æ³•éœ€è¦é«˜æ€§èƒ½ï¼Œæ”¯æŒç§’çº§å“åº”

### 3.5 å®Œæ•´ä»£ç å®ç°

ç”±äºç¯‡å¹…é™åˆ¶ï¼Œæ­¤å¤„å±•ç¤ºæ ¸å¿ƒä»£ç ï¼š

```python
#!/usr/bin/env python3
"""
åŸå¸‚é…ç”µç½‘è‡ªåŠ¨åŒ–ç³»ç»Ÿ
åŠŸèƒ½ï¼šæ•…éšœå®šä½ã€è´Ÿè·ç›‘æµ‹ã€æ‹“æ‰‘åˆ†æã€æŠ¢ä¿®è°ƒåº¦
"""

from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum
import heapq


class DeviceType(str, Enum):
    """è®¾å¤‡ç±»å‹"""
    TRANSFORMER = "transformer"
    SWITCH = "switch"
    LINE = "line"


class SwitchStatus(str, Enum):
    """å¼€å…³çŠ¶æ€"""
    CLOSED = "closed"
    OPEN = "open"


@dataclass
class DistributionDevice:
    """é…ç”µè®¾å¤‡"""
    device_id: str
    device_type: DeviceType
    name: str
    voltage_level: str
    parent_id: Optional[str] = None
    children_ids: List[str] = field(default_factory=list)
    switch_status: Optional[SwitchStatus] = None
    measurements: Dict[str, float] = field(default_factory=dict)
    is_faulty: bool = False


class DistributionNetwork:
    """é…ç”µç½‘æ¨¡å‹"""
    
    def __init__(self):
        self.devices: Dict[str, DistributionDevice] = {}
        self.root_id: Optional[str] = None
    
    def add_device(self, device: DistributionDevice):
        """æ·»åŠ è®¾å¤‡"""
        self.devices[device.device_id] = device
    
    def get_powered_devices(self) -> Set[str]:
        """è·å–å½“å‰å¸¦ç”µè®¾å¤‡"""
        if not self.root_id:
            return set()
        
        powered = set()
        queue = [self.root_id]
        
        while queue:
            device_id = queue.pop(0)
            if device_id in powered:
                continue
            
            device = self.devices.get(device_id)
            if not device:
                continue
            
            # å¦‚æœæ˜¯å¼€å…³ä¸”æ–­å¼€ï¼Œåˆ™ä¸ç»§ç»­å‘ä¸‹ä¼ æ’­
            if device.device_type == DeviceType.SWITCH and device.switch_status == SwitchStatus.OPEN:
                continue
            
            powered.add(device_id)
            queue.extend(device.children_ids)
        
        return powered
    
    def locate_fault(self, faulty_devices: List[str]) -> Tuple[Set[str], Set[str]]:
        """æ•…éšœå®šä½ï¼Œè¿”å›æ•…éšœåŒºåŸŸå’Œéæ•…éšœåŒºåŸŸ"""
        all_powered = self.get_powered_devices()
        faulty_set = set(faulty_devices)
        
        # æ‰¾åˆ°éœ€è¦éš”ç¦»çš„æœ€å°åŒºåŸŸ
        isolation_zone = set()
        for fault_id in faulty_set:
            isolation_zone.add(fault_id)
            # æ·»åŠ æ•…éšœè®¾å¤‡ä¸‹æ¸¸è®¾å¤‡
            device = self.devices.get(fault_id)
            if device:
                queue = list(device.children_ids)
                while queue:
                    child_id = queue.pop(0)
                    isolation_zone.add(child_id)
                    child = self.devices.get(child_id)
                    if child:
                        queue.extend(child.children_ids)
        
        # éæ•…éšœåŒºåŸŸ
        restoration_zone = all_powered - isolation_zone
        
        return isolation_zone, restoration_zone
    
    def find_alternative_path(self, target_id: str) -> Optional[List[str]]:
        """å¯»æ‰¾æ›¿ä»£ä¾›ç”µè·¯å¾„"""
        # ç®€åŒ–çš„è·¯å¾„æœç´¢ç®—æ³•
        if target_id not in self.devices:
            return None
        
        # BFSå¯»æ‰¾ä»æ ¹èŠ‚ç‚¹åˆ°ç›®æ ‡çš„è·¯å¾„
        visited = {self.root_id}
        queue = [(self.root_id, [self.root_id])]
        
        while queue:
            current_id, path = queue.pop(0)
            
            if current_id == target_id:
                return path
            
            device = self.devices.get(current_id)
            if not device:
                continue
            
            for child_id in device.children_ids:
                if child_id not in visited:
                    child = self.devices.get(child_id)
                    if child and (child.device_type != DeviceType.SWITCH or 
                                 child.switch_status == SwitchStatus.CLOSED):
                        visited.add(child_id)
                        queue.append((child_id, path + [child_id]))
        
        return None


class FaultManagementSystem:
    """æ•…éšœç®¡ç†ç³»ç»Ÿ"""
    
    def __init__(self, network: DistributionNetwork):
        self.network = network
        self.fault_history: List[Dict] = []
    
    def process_fault_report(self, device_id: str, fault_type: str) -> Dict:
        """å¤„ç†æ•…éšœæŠ¥å‘Š"""
        timestamp = datetime.now()
        
        # æ•…éšœå®šä½
        isolation_zone, restoration_zone = self.network.locate_fault([device_id])
        
        # å¯»æ‰¾æ¢å¤è·¯å¾„
        restoration_plan = []
        for device_id in restoration_zone:
            if device_id not in self.network.get_powered_devices():
                path = self.network.find_alternative_path(device_id)
                if path:
                    restoration_plan.append({
                        "target": device_id,
                        "path": path
                    })
        
        fault_record = {
            "timestamp": timestamp.isoformat(),
            "fault_device": device_id,
            "fault_type": fault_type,
            "isolation_zone": list(isolation_zone),
            "restoration_zone": list(restoration_zone),
            "restoration_plan": restoration_plan,
            "status": "processing"
        }
        
        self.fault_history.append(fault_record)
        return fault_record


# ä½¿ç”¨ç¤ºä¾‹
def main():
    """é…ç”µç½‘è‡ªåŠ¨åŒ–æ¼”ç¤º"""
    
    network = DistributionNetwork()
    
    # æ„å»ºé…ç”µç½‘æ‹“æ‰‘
    # å˜ç”µç«™å‡ºçº¿
    network.root_id = "SUB-001"
    network.add_device(DistributionDevice(
        device_id="SUB-001",
        device_type=DeviceType.TRANSFORMER,
        name="110kVå˜ç”µç«™",
        voltage_level="110kV"
    ))
    
    # 10kVé¦ˆçº¿
    network.add_device(DistributionDevice(
        device_id="LINE-001",
        device_type=DeviceType.LINE,
        name="10kVé¦ˆçº¿1",
        voltage_level="10kV",
        parent_id="SUB-001"
    ))
    network.devices["SUB-001"].children_ids.append("LINE-001")
    
    # å¼€å…³
    network.add_device(DistributionDevice(
        device_id="SW-001",
        device_type=DeviceType.SWITCH,
        name="å¼€å…³001",
        voltage_level="10kV",
        parent_id="LINE-001",
        switch_status=SwitchStatus.CLOSED
    ))
    network.devices["LINE-001"].children_ids.append("SW-001")
    
    # é…ç”µå˜å‹å™¨
    for i in range(1, 6):
        device_id = f"DT-{i:03d}"
        network.add_device(DistributionDevice(
            device_id=device_id,
            device_type=DeviceType.TRANSFORMER,
            name=f"é…ç”µå˜å‹å™¨{i}",
            voltage_level="10kV/0.4kV",
            parent_id="SW-001"
        ))
        network.devices["SW-001"].children_ids.append(device_id)
    
    # æ•…éšœæ¨¡æ‹Ÿ
    print("=" * 60)
    print("é…ç”µç½‘æ•…éšœå¤„ç†æ¼”ç¤º")
    print("=" * 60)
    
    fault_system = FaultManagementSystem(network)
    
    print("\n[1] æ¨¡æ‹Ÿæ•…éšœ")
    network.devices["DT-003"].is_faulty = True
    
    print("\n[2] æ•…éšœå¤„ç†")
    result = fault_system.process_fault_report("DT-003", "çŸ­è·¯æ•…éšœ")
    
    print(f"æ•…éšœè®¾å¤‡: {result['fault_device']}")
    print(f"éš”ç¦»åŒºåŸŸ: {result['isolation_zone']}")
    print(f"æ¢å¤åŒºåŸŸ: {result['restoration_zone']}")
    print(f"æ¢å¤æ–¹æ¡ˆ: {result['restoration_plan']}")


if __name__ == "__main__":
    main()
```

### 3.6 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | åŸºçº¿å€¼ | ç›®æ ‡å€¼ | å®é™…å€¼ | è¾¾æˆç‡ |
|------|--------|--------|--------|--------|
| æ•…éšœå¤„ç†æ—¶é—´ | 2å°æ—¶ | â‰¤1åˆ†é’Ÿï¼ˆéæ•…éšœåŒºï¼‰ | 45ç§’ | 133% |
| å˜å‹å™¨è¿‡è½½äº‹ä»¶ | æœˆå‡50èµ· | å‡å°‘80% | å‡å°‘85% | 106% |
| çº¿æŸç‡ | 12% | â‰¤6% | 5.5% | 109% |
| æŠ¢ä¿®æ•ˆç‡ | åŸºå‡† | æå‡50% | æå‡60% | 120% |

**ROIåˆ†æ**ï¼š

1. **ç›´æ¥æˆæœ¬èŠ‚çº¦**
   - çº¿æŸé™ä½ï¼šå¹´èŠ‚çº¦ç”µé‡æˆæœ¬8000ä¸‡å…ƒ
   - æ•…éšœæŸå¤±å‡å°‘ï¼šå¹´å‡å°‘åœç”µæŸå¤±3000ä¸‡å…ƒ
   - è¿ç»´æˆæœ¬é™ä½ï¼šå¹´èŠ‚çº¦è¿ç»´æˆæœ¬2000ä¸‡å…ƒ
   - **å¹´åº¦ç›´æ¥èŠ‚çº¦åˆè®¡ï¼š1.3äº¿å…ƒ**

2. **é—´æ¥æ”¶ç›Š**
   - å®¢æˆ·æ»¡æ„åº¦æå‡ï¼šæŠ•è¯‰å‡å°‘å¸¦æ¥å“ç‰Œä»·å€¼æå‡
   - **å¹´åº¦é—´æ¥æ”¶ç›Šåˆè®¡ï¼š5000ä¸‡å…ƒ**

3. **æŠ•èµ„å›æŠ¥**
   - é¡¹ç›®æ€»æŠ•èµ„ï¼š8000ä¸‡å…ƒ
   - å¹´åº¦æ€»æ”¶ç›Šï¼š1.8äº¿å…ƒ
   - **æŠ•èµ„å›æ”¶æœŸï¼š5.3ä¸ªæœˆ**
   - **3å¹´ROIï¼š575%**

---

## 4. æ¡ˆä¾‹æ€»ç»“

é€šè¿‡ä¸¤ä¸ªç”µåŠ›è¡Œä¸šIEC 61850æ¡ˆä¾‹çš„å®æ–½ï¼Œæˆ‘ä»¬éªŒè¯äº†æ ‡å‡†åœ¨æ™ºèƒ½ç”µç½‘å»ºè®¾ä¸­çš„æ ¸å¿ƒä»·å€¼ï¼š

**å…³é”®æˆåŠŸå› ç´ **ï¼š

1. **æ ‡å‡†å…ˆè¡Œ**ï¼šIEC 61850æ˜¯å®ç°è®¾å¤‡äº’æ“ä½œçš„åŸºç¡€ï¼Œå¿…é¡»åœ¨é¡¹ç›®åˆæœŸç¡®ç«‹
2. **é¡¶å±‚è®¾è®¡**ï¼šæ™ºèƒ½ç”µç½‘æ¶‰åŠå¤šä¸ªç³»ç»Ÿï¼Œéœ€è¦ç»Ÿä¸€æ¶æ„è®¾è®¡
3. **åˆ†æ­¥å®æ–½**ï¼šä»è¯•ç‚¹åˆ°æ¨å¹¿ï¼Œå¾ªåºæ¸è¿›é™ä½é£é™©
4. **ç”Ÿæ€ååŒ**ï¼šéœ€è¦è®¾å¤‡å‚å•†ã€ç³»ç»Ÿé›†æˆå•†ã€ç”¨æˆ·å¤šæ–¹ååŒ

**æŠ€æœ¯æ¼”è¿›æ–¹å‘**ï¼š

1. **äº‘è¾¹ååŒ**ï¼šäº‘ç«¯å¤§æ•°æ®åˆ†æä¸è¾¹ç¼˜å®æ—¶æ§åˆ¶ç›¸ç»“åˆ
2. **AIèµ‹èƒ½**ï¼šäººå·¥æ™ºèƒ½åœ¨æ•…éšœè¯Šæ–­ã€è´Ÿè·é¢„æµ‹ç­‰åœºæ™¯çš„æ·±åº¦åº”ç”¨
3. **æ•°å­—å­ªç”Ÿ**ï¼šå»ºç«‹ç”µç½‘æ•°å­—å­ªç”Ÿï¼Œæ”¯æ’‘ä»¿çœŸåˆ†æå’Œå†³ç­–ä¼˜åŒ–

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æœ€åæ›´æ–°**ï¼š2025-02-15

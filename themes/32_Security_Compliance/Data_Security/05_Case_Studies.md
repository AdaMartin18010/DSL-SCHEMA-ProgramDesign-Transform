# æ•°æ®å®‰å…¨å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [æ•°æ®å®‰å…¨å®è·µæ¡ˆä¾‹](#æ•°æ®å®‰å…¨å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šä¼ä¸šçº§æ•°æ®å®‰å…¨å¹³å°](#2-æ¡ˆä¾‹1ä¼ä¸šçº§æ•°æ®å®‰å…¨å¹³å°)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹æ€»ç»“](#3-æ¡ˆä¾‹æ€»ç»“)
  - [4. å‚è€ƒæ–‡çŒ®](#4-å‚è€ƒæ–‡çŒ®)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ•°æ®å®‰å…¨åœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–æ•°æ®åˆ†ç±»ã€åŠ å¯†ã€è„±æ•ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡ç­‰åœºæ™¯ã€‚

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **Capital One**ï¼šäº‘æ•°æ®å®‰å…¨å®è·µ
- **Dropbox**ï¼šç«¯åˆ°ç«¯åŠ å¯†
- **Apple**ï¼šéšç§ä¿æŠ¤æŠ€æœ¯

---

## 2. æ¡ˆä¾‹1ï¼šä¼ä¸šçº§æ•°æ®å®‰å…¨å¹³å°

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šæŸåŒ»ç–—å¥åº·é›†å›¢ï¼ˆHealthFirstï¼‰

**ä¼ä¸šè§„æ¨¡**ï¼š
- å‘˜å·¥äººæ•°ï¼š25000+
- åŒ»ç–—æœºæ„ï¼š200+å®¶
- æ‚£è€…æ•°æ®ï¼š1äº¿+æ¡
- æ—¥å¤„ç†æ•°æ®é‡ï¼š10TB
- åˆè§„è¦æ±‚ï¼šHIPAA, GDPR

**æŠ€æœ¯æ ˆ**ï¼š
- æ•°æ®åº“ï¼šPostgreSQL, MongoDB, Elasticsearch
- å¤§æ•°æ®ï¼šHadoop, Spark
- äº‘å¹³å°ï¼šAWS, Azure
- å®‰å…¨å·¥å…·ï¼šHashiCorp Vault, AWS KMS

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **æ•°æ®åˆ†ç±»å›°éš¾**ï¼šä¸çŸ¥é“æ•æ„Ÿæ•°æ®åœ¨å“ªé‡Œã€æœ‰å¤šå°‘
2. **åŠ å¯†ç®¡ç†æ··ä¹±**ï¼šä¸åŒç³»ç»Ÿä½¿ç”¨ä¸åŒçš„åŠ å¯†æ–¹æ¡ˆ
3. **æ•°æ®è„±æ•ä¸è¶³**ï¼šéç”Ÿäº§ç¯å¢ƒä½¿ç”¨çœŸå®æ•°æ®
4. **è®¿é—®æ§åˆ¶ç²—æ”¾**ï¼šç¼ºä¹ç»†ç²’åº¦çš„æ•°æ®è®¿é—®æ§åˆ¶
5. **æ•°æ®æ³„éœ²é£é™©**ï¼šç¼ºä¹å®æ—¶ç›‘æ§å’Œå‘Šè­¦

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **è‡ªåŠ¨æ•°æ®åˆ†ç±»**ï¼šè‡ªåŠ¨å‘ç°å’Œåˆ†ç±»æ•æ„Ÿæ•°æ®
2. **ç»Ÿä¸€åŠ å¯†ç®¡ç†**ï¼šç»Ÿä¸€çš„åŠ å¯†å¯†é’¥ç”Ÿå‘½å‘¨æœŸç®¡ç†
3. **åŠ¨æ€æ•°æ®è„±æ•**ï¼šæ ¹æ®ç”¨æˆ·æƒé™åŠ¨æ€è„±æ•
4. **ç»†ç²’åº¦è®¿é—®æ§åˆ¶**ï¼šåŸºäºå±æ€§çš„è®¿é—®æ§åˆ¶ï¼ˆABACï¼‰
5. **å®æ—¶æ³„éœ²æ£€æµ‹**ï¼šå®æ—¶æ£€æµ‹å’Œå“åº”æ•°æ®æ³„éœ²

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **æ€§èƒ½å½±å“**ï¼šåŠ å¯†å’Œè„±æ•å¯¹æ€§èƒ½çš„å½±å“
2. **å¯†é’¥ç®¡ç†**ï¼šå¤§è§„æ¨¡å¯†é’¥çš„å®‰å…¨ç®¡ç†
3. **é—ç•™ç³»ç»Ÿ**ï¼šè€æ—§ç³»ç»Ÿçš„å®‰å…¨æ”¹é€ 
4. **åˆè§„å¤æ‚æ€§**ï¼šæ»¡è¶³å¤šåœ°åŒºæ³•è§„è¦æ±‚
5. **æ•°æ®æµåŠ¨**ï¼šæ•°æ®åœ¨ä¸åŒç³»ç»Ÿé—´æµåŠ¨çš„å®‰å…¨

### 2.5 è§£å†³æ–¹æ¡ˆ

**æ¶æ„è®¾è®¡**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Data Security Architecture                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Data Discovery Layer                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚  Data       â”‚  â”‚   ML-based  â”‚  â”‚    Classification   â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  Scanner    â”‚  â”‚   Classifierâ”‚  â”‚    Engine           â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Protection Layer                           â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚  Encryption â”‚  â”‚   Tokenizationâ”‚  â”‚   Masking         â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (AES/RSA)  â”‚  â”‚   Service   â”‚  â”‚   Service         â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Access Control Layer                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚    ABAC     â”‚  â”‚   RBAC      â”‚  â”‚    Policy Engine    â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  Engine     â”‚  â”‚   Fallback  â”‚  â”‚                     â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚                              â–¼                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Monitoring & Audit                         â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚  DLP        â”‚  â”‚   SIEM      â”‚  â”‚    Audit Log        â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  Scanner    â”‚  â”‚   Integrationâ”‚  â”‚    Storage          â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç»„ä»¶**ï¼š

1. **æ•°æ®å‘ç°å¼•æ“**ï¼šè‡ªåŠ¨æ‰«æå’Œåˆ†ç±»æ•°æ®
2. **åŠ å¯†æœåŠ¡**ï¼šç»Ÿä¸€çš„åŠ å¯†å’Œè§£å¯†æœåŠ¡
3. **ä»¤ç‰ŒåŒ–æœåŠ¡**ï¼šæ•æ„Ÿæ•°æ®ä»¤ç‰ŒåŒ–
4. **åŠ¨æ€è„±æ•**ï¼šæ ¹æ®æƒé™åŠ¨æ€è„±æ•
5. **DLPç³»ç»Ÿ**ï¼šæ•°æ®æ³„éœ²é˜²æŠ¤

### 2.6 å®Œæ•´ä»£ç å®ç°

**æ•°æ®å®‰å…¨å¹³å°Pythonå®ç°**ï¼š

```python
#!/usr/bin/env python3
"""
ä¼ä¸šçº§æ•°æ®å®‰å…¨å¹³å°
æ”¯æŒæ•°æ®åˆ†ç±»ã€åŠ å¯†ã€è„±æ•ã€è®¿é—®æ§åˆ¶ã€æ³„éœ²æ£€æµ‹ç­‰åŠŸèƒ½
"""

import re
import hashlib
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Set, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import base64
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import jwt


class DataClassification(Enum):
    """æ•°æ®åˆ†ç±»çº§åˆ«"""
    PUBLIC = "public"
    INTERNAL = "internal"
    CONFIDENTIAL = "confidential"
    RESTRICTED = "restricted"


class SensitivityLevel(Enum):
    """æ•æ„Ÿåº¦çº§åˆ«"""
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4


@dataclass
class DataField:
    """æ•°æ®å­—æ®µ"""
    name: str
    data_type: str
    classification: DataClassification
    sensitivity: SensitivityLevel
    patterns: List[str] = field(default_factory=list)
    examples: List[str] = field(default_factory=list)


@dataclass
class EncryptionKey:
    """åŠ å¯†å¯†é’¥"""
    id: str
    key_type: str  # symmetric, asymmetric
    algorithm: str  # AES-256, RSA-4096
    created_at: datetime
    expires_at: Optional[datetime]
    key_data: bytes
    key_status: str = "active"  # active, revoked, expired


@dataclass
class AccessPolicy:
    """è®¿é—®ç­–ç•¥"""
    id: str
    name: str
    resource_type: str
    resource_pattern: str
    allowed_classifications: List[DataClassification]
    allowed_actions: List[str]
    conditions: Dict[str, Any]
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class AuditEvent:
    """å®¡è®¡äº‹ä»¶"""
    id: str
    timestamp: datetime
    user_id: str
    action: str
    resource: str
    classification: DataClassification
    success: bool
    details: Dict[str, Any]
    risk_score: float


class DataClassifier:
    """æ•°æ®åˆ†ç±»å™¨"""

    # é¢„å®šä¹‰çš„æ•°æ®æ¨¡å¼
    PATTERNS = {
        'ssn': r'\b\d{3}-\d{2}-\d{4}\b',
        'credit_card': r'\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b',
        'email': r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',
        'phone': r'\b\d{3}-\d{3}-\d{4}\b',
        'date_of_birth': r'\b\d{2}/\d{2}/\d{4}\b',
        'medical_record': r'\bMRN\d{8,10}\b',
        'ip_address': r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b',
    }

    def __init__(self):
        self.logger = logging.getLogger('DataClassifier')
        self.custom_patterns: Dict[str, str] = {}

    def add_pattern(self, name: str, pattern: str, classification: DataClassification):
        """æ·»åŠ è‡ªå®šä¹‰æ¨¡å¼"""
        self.custom_patterns[name] = {
            'pattern': pattern,
            'classification': classification
        }

    def classify_text(self, text: str) -> List[Tuple[str, DataClassification]]:
        """
        å¯¹æ–‡æœ¬è¿›è¡Œåˆ†ç±»
        
        Args:
            text: å¾…åˆ†ç±»æ–‡æœ¬
            
        Returns:
            å‘ç°çš„æ•æ„Ÿæ•°æ®åˆ—è¡¨
        """
        findings = []
        
        # æ£€æŸ¥å†…ç½®æ¨¡å¼
        for data_type, pattern in self.PATTERNS.items():
            matches = re.finditer(pattern, text)
            for match in matches:
                classification = self._get_default_classification(data_type)
                findings.append((match.group(), classification))
        
        # æ£€æŸ¥è‡ªå®šä¹‰æ¨¡å¼
        for data_type, config in self.custom_patterns.items():
            matches = re.finditer(config['pattern'], text)
            for match in matches:
                findings.append((match.group(), config['classification']))
        
        return findings

    def _get_default_classification(self, data_type: str) -> DataClassification:
        """è·å–æ•°æ®ç±»å‹çš„é»˜è®¤åˆ†ç±»"""
        mapping = {
            'ssn': DataClassification.RESTRICTED,
            'credit_card': DataClassification.RESTRICTED,
            'email': DataClassification.CONFIDENTIAL,
            'phone': DataClassification.CONFIDENTIAL,
            'date_of_birth': DataClassification.CONFIDENTIAL,
            'medical_record': DataClassification.RESTRICTED,
            'ip_address': DataClassification.INTERNAL,
        }
        return mapping.get(data_type, DataClassification.INTERNAL)

    def scan_database(
        self,
        connection_string: str,
        table_name: str,
        sample_size: int = 1000
    ) -> Dict[str, DataClassification]:
        """
        æ‰«ææ•°æ®åº“è¡¨
        
        Args:
            connection_string: æ•°æ®åº“è¿æ¥å­—ç¬¦ä¸²
            table_name: è¡¨å
            sample_size: é‡‡æ ·å¤§å°
            
        Returns:
            åˆ—åˆ†ç±»ç»“æœ
        """
        # ç®€åŒ–çš„æ•°æ®åº“æ‰«æå®ç°
        # å®é™…åº”è¯¥ä½¿ç”¨SQLAlchemyç­‰åº“è¿æ¥æ•°æ®åº“
        columns = {}
        
        # æ¨¡æ‹Ÿæ‰«æç»“æœ
        columns['ssn'] = DataClassification.RESTRICTED
        columns['email'] = DataClassification.CONFIDENTIAL
        columns['name'] = DataClassification.INTERNAL
        
        return columns


class EncryptionService:
    """åŠ å¯†æœåŠ¡"""

    def __init__(self, master_key: bytes):
        """
        åˆå§‹åŒ–åŠ å¯†æœåŠ¡
        
        Args:
            master_key: ä¸»å¯†é’¥
        """
        self.master_key = master_key
        self.keys: Dict[str, EncryptionKey] = {}
        self.logger = logging.getLogger('EncryptionService')

    def generate_key(
        self,
        key_type: str = 'symmetric',
        algorithm: str = 'AES-256',
        ttl_days: Optional[int] = None
    ) -> EncryptionKey:
        """
        ç”Ÿæˆå¯†é’¥
        
        Args:
            key_type: å¯†é’¥ç±»å‹
            algorithm: ç®—æ³•
            ttl_days: æœ‰æ•ˆæœŸï¼ˆå¤©ï¼‰
            
        Returns:
            ç”Ÿæˆçš„å¯†é’¥
        """
        key_id = hashlib.sha256(str(datetime.now()).encode()).hexdigest()[:16]
        
        if key_type == 'symmetric':
            key_data = Fernet.generate_key()
        else:
            # ç”ŸæˆRSAå¯†é’¥å¯¹
            private_key = rsa.generate_private_key(
                public_exponent=65537,
                key_size=4096
            )
            key_data = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )
        
        expires_at = None
        if ttl_days:
            expires_at = datetime.now() + timedelta(days=ttl_days)
        
        key = EncryptionKey(
            id=key_id,
            key_type=key_type,
            algorithm=algorithm,
            created_at=datetime.now(),
            expires_at=expires_at,
            key_data=key_data
        )
        
        self.keys[key_id] = key
        self.logger.info(f"ç”Ÿæˆå¯†é’¥: {key_id}")
        
        return key

    def encrypt(self, plaintext: str, key_id: str) -> str:
        """
        åŠ å¯†æ•°æ®
        
        Args:
            plaintext: æ˜æ–‡
            key_id: å¯†é’¥ID
            
        Returns:
            å¯†æ–‡ï¼ˆBase64ç¼–ç ï¼‰
        """
        key = self.keys.get(key_id)
        if not key or key.key_status != 'active':
            raise ValueError(f"å¯†é’¥æ— æ•ˆæˆ–å·²å¤±æ•ˆ: {key_id}")
        
        if key.key_type == 'symmetric':
            f = Fernet(key.key_data)
            ciphertext = f.encrypt(plaintext.encode())
            return base64.b64encode(ciphertext).decode()
        else:
            # RSAåŠ å¯†
            private_key = serialization.load_pem_private_key(key.key_data, password=None)
            public_key = private_key.public_key()
            ciphertext = public_key.encrypt(
                plaintext.encode(),
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            return base64.b64encode(ciphertext).decode()

    def decrypt(self, ciphertext: str, key_id: str) -> str:
        """
        è§£å¯†æ•°æ®
        
        Args:
            ciphertext: å¯†æ–‡ï¼ˆBase64ç¼–ç ï¼‰
            key_id: å¯†é’¥ID
            
        Returns:
            æ˜æ–‡
        """
        key = self.keys.get(key_id)
        if not key:
            raise ValueError(f"å¯†é’¥ä¸å­˜åœ¨: {key_id}")
        
        ciphertext_bytes = base64.b64decode(ciphertext)
        
        if key.key_type == 'symmetric':
            f = Fernet(key.key_data)
            plaintext = f.decrypt(ciphertext_bytes)
            return plaintext.decode()
        else:
            # RSAè§£å¯†
            private_key = serialization.load_pem_private_key(key.key_data, password=None)
            plaintext = private_key.decrypt(
                ciphertext_bytes,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            return plaintext.decode()

    def rotate_key(self, key_id: str) -> EncryptionKey:
        """
        è½®æ¢å¯†é’¥
        
        Args:
            key_id: æ—§å¯†é’¥ID
            
        Returns:
            æ–°å¯†é’¥
        """
        old_key = self.keys.get(key_id)
        if not old_key:
            raise ValueError(f"å¯†é’¥ä¸å­˜åœ¨: {key_id}")
        
        # æ ‡è®°æ—§å¯†é’¥ä¸ºå·²æ’¤é”€
        old_key.key_status = 'revoked'
        
        # ç”Ÿæˆæ–°å¯†é’¥
        new_key = self.generate_key(
            key_type=old_key.key_type,
            algorithm=old_key.algorithm
        )
        
        self.logger.info(f"å¯†é’¥è½®æ¢: {key_id} -> {new_key.id}")
        
        return new_key


class DataMaskingService:
    """æ•°æ®è„±æ•æœåŠ¡"""

    MASKING_RULES = {
        'ssn': lambda x: f"XXX-XX-{x[-4:]}",
        'credit_card': lambda x: f"****-****-****-{x[-4:]}",
        'email': lambda x: f"{x[0]}***@{x.split('@')[1]}",
        'phone': lambda x: f"(XXX) XXX-{x[-4:]}",
        'name': lambda x: f"{x[0]}***",
    }

    def __init__(self):
        self.logger = logging.getLogger('DataMaskingService')

    def mask(
        self,
        data: str,
        data_type: str,
        masking_level: str = 'partial'
    ) -> str:
        """
        è„±æ•æ•°æ®
        
        Args:
            data: åŸå§‹æ•°æ®
            data_type: æ•°æ®ç±»å‹
            masking_level: è„±æ•çº§åˆ«ï¼ˆpartial, full, hashï¼‰
            
        Returns:
            è„±æ•åçš„æ•°æ®
        """
        if masking_level == 'full':
            return '*' * len(data)
        elif masking_level == 'hash':
            return hashlib.sha256(data.encode()).hexdigest()[:16]
        
        # éƒ¨åˆ†è„±æ•
        rule = self.MASKING_RULES.get(data_type)
        if rule:
            return rule(data)
        
        # é»˜è®¤è„±æ•è§„åˆ™
        if len(data) <= 4:
            return '*' * len(data)
        else:
            return f"{'*' * (len(data) - 4)}{data[-4:]}"

    def mask_json(
        self,
        data: Dict,
        sensitive_fields: List[str],
        masking_level: str = 'partial'
    ) -> Dict:
        """
        è„±æ•JSONæ•°æ®
        
        Args:
            data: åŸå§‹æ•°æ®
            sensitive_fields: æ•æ„Ÿå­—æ®µåˆ—è¡¨
            masking_level: è„±æ•çº§åˆ«
            
        Returns:
            è„±æ•åçš„æ•°æ®
        """
        result = {}
        
        for key, value in data.items():
            if key in sensitive_fields and isinstance(value, str):
                result[key] = self.mask(value, key, masking_level)
            elif isinstance(value, dict):
                result[key] = self.mask_json(value, sensitive_fields, masking_level)
            elif isinstance(value, list):
                result[key] = [
                    self.mask_json(item, sensitive_fields, masking_level) 
                    if isinstance(item, dict) else item
                    for item in value
                ]
            else:
                result[key] = value
        
        return result


class AccessControlEngine:
    """è®¿é—®æ§åˆ¶å¼•æ“"""

    def __init__(self):
        self.policies: Dict[str, AccessPolicy] = {}
        self.logger = logging.getLogger('AccessControlEngine')

    def create_policy(
        self,
        name: str,
        resource_type: str,
        resource_pattern: str,
        allowed_classifications: List[DataClassification],
        allowed_actions: List[str],
        conditions: Optional[Dict] = None
    ) -> AccessPolicy:
        """åˆ›å»ºè®¿é—®ç­–ç•¥"""
        policy_id = hashlib.sha256(name.encode()).hexdigest()[:16]
        
        policy = AccessPolicy(
            id=policy_id,
            name=name,
            resource_type=resource_type,
            resource_pattern=resource_pattern,
            allowed_classifications=allowed_classifications,
            allowed_actions=allowed_actions,
            conditions=conditions or {}
        )
        
        self.policies[policy_id] = policy
        return policy

    def check_access(
        self,
        user_id: str,
        user_attributes: Dict,
        resource: str,
        resource_classification: DataClassification,
        action: str,
        context: Optional[Dict] = None
    ) -> Tuple[bool, str]:
        """
        æ£€æŸ¥è®¿é—®æƒé™
        
        Args:
            user_id: ç”¨æˆ·ID
            user_attributes: ç”¨æˆ·å±æ€§
            resource: èµ„æº
            resource_classification: èµ„æºåˆ†ç±»
            action: æ“ä½œ
            context: ä¸Šä¸‹æ–‡
            
        Returns:
            (æ˜¯å¦å…è®¸, åŸå› )
        """
        # æŸ¥æ‰¾åŒ¹é…çš„ç­–ç•¥
        matching_policies = []
        for policy in self.policies.values():
            if self._resource_matches(policy, resource):
                if resource_classification in policy.allowed_classifications:
                    if action in policy.allowed_actions:
                        matching_policies.append(policy)
        
        if not matching_policies:
            return False, "æ²¡æœ‰åŒ¹é…çš„ç­–ç•¥"
        
        # è¯„ä¼°ç­–ç•¥æ¡ä»¶
        for policy in matching_policies:
            if self._evaluate_conditions(policy.conditions, user_attributes, context):
                return True, f"ç­–ç•¥å…è®¸: {policy.name}"
        
        return False, "ä¸æ»¡è¶³ç­–ç•¥æ¡ä»¶"

    def _resource_matches(self, policy: AccessPolicy, resource: str) -> bool:
        """æ£€æŸ¥èµ„æºæ˜¯å¦åŒ¹é…ç­–ç•¥"""
        import fnmatch
        return fnmatch.fnmatch(resource, policy.resource_pattern)

    def _evaluate_conditions(
        self,
        conditions: Dict,
        user_attributes: Dict,
        context: Optional[Dict]
    ) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        context = context or {}
        
        for key, expected in conditions.items():
            if key.startswith('user.'):
                actual = user_attributes.get(key[5:])
            elif key.startswith('context.'):
                actual = context.get(key[8:])
            else:
                actual = user_attributes.get(key)
            
            if actual != expected:
                return False
        
        return True


class DataSecurityPlatform:
    """æ•°æ®å®‰å…¨å¹³å°"""

    def __init__(self, master_key: bytes):
        """
        åˆå§‹åŒ–æ•°æ®å®‰å…¨å¹³å°
        
        Args:
            master_key: ä¸»å¯†é’¥
        """
        self.classifier = DataClassifier()
        self.encryption = EncryptionService(master_key)
        self.masking = DataMaskingService()
        self.access_control = AccessControlEngine()
        self.audit_log: List[AuditEvent] = []
        self.logger = logging.getLogger('DataSecurityPlatform')

    def protect_data(
        self,
        data: str,
        data_type: str,
        protection_method: str = 'encryption'
    ) -> Dict:
        """
        ä¿æŠ¤æ•°æ®
        
        Args:
            data: åŸå§‹æ•°æ®
            data_type: æ•°æ®ç±»å‹
            protection_method: ä¿æŠ¤æ–¹æ³•ï¼ˆencryption, tokenization, maskingï¼‰
            
        Returns:
            ä¿æŠ¤åçš„æ•°æ®ä¿¡æ¯
        """
        # åˆ†ç±»æ•°æ®
        classification = self.classifier._get_default_classification(data_type)
        
        if protection_method == 'encryption':
            # ç”Ÿæˆæˆ–ä½¿ç”¨ç°æœ‰å¯†é’¥
            key = self.encryption.generate_key()
            protected = self.encryption.encrypt(data, key.id)
            return {
                'method': 'encryption',
                'data': protected,
                'key_id': key.id,
                'classification': classification.value
            }
        elif protection_method == 'masking':
            protected = self.masking.mask(data, data_type)
            return {
                'method': 'masking',
                'data': protected,
                'classification': classification.value
            }
        else:
            raise ValueError(f"æœªçŸ¥çš„ä¿æŠ¤æ–¹æ³•: {protection_method}")

    def access_data(
        self,
        user_id: str,
        user_attributes: Dict,
        protected_data: Dict,
        action: str = 'read',
        context: Optional[Dict] = None
    ) -> Optional[str]:
        """
        è®¿é—®å—ä¿æŠ¤æ•°æ®
        
        Args:
            user_id: ç”¨æˆ·ID
            user_attributes: ç”¨æˆ·å±æ€§
            protected_data: å—ä¿æŠ¤æ•°æ®ä¿¡æ¯
            action: æ“ä½œ
            context: ä¸Šä¸‹æ–‡
            
        Returns:
            åŸå§‹æ•°æ®ï¼ˆå¦‚æœæœ‰æƒé™ï¼‰
        """
        # æ£€æŸ¥è®¿é—®æƒé™
        classification = DataClassification(protected_data['classification'])
        
        allowed, reason = self.access_control.check_access(
            user_id=user_id,
            user_attributes=user_attributes,
            resource=protected_data.get('resource', 'unknown'),
            resource_classification=classification,
            action=action,
            context=context
        )
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        event = AuditEvent(
            id=hashlib.sha256(str(datetime.now()).encode()).hexdigest()[:16],
            timestamp=datetime.now(),
            user_id=user_id,
            action=action,
            resource=protected_data.get('resource', 'unknown'),
            classification=classification,
            success=allowed,
            details={'reason': reason},
            risk_score=0.0
        )
        self.audit_log.append(event)
        
        if not allowed:
            self.logger.warning(f"è®¿é—®è¢«æ‹’ç»: {user_id} - {reason}")
            return None
        
        # è§£å¯†æ•°æ®
        if protected_data['method'] == 'encryption':
            return self.encryption.decrypt(
                protected_data['data'],
                protected_data['key_id']
            )
        else:
            return protected_data['data']

    def get_audit_report(
        self,
        start_time: datetime,
        end_time: datetime,
        user_id: Optional[str] = None
    ) -> List[AuditEvent]:
        """è·å–å®¡è®¡æŠ¥å‘Š"""
        events = [
            e for e in self.audit_log
            if start_time <= e.timestamp <= end_time
        ]
        
        if user_id:
            events = [e for e in events if e.user_id == user_id]
        
        return events


def main():
    """ä¸»å‡½æ•°"""
    # åˆå§‹åŒ–å¹³å°
    platform = DataSecurityPlatform(master_key=Fernet.generate_key())
    
    # åˆ›å»ºè®¿é—®ç­–ç•¥
    platform.access_control.create_policy(
        name='doctors_access_phi',
        resource_type='patient_data',
        resource_pattern='patient.*',
        allowed_classifications=[
            DataClassification.INTERNAL,
            DataClassification.CONFIDENTIAL,
            DataClassification.RESTRICTED
        ],
        allowed_actions=['read', 'write'],
        conditions={'user.role': 'doctor', 'context.location': 'hospital'}
    )
    
    # ä¿æŠ¤æ•æ„Ÿæ•°æ®
    patient_ssn = "123-45-6789"
    protected = platform.protect_data(patient_ssn, 'ssn', 'encryption')
    print(f"ä¿æŠ¤åçš„æ•°æ®: {protected['data'][:30]}...")
    
    # è®¿é—®æ•°æ®
    user_attributes = {
        'role': 'doctor',
        'department': 'cardiology'
    }
    
    result = platform.access_data(
        user_id='doc123',
        user_attributes=user_attributes,
        protected_data=protected,
        action='read',
        context={'location': 'hospital', 'time': 'daytime'}
    )
    
    if result:
        print(f"è§£å¯†æˆåŠŸ: {result}")
    else:
        print("è®¿é—®è¢«æ‹’ç»")


if __name__ == '__main__':
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| æ•æ„Ÿæ•°æ®å‘ç°ç‡ | 40% | 95% | 137%æå‡ |
| æ•°æ®åŠ å¯†è¦†ç›–ç‡ | 30% | 100% | 233%æå‡ |
| æ•°æ®æ³„éœ²äº‹ä»¶ | 3æ¬¡/å¹´ | 0æ¬¡/å¹´ | 100%æ¶ˆé™¤ |
| åˆè§„å®¡è®¡æ—¶é—´ | 4å‘¨ | 1å‘¨ | 75%ç¼©çŸ­ |
| è„±æ•å¤„ç†æ—¶é—´ | æ‰‹åŠ¨ | å®æ—¶ | æ˜¾è‘—æå‡ |

**ROIåˆ†æ**ï¼š

1. **æˆæœ¬èŠ‚çº¦**ï¼š
   - æ•°æ®æ³„éœ²æˆæœ¬ï¼šæ¯å¹´ 2000ä¸‡å…ƒ
   - åˆè§„å®¡è®¡æˆæœ¬ï¼šæ¯å¹´ 500ä¸‡å…ƒ
   - äººå·¥åˆ†ç±»æˆæœ¬ï¼šæ¯å¹´ 300ä¸‡å…ƒ

2. **æŠ•èµ„å›æŠ¥ç‡**ï¼š
   - æ€»æŠ•èµ„ï¼š800ä¸‡å…ƒ
   - å¹´åº¦æ”¶ç›Šï¼š2800ä¸‡å…ƒ
   - ROIï¼š350%

**ç»éªŒæ•™è®­**ï¼š

1. **æ•°æ®åˆ†ç±»å…ˆè¡Œ**ï¼šå¿…é¡»å…ˆå‘ç°å’Œåˆ†ç±»æ•°æ®
2. **åŠ å¯†å½±å“è¯„ä¼°**ï¼šè¯„ä¼°åŠ å¯†å¯¹æ€§èƒ½çš„å½±å“
3. **å¯†é’¥ç®¡ç†é‡è¦**ï¼šå¯†é’¥ç®¡ç†æ˜¯åŠ å¯†çš„æ ¸å¿ƒ
4. **æŒç»­ç›‘æ§**ï¼šæ•°æ®å®‰å…¨éœ€è¦æŒç»­ç›‘æ§

---

## 3. æ¡ˆä¾‹æ€»ç»“

### æˆåŠŸå› ç´ 

1. **å…¨é¢å‘ç°**ï¼šè‡ªåŠ¨å‘ç°å’Œåˆ†ç±»æ‰€æœ‰æ•æ„Ÿæ•°æ®
2. **ç»Ÿä¸€åŠ å¯†**ï¼šç»Ÿä¸€çš„åŠ å¯†å’Œå¯†é’¥ç®¡ç†
3. **åŠ¨æ€è„±æ•**ï¼šæ ¹æ®ä¸Šä¸‹æ–‡åŠ¨æ€è„±æ•
4. **ç»†ç²’åº¦æ§åˆ¶**ï¼šåŸºäºå±æ€§çš„è®¿é—®æ§åˆ¶

### æœ€ä½³å®è·µ

1. **æ•°æ®åˆ†ç±»åˆ†çº§**ï¼šå»ºç«‹æ¸…æ™°çš„æ•°æ®åˆ†ç±»æ ‡å‡†
2. **æœ€å°æƒé™åŸåˆ™**ï¼šåªæˆäºˆå¿…è¦çš„è®¿é—®æƒé™
3. **æŒç»­ç›‘æ§**ï¼šå®æ—¶ç›‘æ§æ•°æ®è®¿é—®
4. **å®šæœŸå®¡è®¡**ï¼šå®šæœŸå®¡æŸ¥è®¿é—®æ—¥å¿—

---

## 4. å‚è€ƒæ–‡çŒ®

- [NISTæ•°æ®å®‰å…¨æŒ‡å—](https://csrc.nist.gov/publications/detail/sp/800-111/final)
- [GDPRå®˜æ–¹æŒ‡å—](https://gdpr.eu/)
- [HIPAAå®‰å…¨è§„åˆ™](https://www.hhs.gov/hipaa/for-professionals/security/index.html)

---

**æ–‡æ¡£åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**ç»´æŠ¤è€…**ï¼šDSL Schemaç ”ç©¶å›¢é˜Ÿ  
**æœ€åæ›´æ–°**ï¼š2025-01-21

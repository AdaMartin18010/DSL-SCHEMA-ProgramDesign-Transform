# é›¶ä¿¡ä»»Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [é›¶ä¿¡ä»»Schemaå®è·µæ¡ˆä¾‹](#é›¶ä¿¡ä»»schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šä¼ä¸šé›¶ä¿¡ä»»æ¶æ„å®æ–½](#2-æ¡ˆä¾‹1ä¼ä¸šé›¶ä¿¡ä»»æ¶æ„å®æ–½)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 å®Œæ•´ä»£ç å®ç°](#25-å®Œæ•´ä»£ç å®ç°)
    - [2.6 æ•ˆæœè¯„ä¼°ä¸ROI](#26-æ•ˆæœè¯„ä¼°ä¸roi)
  - [3. æ¡ˆä¾‹æ€»ç»“](#3-æ¡ˆä¾‹æ€»ç»“)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›**é›¶ä¿¡ä»»å®‰å…¨æ¶æ„**åœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ã€‚é›¶ä¿¡ä»»éµå¾ª"æ°¸ä¸ä¿¡ä»»ï¼Œå§‹ç»ˆéªŒè¯"åŸåˆ™ï¼Œé€šè¿‡èº«ä»½éªŒè¯ã€è®¾å¤‡éªŒè¯ã€æœ€å°æƒé™ç­‰æœºåˆ¶ä¿æŠ¤ä¼ä¸šèµ„æºã€‚

---

## 2. æ¡ˆä¾‹1ï¼šä¼ä¸šé›¶ä¿¡ä»»æ¶æ„å®æ–½

### 2.1 ä¼ä¸šèƒŒæ™¯

æŸå¤§å‹é‡‘èæœºæ„ï¼ˆä»¥ä¸‹ç®€ç§°"FinSecure"ï¼‰æ‹¥æœ‰20,000+å‘˜å·¥ï¼Œä¸šåŠ¡ç³»ç»Ÿè¶…è¿‡500ä¸ªã€‚ä¼ ç»ŸVPNæ¶æ„é¢ä¸´å®‰å…¨å¨èƒï¼Œéœ€è¦æ„å»ºç°ä»£åŒ–çš„é›¶ä¿¡ä»»å®‰å…¨ä½“ç³»ã€‚

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **VPNå®‰å…¨æ€§ä¸è¶³**ï¼šä¼ ç»ŸVPNä¸€æ—¦è¢«æ”»ç ´ï¼Œæ”»å‡»è€…å¯è‡ªç”±è®¿é—®å†…ç½‘èµ„æº
2. **å†…éƒ¨å¨èƒéš¾ä»¥é˜²èŒƒ**ï¼šç¼ºä¹å¯¹å†…éƒ¨ç”¨æˆ·è¡Œä¸ºçš„ç»†ç²’åº¦ç›‘æ§
3. **å¤šäº‘è®¿é—®å¤æ‚**ï¼šå¤šä¸ªäº‘å¹³å°çš„è®¿é—®ç®¡ç†ä¸ç»Ÿä¸€
4. **åˆè§„è¦æ±‚ä¸¥æ ¼**ï¼šé‡‘èç›‘ç®¡è¦æ±‚ä¸¥æ ¼çš„è®¿é—®æ§åˆ¶å’Œå®¡è®¡

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. å®ç°æ— VPNçš„å®‰å…¨è¿œç¨‹è®¿é—®
2. å»ºç«‹åŸºäºèº«ä»½å’Œè®¾å¤‡çš„åŠ¨æ€è®¿é—®æ§åˆ¶
3. å®ç°å¤šäº‘èµ„æºçš„ç»Ÿä¸€è®¿é—®ç®¡ç†
4. æ»¡è¶³é‡‘èç›‘ç®¡åˆè§„è¦æ±‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. é«˜å¹¶å‘èº«ä»½éªŒè¯ï¼ˆ50,000+å¹¶å‘ç”¨æˆ·ï¼‰
2. å®æ—¶è®¾å¤‡åˆè§„æ£€æŸ¥
3. å¾®æœåŠ¡é—´çš„å®‰å…¨é€šä¿¡
4. é—ç•™ç³»ç»Ÿå…¼å®¹

### 2.5 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
é›¶ä¿¡ä»»ç­–ç•¥å¼•æ“
FinSecure é›¶ä¿¡ä»»æ¶æ„æ ¸å¿ƒç»„ä»¶
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set
from enum import Enum
import json
import jwt
import hashlib


class TrustLevel(Enum):
    """ä¿¡ä»»ç­‰çº§"""
    UNTRUSTED = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3


class AccessDecision(Enum):
    """è®¿é—®å†³ç­–"""
    DENY = "deny"
    ALLOW = "allow"
    MFA_REQUIRED = "mfa_required"
    STEP_UP = "step_up"


@dataclass
class Identity:
    """èº«ä»½ä¿¡æ¯"""
    user_id: str
    username: str
    email: str
    groups: List[str] = field(default_factory=list)
    mfa_verified: bool = False
    last_auth_time: datetime = field(default_factory=datetime.now)
    risk_score: float = 0.0


@dataclass
class Device:
    """è®¾å¤‡ä¿¡æ¯"""
    device_id: str
    device_type: str  # laptop, mobile, tablet
    os_version: str
    compliance_status: bool = False
    trust_score: float = 0.0
    installed_certs: bool = False
    encryption_enabled: bool = False


@dataclass
class AccessRequest:
    """è®¿é—®è¯·æ±‚"""
    request_id: str
    identity: Identity
    device: Device
    resource: str
    action: str
    location: str
    timestamp: datetime = field(default_factory=datetime.now)


class ZeroTrustPolicyEngine:
    """é›¶ä¿¡ä»»ç­–ç•¥å¼•æ“"""
    
    def __init__(self):
        self.policies = []
        self.risk_threshold = 0.7
        self.session_duration = timedelta(hours=8)
        self._load_policies()
    
    def _load_policies(self):
        """åŠ è½½ç­–ç•¥"""
        self.policies = [
            {
                'name': 'Require MFA for Admin',
                'condition': lambda req: 'admin' in req.identity.groups,
                'action': AccessDecision.MFA_REQUIRED
            },
            {
                'name': 'Block Non-compliant Devices',
                'condition': lambda req: not req.device.compliance_status,
                'action': AccessDecision.DENY
            },
            {
                'name': 'High Risk User Review',
                'condition': lambda req: req.identity.risk_score > 0.8,
                'action': AccessDecision.STEP_UP
            },
            {
                'name': 'Off-hours Access Restricted',
                'condition': lambda req: not self._is_business_hours(req.timestamp),
                'action': AccessDecision.MFA_REQUIRED
            }
        ]
    
    def _is_business_hours(self, timestamp: datetime) -> bool:
        """æ£€æŸ¥æ˜¯å¦å·¥ä½œæ—¶é—´"""
        return 9 <= timestamp.hour < 18
    
    def evaluate(self, request: AccessRequest) -> Dict:
        """è¯„ä¼°è®¿é—®è¯·æ±‚"""
        # 1. è®¡ç®—ç»¼åˆä¿¡ä»»åˆ†æ•°
        trust_score = self._calculate_trust_score(request)
        
        # 2. åº”ç”¨ç­–ç•¥
        decision = AccessDecision.ALLOW
        matched_policies = []
        
        for policy in self.policies:
            if policy['condition'](request):
                decision = policy['action']
                matched_policies.append(policy['name'])
                
                if decision == AccessDecision.DENY:
                    break
        
        # 3. æ£€æŸ¥ä¿¡ä»»é˜ˆå€¼
        if trust_score < 0.3 and decision == AccessDecision.ALLOW:
            decision = AccessDecision.MFA_REQUIRED
        
        # 4. ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
        token = None
        if decision == AccessDecision.ALLOW:
            token = self._generate_token(request, trust_score)
        
        return {
            'request_id': request.request_id,
            'decision': decision.value,
            'trust_score': trust_score,
            'matched_policies': matched_policies,
            'token': token,
            'expires_at': (datetime.now() + self.session_duration).isoformat()
        }
    
    def _calculate_trust_score(self, request: AccessRequest) -> float:
        """è®¡ç®—ä¿¡ä»»åˆ†æ•°"""
        scores = []
        
        # èº«ä»½åˆ†æ•°
        identity_score = 1.0 - request.identity.risk_score
        if request.identity.mfa_verified:
            identity_score += 0.2
        scores.append(identity_score)
        
        # è®¾å¤‡åˆ†æ•°
        device_score = request.device.trust_score
        if request.device.compliance_status:
            device_score += 0.3
        scores.append(device_score)
        
        # è¡Œä¸ºåˆ†æ•°ï¼ˆç®€åŒ–ï¼‰
        behavior_score = 0.8  # é»˜è®¤è‰¯å¥½
        scores.append(behavior_score)
        
        return sum(scores) / len(scores)
    
    def _generate_token(self, request: AccessRequest, trust_score: float) -> str:
        """ç”ŸæˆJWTä»¤ç‰Œ"""
        payload = {
            'sub': request.identity.user_id,
            'device': request.device.device_id,
            'resource': request.resource,
            'trust_level': self._trust_level(trust_score).name,
            'iat': datetime.now(),
            'exp': datetime.now() + self.session_duration
        }
        
        return jwt.encode(payload, 'secret', algorithm='HS256')
    
    def _trust_level(self, score: float) -> TrustLevel:
        """ä¿¡ä»»ç­‰çº§"""
        if score >= 0.8:
            return TrustLevel.HIGH
        elif score >= 0.5:
            return TrustLevel.MEDIUM
        elif score >= 0.3:
            return TrustLevel.LOW
        return TrustLevel.UNTRUSTED


# æ¼”ç¤º
if __name__ == "__main__":
    print("é›¶ä¿¡ä»»ç­–ç•¥å¼•æ“æ¼”ç¤º")
    print("-" * 50)
    
    engine = ZeroTrustPolicyEngine()
    
    # æ­£å¸¸ç”¨æˆ·è¯·æ±‚
    request1 = AccessRequest(
        request_id="REQ001",
        identity=Identity(
            user_id="U001",
            username="john.doe",
            email="john@company.com",
            groups=["users"],
            mfa_verified=True,
            risk_score=0.1
        ),
        device=Device(
            device_id="D001",
            device_type="laptop",
            os_version="Windows 11",
            compliance_status=True,
            trust_score=0.8
        ),
        resource="intranet.portal",
        action="read",
        location="office"
    )
    
    result1 = engine.evaluate(request1)
    print(f"æ­£å¸¸ç”¨æˆ·: {result1['decision']} (ä¿¡ä»»åº¦: {result1['trust_score']:.2f})")
    
    # é«˜é£é™©ç”¨æˆ·è¯·æ±‚
    request2 = AccessRequest(
        request_id="REQ002",
        identity=Identity(
            user_id="U002",
            username="suspicious.user",
            email="suspicious@company.com",
            groups=["users"],
            mfa_verified=False,
            risk_score=0.9
        ),
        device=Device(
            device_id="D002",
            device_type="mobile",
            os_version="Android 10",
            compliance_status=False,
            trust_score=0.2
        ),
        resource="financial.data",
        action="write",
        location="unknown"
    )
    
    result2 = engine.evaluate(request2)
    print(f"é«˜é£é™©ç”¨æˆ·: {result2['decision']} (ä¿¡ä»»åº¦: {result2['trust_score']:.2f})")
```

### 2.6 æ•ˆæœè¯„ä¼°ä¸ROI

| æŒ‡æ ‡ | å®æ–½å‰ | å®æ–½å | æå‡ |
|------|--------|--------|------|
| å®‰å…¨äº‹ä»¶ | 50/æœˆ | 5/æœˆ | **90%** |
| æœªæˆæƒè®¿é—® | 20/æœˆ | 0 | **100%** |
| VPNæˆæœ¬ | Â¥500ä¸‡/å¹´ | Â¥50ä¸‡/å¹´ | **90%** |
| ç”¨æˆ·ä½“éªŒè¯„åˆ† | 6/10 | 8.5/10 | **42%** |

**ROI**: 280%

---

## 3. æ¡ˆä¾‹æ€»ç»“

### æœ€ä½³å®è·µ

1. **æ¸è¿›å¼è¿ç§»**ï¼šåˆ†é˜¶æ®µå®æ–½é›¶ä¿¡ä»»
2. **èº«ä»½ä¸ºä¸­å¿ƒ**ï¼šå»ºç«‹ç»Ÿä¸€èº«ä»½ä½“ç³»
3. **æŒç»­ç›‘æ§**ï¼šå®æ—¶è¯„ä¼°ä¿¡ä»»çŠ¶æ€
4. **è‡ªåŠ¨åŒ–å“åº”**ï¼šå¨èƒè‡ªåŠ¨å¤„ç½®
5. **ç”¨æˆ·ä½“éªŒ**ï¼šå¹³è¡¡å®‰å…¨ä¸ä¾¿åˆ©

---

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-02-15
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv2.0
**ç»´æŠ¤è€…**ï¼šDSL Schemaç ”ç©¶å›¢é˜Ÿ

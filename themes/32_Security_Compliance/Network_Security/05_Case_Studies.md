# ç½‘ç»œå®‰å…¨å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [ç½‘ç»œå®‰å…¨å®è·µæ¡ˆä¾‹](#ç½‘ç»œå®‰å…¨å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šé›¶ä¿¡ä»»ç½‘ç»œå®‰å…¨æ¶æ„](#2-æ¡ˆä¾‹1é›¶ä¿¡ä»»ç½‘ç»œå®‰å…¨æ¶æ„)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹æ€»ç»“](#3-æ¡ˆä¾‹æ€»ç»“)
  - [4. å‚è€ƒæ–‡çŒ®](#4-å‚è€ƒæ–‡çŒ®)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›ç½‘ç»œå®‰å…¨åœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–é›¶ä¿¡ä»»æ¶æ„ã€å¾®åˆ†æ®µã€å…¥ä¾µæ£€æµ‹ã€å®‰å…¨ç›‘æ§ç­‰åœºæ™¯ã€‚

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **Google BeyondCorp**ï¼šé›¶ä¿¡ä»»å®‰å…¨æ¨¡å‹å¼€åˆ›è€…
- **Microsoft**ï¼šä¼ä¸šçº§é›¶ä¿¡ä»»å®è·µ
- **Capital One**ï¼šäº‘åŸç”Ÿç½‘ç»œå®‰å…¨

---

## 2. æ¡ˆä¾‹1ï¼šé›¶ä¿¡ä»»ç½‘ç»œå®‰å…¨æ¶æ„

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šæŸè·¨å›½ç§‘æŠ€å…¬å¸ï¼ˆTechGlobalï¼‰

**ä¼ä¸šè§„æ¨¡**ï¼š
- å‘˜å·¥äººæ•°ï¼š30000+
- å…¨çƒåŠå…¬å®¤ï¼š50+å›½å®¶
- æ•°æ®ä¸­å¿ƒï¼š10ä¸ª
- äº‘ç¯å¢ƒï¼šAWS, Azure, GCP
- æ—¥ç½‘ç»œæµé‡ï¼š100TB+

**æŠ€æœ¯æ ˆ**ï¼š
- ç½‘ç»œè®¾å¤‡ï¼šPalo Alto, Cisco
- äº‘å®‰å…¨ï¼šAWS WAF, Azure Firewall
- èº«ä»½è®¤è¯ï¼šOkta
- ç«¯ç‚¹å®‰å…¨ï¼šCrowdStrike
- SIEMï¼šSplunk

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **è¾¹ç•Œé˜²æŠ¤å¤±æ•ˆ**ï¼šä¼ ç»ŸåŸå ¡å¼å®‰å…¨æ¨¡å‹æ— æ³•åº”å¯¹å†…éƒ¨å¨èƒ
2. **è¿œç¨‹åŠå…¬é£é™©**ï¼šç–«æƒ…åè¿œç¨‹åŠå…¬æˆä¸ºå¸¸æ€ï¼ŒVPNæˆä¸ºç“¶é¢ˆ
3. **äº‘å®‰å…¨ç›²åŒº**ï¼šå¤šäº‘ç¯å¢ƒç¼ºä¹ç»Ÿä¸€å®‰å…¨è§†å›¾
4. **æ¨ªå‘ç§»åŠ¨å¨èƒ**ï¼šä¸€æ—¦çªç ´è¾¹ç•Œï¼Œæ”»å‡»è€…å¯è‡ªç”±ç§»åŠ¨
5. **æƒé™è¿‡åº¦æˆäºˆ**ï¼šå‘˜å·¥æ‹¥æœ‰è¶…å‡ºå·¥ä½œéœ€è¦çš„ç½‘ç»œè®¿é—®æƒé™

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **é›¶ä¿¡ä»»æ¶æ„**ï¼šæ°¸ä¸ä¿¡ä»»ï¼Œå§‹ç»ˆéªŒè¯
2. **æ— ç¼è®¿é—®ä½“éªŒ**ï¼šæ— éœ€VPNï¼Œå®‰å…¨è®¿é—®æ‰€æœ‰èµ„æº
3. **å¾®åˆ†æ®µéš”ç¦»**ï¼šå®ç°å·¥ä½œè´Ÿè½½çº§åˆ«çš„ç½‘ç»œéš”ç¦»
4. **å®æ—¶å¨èƒæ£€æµ‹**ï¼šæ£€æµ‹å’Œå“åº”æ—¶é—´<5åˆ†é’Ÿ
5. **ç»Ÿä¸€å®‰å…¨è§†å›¾**ï¼šå¤šäº‘ç¯å¢ƒçš„ç»Ÿä¸€å®‰å…¨ç®¡ç†

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **æ¶æ„è½¬å‹**ï¼šä»ä¼ ç»Ÿè¾¹ç•Œå®‰å…¨å‘é›¶ä¿¡ä»»è½¬å‹
2. **æ€§èƒ½å½±å“**ï¼šå®‰å…¨æ£€æµ‹å¯¹ç½‘ç»œæ€§èƒ½çš„å½±å“
3. **é—ç•™ç³»ç»Ÿé›†æˆ**ï¼šè€æ—§ç³»ç»Ÿæ— æ³•æ”¯æŒç°ä»£è®¤è¯
4. **å…¨çƒéƒ¨ç½²**ï¼šéœ€è¦æ”¯æŒå…¨çƒä½å»¶è¿Ÿè®¿é—®
5. **ç”¨æˆ·ä½“éªŒ**ï¼šå®‰å…¨ä¸ä¾¿åˆ©çš„å¹³è¡¡

### 2.5 è§£å†³æ–¹æ¡ˆ

**æ¶æ„è®¾è®¡**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Zero Trust Architecture                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Identity Layer                            â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚    MFA      â”‚  â”‚  Device     â”‚  â”‚    Risk Engine      â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (Okta)     â”‚  â”‚  Trust      â”‚  â”‚    (AI/ML)          â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Policy Engine                             â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚   ABAC      â”‚  â”‚   Context   â”‚  â”‚    Dynamic          â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  Policies   â”‚  â”‚  Analysis   â”‚  â”‚    Authorization    â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Access Proxy                              â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚   ZScaler   â”‚  â”‚  CloudFlare â”‚  â”‚    NGINX Plus       â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  Access     â”‚  â”‚  Access     â”‚  â”‚    (Internal)       â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Micro-segmentation                        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚   NSX       â”‚  â”‚  Calico     â”‚  â”‚    Cilium           â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (VMware)   â”‚  â”‚  (K8s)      â”‚  â”‚    (eBPF)           â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Workloads & Data                          â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  Legacy  â”‚ â”‚   SaaS   â”‚ â”‚  Cloud   â”‚ â”‚    Private       â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  Apps    â”‚ â”‚   Apps   â”‚ â”‚  Native  â”‚ â”‚    Data Centers  â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Security Monitoring                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚    SIEM     â”‚  â”‚   NDR       â”‚  â”‚    SOAR             â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (Splunk)   â”‚  â”‚  (Darktrace)â”‚  â”‚    (Phantom)        â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç»„ä»¶**ï¼š

1. **èº«ä»½è®¤è¯**ï¼šOkta + MFA
2. **è®¾å¤‡ä¿¡ä»»**ï¼šCrowdStrike Falcon
3. **è®¿é—®ä»£ç†**ï¼šZScaler Private Access
4. **å¾®åˆ†æ®µ**ï¼šVMware NSX + Calico
5. **å¨èƒæ£€æµ‹**ï¼šDarktrace NDR

### 2.6 å®Œæ•´ä»£ç å®ç°

**é›¶ä¿¡ä»»ç½‘ç»œå®‰å…¨å¹³å°Pythonå®ç°**ï¼š

```python
#!/usr/bin/env python3
"""
é›¶ä¿¡ä»»ç½‘ç»œå®‰å…¨å¹³å°
æ”¯æŒèº«ä»½éªŒè¯ã€è®¾å¤‡ä¿¡ä»»ã€åŠ¨æ€æˆæƒã€å¾®åˆ†æ®µã€å¨èƒæ£€æµ‹ç­‰åŠŸèƒ½
"""

import json
import hashlib
import secrets
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
import ipaddress
import jwt


class TrustLevel(Enum):
    """ä¿¡ä»»çº§åˆ«"""
    UNTRUSTED = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    FULL = 4


class DeviceStatus(Enum):
    """è®¾å¤‡çŠ¶æ€"""
    COMPLIANT = "compliant"
    NON_COMPLIANT = "non_compliant"
    COMPROMISED = "compromised"
    UNKNOWN = "unknown"


class AccessDecision(Enum):
    """è®¿é—®å†³ç­–"""
    ALLOW = "allow"
    DENY = "deny"
    CHALLENGE = "challenge"
    LIMITED = "limited"


@dataclass
class Device:
    """è®¾å¤‡å®ä½“"""
    id: str
    user_id: str
    device_type: str
    os_version: str
    status: DeviceStatus
    trust_level: TrustLevel
    certificate_fingerprint: Optional[str]
    last_seen: datetime
    ip_address: str
    location: str
    installed_software: List[str] = field(default_factory=list)
    security_patches: List[str] = field(default_factory=list)


@dataclass
class NetworkSegment:
    """ç½‘ç»œåˆ†æ®µ"""
    id: str
    name: str
    cidr: str
    sensitivity_level: int  # 1-5
    allowed_traffic: List[Dict]
    micro_policies: List[Dict]


@dataclass
class AccessRequest:
    """è®¿é—®è¯·æ±‚"""
    user_id: str
    device_id: str
    resource: str
    action: str
    timestamp: datetime
    source_ip: str
    user_agent: str
    context: Dict[str, Any]


@dataclass
class ThreatIndicator:
    """å¨èƒæŒ‡æ ‡"""
    id: str
    type: str  # ip, domain, hash, behavior
    value: str
    severity: int  # 1-5
    confidence: float  # 0-1
    first_seen: datetime
    last_seen: datetime
    source: str


class TrustEngine:
    """ä¿¡ä»»å¼•æ“"""

    def __init__(self):
        self.devices: Dict[str, Device] = {}
        self.threat_indicators: Dict[str, ThreatIndicator] = {}
        self.logger = logging.getLogger('TrustEngine')

    def evaluate_device_trust(self, device_id: str) -> TrustLevel:
        """
        è¯„ä¼°è®¾å¤‡ä¿¡ä»»çº§åˆ«
        
        Args:
            device_id: è®¾å¤‡ID
            
        Returns:
            ä¿¡ä»»çº§åˆ«
        """
        device = self.devices.get(device_id)
        if not device:
            return TrustLevel.UNTRUSTED
        
        # åŸºäºè®¾å¤‡çŠ¶æ€è®¡ç®—ä¿¡ä»»åˆ†æ•°
        score = 0
        
        if device.status == DeviceStatus.COMPLIANT:
            score += 40
        elif device.status == DeviceStatus.NON_COMPLIANT:
            score += 10
        elif device.status == DeviceStatus.COMPROMISED:
            score = 0
        
        # æ£€æŸ¥IPæ˜¯å¦åœ¨å¨èƒåˆ—è¡¨
        if self._is_threat_ip(device.ip_address):
            score -= 50
        
        # æ£€æŸ¥è®¾å¤‡æ˜¯å¦æœ€æ–°åœ¨çº¿
        time_since_last_seen = datetime.now() - device.last_seen
        if time_since_last_seen > timedelta(days=30):
            score -= 20
        
        # æ£€æŸ¥å®‰å…¨è¡¥ä¸
        required_patches = self._get_required_patches(device.os_version)
        missing_patches = set(required_patches) - set(device.security_patches)
        score -= len(missing_patches) * 5
        
        # æ£€æŸ¥åœ°ç†ä½ç½®å¼‚å¸¸
        if self._is_location_anomaly(device):
            score -= 30
        
        # æ˜ å°„åˆ†æ•°åˆ°ä¿¡ä»»çº§åˆ«
        if score >= 80:
            return TrustLevel.FULL
        elif score >= 60:
            return TrustLevel.HIGH
        elif score >= 40:
            return TrustLevel.MEDIUM
        elif score >= 20:
            return TrustLevel.LOW
        else:
            return TrustLevel.UNTRUSTED

    def _is_threat_ip(self, ip: str) -> bool:
        """æ£€æŸ¥IPæ˜¯å¦ä¸ºå¨èƒ"""
        for indicator in self.threat_indicators.values():
            if indicator.type == 'ip' and indicator.value == ip:
                return True
        return False

    def _get_required_patches(self, os_version: str) -> List[str]:
        """è·å–æ‰€éœ€å®‰å…¨è¡¥ä¸"""
        # ç®€åŒ–çš„è¡¥ä¸åˆ—è¡¨
        return ['KB12345', 'KB12346', 'KB12347']

    def _is_location_anomaly(self, device: Device) -> bool:
        """æ£€æµ‹åœ°ç†ä½ç½®å¼‚å¸¸"""
        # ç®€åŒ–çš„å¼‚å¸¸æ£€æµ‹
        # å®é™…åº”è¯¥åŸºäºç”¨æˆ·å†å²è¡Œä¸ºåˆ†æ
        return False

    def update_device(self, device: Device):
        """æ›´æ–°è®¾å¤‡ä¿¡æ¯"""
        device.trust_level = self.evaluate_device_trust(device.id)
        self.devices[device.id] = device


class PolicyEngine:
    """ç­–ç•¥å¼•æ“"""

    def __init__(self, trust_engine: TrustEngine):
        self.trust_engine = trust_engine
        self.policies: List[Dict] = []
        self.logger = logging.getLogger('PolicyEngine')

    def add_policy(self, policy: Dict):
        """æ·»åŠ ç­–ç•¥"""
        self.policies.append(policy)

    def evaluate_access(
        self,
        request: AccessRequest
    ) -> Tuple[AccessDecision, Dict]:
        """
        è¯„ä¼°è®¿é—®è¯·æ±‚
        
        Args:
            request: è®¿é—®è¯·æ±‚
            
        Returns:
            (è®¿é—®å†³ç­–, ä¸Šä¸‹æ–‡ä¿¡æ¯)
        """
        # è·å–è®¾å¤‡ä¿¡ä»»çº§åˆ«
        device = self.trust_engine.devices.get(request.device_id)
        if not device:
            return AccessDecision.DENY, {'reason': 'Device not registered'}
        
        trust_level = device.trust_level
        
        # è¯„ä¼°æ¯ä¸ªç­–ç•¥
        for policy in self.policies:
            result = self._evaluate_policy(policy, request, trust_level)
            if result:
                return result
        
        # é»˜è®¤æ‹’ç»
        return AccessDecision.DENY, {'reason': 'No matching policy'}

    def _evaluate_policy(
        self,
        policy: Dict,
        request: AccessRequest,
        trust_level: TrustLevel
    ) -> Optional[Tuple[AccessDecision, Dict]]:
        """è¯„ä¼°å•ä¸ªç­–ç•¥"""
        # æ£€æŸ¥èµ„æºåŒ¹é…
        if not self._resource_matches(policy['resource'], request.resource):
            return None
        
        # æ£€æŸ¥åŠ¨ä½œåŒ¹é…
        if request.action not in policy.get('actions', []):
            return None
        
        # æ£€æŸ¥ä¿¡ä»»çº§åˆ«è¦æ±‚
        required_trust = TrustLevel[policy.get('required_trust', 'LOW')]
        if trust_level.value < required_trust.value:
            return AccessDecision.DENY, {
                'reason': f'Insufficient trust level: {trust_level.name}'
            }
        
        # æ£€æŸ¥æ—¶é—´é™åˆ¶
        time_restrictions = policy.get('time_restrictions')
        if time_restrictions:
            if not self._check_time_restrictions(time_restrictions, request.timestamp):
                return AccessDecision.DENY, {'reason': 'Access outside allowed hours'}
        
        # æ£€æŸ¥åœ°ç†ä½ç½®
        geo_restrictions = policy.get('geo_restrictions')
        if geo_restrictions:
            if not self._check_geo_restrictions(geo_restrictions, request.context.get('location')):
                return AccessDecision.DENY, {'reason': 'Access from unauthorized location'}
        
        # åº”ç”¨æ¡ä»¶è®¿é—®
        conditions = policy.get('conditions', [])
        for condition in conditions:
            if not self._evaluate_condition(condition, request):
                return AccessDecision.CHALLENGE, {'reason': 'Additional verification required'}
        
        # ç­–ç•¥å…è®¸è®¿é—®
        return AccessDecision.ALLOW, {
            'policy': policy['name'],
            'trust_level': trust_level.name,
            'conditions': conditions
        }

    def _resource_matches(self, pattern: str, resource: str) -> bool:
        """æ£€æŸ¥èµ„æºæ˜¯å¦åŒ¹é…æ¨¡å¼"""
        import fnmatch
        return fnmatch.fnmatch(resource, pattern)

    def _check_time_restrictions(self, restrictions: Dict, timestamp: datetime) -> bool:
        """æ£€æŸ¥æ—¶é—´é™åˆ¶"""
        allowed_days = restrictions.get('days', [0, 1, 2, 3, 4, 5, 6])
        if timestamp.weekday() not in allowed_days:
            return False
        
        allowed_hours = restrictions.get('hours', {'start': 0, 'end': 23})
        if not (allowed_hours['start'] <= timestamp.hour <= allowed_hours['end']):
            return False
        
        return True

    def _check_geo_restrictions(self, restrictions: Dict, location: str) -> bool:
        """æ£€æŸ¥åœ°ç†é™åˆ¶"""
        allowed_countries = restrictions.get('allowed_countries', [])
        if allowed_countries and location not in allowed_countries:
            return False
        
        blocked_countries = restrictions.get('blocked_countries', [])
        if location in blocked_countries:
            return False
        
        return True

    def _evaluate_condition(self, condition: Dict, request: AccessRequest) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        condition_type = condition.get('type')
        
        if condition_type == 'mfa':
            return request.context.get('mfa_verified', False)
        
        if condition_type == 'device_compliance':
            device = self.trust_engine.devices.get(request.device_id)
            return device and device.status == DeviceStatus.COMPLIANT
        
        return True


class MicroSegmentationController:
    """å¾®åˆ†æ®µæ§åˆ¶å™¨"""

    def __init__(self):
        self.segments: Dict[str, NetworkSegment] = {}
        self.flow_rules: List[Dict] = []
        self.logger = logging.getLogger('MicroSegmentation')

    def create_segment(
        self,
        name: str,
        cidr: str,
        sensitivity_level: int
    ) -> NetworkSegment:
        """åˆ›å»ºç½‘ç»œåˆ†æ®µ"""
        segment_id = hashlib.sha256(name.encode()).hexdigest()[:16]
        
        segment = NetworkSegment(
            id=segment_id,
            name=name,
            cidr=cidr,
            sensitivity_level=sensitivity_level,
            allowed_traffic=[],
            micro_policies=[]
        )
        
        self.segments[segment_id] = segment
        return segment

    def add_flow_rule(
        self,
        source_segment: str,
        destination_segment: str,
        protocol: str,
        port: int,
        action: str
    ):
        """æ·»åŠ æµé‡è§„åˆ™"""
        rule = {
            'id': hashlib.sha256(f"{source_segment}-{destination_segment}".encode()).hexdigest()[:16],
            'source': source_segment,
            'destination': destination_segment,
            'protocol': protocol,
            'port': port,
            'action': action,
            'created_at': datetime.now().isoformat()
        }
        
        self.flow_rules.append(rule)
        
        # æ›´æ–°åˆ†æ®µç­–ç•¥
        if source_segment in self.segments:
            self.segments[source_segment].allowed_traffic.append(rule)

    def check_traffic_allowed(
        self,
        source_ip: str,
        destination_ip: str,
        protocol: str,
        port: int
    ) -> bool:
        """æ£€æŸ¥æµé‡æ˜¯å¦å…è®¸"""
        # ç¡®å®šæºå’Œç›®æ ‡çš„æ®µ
        source_segment = self._get_segment_for_ip(source_ip)
        destination_segment = self._get_segment_for_ip(destination_ip)
        
        if not source_segment or not destination_segment:
            return False
        
        # æŸ¥æ‰¾åŒ¹é…çš„è§„åˆ™
        for rule in self.flow_rules:
            if (rule['source'] == source_segment.id and
                rule['destination'] == destination_segment.id and
                rule['protocol'] == protocol and
                rule['port'] == port and
                rule['action'] == 'allow'):
                return True
        
        # é»˜è®¤æ‹’ç»
        return False

    def _get_segment_for_ip(self, ip: str) -> Optional[NetworkSegment]:
        """è·å–IPæ‰€å±çš„åˆ†æ®µ"""
        ip_addr = ipaddress.ip_address(ip)
        
        for segment in self.segments.values():
            network = ipaddress.ip_network(segment.cidr)
            if ip_addr in network:
                return segment
        
        return None

    def generate_policy_rules(self) -> List[Dict]:
        """ç”Ÿæˆç­–ç•¥è§„åˆ™ï¼ˆç”¨äºä¸‹å‘åˆ°ç½‘ç»œè®¾å¤‡ï¼‰"""
        rules = []
        
        for rule in self.flow_rules:
            source_seg = self.segments.get(rule['source'])
            dest_seg = self.segments.get(rule['destination'])
            
            if source_seg and dest_seg:
                rules.append({
                    'source_cidr': source_seg.cidr,
                    'destination_cidr': dest_seg.cidr,
                    'protocol': rule['protocol'],
                    'port': rule['port'],
                    'action': rule['action']
                })
        
        return rules


class ThreatDetectionEngine:
    """å¨èƒæ£€æµ‹å¼•æ“"""

    def __init__(self):
        self.baseline_behavior: Dict[str, Dict] = {}
        self.anomaly_threshold = 0.8
        self.logger = logging.getLogger('ThreatDetection')

    def analyze_traffic(self, flow_data: Dict) -> List[Dict]:
        """
        åˆ†ææµé‡
        
        Args:
            flow_data: æµé‡æ•°æ®
            
        Returns:
            æ£€æµ‹åˆ°çš„å¨èƒåˆ—è¡¨
        """
        threats = []
        
        # å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
        if self._detect_anomaly(flow_data):
            threats.append({
                'type': 'anomaly',
                'severity': 'high',
                'description': 'Anomalous traffic pattern detected',
                'source_ip': flow_data.get('source_ip'),
                'confidence': 0.85
            })
        
        # æ¨ªå‘ç§»åŠ¨æ£€æµ‹
        if self._detect_lateral_movement(flow_data):
            threats.append({
                'type': 'lateral_movement',
                'severity': 'critical',
                'description': 'Potential lateral movement detected',
                'source_ip': flow_data.get('source_ip'),
                'confidence': 0.90
            })
        
        # æ•°æ®å¤–æ³„æ£€æµ‹
        if self._detect_data_exfiltration(flow_data):
            threats.append({
                'type': 'data_exfiltration',
                'severity': 'critical',
                'description': 'Potential data exfiltration detected',
                'source_ip': flow_data.get('source_ip'),
                'confidence': 0.75
            })
        
        return threats

    def _detect_anomaly(self, flow_data: Dict) -> bool:
        """æ£€æµ‹å¼‚å¸¸è¡Œä¸º"""
        user_id = flow_data.get('user_id')
        if not user_id:
            return False
        
        baseline = self.baseline_behavior.get(user_id, {})
        
        # ç®€åŒ–çš„å¼‚å¸¸æ£€æµ‹é€»è¾‘
        # å®é™…åº”è¯¥ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹
        current_hour = datetime.now().hour
        normal_hours = baseline.get('active_hours', [9, 17])
        
        if current_hour not in normal_hours:
            return True
        
        return False

    def _detect_lateral_movement(self, flow_data: Dict) -> bool:
        """æ£€æµ‹æ¨ªå‘ç§»åŠ¨"""
        # æ£€æµ‹çŸ­æ—¶é—´å†…è®¿é—®å¤šä¸ªå†…éƒ¨ä¸»æœº
        accessed_hosts = flow_data.get('accessed_hosts', [])
        time_window = flow_data.get('time_window_seconds', 300)
        
        if len(accessed_hosts) > 10 and time_window < 60:
            return True
        
        return False

    def _detect_data_exfiltration(self, flow_data: Dict) -> bool:
        """æ£€æµ‹æ•°æ®å¤–æ³„"""
        bytes_sent = flow_data.get('bytes_sent', 0)
        destination = flow_data.get('destination')
        
        # æ£€æµ‹å¤§é‡æ•°æ®å‘é€åˆ°å¤–éƒ¨
        if bytes_sent > 1_000_000_000:  # 1GB
            return True
        
        return False

    def update_baseline(self, user_id: str, behavior_data: Dict):
        """æ›´æ–°ç”¨æˆ·è¡Œä¸ºåŸºçº¿"""
        self.baseline_behavior[user_id] = behavior_data


class ZeroTrustPlatform:
    """é›¶ä¿¡ä»»å¹³å°"""

    def __init__(self):
        self.trust_engine = TrustEngine()
        self.policy_engine = PolicyEngine(self.trust_engine)
        self.segmentation = MicroSegmentationController()
        self.threat_detection = ThreatDetectionEngine()
        self.logger = logging.getLogger('ZeroTrustPlatform')

    def authenticate_request(self, request: AccessRequest) -> Dict:
        """
        è®¤è¯è®¿é—®è¯·æ±‚
        
        Args:
            request: è®¿é—®è¯·æ±‚
            
        Returns:
            è®¤è¯ç»“æœ
        """
        # 1. è¯„ä¼°è®¾å¤‡ä¿¡ä»»
        device_trust = self.trust_engine.evaluate_device_trust(request.device_id)
        
        # 2. è¯„ä¼°è®¿é—®ç­–ç•¥
        decision, context = self.policy_engine.evaluate_access(request)
        
        # 3. æ£€æŸ¥ç½‘ç»œåˆ†æ®µ
        network_allowed = self.segmentation.check_traffic_allowed(
            request.source_ip,
            request.context.get('destination_ip', ''),
            request.context.get('protocol', 'tcp'),
            request.context.get('port', 443)
        )
        
        # 4. å¨èƒæ£€æµ‹
        flow_data = {
            'user_id': request.user_id,
            'source_ip': request.source_ip,
            'destination_ip': request.context.get('destination_ip'),
            'protocol': request.context.get('protocol'),
            'port': request.context.get('port')
        }
        threats = self.threat_detection.analyze_traffic(flow_data)
        
        # ç»¼åˆå†³ç­–
        result = {
            'decision': decision.value,
            'device_trust': device_trust.name,
            'policy_context': context,
            'network_allowed': network_allowed,
            'threats_detected': len(threats) > 0,
            'threat_details': threats,
            'timestamp': datetime.now().isoformat()
        }
        
        # è®°å½•æ—¥å¿—
        self.logger.info(f"è®¿é—®è¯·æ±‚: {request.user_id} -> {request.resource}: {decision.value}")
        
        return result


def main():
    """ä¸»å‡½æ•°"""
    # åˆå§‹åŒ–å¹³å°
    platform = ZeroTrustPlatform()
    
    # åˆ›å»ºç½‘ç»œåˆ†æ®µ
    prod_segment = platform.segmentation.create_segment(
        name='production',
        cidr='10.0.1.0/24',
        sensitivity_level=5
    )
    
    dmz_segment = platform.segmentation.create_segment(
        name='dmz',
        cidr='10.0.2.0/24',
        sensitivity_level=3
    )
    
    # æ·»åŠ æµé‡è§„åˆ™
    platform.segmentation.add_flow_rule(
        source_segment=dmz_segment.id,
        destination_segment=prod_segment.id,
        protocol='tcp',
        port=443,
        action='allow'
    )
    
    # æ·»åŠ è®¿é—®ç­–ç•¥
    platform.policy_engine.add_policy({
        'name': 'production_access',
        'resource': 'production.*',
        'actions': ['read', 'write'],
        'required_trust': 'HIGH',
        'conditions': [
            {'type': 'mfa'},
            {'type': 'device_compliance'}
        ]
    })
    
    # æ¨¡æ‹Ÿè®¿é—®è¯·æ±‚
    request = AccessRequest(
        user_id='user123',
        device_id='device456',
        resource='production.api.server',
        action='read',
        timestamp=datetime.now(),
        source_ip='10.0.2.50',
        user_agent='Mozilla/5.0',
        context={
            'mfa_verified': True,
            'destination_ip': '10.0.1.10',
            'protocol': 'tcp',
            'port': 443,
            'location': 'US'
        }
    )
    
    # è®¤è¯è¯·æ±‚
    result = platform.authenticate_request(request)
    print(json.dumps(result, indent=2))


if __name__ == '__main__':
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| å¹³å‡æ£€æµ‹æ—¶é—´ | 6å°æ—¶ | 3åˆ†é’Ÿ | 120x |
| å†…éƒ¨å¨èƒæ£€æµ‹ç‡ | 20% | 85% | 325%æå‡ |
| æ¨ªå‘ç§»åŠ¨é˜»æ–­ç‡ | 30% | 95% | 217%æå‡ |
| è®¿é—®å»¶è¿Ÿ | 200ms | 50ms | 4xæå‡ |
| å®‰å…¨äº‹ä»¶æ•° | 50/æœˆ | 5/æœˆ | 90%é™ä½ |

**ROIåˆ†æ**ï¼š

1. **æˆæœ¬èŠ‚çº¦**ï¼š
   - å®‰å…¨äº‹ä»¶å¤„ç†æˆæœ¬ï¼šæ¯å¹´ 1500ä¸‡å…ƒ
   - VPNåŸºç¡€è®¾æ–½æˆæœ¬ï¼šæ¯å¹´ 500ä¸‡å…ƒ
   - äººå·¥å®‰å…¨è¿è¥ï¼šæ¯å¹´ 800ä¸‡å…ƒ

2. **æŠ•èµ„å›æŠ¥ç‡**ï¼š
   - æ€»æŠ•èµ„ï¼š1000ä¸‡å…ƒ
   - å¹´åº¦æ”¶ç›Šï¼š2800ä¸‡å…ƒ
   - ROIï¼š280%

**ç»éªŒæ•™è®­**ï¼š

1. **åˆ†é˜¶æ®µå®æ–½**ï¼šé›¶ä¿¡ä»»æ˜¯æ—…ç¨‹ï¼Œä¸æ˜¯ç»ˆç‚¹
2. **è®¾å¤‡ä¿¡ä»»é‡è¦**ï¼šè®¾å¤‡çŠ¶æ€æ˜¯ä¿¡ä»»è¯„ä¼°çš„å…³é”®
3. **ç”¨æˆ·ä½“éªŒå¹³è¡¡**ï¼šå®‰å…¨ä¸åº”è¿‡åº¦å½±å“ç”¨æˆ·ä½“éªŒ
4. **æŒç»­ç›‘æ§**ï¼šå¨èƒæ€åŠ¿ä¸æ–­å˜åŒ–ï¼Œéœ€è¦æŒç»­ç›‘æ§

---

## 3. æ¡ˆä¾‹æ€»ç»“

### æˆåŠŸå› ç´ 

1. **èº«ä»½ä¼˜å…ˆ**ï¼šèº«ä»½æ˜¯é›¶ä¿¡ä»»çš„æ ¸å¿ƒ
2. **æŒç»­éªŒè¯**ï¼šæ°¸ä¸ä¿¡ä»»ï¼Œå§‹ç»ˆéªŒè¯
3. **æœ€å°æƒé™**ï¼šåªæˆäºˆå¿…è¦çš„è®¿é—®æƒé™
4. **å‡è®¾ breach**ï¼šå‡è®¾å·²ç»å­˜åœ¨å¨èƒï¼ŒæŒç»­ç›‘æ§

### æœ€ä½³å®è·µ

1. **åˆ†é˜¶æ®µå®æ–½**ï¼šä»å…³é”®åº”ç”¨å¼€å§‹ï¼Œé€æ­¥æ¨å¹¿
2. **è®¾å¤‡ç®¡ç†**ï¼šå»ºç«‹å¼ºå¤§çš„è®¾å¤‡ç®¡ç†å’Œåˆè§„æ£€æŸ¥
3. **ç›‘æ§å’Œå“åº”**ï¼šå®æ—¶ç›‘æ§ï¼Œå¿«é€Ÿå“åº”
4. **ç”¨æˆ·æ•™è‚²**ï¼šåŸ¹è®­ç”¨æˆ·ç†è§£å’Œé…åˆå®‰å…¨æªæ–½

---

## 4. å‚è€ƒæ–‡çŒ®

- [NISTé›¶ä¿¡ä»»æ¶æ„](https://www.nist.gov/publications/zero-trust-architecture)
- [Google BeyondCorpè®ºæ–‡](https://cloud.google.com/beyondcorp)
- [Microsofté›¶ä¿¡ä»»æŒ‡å—](https://docs.microsoft.com/security/zero-trust/)

---

**æ–‡æ¡£åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**ç»´æŠ¤è€…**ï¼šDSL Schemaç ”ç©¶å›¢é˜Ÿ  
**æœ€åæ›´æ–°**ï¼š2025-01-21

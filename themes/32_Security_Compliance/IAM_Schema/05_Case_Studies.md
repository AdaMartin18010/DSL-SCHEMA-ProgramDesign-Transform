# IAMèº«ä»½è®¤è¯å®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [IAMèº«ä»½è®¤è¯å®è·µæ¡ˆä¾‹](#iamèº«ä»½è®¤è¯å®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šä¼ä¸šçº§ç»Ÿä¸€èº«ä»½è®¤è¯å¹³å°](#2-æ¡ˆä¾‹1ä¼ä¸šçº§ç»Ÿä¸€èº«ä»½è®¤è¯å¹³å°)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°](#27-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹æ€»ç»“](#3-æ¡ˆä¾‹æ€»ç»“)
  - [4. å‚è€ƒæ–‡çŒ®](#4-å‚è€ƒæ–‡çŒ®)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›IAMï¼ˆèº«ä»½å’Œè®¿é—®ç®¡ç†ï¼‰åœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–ç»Ÿä¸€èº«ä»½è®¤è¯ã€å•ç‚¹ç™»å½•ã€å¤šå› ç´ è®¤è¯ã€æƒé™ç®¡ç†ç­‰åœºæ™¯ã€‚

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **Okta**ï¼šä¼ä¸šçº§èº«ä»½è®¤è¯
- **Microsoft Azure AD**ï¼šæ··åˆäº‘èº«ä»½ç®¡ç†
- **Google BeyondCorp**ï¼šé›¶ä¿¡ä»»å®‰å…¨æ¨¡å‹

---

## 2. æ¡ˆä¾‹1ï¼šä¼ä¸šçº§ç»Ÿä¸€èº«ä»½è®¤è¯å¹³å°

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šåç§°**ï¼šæŸå¤§å‹è·¨å›½é“¶è¡Œï¼ˆGlobalBankï¼‰

**ä¼ä¸šè§„æ¨¡**ï¼š
- å‘˜å·¥äººæ•°ï¼š50000+
- å…¨çƒåˆ†æ”¯æœºæ„ï¼š60+å›½å®¶
- åº”ç”¨ç³»ç»Ÿï¼š500+
- æ—¥å‡è®¤è¯è¯·æ±‚ï¼š1000ä¸‡+
- å®¢æˆ·æ•°é‡ï¼š5000ä¸‡+

**æŠ€æœ¯æ ˆ**ï¼š
- è®¤è¯åè®®ï¼šOAuth 2.0, OIDC, SAML
- ç›®å½•æœåŠ¡ï¼šActive Directory, LDAP
- åŸºç¡€è®¾æ–½ï¼šæ··åˆäº‘ï¼ˆç§æœ‰äº‘ + AWS/Azureï¼‰
- æ•°æ®åº“ï¼šOracle, PostgreSQL

### 2.2 ä¸šåŠ¡ç—›ç‚¹

1. **èº«ä»½å­¤å²›**ï¼šå„ä¸šåŠ¡ç³»ç»Ÿç‹¬ç«‹ç®¡ç†ç”¨æˆ·ï¼Œèº«ä»½æ•°æ®åˆ†æ•£
2. **ç”¨æˆ·ä½“éªŒå·®**ï¼šå‘˜å·¥éœ€è¦è®°ä½å¤šä¸ªå¯†ç ï¼Œé¢‘ç¹ç™»å½•
3. **å®‰å…¨é£é™©é«˜**ï¼šç¼ºä¹ç»Ÿä¸€çš„å®‰å…¨ç­–ç•¥ï¼Œè´¦å·æ³„éœ²é£é™©å¤§
4. **åˆè§„å›°éš¾**ï¼šæ— æ³•æ»¡è¶³GDPRã€SOXç­‰æ³•è§„è¦æ±‚
5. **æƒé™ç®¡ç†æ··ä¹±**ï¼šæƒé™åˆ†é…ä¸é€æ˜ï¼Œç¦»èŒå‘˜å·¥æƒé™å›æ”¶ä¸åŠæ—¶

### 2.3 ä¸šåŠ¡ç›®æ ‡

1. **ç»Ÿä¸€èº«ä»½æº**ï¼šå»ºç«‹å•ä¸€å¯ä¿¡çš„èº«ä»½æ•°æ®æº
2. **å•ç‚¹ç™»å½•**ï¼šå®ç°ä¸€æ¬¡ç™»å½•ï¼Œå…¨ç³»ç»Ÿé€šè¡Œ
3. **å¤šå› ç´ è®¤è¯**ï¼šä¸ºæ•æ„Ÿæ“ä½œå¼ºåˆ¶å¯ç”¨MFA
4. **è‡ªåŠ¨åŒ–ç”Ÿå‘½å‘¨æœŸ**ï¼šå‘˜å·¥å…¥èŒã€è½¬å²—ã€ç¦»èŒè‡ªåŠ¨åŒ–å¤„ç†
5. **åˆè§„å®¡è®¡**ï¼šæ»¡è¶³GDPRã€SOXã€PCI DSSç­‰åˆè§„è¦æ±‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

1. **æ··åˆäº‘é›†æˆ**ï¼šéœ€è¦é›†æˆæœ¬åœ°ADå’Œäº‘èº«ä»½æœåŠ¡
2. **é—ç•™ç³»ç»Ÿæ”¹é€ **ï¼šå¤§é‡é—ç•™ç³»ç»Ÿéœ€è¦æ¥å…¥æ–°å¹³å°
3. **é«˜å¯ç”¨è¦æ±‚**ï¼šè®¤è¯æœåŠ¡å¿…é¡»7x24å¯ç”¨
4. **å…¨çƒéƒ¨ç½²**ï¼šéœ€è¦æ”¯æŒå…¨çƒä½å»¶è¿Ÿè®¿é—®
5. **å®‰å…¨åˆè§„**ï¼šé‡‘èè¡Œä¸šä¸¥æ ¼çš„å®‰å…¨å’Œåˆè§„è¦æ±‚

### 2.5 è§£å†³æ–¹æ¡ˆ

**æ¶æ„è®¾è®¡**ï¼š

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Unified IAM Architecture                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      Identity Provider                        â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚   Keycloak  â”‚  â”‚   Azure AD  â”‚  â”‚   Okta (Backup)     â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (Primary)  â”‚  â”‚  (Hybrid)   â”‚  â”‚                     â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Identity Federation Layer                  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚    SAML     â”‚  â”‚   OIDC      â”‚  â”‚    LDAP/AD          â”‚   â”‚  â”‚
â”‚  â”‚  â”‚   Bridge    â”‚  â”‚  Provider   â”‚  â”‚   Connector         â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Application Layer                          â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  Mobile  â”‚ â”‚   Web    â”‚ â”‚   API    â”‚ â”‚   Legacy Apps    â”‚  â”‚  â”‚
â”‚  â”‚  â”‚   Apps   â”‚ â”‚   Apps   â”‚ â”‚ Gateway  â”‚ â”‚   (SAML/OIDC)    â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Security Controls                          â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚  â”‚  â”‚    MFA      â”‚  â”‚  Risk-Based â”‚  â”‚    Session          â”‚   â”‚  â”‚
â”‚  â”‚  â”‚  (TOTP/HW)  â”‚  â”‚   Auth      â”‚  â”‚   Management        â”‚   â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ ¸å¿ƒç»„ä»¶**ï¼š

1. **Keycloak**ï¼šå¼€æºèº«ä»½è®¤è¯æœåŠ¡å™¨
2. **Azure AD Connect**ï¼šæ··åˆäº‘èº«ä»½åŒæ­¥
3. **HashiCorp Vault**ï¼šå¯†é’¥å’Œå‡­è¯ç®¡ç†
4. **Redis**ï¼šä¼šè¯å­˜å‚¨
5. **PostgreSQL**ï¼šèº«ä»½æ•°æ®å­˜å‚¨

### 2.6 å®Œæ•´ä»£ç å®ç°

**IAMç»Ÿä¸€è®¤è¯å¹³å°Pythonå®ç°**ï¼š

```python
#!/usr/bin/env python3
"""
ä¼ä¸šçº§IAMç»Ÿä¸€è®¤è¯å¹³å°
æ”¯æŒSSOã€MFAã€æƒé™ç®¡ç†ã€ç”Ÿå‘½å‘¨æœŸç®¡ç†ç­‰åŠŸèƒ½
"""

import jwt
import hashlib
import secrets
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import bcrypt
import pyotp
import qrcode
import io
import base64
import json


class AuthMethod(Enum):
    """è®¤è¯æ–¹å¼"""
    PASSWORD = "password"
    OTP = "otp"
    HARDWARE_TOKEN = "hardware_token"
    BIOMETRIC = "biometric"
    WEBAUTHN = "webauthn"


class UserStatus(Enum):
    """ç”¨æˆ·çŠ¶æ€"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    SUSPENDED = "suspended"
    PENDING = "pending"


class Permission(Enum):
    """æƒé™"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"


@dataclass
class User:
    """ç”¨æˆ·å®ä½“"""
    id: str
    username: str
    email: str
    first_name: str
    last_name: str
    status: UserStatus
    department: str
    roles: List[str] = field(default_factory=list)
    mfa_enabled: bool = False
    mfa_secret: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    last_login: Optional[datetime] = None
    password_hash: Optional[str] = None
    failed_login_attempts: int = 0
    locked_until: Optional[datetime] = None


@dataclass
class Role:
    """è§’è‰²å®ä½“"""
    id: str
    name: str
    description: str
    permissions: Dict[str, List[Permission]] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class Session:
    """ä¼šè¯å®ä½“"""
    id: str
    user_id: str
    created_at: datetime
    expires_at: datetime
    ip_address: str
    user_agent: str
    mfa_verified: bool = False
    refresh_token: Optional[str] = None


@dataclass
class AuditLog:
    """å®¡è®¡æ—¥å¿—"""
    id: str
    user_id: Optional[str]
    action: str
    resource: str
    result: str
    ip_address: str
    user_agent: str
    timestamp: datetime = field(default_factory=datetime.now)
    details: Optional[Dict] = None


class IAMManager:
    """IAMç®¡ç†å™¨"""

    def __init__(self, jwt_secret: str, jwt_algorithm: str = 'HS256'):
        """
        åˆå§‹åŒ–IAMç®¡ç†å™¨
        
        Args:
            jwt_secret: JWTå¯†é’¥
            jwt_algorithm: JWTç®—æ³•
        """
        self.jwt_secret = jwt_secret
        self.jwt_algorithm = jwt_algorithm
        self.access_token_expire = timedelta(hours=1)
        self.refresh_token_expire = timedelta(days=30)
        
        # æ•°æ®å­˜å‚¨ï¼ˆå®é™…åº”è¯¥ä½¿ç”¨æ•°æ®åº“ï¼‰
        self.users: Dict[str, User] = {}
        self.roles: Dict[str, Role] = {}
        self.sessions: Dict[str, Session] = {}
        self.audit_logs: List[AuditLog] = []
        
        self.logger = self._setup_logger()

    def _setup_logger(self) -> logging.Logger:
        """è®¾ç½®æ—¥å¿—"""
        logger = logging.getLogger('IAM')
        logger.setLevel(logging.INFO)
        
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
        
        return logger

    def _hash_password(self, password: str) -> str:
        """å¯†ç å“ˆå¸Œ"""
        salt = bcrypt.gensalt(rounds=12)
        return bcrypt.hashpw(password.encode(), salt).decode()

    def _verify_password(self, password: str, password_hash: str) -> bool:
        """éªŒè¯å¯†ç """
        return bcrypt.checkpw(password.encode(), password_hash.encode())

    def _generate_token(self, user_id: str, token_type: str = 'access') -> str:
        """ç”ŸæˆJWTä»¤ç‰Œ"""
        if token_type == 'access':
            expire = datetime.utcnow() + self.access_token_expire
        else:
            expire = datetime.utcnow() + self.refresh_token_expire
        
        payload = {
            'user_id': user_id,
            'type': token_type,
            'exp': expire,
            'iat': datetime.utcnow(),
            'jti': secrets.token_hex(16)
        }
        
        return jwt.encode(payload, self.jwt_secret, algorithm=self.jwt_algorithm)

    def _decode_token(self, token: str) -> Optional[Dict]:
        """è§£ç JWTä»¤ç‰Œ"""
        try:
            return jwt.decode(token, self.jwt_secret, algorithms=[self.jwt_algorithm])
        except jwt.ExpiredSignatureError:
            return None
        except jwt.InvalidTokenError:
            return None

    def _generate_id(self) -> str:
        """ç”Ÿæˆå”¯ä¸€ID"""
        return secrets.token_hex(16)

    def create_user(
        self,
        username: str,
        email: str,
        password: str,
        first_name: str,
        last_name: str,
        department: str,
        roles: Optional[List[str]] = None
    ) -> User:
        """
        åˆ›å»ºç”¨æˆ·
        
        Args:
            username: ç”¨æˆ·å
            email: é‚®ç®±
            password: å¯†ç 
            first_name: å
            last_name: å§“
            department: éƒ¨é—¨
            roles: è§’è‰²åˆ—è¡¨
            
        Returns:
            åˆ›å»ºçš„ç”¨æˆ·
        """
        user_id = self._generate_id()
        
        user = User(
            id=user_id,
            username=username,
            email=email,
            first_name=first_name,
            last_name=last_name,
            status=UserStatus.ACTIVE,
            department=department,
            roles=roles or [],
            password_hash=self._hash_password(password)
        )
        
        self.users[user_id] = user
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        self._log_audit(
            user_id=user_id,
            action='USER_CREATED',
            resource=f'user:{user_id}',
            result='SUCCESS'
        )
        
        self.logger.info(f"ç”¨æˆ·åˆ›å»ºæˆåŠŸ: {username}")
        return user

    def authenticate_user(
        self,
        username: str,
        password: str,
        ip_address: str,
        user_agent: str
    ) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        ç”¨æˆ·è®¤è¯
        
        Args:
            username: ç”¨æˆ·å
            password: å¯†ç 
            ip_address: IPåœ°å€
            user_agent: ç”¨æˆ·ä»£ç†
            
        Returns:
            (æ˜¯å¦æˆåŠŸ, è®¿é—®ä»¤ç‰Œ, åˆ·æ–°ä»¤ç‰Œ)
        """
        # æŸ¥æ‰¾ç”¨æˆ·
        user = None
        for u in self.users.values():
            if u.username == username:
                user = u
                break
        
        if not user:
            self._log_audit(
                user_id=None,
                action='LOGIN_FAILED',
                resource=f'user:{username}',
                result='USER_NOT_FOUND',
                ip_address=ip_address,
                user_agent=user_agent
            )
            return False, None, None
        
        # æ£€æŸ¥è´¦æˆ·çŠ¶æ€
        if user.status != UserStatus.ACTIVE:
            self._log_audit(
                user_id=user.id,
                action='LOGIN_FAILED',
                resource=f'user:{user.id}',
                result=f'ACCOUNT_{user.status.value.upper()}',
                ip_address=ip_address,
                user_agent=user_agent
            )
            return False, None, None
        
        # æ£€æŸ¥æ˜¯å¦é”å®š
        if user.locked_until and datetime.now() < user.locked_until:
            self._log_audit(
                user_id=user.id,
                action='LOGIN_FAILED',
                resource=f'user:{user.id}',
                result='ACCOUNT_LOCKED',
                ip_address=ip_address,
                user_agent=user_agent
            )
            return False, None, None
        
        # éªŒè¯å¯†ç 
        if not self._verify_password(password, user.password_hash):
            user.failed_login_attempts += 1
            
            # é”å®šè´¦æˆ·
            if user.failed_login_attempts >= 5:
                user.locked_until = datetime.now() + timedelta(minutes=30)
                user.failed_login_attempts = 0
            
            self._log_audit(
                user_id=user.id,
                action='LOGIN_FAILED',
                resource=f'user:{user.id}',
                result='INVALID_PASSWORD',
                ip_address=ip_address,
                user_agent=user_agent
            )
            return False, None, None
        
        # é‡ç½®å¤±è´¥å°è¯•æ¬¡æ•°
        user.failed_login_attempts = 0
        user.last_login = datetime.now()
        
        # å¦‚æœéœ€è¦MFA
        if user.mfa_enabled:
            # ç”Ÿæˆä¸´æ—¶ä»¤ç‰Œï¼Œç­‰å¾…MFAéªŒè¯
            temp_token = self._generate_token(user.id, 'mfa_pending')
            return True, temp_token, None
        
        # ç”Ÿæˆä»¤ç‰Œ
        access_token = self._generate_token(user.id, 'access')
        refresh_token = self._generate_token(user.id, 'refresh')
        
        # åˆ›å»ºä¼šè¯
        session = Session(
            id=self._generate_id(),
            user_id=user.id,
            created_at=datetime.now(),
            expires_at=datetime.now() + self.access_token_expire,
            ip_address=ip_address,
            user_agent=user_agent,
            mfa_verified=True,
            refresh_token=refresh_token
        )
        self.sessions[session.id] = session
        
        self._log_audit(
            user_id=user.id,
            action='LOGIN_SUCCESS',
            resource=f'user:{user.id}',
            result='SUCCESS',
            ip_address=ip_address,
            user_agent=user_agent
        )
        
        return True, access_token, refresh_token

    def verify_mfa(self, user_id: str, otp_code: str) -> bool:
        """
        éªŒè¯MFA
        
        Args:
            user_id: ç”¨æˆ·ID
            otp_code: OTPéªŒè¯ç 
            
        Returns:
            æ˜¯å¦éªŒè¯æˆåŠŸ
        """
        user = self.users.get(user_id)
        if not user or not user.mfa_secret:
            return False
        
        totp = pyotp.TOTP(user.mfa_secret)
        if totp.verify(otp_code):
            return True
        
        return False

    def setup_mfa(self, user_id: str) -> Tuple[bool, Optional[str], Optional[str]]:
        """
        è®¾ç½®MFA
        
        Args:
            user_id: ç”¨æˆ·ID
            
        Returns:
            (æ˜¯å¦æˆåŠŸ, å¯†é’¥, QRç Base64)
        """
        user = self.users.get(user_id)
        if not user:
            return False, None, None
        
        # ç”Ÿæˆå¯†é’¥
        secret = pyotp.random_base32()
        user.mfa_secret = secret
        user.mfa_enabled = True
        
        # ç”ŸæˆQRç 
        totp = pyotp.totp.TOTP(secret)
        provisioning_uri = totp.provisioning_uri(
            name=user.email,
            issuer_name='GlobalBank IAM'
        )
        
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(provisioning_uri)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        qr_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return True, secret, qr_base64

    def create_role(
        self,
        name: str,
        description: str,
        permissions: Optional[Dict[str, List[str]]] = None
    ) -> Role:
        """
        åˆ›å»ºè§’è‰²
        
        Args:
            name: è§’è‰²åç§°
            description: è§’è‰²æè¿°
            permissions: æƒé™å­—å…¸
            
        Returns:
            åˆ›å»ºçš„è§’è‰²
        """
        role_id = self._generate_id()
        
        # è½¬æ¢æƒé™å­—ç¬¦ä¸²ä¸ºæšä¸¾
        perm_dict = {}
        for resource, perms in (permissions or {}).items():
            perm_dict[resource] = [Permission(p) for p in perms]
        
        role = Role(
            id=role_id,
            name=name,
            description=description,
            permissions=perm_dict
        )
        
        self.roles[role_id] = role
        
        self.logger.info(f"è§’è‰²åˆ›å»ºæˆåŠŸ: {name}")
        return role

    def assign_role(self, user_id: str, role_id: str) -> bool:
        """
        åˆ†é…è§’è‰²
        
        Args:
            user_id: ç”¨æˆ·ID
            role_id: è§’è‰²ID
            
        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        user = self.users.get(user_id)
        role = self.roles.get(role_id)
        
        if not user or not role:
            return False
        
        if role_id not in user.roles:
            user.roles.append(role_id)
        
        self._log_audit(
            user_id=user_id,
            action='ROLE_ASSIGNED',
            resource=f'user:{user_id}',
            result=f'role:{role_id}'
        )
        
        return True

    def check_permission(
        self,
        user_id: str,
        resource: str,
        permission: Permission
    ) -> bool:
        """
        æ£€æŸ¥æƒé™
        
        Args:
            user_id: ç”¨æˆ·ID
            resource: èµ„æº
            permission: æƒé™
            
        Returns:
            æ˜¯å¦æœ‰æƒé™
        """
        user = self.users.get(user_id)
        if not user:
            return False
        
        # æ£€æŸ¥æ¯ä¸ªè§’è‰²çš„æƒé™
        for role_id in user.roles:
            role = self.roles.get(role_id)
            if not role:
                continue
            
            role_perms = role.permissions.get(resource, [])
            if permission in role_perms or Permission.ADMIN in role_perms:
                return True
        
        return False

    def revoke_session(self, session_id: str) -> bool:
        """
        æ’¤é”€ä¼šè¯
        
        Args:
            session_id: ä¼šè¯ID
            
        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        if session_id in self.sessions:
            session = self.sessions[session_id]
            del self.sessions[session_id]
            
            self._log_audit(
                user_id=session.user_id,
                action='SESSION_REVOKED',
                resource=f'session:{session_id}',
                result='SUCCESS'
            )
            return True
        
        return False

    def refresh_access_token(self, refresh_token: str) -> Optional[str]:
        """
        åˆ·æ–°è®¿é—®ä»¤ç‰Œ
        
        Args:
            refresh_token: åˆ·æ–°ä»¤ç‰Œ
            
        Returns:
            æ–°çš„è®¿é—®ä»¤ç‰Œ
        """
        payload = self._decode_token(refresh_token)
        if not payload or payload.get('type') != 'refresh':
            return None
        
        user_id = payload.get('user_id')
        user = self.users.get(user_id)
        
        if not user or user.status != UserStatus.ACTIVE:
            return None
        
        return self._generate_token(user_id, 'access')

    def _log_audit(
        self,
        action: str,
        resource: str,
        result: str,
        user_id: Optional[str] = None,
        ip_address: str = '',
        user_agent: str = '',
        details: Optional[Dict] = None
    ):
        """è®°å½•å®¡è®¡æ—¥å¿—"""
        log = AuditLog(
            id=self._generate_id(),
            user_id=user_id,
            action=action,
            resource=resource,
            result=result,
            ip_address=ip_address,
            user_agent=user_agent,
            details=details
        )
        
        self.audit_logs.append(log)

    def get_user_audit_logs(self, user_id: str) -> List[AuditLog]:
        """
        è·å–ç”¨æˆ·å®¡è®¡æ—¥å¿—
        
        Args:
            user_id: ç”¨æˆ·ID
            
        Returns:
            å®¡è®¡æ—¥å¿—åˆ—è¡¨
        """
        return [log for log in self.audit_logs if log.user_id == user_id]

    def deactivate_user(self, user_id: str, reason: str = '') -> bool:
        """
        åœç”¨ç”¨æˆ·
        
        Args:
            user_id: ç”¨æˆ·ID
            reason: åŸå› 
            
        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        user = self.users.get(user_id)
        if not user:
            return False
        
        user.status = UserStatus.INACTIVE
        
        # æ’¤é”€æ‰€æœ‰ä¼šè¯
        for session_id, session in list(self.sessions.items()):
            if session.user_id == user_id:
                self.revoke_session(session_id)
        
        self._log_audit(
            user_id=user_id,
            action='USER_DEACTIVATED',
            resource=f'user:{user_id}',
            result='SUCCESS',
            details={'reason': reason}
        )
        
        return True

    def export_user_data(self, user_id: str) -> Dict:
        """
        å¯¼å‡ºç”¨æˆ·æ•°æ®ï¼ˆGDPRï¼‰
        
        Args:
            user_id: ç”¨æˆ·ID
            
        Returns:
            ç”¨æˆ·æ•°æ®
        """
        user = self.users.get(user_id)
        if not user:
            return {}
        
        logs = self.get_user_audit_logs(user_id)
        
        return {
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'first_name': user.first_name,
                'last_name': user.last_name,
                'department': user.department,
                'status': user.status.value,
                'created_at': user.created_at.isoformat(),
                'last_login': user.last_login.isoformat() if user.last_login else None
            },
            'roles': [self.roles.get(r).name for r in user.roles if r in self.roles],
            'audit_logs': [
                {
                    'action': log.action,
                    'resource': log.resource,
                    'result': log.result,
                    'timestamp': log.timestamp.isoformat()
                }
                for log in logs
            ]
        }


def main():
    """ä¸»å‡½æ•°"""
    # åˆå§‹åŒ–IAMç®¡ç†å™¨
    iam = IAMManager(jwt_secret='your-secret-key')
    
    # åˆ›å»ºè§’è‰²
    admin_role = iam.create_role(
        name='admin',
        description='Administrator role',
        permissions={
            '*': ['admin']
        }
    )
    
    user_role = iam.create_role(
        name='user',
        description='Standard user role',
        permissions={
            'profile': ['read', 'write'],
            'documents': ['read']
        }
    )
    
    # åˆ›å»ºç”¨æˆ·
    user = iam.create_user(
        username='john.doe',
        email='john.doe@example.com',
        password='SecurePass123!',
        first_name='John',
        last_name='Doe',
        department='IT',
        roles=[user_role.id]
    )
    
    # è®¤è¯ç”¨æˆ·
    success, access_token, refresh_token = iam.authenticate_user(
        username='john.doe',
        password='SecurePass123!',
        ip_address='192.168.1.1',
        user_agent='Mozilla/5.0'
    )
    
    if success:
        print(f"è®¤è¯æˆåŠŸï¼Œè®¿é—®ä»¤ç‰Œ: {access_token[:20]}...")
        
        # æ£€æŸ¥æƒé™
        has_permission = iam.check_permission(
            user_id=user.id,
            resource='documents',
            permission=Permission.READ
        )
        print(f"æœ‰è¯»å–æƒé™: {has_permission}")
    else:
        print("è®¤è¯å¤±è´¥")


if __name__ == '__main__':
    main()
```

### 2.7 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| å¹³å‡è®¤è¯æ—¶é—´ | 5ç§’ | 0.5ç§’ | 10x |
| ç”¨æˆ·ç™»å½•æ¬¡æ•° | 10æ¬¡/å¤© | 1æ¬¡/å¤© | 90%å‡å°‘ |
| è´¦å·æ³„éœ²äº‹ä»¶ | 5æ¬¡/å¹´ | 0æ¬¡/å¹´ | 100%æ¶ˆé™¤ |
| æƒé™å›æ”¶æ—¶é—´ | 3å¤© | å®æ—¶ | æ˜¾è‘—æå‡ |
| åˆè§„å®¡è®¡å‡†å¤‡ | 2å‘¨ | å®æ—¶ | æ˜¾è‘—æå‡ |

**ROIåˆ†æ**ï¼š

1. **æˆæœ¬èŠ‚çº¦**ï¼š
   - å¯†ç é‡ç½®æ”¯æŒæˆæœ¬ï¼šæ¯å¹´ 200ä¸‡å…ƒ
   - å®‰å…¨äº‹ä»¶å¤„ç†æˆæœ¬ï¼šæ¯å¹´ 500ä¸‡å…ƒ
   - åˆè§„å®¡è®¡æˆæœ¬ï¼šæ¯å¹´ 300ä¸‡å…ƒ

2. **æŠ•èµ„å›æŠ¥ç‡**ï¼š
   - æ€»æŠ•èµ„ï¼š600ä¸‡å…ƒ
   - å¹´åº¦æ”¶ç›Šï¼š1000ä¸‡å…ƒ
   - ROIï¼š167%

**ç»éªŒæ•™è®­**ï¼š

1. **æ¸è¿›å¼è¿ç§»**ï¼šå¤§è§„æ¨¡è¿ç§»åº”åˆ†é˜¶æ®µè¿›è¡Œ
2. **ç”¨æˆ·ä½“éªŒ**ï¼šå®‰å…¨ä¸åº”ä»¥ç‰ºç‰²ç”¨æˆ·ä½“éªŒä¸ºä»£ä»·
3. **ç›‘æ§å…ˆè¡Œ**ï¼šå®Œå–„çš„ç›‘æ§æ˜¯å¿«é€Ÿå‘ç°é—®é¢˜çš„å…³é”®
4. **æŒç»­åŸ¹è®­**ï¼šå®šæœŸå¯¹ç”¨æˆ·è¿›è¡Œå®‰å…¨æ„è¯†åŸ¹è®­

---

## 3. æ¡ˆä¾‹æ€»ç»“

### æˆåŠŸå› ç´ 

1. **ç»Ÿä¸€èº«ä»½æº**ï¼šå•ä¸€å¯ä¿¡çš„èº«ä»½æ•°æ®æº
2. **é›¶ä¿¡ä»»å®‰å…¨**ï¼šé»˜è®¤ä¸ä¿¡ä»»ï¼ŒæŒç»­éªŒè¯
3. **è‡ªåŠ¨åŒ–ç”Ÿå‘½å‘¨æœŸ**ï¼šå…¥èŒã€è½¬å²—ã€ç¦»èŒè‡ªåŠ¨åŒ–
4. **å…¨é¢å®¡è®¡**ï¼šæ‰€æœ‰æ“ä½œéƒ½æœ‰å®¡è®¡æ—¥å¿—

### æœ€ä½³å®è·µ

1. **æœ€å°æƒé™åŸåˆ™**ï¼šåªæˆäºˆå¿…è¦çš„æƒé™
2. **MFAå¼ºåˆ¶å¯ç”¨**ï¼šæ•æ„Ÿæ“ä½œå¿…é¡»å¯ç”¨MFA
3. **å®šæœŸè®¿é—®å®¡æŸ¥**ï¼šå®šæœŸå®¡æŸ¥å’Œå›æ”¶æƒé™
4. **å¯†ç ç­–ç•¥**ï¼šå¼ºå¯†ç ç­–ç•¥å’Œå®šæœŸæ›´æ¢

---

## 4. å‚è€ƒæ–‡çŒ®

- [OAuth 2.0å®˜æ–¹æ–‡æ¡£](https://oauth.net/2/)
- [OpenID Connect](https://openid.net/connect/)
- [NISTèº«ä»½æŒ‡å—](https://pages.nist.gov/800-63-3/)
- [BeyondCorpè®ºæ–‡](https://cloud.google.com/beyondcorp)

---

**æ–‡æ¡£åˆ›å»ºæ—¶é—´**ï¼š2025-01-21  
**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**ç»´æŠ¤è€…**ï¼šDSL Schemaç ”ç©¶å›¢é˜Ÿ  
**æœ€åæ›´æ–°**ï¼š2025-01-21

# é¢„æµ‹åˆ†æSchemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [é¢„æµ‹åˆ†æSchemaå®è·µæ¡ˆä¾‹](#é¢„æµ‹åˆ†æschemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šæ–°èƒ½æºè½¦ä¼éœ€æ±‚é¢„æµ‹ä¸ä¾›åº”é“¾ä¼˜åŒ–ç³»ç»Ÿ](#2-æ¡ˆä¾‹1æ–°èƒ½æºè½¦ä¼éœ€æ±‚é¢„æµ‹ä¸ä¾›åº”é“¾ä¼˜åŒ–ç³»ç»Ÿ)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ](#27-æ•ˆæœè¯„ä¼°ä¸roiåˆ†æ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›é¢„æµ‹åˆ†æSchemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„æ·±åº¦å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–éœ€æ±‚é¢„æµ‹ã€ä¾›åº”é“¾ä¼˜åŒ–ã€è®¾å¤‡é¢„æµ‹æ€§ç»´æŠ¤ç­‰ä¼ä¸šçº§åœºæ™¯ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šæ–°èƒ½æºè½¦ä¼éœ€æ±‚é¢„æµ‹ä¸ä¾›åº”é“¾ä¼˜åŒ–ç³»ç»Ÿ

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šç®€ä»‹**ï¼š
æŸæ–°èƒ½æºæ±½è½¦ä¼ä¸šï¼ˆä»¥ä¸‹ç®€ç§°"åèƒ½æ±½è½¦"ï¼‰æˆç«‹äº2015å¹´ï¼Œæ˜¯å›½å†…é¢†å…ˆçš„æ–°èƒ½æºæ±½è½¦åˆ¶é€ å•†ã€‚å…¬å¸æ‹¥æœ‰5å¤§ç”Ÿäº§åŸºåœ°ï¼Œå¹´äº§èƒ½50ä¸‡è¾†ï¼Œ2024å¹´é”€é‡çªç ´30ä¸‡è¾†ã€‚

**ä¸šåŠ¡è§„æ¨¡**ï¼š

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| å¹´äº§èƒ½ | 50ä¸‡è¾† |
| 2024å¹´é”€é‡ | 30ä¸‡è¾† |
| è½¦å‹æ•°é‡ | 8æ¬¾ |
| ä¾›åº”å•† | 500+ |
| SKUæ•°é‡ | 2ä¸‡+ |
| é”€å”®ç½‘ç‚¹ | 1000+ |

### 2.2 ä¸šåŠ¡ç—›ç‚¹

**ç—›ç‚¹1ï¼šéœ€æ±‚é¢„æµ‹ä¸å‡†**
ä¼ ç»Ÿé¢„æµ‹æ–¹æ³•å‡†ç¡®ç‡ä»…65%ï¼Œå¯¼è‡´åº“å­˜ç§¯å‹ä¸ç¼ºè´§å¹¶å­˜ï¼Œåº“å­˜å‘¨è½¬å¤©æ•°é«˜è¾¾45å¤©ã€‚

**ç—›ç‚¹2ï¼šä¾›åº”é“¾å“åº”æ…¢**
é›¶éƒ¨ä»¶ä¾›åº”å‘¨æœŸé•¿ï¼Œé¢å¯¹éœ€æ±‚æ³¢åŠ¨å“åº”è¿Ÿç¼“ï¼Œé¢‘ç¹å‡ºç°æ–­ä¾›æˆ–è¿‡é‡é‡‡è´­ã€‚

**ç—›ç‚¹3ï¼šç”Ÿäº§è®¡åˆ’å¤±è¡¡**
ç”Ÿäº§è®¡åˆ’ä¸å®é™…é”€å”®è„±èŠ‚ï¼Œäº§èƒ½åˆ©ç”¨ç‡æ³¢åŠ¨å¤§ï¼ˆ60%-95%ï¼‰ï¼Œå½±å“æˆæœ¬æ§åˆ¶ã€‚

**ç—›ç‚¹4ï¼šæ–°å“ä¸Šå¸‚é£é™©é«˜**
æ–°è½¦å‹éœ€æ±‚éš¾ä»¥é¢„ä¼°ï¼Œé¦–å•ç”Ÿäº§é‡å†³ç­–ç¼ºä¹æ•°æ®æ”¯æ’‘ï¼Œåº“å­˜ç§¯å‹é£é™©å¤§ã€‚

**ç—›ç‚¹5ï¼šå­£èŠ‚æ€§æ³¢åŠ¨éš¾åº”å¯¹**
æ–°èƒ½æºæ±½è½¦å¸‚åœºå—æ”¿ç­–ã€å­£èŠ‚å½±å“å¤§ï¼Œä¼ ç»Ÿé¢„æµ‹æ— æ³•æ•æ‰å¤æ‚æ¨¡å¼ã€‚

### 2.3 ä¸šåŠ¡ç›®æ ‡

**ç›®æ ‡1ï¼šæå‡é¢„æµ‹å‡†ç¡®ç‡**
æ„å»ºAIé©±åŠ¨çš„éœ€æ±‚é¢„æµ‹æ¨¡å‹ï¼Œå°†é¢„æµ‹å‡†ç¡®ç‡æå‡è‡³85%ä»¥ä¸Šã€‚

**ç›®æ ‡2ï¼šä¼˜åŒ–åº“å­˜ç®¡ç†**
å®ç°é›¶éƒ¨ä»¶æ™ºèƒ½è¡¥è´§ï¼Œå°†åº“å­˜å‘¨è½¬å¤©æ•°é™è‡³30å¤©ä»¥å†…ï¼Œé™ä½åº“å­˜æˆæœ¬20%ã€‚

**ç›®æ ‡3ï¼šåŠ¨æ€ç”Ÿäº§è®¡åˆ’**
æ”¯æŒå‘¨çº§æ»šåŠ¨é¢„æµ‹ï¼Œç”Ÿäº§è®¡åˆ’ä¸å®é™…éœ€æ±‚åŒ¹é…åº¦æå‡è‡³90%ã€‚

**ç›®æ ‡4ï¼šé™ä½ä¾›åº”é“¾é£é™©**
å»ºç«‹ä¾›åº”å•†é£é™©é¢„è­¦æœºåˆ¶ï¼Œæ–­ä¾›é£é™©æå‰30å¤©é¢„è­¦ã€‚

**ç›®æ ‡5ï¼šæå‡å¸‚åœºå“åº”é€Ÿåº¦**
ä»éœ€æ±‚å˜åŒ–è¯†åˆ«åˆ°ä¾›åº”é“¾è°ƒæ•´ï¼Œå“åº”æ—¶é—´ç¼©çŸ­è‡³7å¤©ä»¥å†…ã€‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

**æŒ‘æˆ˜1ï¼šå¤šç»´åº¦é¢„æµ‹**
éœ€è¦åŒæ—¶è€ƒè™‘è½¦å‹ã€é…ç½®ã€åŒºåŸŸã€æ—¶é—´ç­‰å¤šç»´åº¦å› ç´ ï¼Œé¢„æµ‹å¤æ‚åº¦æé«˜ã€‚

**æŒ‘æˆ˜2ï¼šå¤–éƒ¨å› ç´ å½±å“**
æ”¿ç­–è¡¥è´´ã€ç«å“åŠ¨æ€ã€å®è§‚ç»æµã€å¤©æ°”ç­‰å¤–éƒ¨å› ç´ å¯¹éœ€æ±‚å½±å“æ˜¾è‘—ã€‚

**æŒ‘æˆ˜3ï¼šæ–°äº§å“å†·å¯åŠ¨**
æ–°è½¦å‹ç¼ºä¹å†å²æ•°æ®ï¼Œéœ€è¦ç»“åˆç›¸ä¼¼äº§å“å’Œå¸‚åœºç ”ç©¶è¿›è¡Œé¢„æµ‹ã€‚

**æŒ‘æˆ˜4ï¼šé•¿å‘¨æœŸä¾èµ–**
é›¶éƒ¨ä»¶é‡‡è´­å‘¨æœŸé•¿ï¼ˆ3-6ä¸ªæœˆï¼‰ï¼Œéœ€è¦ä¸­é•¿æœŸé¢„æµ‹æ”¯æ’‘é‡‡è´­å†³ç­–ã€‚

**æŒ‘æˆ˜5ï¼šä¸ç¡®å®šæ€§é‡åŒ–**
éœ€è¦è¾“å‡ºé¢„æµ‹åŒºé—´è€Œä¸ä»…æ˜¯ç‚¹ä¼°è®¡ï¼Œæ”¯æŒé£é™©å†³ç­–ã€‚

### 2.5 è§£å†³æ–¹æ¡ˆ

**é¢„æµ‹æ¨¡å‹æ¶æ„**ï¼š
- **çŸ­æœŸé¢„æµ‹ï¼ˆ1-4å‘¨ï¼‰**ï¼šLSTM + XGBoost
- **ä¸­æœŸé¢„æµ‹ï¼ˆ1-6æœˆï¼‰**ï¼šProphet + å¤–éƒ¨å› ç´ å›å½’
- **é•¿æœŸé¢„æµ‹ï¼ˆ6-12æœˆï¼‰**ï¼šè®¡é‡ç»æµæ¨¡å‹ + æƒ…æ™¯åˆ†æ
- **æ–°å“é¢„æµ‹**ï¼šç±»æ¯”æ³• + ä¸“å®¶åˆ¤æ–­ + ä¸Šå¸‚æ›²çº¿æ‹Ÿåˆ

**ä¾›åº”é“¾ä¼˜åŒ–**ï¼š
- å®‰å…¨åº“å­˜åŠ¨æ€è®¡ç®—
- å¤šçº§åº“å­˜ä¼˜åŒ–ï¼ˆä¸­å¿ƒä»“+åŒºåŸŸä»“ï¼‰
- ä¾›åº”å•†ååŒé¢„æµ‹ï¼ˆCPFRï¼‰

### 2.6 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
æ–°èƒ½æºè½¦ä¼éœ€æ±‚é¢„æµ‹ä¸ä¾›åº”é“¾ä¼˜åŒ–ç³»ç»Ÿ
åŸºäºæ·±åº¦å­¦ä¹ å’Œæ—¶é—´åºåˆ—åˆ†æçš„ä¼ä¸šçº§é¢„æµ‹è§£å†³æ–¹æ¡ˆ
"""

from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timedelta
import json
import numpy as np
from collections import defaultdict


class ForecastHorizon(str, Enum):
    """é¢„æµ‹å‘¨æœŸ"""
    SHORT_TERM = "Short"      # 1-4å‘¨
    MEDIUM_TERM = "Medium"    # 1-6æœˆ
    LONG_TERM = "Long"        # 6-12æœˆ


class ProductLifecycle(str, Enum):
    """äº§å“ç”Ÿå‘½å‘¨æœŸ"""
    INTRODUCTION = "Introduction"
    GROWTH = "Growth"
    MATURITY = "Maturity"
    DECLINE = "Decline"


class SupplyRiskLevel(str, Enum):
    """ä¾›åº”é£é™©ç­‰çº§"""
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"
    CRITICAL = "Critical"


@dataclass
class VehicleModel:
    """è½¦å‹"""
    model_id: str
    model_name: str
    launch_date: datetime
    lifecycle_stage: ProductLifecycle
    base_price: float
    
    # å†å²é”€é‡ï¼ˆæŒ‰å‘¨ï¼‰
    weekly_sales_history: List[Tuple[datetime, int]] = field(default_factory=list)
    
    def get_sales_trend(self, weeks: int = 12) -> float:
        """è·å–é”€é‡è¶‹åŠ¿"""
        if len(self.weekly_sales_history) < weeks:
            return 0.0
        
        recent_sales = [s[1] for s in self.weekly_sales_history[-weeks:]]
        if len(recent_sales) < 2:
            return 0.0
        
        # è®¡ç®—è¶‹åŠ¿ï¼ˆçº¿æ€§å›å½’æ–œç‡ç®€åŒ–ç‰ˆï¼‰
        x = np.arange(len(recent_sales))
        slope = np.polyfit(x, recent_sales, 1)[0]
        return slope


@dataclass
class ExternalFactor:
    """å¤–éƒ¨å› ç´ """
    factor_id: str
    factor_name: str
    factor_type: str  # Policy, Economic, Seasonal, Competition, Weather
    impact_weight: float  # -1 to 1
    current_value: float
    forecast_values: List[Tuple[datetime, float]] = field(default_factory=list)


@dataclass
class DemandForecast:
    """éœ€æ±‚é¢„æµ‹ç»“æœ"""
    forecast_id: str
    model_id: str
    horizon: ForecastHorizon
    forecast_date: datetime
    
    # ç‚¹é¢„æµ‹
    point_forecast: int
    
    # åŒºé—´é¢„æµ‹
    lower_bound: int  # 95%ç½®ä¿¡åŒºé—´ä¸‹é™
    upper_bound: int  # 95%ç½®ä¿¡åŒºé—´ä¸Šé™
    
    # åˆ†è§£é¢„æµ‹
    baseline_demand: int  # åŸºç¡€éœ€æ±‚
    trend_component: int  # è¶‹åŠ¿æˆåˆ†
    seasonal_component: int  # å­£èŠ‚æˆåˆ†
    external_impact: int  # å¤–éƒ¨å› ç´ å½±å“
    
    # ç½®ä¿¡åº¦
    confidence_score: float  # 0-1
    
    # å½±å“å› ç´ 
    key_drivers: List[Dict[str, Any]] = field(default_factory=list)


@dataclass
class Supplier:
    """ä¾›åº”å•†"""
    supplier_id: str
    supplier_name: str
    component_types: List[str]
    lead_time_days: int
    reliability_score: float  # 0-1
    capacity_monthly: int
    
    # é£é™©æŒ‡æ ‡
    financial_health: str  # Good, Fair, Poor
    geographic_risk: str  # Low, Medium, High
    alternative_count: int  # æ›¿ä»£ä¾›åº”å•†æ•°é‡
    
    def calculate_risk_score(self) -> float:
        """è®¡ç®—é£é™©è¯„åˆ†"""
        risk = 0.0
        
        # è´¢åŠ¡å¥åº·åº¦
        if self.financial_health == "Poor":
            risk += 0.3
        elif self.financial_health == "Fair":
            risk += 0.15
        
        # äº¤è´§å¯é æ€§
        risk += (1 - self.reliability_score) * 0.3
        
        # åœ°ç†é£é™©
        if self.geographic_risk == "High":
            risk += 0.25
        elif self.geographic_risk == "Medium":
            risk += 0.1
        
        # æ›¿ä»£æ€§
        if self.alternative_count == 0:
            risk += 0.15
        elif self.alternative_count < 3:
            risk += 0.05
        
        return min(1.0, risk)
    
    def get_risk_level(self) -> SupplyRiskLevel:
        """è·å–é£é™©ç­‰çº§"""
        score = self.calculate_risk_score()
        if score >= 0.7:
            return SupplyRiskLevel.CRITICAL
        elif score >= 0.5:
            return SupplyRiskLevel.HIGH
        elif score >= 0.3:
            return SupplyRiskLevel.MEDIUM
        else:
            return SupplyRiskLevel.LOW


@dataclass
class InventoryPolicy:
    """åº“å­˜ç­–ç•¥"""
    component_id: str
    component_name: str
    current_stock: int
    reorder_point: int
    safety_stock: int
    economic_order_qty: int
    
    supplier_id: str
    lead_time_days: int
    
    def calculate_safety_stock(self, demand_forecast: DemandForecast, 
                              service_level: float = 0.95) -> int:
        """è®¡ç®—å®‰å…¨åº“å­˜"""
        # ç®€åŒ–è®¡ç®—
        avg_demand = demand_forecast.point_forecast / 30  # æ—¥å‡éœ€æ±‚
        demand_std = (demand_forecast.upper_bound - demand_forecast.lower_bound) / 4
        
        # Zå€¼ï¼ˆ95%æœåŠ¡æ°´å¹³å¯¹åº”1.65ï¼‰
        z_score = 1.65
        
        # å®‰å…¨åº“å­˜ = Z * Ïƒ * sqrt(lead_time)
        safety_stock = int(z_score * demand_std * np.sqrt(self.lead_time_days))
        return safety_stock
    
    def should_reorder(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¡¥è´§"""
        return self.current_stock <= self.reorder_point
    
    def get_reorder_qty(self) -> int:
        """è·å–å»ºè®®è¡¥è´§é‡"""
        if not self.should_reorder():
            return 0
        return self.economic_order_qty


@dataclass
class PredictiveAnalyticsEngine:
    """é¢„æµ‹åˆ†æå¼•æ“"""
    engine_id: str
    engine_name: str
    
    # è½¦å‹æ³¨å†Œè¡¨
    vehicle_models: Dict[str, VehicleModel] = field(default_factory=dict)
    
    # å¤–éƒ¨å› ç´ 
    external_factors: Dict[str, ExternalFactor] = field(default_factory=dict)
    
    # ä¾›åº”å•†æ³¨å†Œè¡¨
    suppliers: Dict[str, Supplier] = field(default_factory=dict)
    
    # åº“å­˜ç­–ç•¥
    inventory_policies: Dict[str, InventoryPolicy] = field(default_factory=dict)
    
    def register_vehicle_model(self, model: VehicleModel):
        """æ³¨å†Œè½¦å‹"""
        self.vehicle_models[model.model_id] = model
    
    def register_external_factor(self, factor: ExternalFactor):
        """æ³¨å†Œå¤–éƒ¨å› ç´ """
        self.external_factors[factor.factor_id] = factor
    
    def register_supplier(self, supplier: Supplier):
        """æ³¨å†Œä¾›åº”å•†"""
        self.suppliers[supplier.supplier_id] = supplier
    
    def generate_forecast(self, model_id: str, horizon: ForecastHorizon, 
                         periods: int) -> List[DemandForecast]:
        """ç”Ÿæˆéœ€æ±‚é¢„æµ‹"""
        model = self.vehicle_models.get(model_id)
        if not model:
            return []
        
        forecasts = []
        base_date = datetime.now()
        
        # è®¡ç®—åŸºç¡€éœ€æ±‚
        if model.weekly_sales_history:
            recent_avg = np.mean([s[1] for s in model.weekly_sales_history[-12:]])
        else:
            recent_avg = 1000  # é»˜è®¤å€¼
        
        # è·å–è¶‹åŠ¿
        trend = model.get_sales_trend()
        
        # å¤–éƒ¨å› ç´ ç»¼åˆå½±å“
        external_impact = sum(f.impact_weight * f.current_value 
                            for f in self.external_factors.values())
        
        for i in range(periods):
            forecast_date = base_date + timedelta(weeks=i+1)
            
            # è¶‹åŠ¿æˆåˆ†
            trend_comp = trend * (i + 1)
            
            # å­£èŠ‚æˆåˆ†ï¼ˆç®€åŒ–æ¨¡æ‹Ÿï¼‰
            month = forecast_date.month
            seasonal_factor = 1.0 + 0.1 * np.sin(2 * np.pi * month / 12)
            seasonal_comp = recent_avg * (seasonal_factor - 1)
            
            # ç‚¹é¢„æµ‹
            point_forecast = int(recent_avg + trend_comp + seasonal_comp + 
                               recent_avg * external_impact * 0.1)
            point_forecast = max(0, point_forecast)
            
            # åŒºé—´é¢„æµ‹
            uncertainty = 0.15 * point_forecast * (1 + i * 0.05)  # é¢„æµ‹è¶Šè¿œä¸ç¡®å®šæ€§è¶Šå¤§
            lower_bound = int(point_forecast - 1.96 * uncertainty)
            upper_bound = int(point_forecast + 1.96 * uncertainty)
            
            forecast = DemandForecast(
                forecast_id=f"FC-{model_id}-{i}",
                model_id=model_id,
                horizon=horizon,
                forecast_date=forecast_date,
                point_forecast=point_forecast,
                lower_bound=max(0, lower_bound),
                upper_bound=upper_bound,
                baseline_demand=int(recent_avg),
                trend_component=int(trend_comp),
                seasonal_component=int(seasonal_comp),
                external_impact=int(recent_avg * external_impact * 0.1),
                confidence_score=max(0.5, 0.95 - i * 0.02),
                key_drivers=[
                    {"factor": "Trend", "impact": trend_comp},
                    {"factor": "Seasonality", "impact": seasonal_comp},
                    {"factor": "External", "impact": external_impact}
                ]
            )
            forecasts.append(forecast)
        
        return forecasts
    
    def optimize_inventory(self, component_id: str, 
                          forecast: DemandForecast) -> InventoryPolicy:
        """ä¼˜åŒ–åº“å­˜ç­–ç•¥"""
        # æŸ¥æ‰¾ç°æœ‰ç­–ç•¥æˆ–åˆ›å»ºæ–°ç­–ç•¥
        policy = self.inventory_policies.get(component_id)
        if not policy:
            # åˆ›å»ºæ–°ç­–ç•¥
            policy = InventoryPolicy(
                component_id=component_id,
                component_name=f"Component-{component_id}",
                current_stock=5000,
                reorder_point=0,
                safety_stock=0,
                economic_order_qty=10000,
                supplier_id="SUP-001",
                lead_time_days=30
            )
        
        # é‡æ–°è®¡ç®—å®‰å…¨åº“å­˜
        policy.safety_stock = policy.calculate_safety_stock(forecast)
        
        # é‡æ–°è®¡ç®—å†è®¢è´§ç‚¹
        daily_demand = forecast.point_forecast / 30
        policy.reorder_point = int(daily_demand * policy.lead_time_days + policy.safety_stock)
        
        self.inventory_policies[component_id] = policy
        return policy
    
    def assess_supply_risks(self) -> List[Dict[str, Any]]:
        """è¯„ä¼°ä¾›åº”é£é™©"""
        risks = []
        
        for supplier in self.suppliers.values():
            risk_score = supplier.calculate_risk_score()
            risk_level = supplier.get_risk_level()
            
            if risk_level in [SupplyRiskLevel.HIGH, SupplyRiskLevel.CRITICAL]:
                risks.append({
                    "supplier_id": supplier.supplier_id,
                    "supplier_name": supplier.supplier_name,
                    "risk_score": risk_score,
                    "risk_level": risk_level.value,
                    "affected_components": supplier.component_types,
                    "mitigation_suggestions": self._generate_mitigation_suggestions(supplier)
                })
        
        return sorted(risks, key=lambda x: x["risk_score"], reverse=True)
    
    def _generate_mitigation_suggestions(self, supplier: Supplier) -> List[str]:
        """ç”Ÿæˆé£é™©ç¼“è§£å»ºè®®"""
        suggestions = []
        
        if supplier.alternative_count < 2:
            suggestions.append("Develop alternative suppliers")
        
        if supplier.financial_health == "Poor":
            suggestions.append("Monitor financial status closely and consider prepayment protection")
        
        if supplier.geographic_risk == "High":
            suggestions.append("Diversify sourcing geographically")
        
        if supplier.reliability_score < 0.8:
            suggestions.append("Implement supplier quality improvement program")
        
        return suggestions
    
    def generate_executive_report(self) -> Dict[str, Any]:
        """ç”Ÿæˆé«˜ç®¡æŠ¥å‘Š"""
        return {
            "report_date": datetime.now().isoformat(),
            "forecast_summary": {
                "models_count": len(self.vehicle_models),
                "forecast_periods": 12,
                "avg_confidence": 0.85
            },
            "inventory_summary": {
                "total_components": len(self.inventory_policies),
                "reorder_needed": len([p for p in self.inventory_policies.values() if p.should_reorder()]),
                "avg_safety_stock_days": 15
            },
            "supply_risk_summary": {
                "total_suppliers": len(self.suppliers),
                "high_risk_suppliers": len([s for s in self.suppliers.values() 
                                           if s.get_risk_level() in [SupplyRiskLevel.HIGH, SupplyRiskLevel.CRITICAL]]),
                "risk_alerts": len(self.assess_supply_risks())
            }
        }


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    print("=" * 70)
    print("åèƒ½æ±½è½¦ - éœ€æ±‚é¢„æµ‹ä¸ä¾›åº”é“¾ä¼˜åŒ–ç³»ç»Ÿ")
    print("=" * 70)
    
    # åˆ›å»ºé¢„æµ‹å¼•æ“
    engine = PredictiveAnalyticsEngine(
        engine_id="PA-HUANENG-001",
        engine_name="åèƒ½æ±½è½¦é¢„æµ‹åˆ†æå¼•æ“"
    )
    
    # 1. æ³¨å†Œè½¦å‹
    print("\n[1] æ³¨å†Œè½¦å‹æ•°æ®...")
    model_a = VehicleModel(
        model_id="MODEL-A",
        model_name="åèƒ½A Plus",
        launch_date=datetime(2023, 6, 1),
        lifecycle_stage=ProductLifecycle.GROWTH,
        base_price=250000,
        weekly_sales_history=[(datetime.now() - timedelta(weeks=i), 2000 + i*50) for i in range(24, 0, -1)]
    )
    engine.register_vehicle_model(model_a)
    print(f"è½¦å‹: {model_a.model_name}")
    print(f"ç”Ÿå‘½å‘¨æœŸ: {model_a.lifecycle_stage.value}")
    print(f"å†å²é”€é‡è¶‹åŠ¿: {model_a.get_sales_trend():.1f} è¾†/å‘¨")
    
    # 2. æ³¨å†Œå¤–éƒ¨å› ç´ 
    print("\n[2] æ³¨å†Œå¤–éƒ¨å½±å“å› ç´ ...")
    subsidy_factor = ExternalFactor(
        factor_id="FACTOR-SUBSIDY",
        factor_name="æ–°èƒ½æºè¡¥è´´",
        factor_type="Policy",
        impact_weight=0.3,
        current_value=1.0
    )
    engine.register_external_factor(subsidy_factor)
    
    season_factor = ExternalFactor(
        factor_id="FACTOR-SEASON",
        factor_name="å­£èŠ‚æ€§å› ç´ ",
        factor_type="Seasonal",
        impact_weight=0.2,
        current_value=1.0
    )
    engine.register_external_factor(season_factor)
    
    # 3. ç”Ÿæˆéœ€æ±‚é¢„æµ‹
    print("\n[3] ç”Ÿæˆæœªæ¥12å‘¨éœ€æ±‚é¢„æµ‹...")
    forecasts = engine.generate_forecast("MODEL-A", ForecastHorizon.SHORT_TERM, 12)
    
    print(f"é¢„æµ‹ç»“æœæ±‡æ€»:")
    total_forecast = sum(f.point_forecast for f in forecasts)
    print(f"  æ€»é¢„æµ‹éœ€æ±‚: {total_forecast:,} è¾†")
    print(f"  å¹³å‡å‘¨éœ€æ±‚: {total_forecast/12:,.0f} è¾†")
    print(f"  é¢„æµ‹ç½®ä¿¡åº¦: {np.mean([f.confidence_score for f in forecasts]):.1%}")
    
    print("\nå‰4å‘¨è¯¦ç»†é¢„æµ‹:")
    for i, forecast in enumerate(forecasts[:4], 1):
        print(f"  ç¬¬{i}å‘¨ ({forecast.forecast_date.strftime('%Y-%m-%d')}):")
        print(f"    é¢„æµ‹å€¼: {forecast.point_forecast:,} è¾†")
        print(f"    ç½®ä¿¡åŒºé—´: [{forecast.lower_bound:,}, {forecast.upper_bound:,}]")
    
    # 4. æ³¨å†Œä¾›åº”å•†
    print("\n[4] æ³¨å†Œä¾›åº”å•†ä¿¡æ¯...")
    supplier1 = Supplier(
        supplier_id="SUP-001",
        supplier_name="åé€šç”µæ± ",
        component_types=["Battery", "BMS"],
        lead_time_days=45,
        reliability_score=0.92,
        capacity_monthly=50000,
        financial_health="Good",
        geographic_risk="Low",
        alternative_count=3
    )
    engine.register_supplier(supplier1)
    
    supplier2 = Supplier(
        supplier_id="SUP-002",
        supplier_name="è¿œè¾¾èŠ¯ç‰‡",
        component_types=["Chip", "MCU"],
        lead_time_days=90,
        reliability_score=0.75,
        capacity_monthly=30000,
        financial_health="Fair",
        geographic_risk="High",
        alternative_count=1
    )
    engine.register_supplier(supplier2)
    
    # 5. ä¼˜åŒ–åº“å­˜ç­–ç•¥
    print("\n[5] ä¼˜åŒ–é›¶éƒ¨ä»¶åº“å­˜ç­–ç•¥...")
    policy = engine.optimize_inventory("BATT-001", forecasts[0])
    print(f"é›¶éƒ¨ä»¶: {policy.component_id}")
    print(f"å®‰å…¨åº“å­˜: {policy.safety_stock:,} ä»¶")
    print(f"å†è®¢è´§ç‚¹: {policy.reorder_point:,} ä»¶")
    print(f"ç»æµè®¢è´§é‡: {policy.economic_order_qty:,} ä»¶")
    print(f"å½“å‰åº“å­˜: {policy.current_stock:,} ä»¶")
    print(f"æ˜¯å¦éœ€è¦è¡¥è´§: {'æ˜¯' if policy.should_reorder() else 'å¦'}")
    
    # 6. ä¾›åº”é£é™©è¯„ä¼°
    print("\n[6] ä¾›åº”å•†é£é™©è¯„ä¼°...")
    risks = engine.assess_supply_risks()
    if risks:
        print(f"å‘ç° {len(risks)} ä¸ªé«˜é£é™©ä¾›åº”å•†:")
        for risk in risks:
            print(f"  - {risk['supplier_name']} (é£é™©è¯„åˆ†: {risk['risk_score']:.2f})")
            print(f"    é£é™©ç­‰çº§: {risk['risk_level']}")
            print(f"    å»ºè®®æªæ–½: {', '.join(risk['mitigation_suggestions'])}")
    else:
        print("æ‰€æœ‰ä¾›åº”å•†é£é™©å¯æ§")
    
    # 7. ç”Ÿæˆé«˜ç®¡æŠ¥å‘Š
    print("\n[7] ç”Ÿæˆé«˜ç®¡å†³ç­–æŠ¥å‘Š...")
    report = engine.generate_executive_report()
    print(f"é¢„æµ‹æ¦‚è§ˆ:")
    print(f"  è½¦å‹æ•°é‡: {report['forecast_summary']['models_count']}")
    print(f"  å¹³å‡ç½®ä¿¡åº¦: {report['forecast_summary']['avg_confidence']:.1%}")
    print(f"\nåº“å­˜æ¦‚è§ˆ:")
    print(f"  é›¶éƒ¨ä»¶ç§ç±»: {report['inventory_summary']['total_components']}")
    print(f"  éœ€è¡¥è´§é¡¹: {report['inventory_summary']['reorder_needed']}")
    print(f"\nä¾›åº”é£é™©æ¦‚è§ˆ:")
    print(f"  ä¾›åº”å•†æ€»æ•°: {report['supply_risk_summary']['total_suppliers']}")
    print(f"  é«˜é£é™©ä¾›åº”å•†: {report['supply_risk_summary']['high_risk_suppliers']}")
```

### 2.7 æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ

**é¡¹ç›®æŠ•å…¥**ï¼š

| æŠ•å…¥ç±»åˆ« | é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰ |
|---------|------------|
| è½¯ä»¶å¹³å° | 500 |
| æ•°æ®å·¥ç¨‹ | 300 |
| æ¨¡å‹å¼€å‘ | 400 |
| é›†æˆå®æ–½ | 300 |
| **æ€»æŠ•èµ„** | **1500** |

**é‡åŒ–æ”¶ç›Š**ï¼š

| æ”¶ç›Šç±»åˆ« | å¹´æ”¶ç›Šï¼ˆä¸‡å…ƒï¼‰ |
|---------|--------------|
| åº“å­˜æˆæœ¬é™ä½ | 3000 |
| ç¼ºè´§æŸå¤±å‡å°‘ | 1500 |
| ç”Ÿäº§æ•ˆç‡æå‡ | 800 |
| ä¾›åº”é“¾é£é™©é™ä½ | 500 |
| **å¹´æ€»æ”¶ç›Š** | **5800** |

**ROI**ï¼š
```
ROI = (5800 - 200) / 1500 Ã— 100% = 373%
æŠ•èµ„å›æ”¶æœŸ = 1500 / 5600 = 0.27å¹´ï¼ˆçº¦3.2ä¸ªæœˆï¼‰
```

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| é¢„æµ‹å‡†ç¡®ç‡ | 65% | 87% | +34% |
| åº“å­˜å‘¨è½¬å¤©æ•° | 45å¤© | 28å¤© | -38% |
| ç¼ºè´§ç‡ | 8% | 2% | -75% |
| äº§èƒ½åˆ©ç”¨ç‡æ³¢åŠ¨ | Â±20% | Â±5% | -75% |
| ä¾›åº”é“¾å“åº”æ—¶é—´ | 30å¤© | 7å¤© | -77% |

---

**åˆ›å»ºæ—¶é—´**ï¼š2025-02-15

# æ•°æ®æ²»ç†Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [æ•°æ®æ²»ç†Schemaå®è·µæ¡ˆä¾‹](#æ•°æ®æ²»ç†schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šåŒ»ç–—é›†å›¢æ•°æ®æ²»ç†ä¸åˆè§„å¹³å°](#2-æ¡ˆä¾‹1åŒ»ç–—é›†å›¢æ•°æ®æ²»ç†ä¸åˆè§„å¹³å°)
    - [2.1 ä¼ä¸šèƒŒæ™¯](#21-ä¼ä¸šèƒŒæ™¯)
    - [2.2 ä¸šåŠ¡ç—›ç‚¹](#22-ä¸šåŠ¡ç—›ç‚¹)
    - [2.3 ä¸šåŠ¡ç›®æ ‡](#23-ä¸šåŠ¡ç›®æ ‡)
    - [2.4 æŠ€æœ¯æŒ‘æˆ˜](#24-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.5 è§£å†³æ–¹æ¡ˆ](#25-è§£å†³æ–¹æ¡ˆ)
    - [2.6 å®Œæ•´ä»£ç å®ç°](#26-å®Œæ•´ä»£ç å®ç°)
    - [2.7 æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ](#27-æ•ˆæœè¯„ä¼°ä¸roiåˆ†æ)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›æ•°æ®æ²»ç†Schemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„æ·±åº¦å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–åŒ»ç–—æ•°æ®åˆè§„ã€ä¸»æ•°æ®ç®¡ç†ã€æ•°æ®è´¨é‡ç®¡ç†ç­‰ä¼ä¸šçº§åœºæ™¯ã€‚

---

## 2. æ¡ˆä¾‹1ï¼šåŒ»ç–—é›†å›¢æ•°æ®æ²»ç†ä¸åˆè§„å¹³å°

### 2.1 ä¼ä¸šèƒŒæ™¯

**ä¼ä¸šç®€ä»‹**ï¼š
æŸå¤§å‹åŒ»ç–—é›†å›¢ï¼ˆä»¥ä¸‹ç®€ç§°"ååº·åŒ»ç–—"ï¼‰æ‹¥æœ‰50å®¶åŒ»é™¢ã€200å®¶è¯Šæ‰€ï¼Œå¹´é—¨è¯Šé‡3000ä¸‡äººæ¬¡ï¼Œå¹´ä½é™¢é‡100ä¸‡äººæ¬¡ï¼Œæ˜¯ä¸­å›½é¢†å…ˆçš„ç»¼åˆæ€§åŒ»ç–—æœåŠ¡é›†å›¢ã€‚

**ä¸šåŠ¡è§„æ¨¡**ï¼š

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| åŒ»é™¢æ•°é‡ | 50å®¶ |
| è¯Šæ‰€æ•°é‡ | 200å®¶ |
| å¹´é—¨è¯Šé‡ | 3000ä¸‡+ |
| å¹´ä½é™¢é‡ | 100ä¸‡+ |
| ç”µå­ç—…å†æ•° | 5000ä¸‡+ |
| æ—¥æ–°å¢æ•°æ® | 500GB+ |
| åˆè§„è¦æ±‚ | HIPAA + ç­‰ä¿2.0 + ä¸ªäººä¿¡æ¯ä¿æŠ¤æ³• |

### 2.2 ä¸šåŠ¡ç—›ç‚¹

**ç—›ç‚¹1ï¼šæ•°æ®åˆè§„é£é™©é«˜**
åŒ»ç–—æ•°æ®æ¶‰åŠé«˜åº¦æ•æ„Ÿçš„ä¸ªäººå¥åº·ä¿¡æ¯ï¼ˆPHIï¼‰ï¼Œéœ€è¦ç¬¦åˆHIPAAã€ç­‰ä¿2.0ã€ä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ç­‰ä¸¥æ ¼æ³•è§„ï¼Œè¿è§„é£é™©æé«˜ã€‚

**ç—›ç‚¹2ï¼šæ•°æ®è´¨é‡å·®**
å„åŒ»é™¢æ•°æ®æ ‡å‡†ä¸ç»Ÿä¸€ï¼ŒåŒä¸€æ‚£è€…å­˜åœ¨å¤šä¸ªIDï¼Œè¯Šæ–­ç¼–ç ä¸è§„èŒƒï¼Œæ•°æ®ç¼ºå¤±ç‡é«˜è¾¾20%ï¼Œå½±å“ä¸´åºŠå†³ç­–å’Œç§‘ç ”åˆ†æã€‚

**ç—›ç‚¹3ï¼šæ•°æ®å­¤å²›ä¸¥é‡**
HISã€EMRã€PACSã€LISç­‰ç³»ç»Ÿå„è‡ªç‹¬ç«‹ï¼Œæ‚£è€…æ•°æ®æ— æ³•è·¨é™¢å…±äº«ï¼Œé‡å¤æ£€æŸ¥ã€é‡å¤ç”¨è¯é—®é¢˜çªå‡ºã€‚

**ç—›ç‚¹4ï¼šéšç§ä¿æŠ¤å›°éš¾**
ç¼ºä¹æœ‰æ•ˆçš„æ•°æ®è„±æ•å’Œè®¿é—®æ§åˆ¶æœºåˆ¶ï¼Œæ•°æ®æ³„éœ²é£é™©é«˜ï¼Œéš¾ä»¥å¹³è¡¡æ•°æ®åˆ©ç”¨å’Œéšç§ä¿æŠ¤ã€‚

**ç—›ç‚¹5ï¼šç¼ºä¹ç»Ÿä¸€è§†å›¾**
æ— æ³•æ„å»ºå®Œæ•´çš„æ‚£è€…360åº¦è§†å›¾ï¼ŒåŒ»ç”Ÿæ— æ³•è·å–æ‚£è€…å®Œæ•´å°±è¯Šå†å²ï¼Œå½±å“è¯Šç–—è´¨é‡ã€‚

### 2.3 ä¸šåŠ¡ç›®æ ‡

**ç›®æ ‡1ï¼šå»ºç«‹ç»Ÿä¸€æ•°æ®æ ‡å‡†**
åˆ¶å®šé›†å›¢çº§æ•°æ®æ ‡å‡†ï¼Œç»Ÿä¸€æ‚£è€…ä¸»æ•°æ®ã€åŒ»å­¦æœ¯è¯­ã€è¯Šæ–­ç¼–ç ï¼Œå®ç°æ•°æ®æ ‡å‡†åŒ–ç‡95%ä»¥ä¸Šã€‚

**ç›®æ ‡2ï¼šå®ç°åˆè§„è‡ªåŠ¨åŒ–**
å»ºç«‹è‡ªåŠ¨åŒ–çš„åˆè§„æ£€æŸ¥å’Œå®¡è®¡æœºåˆ¶ï¼Œç¡®ä¿æ‰€æœ‰æ•°æ®æ“ä½œç¬¦åˆæ³•è§„è¦æ±‚ï¼Œåˆè§„æ£€æŸ¥è¦†ç›–ç‡100%ã€‚

**ç›®æ ‡3ï¼šæ„å»ºä¸»æ•°æ®ç®¡ç†ï¼ˆMDMï¼‰**
å»ºç«‹ç»Ÿä¸€çš„æ‚£è€…ã€åŒ»ç”Ÿã€è¯å“ã€è¯Šæ–­ä¸»æ•°æ®ç®¡ç†ä¸­å¿ƒï¼Œå®ç°æ‚£è€…å”¯ä¸€èº«ä»½è¯†åˆ«ã€‚

**ç›®æ ‡4ï¼šæå‡æ•°æ®è´¨é‡**
å»ºç«‹æ•°æ®è´¨é‡ç®¡ç†ä½“ç³»ï¼Œå°†æ•°æ®å‡†ç¡®ç‡æå‡è‡³98%ï¼Œæ•°æ®å®Œæ•´ç‡æå‡è‡³95%ã€‚

**ç›®æ ‡5ï¼šå®ç°å®‰å…¨æ•°æ®å…±äº«**
åœ¨ä¿éšœéšç§çš„å‰æä¸‹ï¼Œå®ç°è·¨é™¢æ•°æ®å®‰å…¨å…±äº«ï¼Œæ”¯æŒä¸´åºŠåä½œå’Œç§‘ç ”åˆ›æ–°ã€‚

### 2.4 æŠ€æœ¯æŒ‘æˆ˜

**æŒ‘æˆ˜1ï¼šå¤šæºå¼‚æ„æ•°æ®æ•´åˆ**
éœ€è¦æ•´åˆæ¥è‡ª50å®¶åŒ»é™¢çš„HISã€EMRã€PACSã€LISç­‰20å¤šç±»ç³»ç»Ÿï¼Œæ•°æ®æ ¼å¼ã€ç¼–ç æ ‡å‡†å„ä¸ç›¸åŒã€‚

**æŒ‘æˆ˜2ï¼šæ‚£è€…èº«ä»½è¯†åˆ«ï¼ˆEMPIï¼‰**
åŒä¸€æ‚£è€…åœ¨ä¸åŒåŒ»é™¢å¯èƒ½æœ‰ä¸åŒIDï¼Œéœ€è¦æ„å»ºä¼ä¸šçº§æ‚£è€…ç´¢å¼•ï¼ˆEMPIï¼‰ï¼Œå‡†ç¡®è¯†åˆ«åŒä¸€æ‚£è€…ã€‚

**æŒ‘æˆ˜3ï¼šå®æ—¶åˆè§„æ£€æŸ¥**
æ‰€æœ‰æ•°æ®è®¿é—®å’Œæ“ä½œéƒ½éœ€è¦å®æ—¶åˆè§„æ£€æŸ¥ï¼Œä¸èƒ½å½±å“ä¸šåŠ¡ç³»ç»Ÿæ€§èƒ½ã€‚

**æŒ‘æˆ˜4ï¼šç»†ç²’åº¦è®¿é—®æ§åˆ¶**
éœ€è¦æ”¯æŒåŸºäºè§’è‰²ã€æ‚£è€…ã€ç§‘å®¤ã€ç—…ç§çš„å¤šç»´åº¦è®¿é—®æ§åˆ¶ï¼Œæƒé™ç®¡ç†æå…¶å¤æ‚ã€‚

**æŒ‘æˆ˜5ï¼šæ•°æ®è„±æ•ä¸æº¯æº**
éœ€è¦å®ç°æ™ºèƒ½åŒ–çš„æ•°æ®è„±æ•ï¼ŒåŒæ—¶ä¿ç•™æ•°æ®è¡€ç¼˜ï¼Œæ”¯æŒåˆè§„å®¡è®¡ã€‚

### 2.5 è§£å†³æ–¹æ¡ˆ

**æ•´ä½“æ¶æ„**ï¼š
- **ä¸»æ•°æ®ç®¡ç†å±‚**ï¼šæ‚£è€…ä¸»æ•°æ®ã€åŒ»ç–—æœ¯è¯­ã€æ ‡å‡†ç¼–ç 
- **æ•°æ®è´¨é‡å±‚**ï¼šæ•°æ®æ¸…æ´—ã€è´¨é‡ç›‘æ§ã€é—®é¢˜ä¿®å¤
- **æ•°æ®å®‰å…¨å±‚**ï¼šåŠ å¯†ã€è„±æ•ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡
- **åˆè§„ç®¡ç†å±‚**ï¼šæ³•è§„æ˜ å°„ã€åˆè§„æ£€æŸ¥ã€å®¡è®¡æŠ¥å‘Š

**æŠ€æœ¯è·¯çº¿**ï¼š
- EMPIï¼šæ¦‚ç‡åŒ¹é…ç®—æ³• + äººå·¥å®¡æ ¸
- æ•°æ®è´¨é‡ï¼šApache Griffin + è‡ªå®šä¹‰è§„åˆ™
- æ•°æ®å®‰å…¨ï¼šåˆ—çº§åŠ å¯† + åŠ¨æ€è„±æ•
- åˆè§„ç®¡ç†ï¼šè‡ªåŠ¨åŒ–ç­–ç•¥å¼•æ“

### 2.6 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
åŒ»ç–—é›†å›¢æ•°æ®æ²»ç†ä¸åˆè§„å¹³å°
æ”¯æŒHIPAAåˆè§„ã€ä¸»æ•°æ®ç®¡ç†ã€æ•°æ®è´¨é‡ç®¡ç†çš„ä¼ä¸šçº§æ–¹æ¡ˆ
"""

from typing import Dict, List, Optional, Set, Any
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import hashlib
import re


class DataClassification(str, Enum):
    """æ•°æ®åˆ†ç±»"""
    PUBLIC = "Public"
    INTERNAL = "Internal"
    CONFIDENTIAL = "Confidential"
    RESTRICTED = "Restricted"  # PHIæ•°æ®


class ComplianceFramework(str, Enum):
    """åˆè§„æ¡†æ¶"""
    HIPAA = "HIPAA"
    GDPR = "GDPR"
    PERSONAL_INFO_PROTECTION = "PersonalInfoProtection"
    GRADE_PROTECTION_2_0 = "GradeProtection2.0"


class QualityDimension(str, Enum):
    """æ•°æ®è´¨é‡ç»´åº¦"""
    COMPLETENESS = "Completeness"
    UNIQUENESS = "Uniqueness"
    VALIDITY = "Validity"
    CONSISTENCY = "Consistency"
    ACCURACY = "Accuracy"
    TIMELINESS = "Timeliness"


class ConsentStatus(str, Enum):
    """æˆæƒçŠ¶æ€"""
    GRANTED = "Granted"
    REVOKED = "Revoked"
    EXPIRED = "Expired"
    PENDING = "Pending"


@dataclass
class PatientIdentity:
    """æ‚£è€…èº«ä»½"""
    patient_id: str
    empi_id: Optional[str] = None  # ä¼ä¸šçº§æ‚£è€…å”¯ä¸€æ ‡è¯†
    
    # èº«ä»½ä¿¡æ¯
    name: str = ""
    id_card: str = ""
    phone: str = ""
    email: Optional[str] = None
    date_of_birth: Optional[datetime] = None
    gender: str = ""
    
    # åœ°å€ä¿¡æ¯
    address: str = ""
    city: str = ""
    province: str = ""
    
    # åŒ¹é…æƒé‡
    match_score: float = 0.0
    source_systems: List[str] = field(default_factory=list)
    
    def get_pii_fields(self) -> List[str]:
        """è·å–PIIå­—æ®µ"""
        return ["name", "id_card", "phone", "email", "address"]
    
    def generate_empi(self) -> str:
        """ç”ŸæˆEMPI"""
        # ä½¿ç”¨èº«ä»½è¯å·å“ˆå¸Œç”ŸæˆEMPI
        if self.id_card:
            hash_obj = hashlib.sha256(self.id_card.encode())
            self.empi_id = f"EMPI-{hash_obj.hexdigest()[:16].upper()}"
        return self.empi_id


@dataclass
class DataQualityRule:
    """æ•°æ®è´¨é‡è§„åˆ™"""
    rule_id: str
    rule_name: str
    dimension: QualityDimension
    rule_type: str
    rule_expression: str
    threshold: float = 0.95
    severity: str = "Error"
    
    def evaluate(self, data: Dict) -> tuple[bool, str]:
        """è¯„ä¼°æ•°æ®è´¨é‡"""
        try:
            if self.dimension == QualityDimension.COMPLETENESS:
                return self._check_completeness(data)
            elif self.dimension == QualityDimension.VALIDITY:
                return self._check_validity(data)
            elif self.dimension == QualityDimension.UNIQUENESS:
                return self._check_uniqueness(data)
            return True, "Pass"
        except Exception as e:
            return False, str(e)
    
    def _check_completeness(self, data: Dict) -> tuple[bool, str]:
        """æ£€æŸ¥å®Œæ•´æ€§"""
        required_fields = self.rule_expression.split(",")
        missing = [f for f in required_fields if not data.get(f)]
        if missing:
            return False, f"Missing fields: {missing}"
        return True, "Pass"
    
    def _check_validity(self, data: Dict) -> tuple[bool, str]:
        """æ£€æŸ¥æœ‰æ•ˆæ€§"""
        if "id_card" in self.rule_expression:
            id_card = data.get("id_card", "")
            # ç®€åŒ–èº«ä»½è¯å·æ ¡éªŒ
            if len(id_card) != 18:
                return False, "Invalid ID card format"
        return True, "Pass"
    
    def _check_uniqueness(self, data: Dict) -> tuple[bool, str]:
        """æ£€æŸ¥å”¯ä¸€æ€§"""
        return True, "Pass"


@dataclass
class DataAccessPolicy:
    """æ•°æ®è®¿é—®ç­–ç•¥"""
    policy_id: str
    policy_name: str
    data_classification: DataClassification
    allowed_roles: List[str] = field(default_factory=list)
    allowed_operations: List[str] = field(default_factory=list)  # READ, WRITE, DELETE
    require_consent: bool = True
    require_approval: bool = False
    mask_fields: List[str] = field(default_factory=list)
    
    def check_access(self, user_role: str, operation: str, has_consent: bool) -> bool:
        """æ£€æŸ¥è®¿é—®æƒé™"""
        if user_role not in self.allowed_roles:
            return False
        if operation not in self.allowed_operations:
            return False
        if self.require_consent and not has_consent:
            return False
        return True


@dataclass
class AuditLog:
    """å®¡è®¡æ—¥å¿—"""
    log_id: str
    timestamp: datetime
    user_id: str
    user_role: str
    patient_id: str
    operation: str
    data_class: DataClassification
    accessed_fields: List[str]
    ip_address: str
    result: str  # SUCCESS, DENIED, ERROR
    reason: Optional[str] = None


@dataclass
class HealthcareDataGovernance:
    """åŒ»ç–—æ•°æ®æ²»ç†å¹³å°"""
    platform_id: str
    platform_name: str
    
    # æ‚£è€…ä¸»æ•°æ®
    patient_registry: Dict[str, PatientIdentity] = field(default_factory=dict)
    
    # æ•°æ®è´¨é‡è§„åˆ™
    quality_rules: List[DataQualityRule] = field(default_factory=list)
    
    # è®¿é—®ç­–ç•¥
    access_policies: Dict[str, DataAccessPolicy] = field(default_factory=dict)
    
    # å®¡è®¡æ—¥å¿—
    audit_logs: List[AuditLog] = field(default_factory=list)
    
    # åˆè§„æ¡†æ¶
    compliance_frameworks: List[ComplianceFramework] = field(default_factory=list)
    
    def register_patient(self, patient: PatientIdentity):
        """æ³¨å†Œæ‚£è€…"""
        patient.generate_empi()
        self.patient_registry[patient.patient_id] = patient
        return patient.empi_id
    
    def match_patient(self, query: Dict) -> List[PatientIdentity]:
        """æ‚£è€…åŒ¹é…ï¼ˆEMPIï¼‰"""
        matches = []
        for patient in self.patient_registry.values():
            score = 0
            if query.get("name") == patient.name:
                score += 0.3
            if query.get("id_card") == patient.id_card:
                score += 0.4
            if query.get("phone") == patient.phone:
                score += 0.2
            if query.get("date_of_birth") == patient.date_of_birth:
                score += 0.1
            
            if score >= 0.8:
                patient.match_score = score
                matches.append(patient)
        
        return sorted(matches, key=lambda x: x.match_score, reverse=True)
    
    def add_quality_rule(self, rule: DataQualityRule):
        """æ·»åŠ è´¨é‡è§„åˆ™"""
        self.quality_rules.append(rule)
    
    def evaluate_data_quality(self, data: Dict) -> Dict[str, Any]:
        """è¯„ä¼°æ•°æ®è´¨é‡"""
        results = {
            "timestamp": datetime.now().isoformat(),
            "total_rules": len(self.quality_rules),
            "passed": 0,
            "failed": 0,
            "details": []
        }
        
        for rule in self.quality_rules:
            passed, message = rule.evaluate(data)
            results["details"].append({
                "rule_id": rule.rule_id,
                "rule_name": rule.rule_name,
                "dimension": rule.dimension.value,
                "passed": passed,
                "message": message
            })
            if passed:
                results["passed"] += 1
            else:
                results["failed"] += 1
        
        return results
    
    def create_access_policy(self, policy: DataAccessPolicy):
        """åˆ›å»ºè®¿é—®ç­–ç•¥"""
        self.access_policies[policy.policy_id] = policy
    
    def access_data(
        self,
        user_id: str,
        user_role: str,
        patient_id: str,
        operation: str,
        requested_fields: List[str],
        ip_address: str,
        has_consent: bool = False
    ) -> Dict[str, Any]:
        """è®¿é—®æ•°æ®ï¼ˆå¸¦åˆè§„æ£€æŸ¥ï¼‰"""
        
        # è·å–æ‚£è€…æ•°æ®
        patient = self.patient_registry.get(patient_id)
        if not patient:
            return {"success": False, "error": "Patient not found"}
        
        # ç¡®å®šæ•°æ®åˆ†ç±»
        data_class = DataClassification.RESTRICTED
        
        # æŸ¥æ‰¾è®¿é—®ç­–ç•¥
        policy = None
        for p in self.access_policies.values():
            if p.data_classification == data_class:
                policy = p
                break
        
        if not policy:
            result = "DENIED"
            reason = "No access policy found"
        else:
            # æ£€æŸ¥æƒé™
            allowed = policy.check_access(user_role, operation, has_consent)
            if allowed:
                result = "SUCCESS"
                reason = None
            else:
                result = "DENIED"
                reason = "Access denied by policy"
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        audit_log = AuditLog(
            log_id=f"LOG-{datetime.now().strftime('%Y%m%d%H%M%S')}",
            timestamp=datetime.now(),
            user_id=user_id,
            user_role=user_role,
            patient_id=patient_id,
            operation=operation,
            data_class=data_class,
            accessed_fields=requested_fields,
            ip_address=ip_address,
            result=result,
            reason=reason
        )
        self.audit_logs.append(audit_log)
        
        if result == "SUCCESS":
            # åº”ç”¨è„±æ•
            masked_data = self._apply_masking(patient, policy.mask_fields if policy else [])
            return {"success": True, "data": masked_data}
        else:
            return {"success": False, "error": reason}
    
    def _apply_masking(self, patient: PatientIdentity, mask_fields: List[str]) -> Dict:
        """åº”ç”¨æ•°æ®è„±æ•"""
        data = {
            "patient_id": patient.patient_id,
            "empi_id": patient.empi_id,
            "name": patient.name,
            "id_card": patient.id_card,
            "phone": patient.phone,
            "email": patient.email
        }
        
        for field in mask_fields:
            if field in data and data[field]:
                value = str(data[field])
                if field in ["name"]:
                    data[field] = value[0] + "*" * (len(value) - 1)
                elif field in ["id_card"]:
                    data[field] = value[:6] + "*" * 8 + value[-4:]
                elif field in ["phone"]:
                    data[field] = value[:3] + "*" * 4 + value[-4:]
        
        return data
    
    def generate_compliance_report(self) -> Dict[str, Any]:
        """ç”Ÿæˆåˆè§„æŠ¥å‘Š"""
        total_accesses = len(self.audit_logs)
        successful_accesses = len([l for l in self.audit_logs if l.result == "SUCCESS"])
        denied_accesses = len([l for l in self.audit_logs if l.result == "DENIED"])
        
        return {
            "report_date": datetime.now().isoformat(),
            "total_audit_logs": total_accesses,
            "successful_accesses": successful_accesses,
            "denied_accesses": denied_accesses,
            "success_rate": successful_accesses / total_accesses if total_accesses else 0,
            "compliance_frameworks": [f.value for f in self.compliance_frameworks],
            "active_policies": len(self.access_policies),
            "registered_patients": len(self.patient_registry)
        }


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == '__main__':
    print("=" * 70)
    print("ååº·åŒ»ç–— - æ•°æ®æ²»ç†ä¸åˆè§„å¹³å°")
    print("=" * 70)
    
    # åˆ›å»ºå¹³å°
    platform = HealthcareDataGovernance(
        platform_id="DG-HUAKANG-001",
        platform_name="ååº·åŒ»ç–—æ•°æ®æ²»ç†å¹³å°",
        compliance_frameworks=[
            ComplianceFramework.HIPAA,
            ComplianceFramework.PERSONAL_INFO_PROTECTION,
            ComplianceFramework.GRADE_PROTECTION_2_0
        ]
    )
    
    # 1. æ³¨å†Œæ‚£è€…
    print("\n[1] æ³¨å†Œæ‚£è€…...")
    patient1 = PatientIdentity(
        patient_id="PAT-001",
        name="å¼ ä¸‰",
        id_card="110101199001011234",
        phone="13800138000",
        gender="M",
        date_of_birth=datetime(1990, 1, 1),
        source_systems=["HIS-Hospital-A"]
    )
    empi = platform.register_patient(patient1)
    print(f"æ‚£è€…ID: {patient1.patient_id}")
    print(f"EMPI: {empi}")
    
    # 2. æ·»åŠ æ•°æ®è´¨é‡è§„åˆ™
    print("\n[2] æ·»åŠ æ•°æ®è´¨é‡è§„åˆ™...")
    completeness_rule = DataQualityRule(
        rule_id="RULE-COMP-001",
        rule_name="æ‚£è€…ä¿¡æ¯å®Œæ•´æ€§æ£€æŸ¥",
        dimension=QualityDimension.COMPLETENESS,
        rule_type="RequiredFields",
        rule_expression="name,id_card,phone,date_of_birth",
        threshold=1.0
    )
    platform.add_quality_rule(completeness_rule)
    
    validity_rule = DataQualityRule(
        rule_id="RULE-VALID-001",
        rule_name="èº«ä»½è¯å·æœ‰æ•ˆæ€§æ£€æŸ¥",
        dimension=QualityDimension.VALIDITY,
        rule_type="RegexMatch",
        rule_expression="id_card",
        threshold=1.0
    )
    platform.add_quality_rule(validity_rule)
    
    print(f"å·²æ·»åŠ  {len(platform.quality_rules)} æ¡è´¨é‡è§„åˆ™")
    
    # 3. è¯„ä¼°æ•°æ®è´¨é‡
    print("\n[3] è¯„ä¼°æ•°æ®è´¨é‡...")
    quality_result = platform.evaluate_data_quality({
        "name": "å¼ ä¸‰",
        "id_card": "110101199001011234",
        "phone": "13800138000",
        "date_of_birth": datetime(1990, 1, 1)
    })
    print(f"é€šè¿‡è§„åˆ™æ•°: {quality_result['passed']}")
    print(f"å¤±è´¥è§„åˆ™æ•°: {quality_result['failed']}")
    
    # 4. åˆ›å»ºè®¿é—®ç­–ç•¥
    print("\n[4] åˆ›å»ºæ•°æ®è®¿é—®ç­–ç•¥...")
    policy = DataAccessPolicy(
        policy_id="POLICY-001",
        policy_name="åŒ»ç”Ÿè®¿é—®PHIæ•°æ®ç­–ç•¥",
        data_classification=DataClassification.RESTRICTED,
        allowed_roles=["DOCTOR", "NURSE", "ADMIN"],
        allowed_operations=["READ"],
        require_consent=True,
        mask_fields=["id_card", "phone"]
    )
    platform.create_access_policy(policy)
    print(f"ç­–ç•¥ID: {policy.policy_id}")
    
    # 5. è®¿é—®æ•°æ®
    print("\n[5] æ•°æ®è®¿é—®æ§åˆ¶æµ‹è¯•...")
    
    # æœ‰æƒé™çš„è®¿é—®
    result1 = platform.access_data(
        user_id="DOC-001",
        user_role="DOCTOR",
        patient_id="PAT-001",
        operation="READ",
        requested_fields=["name", "id_card", "phone"],
        ip_address="192.168.1.100",
        has_consent=True
    )
    print(f"åŒ»ç”Ÿè®¿é—®ï¼ˆæœ‰æˆæƒï¼‰: {'æˆåŠŸ' if result1['success'] else 'å¤±è´¥'}")
    if result1.get('data'):
        print(f"  è„±æ•åæ•°æ®: {result1['data']}")
    
    # æ— æƒé™çš„è®¿é—®
    result2 = platform.access_data(
        user_id="USER-001",
        user_role="PATIENT",
        patient_id="PAT-001",
        operation="READ",
        requested_fields=["name", "id_card"],
        ip_address="192.168.1.200"
    )
    print(f"æ‚£è€…è§’è‰²è®¿é—®: {'æˆåŠŸ' if result2['success'] else 'å¤±è´¥'}")
    if not result2['success']:
        print(f"  æ‹’ç»åŸå› : {result2.get('error')}")
    
    # 6. ç”Ÿæˆåˆè§„æŠ¥å‘Š
    print("\n[6] ç”Ÿæˆåˆè§„å®¡è®¡æŠ¥å‘Š...")
    report = platform.generate_compliance_report()
    print(f"å®¡è®¡æ—¥å¿—æ€»æ•°: {report['total_audit_logs']}")
    print(f"æˆåŠŸè®¿é—®æ¬¡æ•°: {report['successful_accesses']}")
    print(f"æ‹’ç»è®¿é—®æ¬¡æ•°: {report['denied_accesses']}")
    print(f"è®¿é—®æˆåŠŸç‡: {report['success_rate']:.1%}")
    print(f"æ³¨å†Œæ‚£è€…æ•°: {report['registered_patients']}")
```

### 2.7 æ•ˆæœè¯„ä¼°ä¸ROIåˆ†æ

**é¡¹ç›®æŠ•å…¥**ï¼š

| æŠ•å…¥ç±»åˆ« | é‡‘é¢ï¼ˆä¸‡å…ƒï¼‰ |
|---------|------------|
| è½¯ä»¶å¹³å° | 600 |
| å®æ–½æœåŠ¡ | 400 |
| åŸ¹è®­å’¨è¯¢ | 200 |
| **æ€»æŠ•èµ„** | **1200** |

**é‡åŒ–æ”¶ç›Š**ï¼š

| æ”¶ç›Šç±»åˆ« | å¹´æ”¶ç›Šï¼ˆä¸‡å…ƒï¼‰ |
|---------|--------------|
| åˆè§„é£é™©é™ä½ | 2000 |
| é‡å¤æ£€æŸ¥å‡å°‘ | 800 |
| ç§‘ç ”æ•ˆç‡æå‡ | 500 |
| æ•°æ®è´¨é‡æå‡ | 300 |
| **å¹´æ€»æ”¶ç›Š** | **3600** |

**ROI**ï¼š300%ï¼ˆå¹´æ”¶ç›Š3600ä¸‡ vs æŠ•èµ„1200ä¸‡ï¼‰

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| æ•°æ®æ ‡å‡†åŒ–ç‡ | 60% | 95% | +58% |
| æ‚£è€…åŒ¹é…å‡†ç¡®ç‡ | 70% | 98% | +40% |
| åˆè§„æ£€æŸ¥è¦†ç›–ç‡ | 40% | 100% | +150% |
| æ•°æ®è®¿é—®å®¡æ‰¹æ—¶é—´ | 3å¤© | å®æ—¶ | 100% |

---

**åˆ›å»ºæ—¶é—´**ï¼š2025-02-15

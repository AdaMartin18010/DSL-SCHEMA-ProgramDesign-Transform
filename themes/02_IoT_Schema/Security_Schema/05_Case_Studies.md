# IoTå®‰å…¨Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [IoTå®‰å…¨Schemaå®è·µæ¡ˆä¾‹](#iotå®‰å…¨schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šä¼ä¸šæ™ºèƒ½å®¶å±…å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ](#2-æ¡ˆä¾‹1ä¼ä¸šæ™ºèƒ½å®¶å±…å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ)
    - [2.1 ä¸šåŠ¡èƒŒæ™¯](#21-ä¸šåŠ¡èƒŒæ™¯)
    - [2.2 æŠ€æœ¯æŒ‘æˆ˜](#22-æŠ€æœ¯æŒ‘æˆ˜)
    - [2.3 è§£å†³æ–¹æ¡ˆ](#23-è§£å†³æ–¹æ¡ˆ)
    - [2.4 Schemaå®šä¹‰](#24-schemaå®šä¹‰)
    - [2.5 å®Œæ•´ä»£ç å®ç°](#25-å®Œæ•´ä»£ç å®ç°)
    - [2.6 æ•ˆæœè¯„ä¼°](#26-æ•ˆæœè¯„ä¼°)
  - [3. æ¡ˆä¾‹2ï¼šå·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ç³»ç»Ÿ](#3-æ¡ˆä¾‹2å·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ç³»ç»Ÿ)
    - [3.1 ä¸šåŠ¡èƒŒæ™¯](#31-ä¸šåŠ¡èƒŒæ™¯)
    - [3.2 æŠ€æœ¯æŒ‘æˆ˜](#32-æŠ€æœ¯æŒ‘æˆ˜)
    - [3.3 Schemaå®šä¹‰](#33-schemaå®šä¹‰)
    - [3.4 å®Œæ•´ä»£ç å®ç°](#34-å®Œæ•´ä»£ç å®ç°)
    - [3.5 æ•ˆæœè¯„ä¼°](#35-æ•ˆæœè¯„ä¼°)
  - [4. æ¡ˆä¾‹3ï¼šåŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç³»ç»Ÿ](#4-æ¡ˆä¾‹3åŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç³»ç»Ÿ)
    - [4.1 ä¸šåŠ¡èƒŒæ™¯](#41-ä¸šåŠ¡èƒŒæ™¯)
    - [4.2 æŠ€æœ¯æŒ‘æˆ˜](#42-æŠ€æœ¯æŒ‘æˆ˜)
    - [4.3 Schemaå®šä¹‰](#43-schemaå®šä¹‰)
    - [4.4 å®Œæ•´ä»£ç å®ç°](#44-å®Œæ•´ä»£ç å®ç°)
    - [4.5 æ•ˆæœè¯„ä¼°](#45-æ•ˆæœè¯„ä¼°)
  - [5. æ¡ˆä¾‹4ï¼šIoTå®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿ](#5-æ¡ˆä¾‹4iotå®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿ)
    - [5.1 ä¸šåŠ¡èƒŒæ™¯](#51-ä¸šåŠ¡èƒŒæ™¯)
    - [5.2 æŠ€æœ¯æŒ‘æˆ˜](#52-æŠ€æœ¯æŒ‘æˆ˜)
    - [5.3 Schemaå®šä¹‰](#53-schemaå®šä¹‰)
    - [5.4 å®Œæ•´ä»£ç å®ç°](#54-å®Œæ•´ä»£ç å®ç°)
    - [5.5 æ•ˆæœè¯„ä¼°](#55-æ•ˆæœè¯„ä¼°)
  - [6. æ¡ˆä¾‹æ€»ç»“](#6-æ¡ˆä¾‹æ€»ç»“)
    - [6.1 æˆåŠŸå› ç´ ](#61-æˆåŠŸå› ç´ )
    - [6.2 æœ€ä½³å®è·µ](#62-æœ€ä½³å®è·µ)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [7.1 æ ‡å‡†æ–‡æ¡£](#71-æ ‡å‡†æ–‡æ¡£)
    - [7.2 æŠ€æœ¯æ–‡æ¡£](#72-æŠ€æœ¯æ–‡æ¡£)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›IoTå®‰å…¨Schemaåœ¨å®é™…ä¼ä¸šåº”ç”¨ä¸­çš„å®è·µæ¡ˆä¾‹ï¼Œæ¶µç›–æ™ºèƒ½å®¶å±…å®‰å…¨é˜²æŠ¤ã€å·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ã€åŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç­‰çœŸå®åœºæ™¯ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **æ™ºèƒ½å®¶å±…å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ**ï¼šæ™ºèƒ½å®¶å±…å¹³å°ä¸­çš„ç»¼åˆå®‰å…¨é˜²æŠ¤ä½“ç³»
2. **å·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ç³»ç»Ÿ**ï¼šåˆ¶é€ ä¸šå·¥æ§ç½‘ç»œå®‰å…¨é€šä¿¡æ–¹æ¡ˆ
3. **åŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç³»ç»Ÿ**ï¼šåŒ»é™¢æ‚£è€…æ•°æ®å®‰å…¨ä¸åˆè§„ç®¡ç†
4. **IoTå®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿ**ï¼šå¤§è§„æ¨¡IoTç½‘ç»œçš„å®æ—¶å®‰å…¨ç›‘æ§

**å‚è€ƒä¼ä¸šæ¡ˆä¾‹**ï¼š

- **OWASP IoT Top 10**ï¼šIoTå®‰å…¨æ ‡å‡†
- **NIST IoTå®‰å…¨æ¡†æ¶**ï¼šIoTå®‰å…¨æœ€ä½³å®è·µ

---

## 2. æ¡ˆä¾‹1ï¼šä¼ä¸šæ™ºèƒ½å®¶å±…å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ

### 2.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå¤´éƒ¨æ™ºèƒ½å®¶å±…å¹³å°"æ™ºè”ç”Ÿæ´»"ï¼Œæˆç«‹äº2018å¹´ï¼Œç›®å‰å·²æœåŠ¡è¶…è¿‡500ä¸‡å®¶åº­ç”¨æˆ·ï¼Œæ¥å…¥è®¾å¤‡è¶…è¿‡2000ä¸‡å°ï¼Œæ¶µç›–æ™ºèƒ½é—¨é”ã€æ‘„åƒå¤´ã€æ¸©æ§å™¨ã€ç…§æ˜ç³»ç»Ÿç­‰12å¤§å“ç±»ã€‚å¹³å°é‡‡ç”¨äº‘-è¾¹-ç«¯ååŒæ¶æ„ï¼Œæ—¥å‡å¤„ç†è®¾å¤‡æ•°æ®è¶…è¿‡50äº¿æ¡ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **èº«ä»½å†’ç”¨é£é™©**ï¼š2023å¹´å‘ç”Ÿå¤šèµ·ç”¨æˆ·è´¦å·è¢«ç›—äº‹ä»¶ï¼Œæ”»å‡»è€…é€šè¿‡å¼±å¯†ç æˆ–å‡­è¯æ³„éœ²æ§åˆ¶ç”¨æˆ·è®¾å¤‡ï¼Œé€ æˆéšç§æ³„éœ²å’Œè´¢äº§æŸå¤±
2. **è¶Šæƒè®¿é—®é¢‘å‘**ï¼šå®¶åº­æˆå‘˜æƒé™ç®¡ç†æ··ä¹±ï¼Œå„¿ç«¥å¯è¯¯æ“ä½œå®‰é˜²è®¾å¤‡ï¼Œè®¿å®¢å¯è®¿é—®æ ¸å¿ƒéšç§åŒºåŸŸ
3. **æ•°æ®ä¼ è¾“æš´éœ²**ï¼šéƒ¨åˆ†è€æ—§è®¾å¤‡ä½¿ç”¨æ˜æ–‡HTTPé€šä¿¡ï¼Œä¸­é—´äººæ”»å‡»å¯æˆªè·æ•æ„Ÿæ•°æ®
4. **è®¾å¤‡å›ºä»¶æ¼æ´**ï¼šç¬¬ä¸‰æ–¹è®¾å¤‡å‚å•†å®‰å…¨èƒ½åŠ›å‚å·®ä¸é½ï¼Œå›ºä»¶æ¼æ´æˆä¸ºæ”»å‡»å…¥å£
5. **åˆè§„å®¡è®¡å‹åŠ›**ï¼šé¢ä¸´ã€Šä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ã€‹å’ŒGB/T 37033-2018æ ‡å‡†çš„åˆè§„è¦æ±‚ï¼Œå®¡è®¡èƒ½åŠ›ä¸è¶³

**ä¸šåŠ¡ç›®æ ‡**ï¼š

- å»ºç«‹ç»Ÿä¸€çš„å®‰å…¨ç­–ç•¥ç®¡ç†ä¸­å¿ƒï¼Œè¦†ç›–æ‰€æœ‰æ¥å…¥è®¾å¤‡
- å®ç°å¤šå› å­èº«ä»½è®¤è¯ï¼Œå°†è´¦å·ç›—ç”¨é£é™©é™ä½90%ä»¥ä¸Š
- éƒ¨ç½²ç«¯åˆ°ç«¯åŠ å¯†é€šä¿¡ï¼Œç¡®ä¿æ•°æ®å…¨ç¨‹åŠ å¯†
- å»ºç«‹ç»†ç²’åº¦è®¿é—®æ§åˆ¶æ¨¡å‹ï¼Œæ”¯æŒå®¶åº­åœºæ™¯çš„å¤šè§’è‰²æƒé™ç®¡ç†
- é€šè¿‡ç­‰ä¿2.0ä¸‰çº§è®¤è¯å’ŒISO 27001è®¤è¯

### 2.2 æŠ€æœ¯æŒ‘æˆ˜

1. **å¼‚æ„è®¾å¤‡è®¤è¯éš¾é¢˜**ï¼šè®¾å¤‡ç±»å‹å¤šæ ·ï¼ˆMCUã€Linuxã€Androidï¼‰ï¼Œè®¡ç®—èƒ½åŠ›å·®å¼‚å¤§ï¼Œéœ€æ”¯æŒä»è½»é‡çº§åˆ°é«˜å¼ºåº¦çš„å¤šç§è®¤è¯æ–¹å¼
2. **ä½å»¶è¿Ÿå®‰å…¨é€šä¿¡**ï¼šæ™ºèƒ½å®¶å±…åœºæ™¯å¯¹å“åº”å»¶è¿Ÿæ•æ„Ÿï¼ˆ<100msï¼‰ï¼ŒTLSåŠ å¯†ä¸èƒ½æ˜¾è‘—å½±å“ç”¨æˆ·ä½“éªŒ
3. **ç¦»çº¿åœºæ™¯å®‰å…¨**ï¼šç½‘ç»œä¸­æ–­æ—¶ï¼Œæœ¬åœ°åœºæ™¯è”åŠ¨ï¼ˆå¦‚é—¨é”è”åŠ¨ç¯å…‰ï¼‰ä»éœ€å®‰å…¨æ‰§è¡Œ
4. **å¤§è§„æ¨¡å¯†é’¥ç®¡ç†**ï¼š2000ä¸‡å°è®¾å¤‡éœ€è¦å®‰å…¨çš„å¯†é’¥åˆ†å‘ã€è½®æ¢å’Œæ’¤é”€æœºåˆ¶
5. **éšç§è®¡ç®—éœ€æ±‚**ï¼šç”¨æˆ·è¡Œä¸ºæ•°æ®éœ€ç”¨äºAIä¼˜åŒ–ï¼Œä½†å¿…é¡»åœ¨åŠ å¯†çŠ¶æ€ä¸‹å¤„ç†

### 2.3 è§£å†³æ–¹æ¡ˆ

**æ ¸å¿ƒæ¶æ„**ï¼š
- äº‘ç«¯å®‰å…¨ç­–ç•¥ä¸­å¿ƒï¼šç»Ÿä¸€ç®¡ç†å’Œåˆ†å‘å®‰å…¨ç­–ç•¥
- è¾¹ç¼˜å®‰å…¨ç½‘å…³ï¼šæœ¬åœ°å®‰å…¨å†³ç­–å’Œç¦»çº¿åœºæ™¯æ”¯æŒ
- è®¾å¤‡ç«¯å®‰å…¨SDKï¼šè½»é‡çº§å®‰å…¨èƒ½åŠ›åµŒå…¥

### 2.4 Schemaå®šä¹‰

**å®‰å…¨Schemaå®šä¹‰**ï¼š

```dsl
schema SmartHomeSecurity {
  authentication: {
    method: Enum { Password, OAuth2, Certificate, Biometric }
    password_policy: {
      min_length: Int @default(8)
      require_uppercase: Bool @default(true)
      require_digits: Bool @default(true)
      require_special: Bool @default(true)
      max_age_days: Int @default(90)
    }
    mfa: {
      enabled: Bool @default(true)
      methods: [SMS, TOTP, Biometric]
    }
    session_timeout: Duration @default(30min)
  }

  access_control: {
    policy_model: Enum { RBAC, ABAC }
    roles: [
      { name: "owner", permissions: [read, write, execute, delete, admin] },
      { name: "family", permissions: [read, write, execute] },
      { name: "guest", permissions: [read] @limited @timebound }
    ]
    device_groups: {
      security: [lock, camera, sensor],
      comfort: [thermostat, light, curtain],
      entertainment: [speaker, tv]
    }
  }

  encryption: {
    algorithm: Enum { AES, ChaCha20 }
    key_size: Enum { 256 }
    mode: Enum { GCM, ChaCha20-Poly1305 }
    data_at_rest: Enum { Encrypted }
    data_in_transit: Enum { TLS_1.3 }
    key_management: {
      rotation_period: Duration @default(90days)
      escrow: Bool @default(true)
    }
  }

  secure_communication: {
    protocol: Enum { MQTT_TLS, HTTPS, CoAP_DTLS }
    version: Enum { TLS_1.3 }
    certificate_validation: Enum { Strict }
    mutual_authentication: Bool @default(true)
  }
} @standard("GB/T_37033-2018", "ISO_27001")
```

### 2.5 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
æ™ºèƒ½å®¶å±…å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ - å®Œæ•´å®ç°
è¦†ç›–ï¼šå®‰å…¨ç­–ç•¥ç®¡ç†ã€åŠ å¯†é€šä¿¡ã€è®¿é—®æ§åˆ¶ã€å®¡è®¡æ—¥å¿—
"""

import os
import json
import hashlib
import hmac
import base64
import bcrypt
import jwt
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Set
from dataclasses import dataclass, field, asdict
from enum import Enum
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import ssl
import socket
import threading
import uuid


# ============ æšä¸¾å®šä¹‰ ============

class AuthenticationMethod(str, Enum):
    PASSWORD = "password"
    OAUTH2 = "oauth2"
    CERTIFICATE = "certificate"
    BIOMETRIC = "biometric"
    MFA = "mfa"


class Role(str, Enum):
    OWNER = "owner"
    FAMILY = "family"
    GUEST = "guest"
    SERVICE = "service"


class Permission(str, Enum):
    READ = "read"
    WRITE = "write"
    EXECUTE = "execute"
    DELETE = "delete"
    ADMIN = "admin"


class DeviceType(str, Enum):
    LOCK = "lock"
    CAMERA = "camera"
    SENSOR = "sensor"
    THERMOSTAT = "thermostat"
    LIGHT = "light"
    SPEAKER = "speaker"


# ============ æ•°æ®æ¨¡å‹ ============

@dataclass
class PasswordPolicy:
    """å¯†ç ç­–ç•¥é…ç½®"""
    min_length: int = 8
    require_uppercase: bool = True
    require_lowercase: bool = True
    require_digits: bool = True
    require_special: bool = True
    max_age_days: int = 90
    prevent_reuse: int = 5  # ç¦æ­¢é‡å¤ä½¿ç”¨æœ€è¿‘Næ¬¡å¯†ç 


@dataclass
class User:
    """ç”¨æˆ·å®ä½“"""
    user_id: str
    username: str
    password_hash: str
    role: Role
    mfa_enabled: bool = False
    mfa_secret: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    last_login: Optional[datetime] = None
    login_attempts: int = 0
    locked_until: Optional[datetime] = None
    password_history: List[str] = field(default_factory=list)


@dataclass
class Device:
    """IoTè®¾å¤‡å®ä½“"""
    device_id: str
    device_name: str
    device_type: DeviceType
    owner_id: str
    certificate: Optional[str] = None
    encryption_key: Optional[bytes] = None
    last_seen: Optional[datetime] = None
    trusted: bool = False
    firmware_version: str = "1.0.0"


@dataclass
class AuditLogEntry:
    """å®¡è®¡æ—¥å¿—æ¡ç›®"""
    log_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    event_type: str = ""
    user_id: Optional[str] = None
    device_id: Optional[str] = None
    action: str = ""
    resource: str = ""
    result: str = ""  # success, failure, denied
    ip_address: Optional[str] = None
    details: Dict = field(default_factory=dict)


# ============ æ ¸å¿ƒå®‰å…¨ç±» ============

class SecurityPolicyManager:
    """å®‰å…¨ç­–ç•¥ç®¡ç†å™¨"""
    
    ROLE_PERMISSIONS = {
        Role.OWNER: {Permission.READ, Permission.WRITE, Permission.EXECUTE, Permission.DELETE, Permission.ADMIN},
        Role.FAMILY: {Permission.READ, Permission.WRITE, Permission.EXECUTE},
        Role.GUEST: {Permission.READ},
        Role.SERVICE: {Permission.READ, Permission.EXECUTE}
    }
    
    DEVICE_SENSITIVITY = {
        DeviceType.LOCK: "high",
        DeviceType.CAMERA: "high",
        DeviceType.SENSOR: "medium",
        DeviceType.THERMOSTAT: "medium",
        DeviceType.LIGHT: "low",
        DeviceType.SPEAKER: "low"
    }
    
    def __init__(self):
        self.password_policy = PasswordPolicy()
        self.session_timeout = timedelta(minutes=30)
        self.mfa_required_for_sensitive = True
        self._lock = threading.RLock()
    
    def get_required_auth_level(self, device_type: DeviceType, action: Permission) -> int:
        """è·å–æ“ä½œæ‰€éœ€çš„å®‰å…¨çº§åˆ«ï¼ˆ0-3ï¼‰"""
        sensitivity = self.DEVICE_SENSITIVITY.get(device_type, "low")
        levels = {
            ("high", Permission.DELETE): 3,    # MFA + è¯ä¹¦
            ("high", Permission.WRITE): 3,
            ("high", Permission.EXECUTE): 2,   # MFA
            ("medium", Permission.WRITE): 2,
            ("medium", Permission.EXECUTE): 1, # å¼ºå¯†ç 
        }
        return levels.get((sensitivity, action), 1)
    
    def check_permission(self, role: Role, permission: Permission) -> bool:
        """æ£€æŸ¥è§’è‰²æ˜¯å¦æ‹¥æœ‰æŒ‡å®šæƒé™"""
        return permission in self.ROLE_PERMISSIONS.get(role, set())
    
    def validate_password(self, password: str, history: List[str] = None) -> Tuple[bool, str]:
        """éªŒè¯å¯†ç æ˜¯å¦ç¬¦åˆç­–ç•¥"""
        policy = self.password_policy
        
        if len(password) < policy.min_length:
            return False, f"å¯†ç é•¿åº¦è‡³å°‘{policy.min_length}ä½"
        
        if policy.require_uppercase and not any(c.isupper() for c in password):
            return False, "å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯"
        
        if policy.require_lowercase and not any(c.islower() for c in password):
            return False, "å¯†ç å¿…é¡»åŒ…å«å°å†™å­—æ¯"
        
        if policy.require_digits and not any(c.isdigit() for c in password):
            return False, "å¯†ç å¿…é¡»åŒ…å«æ•°å­—"
        
        if policy.require_special and not any(c in "!@#$%^&*()_+-=[]{}|;:,.<>?" for c in password):
            return False, "å¯†ç å¿…é¡»åŒ…å«ç‰¹æ®Šå­—ç¬¦"
        
        # æ£€æŸ¥å†å²å¯†ç 
        if history:
            for old_hash in history[-policy.prevent_reuse:]:
                if bcrypt.checkpw(password.encode(), old_hash.encode()):
                    return False, "ä¸èƒ½ä½¿ç”¨æœ€è¿‘ä½¿ç”¨è¿‡çš„å¯†ç "
        
        return True, "å¯†ç ç¬¦åˆè¦æ±‚"


class EncryptionManager:
    """åŠ å¯†ç®¡ç†å™¨ - æ”¯æŒå¯¹ç§°å’Œéå¯¹ç§°åŠ å¯†"""
    
    def __init__(self):
        self._keys: Dict[str, bytes] = {}
        self._key_rotation_interval = timedelta(days=90)
        self._key_creation_time: Dict[str, datetime] = {}
    
    def generate_aes_key(self, key_id: str) -> bytes:
        """ç”ŸæˆAES-256å¯†é’¥"""
        key = os.urandom(32)
        self._keys[key_id] = key
        self._key_creation_time[key_id] = datetime.now()
        return key
    
    def encrypt_aes_gcm(self, data: bytes, key_id: str) -> Tuple[bytes, bytes, bytes]:
        """AES-256-GCMåŠ å¯†"""
        key = self._keys.get(key_id)
        if not key:
            raise ValueError(f"å¯†é’¥ä¸å­˜åœ¨: {key_id}")
        
        iv = os.urandom(12)
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(data) + encryptor.finalize()
        return iv, ciphertext, encryptor.tag
    
    def decrypt_aes_gcm(self, iv: bytes, ciphertext: bytes, tag: bytes, key_id: str) -> bytes:
        """AES-256-GCMè§£å¯†"""
        key = self._keys.get(key_id)
        if not key:
            raise ValueError(f"å¯†é’¥ä¸å­˜åœ¨: {key_id}")
        
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag), backend=default_backend())
        decryptor = cipher.decryptor()
        return decryptor.update(ciphertext) + decryptor.finalize()
    
    def generate_rsa_keypair(self) -> Tuple[rsa.RSAPrivateKey, rsa.RSAPublicKey]:
        """ç”ŸæˆRSAå¯†é’¥å¯¹"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        return private_key, private_key.public_key()
    
    def rsa_encrypt(self, data: bytes, public_key: rsa.RSAPublicKey) -> bytes:
        """RSAåŠ å¯†"""
        return public_key.encrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    
    def rsa_decrypt(self, data: bytes, private_key: rsa.RSAPrivateKey) -> bytes:
        """RSAè§£å¯†"""
        return private_key.decrypt(
            data,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
    
    def rotate_key_if_needed(self, key_id: str) -> bool:
        """æ£€æŸ¥å¹¶æ‰§è¡Œå¯†é’¥è½®æ¢"""
        created = self._key_creation_time.get(key_id)
        if not created:
            return False
        
        if datetime.now() - created > self._key_rotation_interval:
            self.generate_aes_key(key_id)
            return True
        return False


class AuditLogger:
    """å®¡è®¡æ—¥å¿—ç®¡ç†å™¨"""
    
    def __init__(self, log_dir: str = "./logs"):
        self.log_dir = log_dir
        os.makedirs(log_dir, exist_ok=True)
        
        # é…ç½®æ—¥å¿—
        self.logger = logging.getLogger("security_audit")
        self.logger.setLevel(logging.INFO)
        
        handler = logging.FileHandler(f"{log_dir}/security_audit.log")
        handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(levelname)s - %(message)s'
        ))
        self.logger.addHandler(handler)
        
        self._entries: List[AuditLogEntry] = []
        self._lock = threading.RLock()
    
    def log(self, entry: AuditLogEntry):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        with self._lock:
            self._entries.append(entry)
            
            # å†™å…¥æ–‡ä»¶æ—¥å¿—
            log_msg = (
                f"[SECURITY] type={entry.event_type} user={entry.user_id} "
                f"device={entry.device_id} action={entry.action} "
                f"resource={entry.resource} result={entry.result}"
            )
            if entry.result == "success":
                self.logger.info(log_msg)
            else:
                self.logger.warning(log_msg)
    
    def query_logs(self, user_id: Optional[str] = None,
                   device_id: Optional[str] = None,
                   event_type: Optional[str] = None,
                   start_time: Optional[datetime] = None,
                   end_time: Optional[datetime] = None) -> List[AuditLogEntry]:
        """æŸ¥è¯¢å®¡è®¡æ—¥å¿—"""
        results = self._entries
        
        if user_id:
            results = [e for e in results if e.user_id == user_id]
        if device_id:
            results = [e for e in results if e.device_id == device_id]
        if event_type:
            results = [e for e in results if e.event_type == event_type]
        if start_time:
            results = [e for e in results if e.timestamp >= start_time]
        if end_time:
            results = [e for e in results if e.timestamp <= end_time]
        
        return results
    
    def get_failed_login_stats(self, hours: int = 24) -> Dict:
        """è·å–ç™»å½•å¤±è´¥ç»Ÿè®¡"""
        cutoff = datetime.now() - timedelta(hours=hours)
        failed = [e for e in self._entries 
                  if e.event_type == "authentication" 
                  and e.result == "failure"
                  and e.timestamp >= cutoff]
        
        return {
            "total_failed": len(failed),
            "unique_users": len(set(e.user_id for e in failed)),
            "unique_ips": len(set(e.ip_address for e in failed if e.ip_address))
        }


class SmartHomeSecurityManager:
    """æ™ºèƒ½å®¶å±…å®‰å…¨ç®¡ç†å™¨ - ä¸»ç±»"""
    
    def __init__(self, secret_key: Optional[str] = None):
        self.secret_key = secret_key or os.urandom(32).hex()
        self.policy_manager = SecurityPolicyManager()
        self.encryption_manager = EncryptionManager()
        self.audit_logger = AuditLogger()
        
        # å­˜å‚¨
        self._users: Dict[str, User] = {}
        self._devices: Dict[str, Device] = {}
        self._sessions: Dict[str, Dict] = {}
        
        self._lock = threading.RLock()
    
    # ========== ç”¨æˆ·ç®¡ç† ==========
    
    def register_user(self, username: str, password: str, role: Role = Role.FAMILY) -> str:
        """æ³¨å†Œæ–°ç”¨æˆ·"""
        user_id = str(uuid.uuid4())
        
        # éªŒè¯å¯†ç ç­–ç•¥
        valid, msg = self.policy_manager.validate_password(password)
        if not valid:
            raise ValueError(f"å¯†ç ä¸ç¬¦åˆè¦æ±‚: {msg}")
        
        # å“ˆå¸Œå¯†ç 
        password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12)).decode()
        
        user = User(
            user_id=user_id,
            username=username,
            password_hash=password_hash,
            role=role
        )
        
        with self._lock:
            self._users[user_id] = user
        
        # è®°å½•å®¡è®¡æ—¥å¿—
        self.audit_logger.log(AuditLogEntry(
            event_type="user_registration",
            user_id=user_id,
            action="register",
            resource="user",
            result="success",
            details={"role": role.value}
        ))
        
        return user_id
    
    def authenticate(self, username: str, password: str, 
                     mfa_code: Optional[str] = None,
                     ip_address: Optional[str] = None) -> Optional[str]:
        """ç”¨æˆ·èº«ä»½è®¤è¯"""
        # æŸ¥æ‰¾ç”¨æˆ·
        user = None
        for u in self._users.values():
            if u.username == username:
                user = u
                break
        
        if not user:
            self.audit_logger.log(AuditLogEntry(
                event_type="authentication",
                action="login",
                resource="user",
                result="failure",
                ip_address=ip_address,
                details={"reason": "user_not_found"}
            ))
            return None
        
        # æ£€æŸ¥è´¦æˆ·é”å®š
        if user.locked_until and datetime.now() < user.locked_until:
            self.audit_logger.log(AuditLogEntry(
                event_type="authentication",
                user_id=user.user_id,
                action="login",
                resource="user",
                result="failure",
                ip_address=ip_address,
                details={"reason": "account_locked"}
            ))
            return None
        
        # éªŒè¯å¯†ç 
        if not bcrypt.checkpw(password.encode(), user.password_hash.encode()):
            user.login_attempts += 1
            
            # 5æ¬¡å¤±è´¥åé”å®š30åˆ†é’Ÿ
            if user.login_attempts >= 5:
                user.locked_until = datetime.now() + timedelta(minutes=30)
                user.login_attempts = 0
            
            self.audit_logger.log(AuditLogEntry(
                event_type="authentication",
                user_id=user.user_id,
                action="login",
                resource="user",
                result="failure",
                ip_address=ip_address,
                details={"reason": "invalid_password", "attempts": user.login_attempts}
            ))
            return None
        
        # æ£€æŸ¥MFA
        if user.mfa_enabled:
            if not mfa_code:
                self.audit_logger.log(AuditLogEntry(
                    event_type="authentication",
                    user_id=user.user_id,
                    action="mfa_required",
                    resource="user",
                    result="pending",
                    ip_address=ip_address
                ))
                return "MFA_REQUIRED"
            # éªŒè¯MFAä»£ç ï¼ˆç®€åŒ–å®ç°ï¼‰
            if not self._verify_mfa(user.mfa_secret, mfa_code):
                self.audit_logger.log(AuditLogEntry(
                    event_type="authentication",
                    user_id=user.user_id,
                    action="mfa_verify",
                    resource="user",
                    result="failure",
                    ip_address=ip_address
                ))
                return None
        
        # è®¤è¯æˆåŠŸ
        user.login_attempts = 0
        user.last_login = datetime.now()
        
        # ç”ŸæˆJWTä»¤ç‰Œ
        token = jwt.encode({
            "user_id": user.user_id,
            "username": user.username,
            "role": user.role.value,
            "exp": datetime.utcnow() + timedelta(minutes=30),
            "iat": datetime.utcnow()
        }, self.secret_key, algorithm="HS256")
        
        # å­˜å‚¨ä¼šè¯
        with self._lock:
            self._sessions[token] = {
                "user_id": user.user_id,
                "created_at": datetime.now(),
                "ip_address": ip_address
            }
        
        self.audit_logger.log(AuditLogEntry(
            event_type="authentication",
            user_id=user.user_id,
            action="login",
            resource="user",
            result="success",
            ip_address=ip_address
        ))
        
        return token
    
    def _verify_mfa(self, secret: Optional[str], code: str) -> bool:
        """éªŒè¯MFAä»£ç ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # å®é™…åº”ä½¿ç”¨pyotpç­‰åº“å®ç°TOTP
        return True
    
    # ========== è®¾å¤‡ç®¡ç† ==========
    
    def register_device(self, device_name: str, device_type: DeviceType, 
                        owner_id: str) -> Device:
        """æ³¨å†ŒIoTè®¾å¤‡"""
        if owner_id not in self._users:
            raise ValueError("ç”¨æˆ·ä¸å­˜åœ¨")
        
        device_id = f"{device_type.value}_{uuid.uuid4().hex[:12]}"
        
        # ç”Ÿæˆè®¾å¤‡åŠ å¯†å¯†é’¥
        encryption_key = self.encryption_manager.generate_aes_key(device_id)
        
        device = Device(
            device_id=device_id,
            device_name=device_name,
            device_type=device_type,
            owner_id=owner_id,
            encryption_key=encryption_key,
            trusted=True
        )
        
        with self._lock:
            self._devices[device_id] = device
        
        self.audit_logger.log(AuditLogEntry(
            event_type="device_registration",
            user_id=owner_id,
            device_id=device_id,
            action="register",
            resource="device",
            result="success",
            details={"device_type": device_type.value}
        ))
        
        return device
    
    # ========== è®¿é—®æ§åˆ¶ ==========
    
    def check_access(self, token: str, device_id: str, 
                     action: Permission) -> Tuple[bool, str]:
        """æ£€æŸ¥è®¿é—®æƒé™"""
        # éªŒè¯ä»¤ç‰Œ
        try:
            payload = jwt.decode(token, self.secret_key, algorithms=["HS256"])
        except jwt.ExpiredSignatureError:
            return False, "ä»¤ç‰Œå·²è¿‡æœŸ"
        except jwt.InvalidTokenError:
            return False, "æ— æ•ˆä»¤ç‰Œ"
        
        user_id = payload.get("user_id")
        role = Role(payload.get("role"))
        
        # è·å–è®¾å¤‡
        device = self._devices.get(device_id)
        if not device:
            return False, "è®¾å¤‡ä¸å­˜åœ¨"
        
        # æ£€æŸ¥æƒé™
        if not self.policy_manager.check_permission(role, action):
            self.audit_logger.log(AuditLogEntry(
                event_type="access_control",
                user_id=user_id,
                device_id=device_id,
                action=action.value,
                resource="device",
                result="denied",
                details={"reason": "insufficient_role_permissions"}
            ))
            return False, "è§’è‰²æƒé™ä¸è¶³"
        
        # æ£€æŸ¥å®‰å…¨çº§åˆ«è¦æ±‚
        required_level = self.policy_manager.get_required_auth_level(
            device.device_type, action
        )
        
        # è®¿å®¢æœ‰æ—¶é—´é™åˆ¶
        if role == Role.GUEST:
            session = self._sessions.get(token)
            if session:
                session_age = datetime.now() - session["created_at"]
                if session_age > timedelta(hours=24):
                    return False, "è®¿å®¢ä¼šè¯å·²è¿‡æœŸ"
        
        self.audit_logger.log(AuditLogEntry(
            event_type="access_control",
            user_id=user_id,
            device_id=device_id,
            action=action.value,
            resource="device",
            result="success"
        ))
        
        return True, "è®¿é—®æˆæƒ"
    
    # ========== å®‰å…¨é€šä¿¡ ==========
    
    def secure_device_message(self, device_id: str, message: bytes) -> Dict:
        """åŠ å¯†è®¾å¤‡æ¶ˆæ¯"""
        device = self._devices.get(device_id)
        if not device:
            raise ValueError("è®¾å¤‡ä¸å­˜åœ¨")
        
        iv, ciphertext, tag = self.encryption_manager.encrypt_aes_gcm(
            message, device_id
        )
        
        return {
            "device_id": device_id,
            "iv": base64.b64encode(iv).decode(),
            "ciphertext": base64.b64encode(ciphertext).decode(),
            "tag": base64.b64encode(tag).decode()
        }
    
    def decrypt_device_message(self, device_id: str, encrypted_msg: Dict) -> bytes:
        """è§£å¯†è®¾å¤‡æ¶ˆæ¯"""
        device = self._devices.get(device_id)
        if not device:
            raise ValueError("è®¾å¤‡ä¸å­˜åœ¨")
        
        iv = base64.b64decode(encrypted_msg["iv"])
        ciphertext = base64.b64decode(encrypted_msg["ciphertext"])
        tag = base64.b64decode(encrypted_msg["tag"])
        
        return self.encryption_manager.decrypt_aes_gcm(iv, ciphertext, tag, device_id)


# ============ ä½¿ç”¨ç¤ºä¾‹ ============

if __name__ == "__main__":
    # åˆå§‹åŒ–å®‰å…¨ç³»ç»Ÿ
    security = SmartHomeSecurityManager()
    
    print("=" * 60)
    print("æ™ºèƒ½å®¶å±…å®‰å…¨ç³»ç»Ÿæ¼”ç¤º")
    print("=" * 60)
    
    # 1. æ³¨å†Œç”¨æˆ·
    print("\n[1] ç”¨æˆ·æ³¨å†Œ")
    owner_id = security.register_user("homeowner", "SecurePass123!", Role.OWNER)
    family_id = security.register_user("family_member", "FamilyPass456!", Role.FAMILY)
    guest_id = security.register_user("guest_user", "GuestPass789!", Role.GUEST)
    print(f"  æˆ¿ä¸»ç”¨æˆ·: {owner_id[:8]}...")
    print(f"  å®¶åº­æˆå‘˜: {family_id[:8]}...")
    print(f"  è®¿å®¢ç”¨æˆ·: {guest_id[:8]}...")
    
    # 2. è®¾å¤‡æ³¨å†Œ
    print("\n[2] è®¾å¤‡æ³¨å†Œ")
    smart_lock = security.register_device("å‰é—¨æ™ºèƒ½é”", DeviceType.LOCK, owner_id)
    camera = security.register_device("å®¢å…æ‘„åƒå¤´", DeviceType.CAMERA, owner_id)
    thermostat = security.register_device("æ™ºèƒ½æ¸©æ§å™¨", DeviceType.THERMOSTAT, owner_id)
    print(f"  æ™ºèƒ½é”: {smart_lock.device_id}")
    print(f"  æ‘„åƒå¤´: {camera.device_id}")
    print(f"  æ¸©æ§å™¨: {thermostat.device_id}")
    
    # 3. èº«ä»½è®¤è¯
    print("\n[3] èº«ä»½è®¤è¯")
    token = security.authenticate("homeowner", "SecurePass123!", ip_address="192.168.1.100")
    print(f"  æˆ¿ä¸»ç™»å½•æˆåŠŸï¼ŒToken: {token[:30]}...")
    
    # 4. è®¿é—®æ§åˆ¶æµ‹è¯•
    print("\n[4] è®¿é—®æ§åˆ¶æµ‹è¯•")
    
    # æˆ¿ä¸»å°è¯•æ§åˆ¶æ™ºèƒ½é”ï¼ˆé«˜å®‰å…¨çº§åˆ«ï¼‰
    allowed, msg = security.check_access(token, smart_lock.device_id, Permission.EXECUTE)
    print(f"  æˆ¿ä¸»å¼€é”: {'âœ“ å…è®¸' if allowed else 'âœ— æ‹’ç»'} - {msg}")
    
    # æ¨¡æ‹Ÿè®¿å®¢ç™»å½•
    guest_token = security.authenticate("guest_user", "GuestPass789!", ip_address="192.168.1.200")
    
    # è®¿å®¢å°è¯•æ§åˆ¶æ™ºèƒ½é”
    allowed, msg = security.check_access(guest_token, smart_lock.device_id, Permission.EXECUTE)
    print(f"  è®¿å®¢å¼€é”: {'âœ“ å…è®¸' if allowed else 'âœ— æ‹’ç»'} - {msg}")
    
    # è®¿å®¢æŸ¥çœ‹æ¸©æ§å™¨ï¼ˆåªè¯»æƒé™ï¼‰
    allowed, msg = security.check_access(guest_token, thermostat.device_id, Permission.READ)
    print(f"  è®¿å®¢æŸ¥çœ‹æ¸©æ§å™¨: {'âœ“ å…è®¸' if allowed else 'âœ— æ‹’ç»'} - {msg}")
    
    # 5. æ•°æ®åŠ å¯†æµ‹è¯•
    print("\n[5] æ•°æ®åŠ å¯†é€šä¿¡")
    message = b'{"command": "unlock", "timestamp": "2024-01-15T10:30:00Z"}'
    encrypted = security.secure_device_message(smart_lock.device_id, message)
    print(f"  åŸå§‹æ¶ˆæ¯: {message.decode()}")
    print(f"  åŠ å¯†æ¶ˆæ¯é•¿åº¦: {len(encrypted['ciphertext'])} bytes")
    
    decrypted = security.decrypt_device_message(smart_lock.device_id, encrypted)
    print(f"  è§£å¯†æ¶ˆæ¯: {decrypted.decode()}")
    
    # 6. å®¡è®¡æ—¥å¿—
    print("\n[6] å®¡è®¡æ—¥å¿—")
    stats = security.audit_logger.get_failed_login_stats(hours=24)
    print(f"  24å°æ—¶å†…ç™»å½•å¤±è´¥ç»Ÿè®¡: {stats}")
    
    recent_logs = security.audit_logger.query_logs(event_type="access_control")
    print(f"  æœ€è¿‘è®¿é—®æ§åˆ¶äº‹ä»¶: {len(recent_logs)} æ¡")
    
    print("\n" + "=" * 60)
    print("æ¼”ç¤ºå®Œæˆ")
    print("=" * 60)
```

### 2.6 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| å®‰å…¨äº‹ä»¶æ£€æµ‹ç‡ | 65% | 99.2% | +52.6% |
| å¹³å‡å“åº”æ—¶é—´ | 45åˆ†é’Ÿ | 3.2åˆ†é’Ÿ | -92.9% |
| è¯¯æŠ¥ç‡ | 23% | 4.5% | -80.4% |
| å¯†ç ç­–ç•¥åˆè§„ç‡ | 58% | 99.7% | +71.9% |
| æ•°æ®åŠ å¯†è¦†ç›–ç‡ | 42% | 100% | +138% |
| èº«ä»½è®¤è¯æˆåŠŸç‡ | 87% | 99.5% | +14.4% |
| APIå®‰å…¨å»¶è¿Ÿå¼€é”€ | - | <15ms | å¯æ¥å— |
| ç³»ç»Ÿå¯ç”¨æ€§ | 99.5% | 99.99% | +0.49% |

**ä¸šåŠ¡ä»·å€¼**ï¼š

1. **é£é™©é™ä½**ï¼šè´¦å·ç›—ç”¨äº‹ä»¶ä»æœˆå‡12èµ·é™è‡³0èµ·ï¼Œè®¾å¤‡åŠ«æŒäº‹ä»¶å®Œå…¨æ¶ˆé™¤
2. **åˆè§„æ”¶ç›Š**ï¼šé€šè¿‡ç­‰ä¿2.0ä¸‰çº§è®¤è¯ï¼Œè·å¾—æ”¿åºœé¡¹ç›®æŠ•æ ‡èµ„æ ¼ï¼Œå¹´åº¦æ–°å¢è®¢å•é¢ estimated Â¥8000ä¸‡
3. **ç”¨æˆ·ä¿¡ä»»**ï¼šå®‰å…¨è¯„åˆ†ä»3.2æå‡è‡³4.8ï¼ˆ5åˆ†åˆ¶ï¼‰ï¼Œç”¨æˆ·ç•™å­˜ç‡æå‡18%
4. **æˆæœ¬èŠ‚çº¦**ï¼šè‡ªåŠ¨åŒ–å®‰å…¨å“åº”å‡å°‘äººå·¥è¿ç»´æˆæœ¬çº¦Â¥350ä¸‡/å¹´
5. **ROIåˆ†æ**ï¼šé¡¹ç›®æ€»æŠ•èµ„Â¥1200ä¸‡ï¼Œé¦–å¹´ç›´æ¥æ”¶ç›Š+é—´æ¥æ”¶ç›Šåˆè®¡Â¥2100ä¸‡ï¼ŒROI = 75%

**ç»éªŒæ•™è®­**ï¼š

1. **æ¸è¿›å¼éƒ¨ç½²**ï¼šå…ˆåœ¨æ ¸å¿ƒé«˜ä»·å€¼è®¾å¤‡ï¼ˆé—¨é”ã€æ‘„åƒå¤´ï¼‰éƒ¨ç½²ï¼Œå†æ¨å¹¿è‡³å…¨å±‹è®¾å¤‡ï¼Œé™ä½ä¸€æ¬¡æ€§é£é™©
2. **ç”¨æˆ·ä½“éªŒå¹³è¡¡**ï¼šMFAåœ¨æ•æ„Ÿæ“ä½œæ—¶æ‰è§¦å‘ï¼Œæ—¥å¸¸ä½¿ç”¨ä¿æŒæµç•…ï¼Œç”¨æˆ·æ¥å—åº¦æå‡è‡³94%
3. **ä¾›åº”é“¾å®‰å…¨**ï¼šè¦æ±‚è®¾å¤‡å‚å•†é¢„ç½®å®‰å…¨SDKï¼Œä»æºå¤´è§£å†³å›ºä»¶æ¼æ´é—®é¢˜
4. **å¯†é’¥ç®¡ç†å…³é”®**ï¼šå»ºç«‹HSMç¡¬ä»¶å®‰å…¨æ¨¡å—æ‰˜ç®¡æ ¹å¯†é’¥ï¼Œæœç»å¯†é’¥æ³„éœ²é£é™©
5. **æŒç»­ç›‘æ§**ï¼š7x24å°æ—¶SOCå®‰å…¨è¿è¥ä¸­å¿ƒæ˜¯åŠæ—¶å‘ç°å’Œå“åº”å¨èƒçš„å…³é”®

**å‚è€ƒæ¡ˆä¾‹**ï¼š

- [OWASP IoT Top 10](https://owasp.org/www-project-internet-of-things/)
- [NIST IoTå®‰å…¨æ¡†æ¶](https://www.nist.gov/itl/applied-cybersecurity/nist-cybersecurity-framework)

---

## 3. æ¡ˆä¾‹2ï¼šå·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ç³»ç»Ÿ

### 3.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå¤§å‹åˆ¶é€ ä¼ä¸š"ç²¾å·¥æ™ºé€ "ï¼Œæˆç«‹äº2005å¹´ï¼Œæ˜¯å›½å†…é¢†å…ˆçš„ç²¾å¯†æœºæ¢°åˆ¶é€ å•†ï¼Œæ‹¥æœ‰5ä¸ªæ™ºèƒ½å·¥å‚ã€è¶…è¿‡500æ¡è‡ªåŠ¨åŒ–ç”Ÿäº§çº¿ï¼Œæ¥å…¥å·¥ä¸šä¼ æ„Ÿå™¨ã€PLCæ§åˆ¶å™¨ã€AGVå°è½¦ã€æœºæ¢°è‡‚ç­‰å·¥ä¸šè®¾å¤‡è¶…è¿‡10ä¸‡å°ã€‚ä¼ä¸šæ­£åœ¨è¿›è¡Œå·¥ä¸š4.0æ•°å­—åŒ–è½¬å‹ï¼Œè®¡åˆ’å»ºè®¾ç»Ÿä¸€çš„å·¥ä¸šäº’è”ç½‘å¹³å°ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **åè®®è„†å¼±æ€§**ï¼šå¤§é‡è®¾å¤‡ä½¿ç”¨Modbusã€OPC Classicç­‰æ˜æ–‡åè®®ï¼Œç¼ºä¹èº«ä»½éªŒè¯å’ŒåŠ å¯†æœºåˆ¶
2. **ç½‘ç»œéš”ç¦»ä¸è¶³**ï¼šITä¸OTç½‘ç»œè¾¹ç•Œæ¨¡ç³Šï¼ŒåŠå…¬ç½‘ç—…æ¯’æ›¾æ‰©æ•£è‡³ç”Ÿäº§ç½‘å¯¼è‡´åœäº§12å°æ—¶
3. **è®¾å¤‡èº«ä»½å†’ç”¨**ï¼šç¼ºä¹è®¾å¤‡è¯ä¹¦ä½“ç³»ï¼Œæ”»å‡»è€…å¯ä¼ªé€ PLCæŒ‡ä»¤å¹²æ‰°ç”Ÿäº§
4. **æ•°æ®ä¼ è¾“é£é™©**ï¼šå…³é”®å·¥è‰ºå‚æ•°ï¼ˆå¦‚æ¸©åº¦ã€å‹åŠ›è®¾å®šå€¼ï¼‰åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­å¯èƒ½è¢«ç¯¡æ”¹
5. **åˆè§„ç›‘ç®¡å‹åŠ›**ï¼šéœ€è¦æ»¡è¶³ã€Šç½‘ç»œå®‰å…¨æ³•ã€‹ã€ç­‰ä¿2.0ã€IEC 62443ç­‰æ³•è§„æ ‡å‡†è¦æ±‚

**ä¸šåŠ¡ç›®æ ‡**ï¼š

- å»ºç«‹å·¥ä¸šçº§åŒå‘è®¤è¯ä½“ç³»ï¼Œå®ç°è®¾å¤‡ç«¯åˆ°ç«¯çš„å¯ä¿¡èº«ä»½
- éƒ¨ç½²TLS 1.3åŠ å¯†é€šé“ï¼Œä¿æŠ¤æ‰€æœ‰å·¥ä¸šé€šä¿¡æ•°æ®
- å»ºç«‹åŸºäºè§’è‰²çš„å·¥ä¸šè®¿é—®æ§åˆ¶æ¨¡å‹ï¼ˆRBAC for OTï¼‰
- å®ç°æ¯«ç§’çº§ä½å»¶è¿Ÿå®‰å…¨é€šä¿¡ï¼ˆ<50msç«¯åˆ°ç«¯ï¼‰
- é€šè¿‡ç­‰ä¿2.0ä¸‰çº§å’ŒIEC 62443 SL-2è®¤è¯

### 3.2 æŠ€æœ¯æŒ‘æˆ˜

1. **é—ç•™è®¾å¤‡å…¼å®¹æ€§**ï¼š60%çš„ç°æœ‰æœºåºŠå’ŒPLCä¸æ”¯æŒç°ä»£åŠ å¯†ç®—æ³•ï¼Œéœ€è¦ç½‘å…³ä»£ç†æ–¹æ¡ˆ
2. **å®æ—¶æ€§è¦æ±‚**ï¼šè¿åŠ¨æ§åˆ¶ç±»åº”ç”¨è¦æ±‚<10mså“åº”ï¼ŒTLSæ¡æ‰‹å¼€é”€éœ€ä¼˜åŒ–è‡³<5ms
3. **å¤§è§„æ¨¡è¯ä¹¦ç®¡ç†**ï¼š10ä¸‡å°è®¾å¤‡éœ€è¦è‡ªåŠ¨åŒ–è¯ä¹¦ç­¾å‘ã€åˆ†å‘ã€è½®æ¢å’Œæ’¤é”€æœºåˆ¶
4. **ç¦»çº¿ç”Ÿäº§èƒ½åŠ›**ï¼šæ–­ç½‘æƒ…å†µä¸‹ç”Ÿäº§çº¿ä»éœ€å®‰å…¨è¿è¡Œè‡³å°‘72å°æ—¶
5. **å¤šåè®®é€‚é…**ï¼šéœ€åŒæ—¶æ”¯æŒMQTTã€OPC UAã€Modbus TCPã€EtherNet/IPç­‰åè®®çš„å®‰å…¨å°è£…

### 3.3 Schemaå®šä¹‰

**å·¥ä¸šç‰©è”ç½‘å®‰å…¨Schema**ï¼š

```dsl
schema IndustrialIoTSecurity {
  authentication: {
    method: Enum { X509_Certificate, Mutual_TLS }
    certificate: {
      format: Enum { PEM, DER }
      key_algorithm: Enum { RSA_2048, ECC_P256 }
      validity_days: Int @default(365)
      ca_hierarchy: {
        root_ca: String
        intermediate_ca: String
        issuing_ca: String
      }
    }
    device_identity: {
      device_id: String @unique
      manufacturer: String
      model: String
      serial_number: String
      production_date: Date
    }
  }

  access_control: {
    policy_model: Enum { RBAC }
    device_roles: [
      { 
        name: "production_controller"
        permissions: [read, write, execute, config]
        safety_level: "high"
      },
      { 
        name: "sensor_node"
        permissions: [read, write]
        allowed_topics: ["telemetry", "alarms"]
      },
      { 
        name: "actuator"
        permissions: [read, execute]
        command_whitelist: ["start", "stop", "reset"]
      },
      {
        name: "hmi_operator"
        permissions: [read, write]
        time_restricted: true
        shift_hours: ["08:00-20:00"]
      }
    ]
    zone_based_access: {
      zones: ["zone_a", "zone_b", "zone_c", "safety_critical"]
      cross_zone_policy: "deny_by_default"
    }
  }

  encryption: {
    tls_config: {
      version: Enum { TLS_1.3 }
      cipher_suites: ["TLS_AES_256_GCM_SHA384", "TLS_CHACHA20_POLY1305_SHA256"]
      psk_enabled: Bool @default(true)
      session_resumption: Bool @default(true)
      0rtt_enabled: Bool @default(false)
    }
    key_exchange: Enum { ECDHE, PSK }
    certificate_pinning: Bool @default(true)
  }

  secure_communication: {
    protocols: [
      { name: "MQTT", port: 8883, qos: [0, 1, 2] },
      { name: "OPC_UA", security_mode: "SignAndEncrypt" },
      { name: "Modbus_TLS", wrapper: true }
    ]
    network_segmentation: {
      dmz_enabled: Bool @default(true)
      firewall_rules: ["allow_established", "deny_cross_zone"]
    }
  }
} @standard("IEC_62443", "GB/T_37033-2018", "ISO_27001")
```

### 3.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
å·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ç³»ç»Ÿ - å®Œæ•´å®ç°
è¦†ç›–ï¼šX.509è¯ä¹¦ç®¡ç†ã€åŒå‘TLSé€šä¿¡ã€å·¥ä¸šåè®®å®‰å…¨å°è£…ã€è®¾å¤‡èº«ä»½ç®¡ç†
"""

import os
import ssl
import json
import hashlib
import threading
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Callable, Set
from dataclasses import dataclass, field, asdict
from enum import Enum
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, ec, padding


# ============ æšä¸¾å®šä¹‰ ============

class DeviceRole(str, Enum):
    PRODUCTION_CONTROLLER = "production_controller"
    SENSOR_NODE = "sensor_node"
    ACTUATOR = "actuator"
    HMI_OPERATOR = "hmi_operator"
    SAFETY_SYSTEM = "safety_system"


class SecurityLevel(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ProtocolType(str, Enum):
    MQTT = "mqtt"
    OPC_UA = "opc_ua"
    MODBUS_TLS = "modbus_tls"


# ============ æ•°æ®æ¨¡å‹ ============

@dataclass
class DeviceIdentity:
    """è®¾å¤‡èº«ä»½ä¿¡æ¯"""
    device_id: str
    manufacturer: str
    model: str
    serial_number: str
    production_date: datetime
    role: DeviceRole
    zone: str
    security_level: SecurityLevel
    certificate_pem: Optional[str] = None
    private_key_pem: Optional[str] = None
    ca_certificate: Optional[str] = None
    registered_at: datetime = field(default_factory=datetime.now)
    last_authenticated: Optional[datetime] = None


@dataclass
class CertificateConfig:
    """è¯ä¹¦é…ç½®"""
    key_algorithm: str = "RSA_2048"
    validity_days: int = 365
    key_size: int = 2048
    country: str = "CN"
    organization: str = "Industrial IoT Platform"
    organizational_unit: str = "Device Security"


@dataclass
class IndustrialSecurityEvent:
    """å·¥ä¸šå®‰å…¨äº‹ä»¶"""
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    event_type: str = ""
    device_id: Optional[str] = None
    source_ip: Optional[str] = None
    severity: str = "info"
    message: str = ""
    details: Dict = field(default_factory=dict)


# ============ è¯ä¹¦ç®¡ç† ============

class CertificateAuthority:
    """è¯ä¹¦é¢å‘æœºæ„ - ç®€åŒ–ç‰ˆPKI"""
    
    def __init__(self, ca_cert_path: Optional[str] = None, ca_key_path: Optional[str] = None):
        self._private_key: Optional[rsa.RSAPrivateKey] = None
        self._certificate: Optional[x509.Certificate] = None
        self._issued_certs: Dict[str, x509.Certificate] = {}
        self._crl: List[str] = []
        
        if ca_cert_path and ca_key_path and os.path.exists(ca_cert_path):
            self._load_ca(ca_cert_path, ca_key_path)
        else:
            self._generate_ca()
    
    def _generate_ca(self):
        """ç”Ÿæˆæ ¹CAè¯ä¹¦"""
        self._private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=4096
        )
        
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "CN"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Industrial IoT Root CA"),
            x509.NameAttribute(NameOID.COMMON_NAME, "IIoT Root CA"),
        ])
        
        self._certificate = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            self._private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=3650)
        ).add_extension(
            x509.BasicConstraints(ca=True, path_length=None),
            critical=True
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                key_cert_sign=True,
                crl_sign=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                encipher_only=False,
                decipher_only=False
            ),
            critical=True
        ).sign(self._private_key, hashes.SHA256())
    
    def _load_ca(self, cert_path: str, key_path: str):
        """åŠ è½½CAè¯ä¹¦å’Œç§é’¥"""
        with open(cert_path, "rb") as f:
            self._certificate = x509.load_pem_x509_certificate(f.read())
        with open(key_path, "rb") as f:
            self._private_key = serialization.load_pem_private_key(f.read(), password=None)
    
    def issue_device_certificate(self, device_id: str, identity: DeviceIdentity,
                                  config: CertificateConfig) -> Tuple[str, str]:
        """ä¸ºè®¾å¤‡ç­¾å‘è¯ä¹¦"""
        device_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=config.key_size
        )
        
        subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, config.country),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, config.organization),
            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, config.organizational_unit),
            x509.NameAttribute(NameOID.COMMON_NAME, device_id),
            x509.NameAttribute(NameOID.SERIAL_NUMBER, identity.serial_number),
        ])
        
        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            self._certificate.subject
        ).public_key(
            device_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=config.validity_days)
        ).add_extension(
            x509.BasicConstraints(ca=False, path_length=None),
            critical=True
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                key_encipherment=True,
                content_commitment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=False,
                crl_sign=False,
                encipher_only=False,
                decipher_only=False
            ),
            critical=True
        ).add_extension(
            x509.ExtendedKeyUsage([
                x509.ExtendedKeyUsageOID.CLIENT_AUTH,
                x509.ExtendedKeyUsageOID.SERVER_AUTH,
            ]),
            critical=False
        ).sign(self._private_key, hashes.SHA256())
        
        cert_pem = cert.public_bytes(serialization.Encoding.PEM).decode()
        key_pem = device_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        ).decode()
        
        self._issued_certs[device_id] = cert
        return cert_pem, key_pem
    
    def revoke_certificate(self, device_id: str):
        """æ’¤é”€è®¾å¤‡è¯ä¹¦"""
        if device_id in self._issued_certs:
            self._crl.append(device_id)
            del self._issued_certs[device_id]
    
    def verify_certificate(self, cert_pem: str) -> bool:
        """éªŒè¯è¯ä¹¦æ˜¯å¦ç”±æœ¬CAç­¾å‘ä¸”æœªè¢«æ’¤é”€"""
        try:
            cert = x509.load_pem_x509_certificate(cert_pem.encode())
            cert.verify_directly_issued_by(self._certificate)
            if datetime.utcnow() > cert.not_valid_after:
                return False
            return True
        except Exception:
            return False
    
    def get_ca_certificate(self) -> str:
        """è·å–CAè¯ä¹¦PEM"""
        return self._certificate.public_bytes(serialization.Encoding.PEM).decode()


# ============ å·¥ä¸šå®‰å…¨å¹³å° ============

class IndustrialIoTSecurityPlatform:
    """å·¥ä¸šç‰©è”ç½‘å®‰å…¨å¹³å° - ä¸»ç±»"""
    
    def __init__(self):
        self.ca = CertificateAuthority()
        self._devices: Dict[str, DeviceIdentity] = {}
        self._zone_policies: Dict[str, Set[str]] = {}
        self._lock = threading.RLock()
    
    def register_device(self, manufacturer: str, model: str, serial_number: str,
                        role: DeviceRole, zone: str,
                        security_level: SecurityLevel = SecurityLevel.MEDIUM) -> DeviceIdentity:
        """æ³¨å†Œå·¥ä¸šè®¾å¤‡"""
        device_id = f"{manufacturer.lower()}_{model.lower()}_{serial_number}"
        
        identity = DeviceIdentity(
            device_id=device_id,
            manufacturer=manufacturer,
            model=model,
            serial_number=serial_number,
            production_date=datetime.now(),
            role=role,
            zone=zone,
            security_level=security_level
        )
        
        config = CertificateConfig()
        cert_pem, key_pem = self.ca.issue_device_certificate(device_id, identity, config)
        
        identity.certificate_pem = cert_pem
        identity.private_key_pem = key_pem
        identity.ca_certificate = self.ca.get_ca_certificate()
        
        with self._lock:
            self._devices[device_id] = identity
        
        print(f"[REGISTER] Device {device_id} registered with role {role.value}")
        return identity
    
    def check_cross_zone_access(self, source_device: str, target_device: str) -> bool:
        """æ£€æŸ¥è·¨åŒºåŸŸè®¿é—®æƒé™"""
        source = self._devices.get(source_device)
        target = self._devices.get(target_device)
        
        if not source or not target:
            return False
        
        if source.zone == target.zone:
            return True
        
        if target.security_level in (SecurityLevel.HIGH, SecurityLevel.CRITICAL):
            return False
        
        allowed_zones = self._zone_policies.get(source.zone, set())
        return target.zone in allowed_zones
    
    def revoke_device(self, device_id: str):
        """æ’¤é”€è®¾å¤‡è®¿é—®æƒé™"""
        self.ca.revoke_certificate(device_id)
        
        with self._lock:
            if device_id in self._devices:
                del self._devices[device_id]
        
        print(f"[REVOKE] Device {device_id} access revoked")


# ============ ä½¿ç”¨ç¤ºä¾‹ ============

if __name__ == "__main__":
    print("=" * 70)
    print("å·¥ä¸šç‰©è”ç½‘å®‰å…¨é€šä¿¡ç³»ç»Ÿæ¼”ç¤º")
    print("=" * 70)
    
    platform = IndustrialIoTSecurityPlatform()
    
    print("\n[1] è®¾å¤‡æ³¨å†Œä¸è¯ä¹¦é¢å‘")
    
    plc_controller = platform.register_device(
        manufacturer="Siemens",
        model="S7-1500",
        serial_number="PLC2024001",
        role=DeviceRole.PRODUCTION_CONTROLLER,
        zone="zone_a",
        security_level=SecurityLevel.HIGH
    )
    print(f"  PLCæ§åˆ¶å™¨: {plc_controller.device_id}")
    
    temperature_sensor = platform.register_device(
        manufacturer="Bosch",
        model="TempSensor-X1",
        serial_number="TS2024001",
        role=DeviceRole.SENSOR_NODE,
        zone="zone_a",
        security_level=SecurityLevel.MEDIUM
    )
    print(f"  æ¸©åº¦ä¼ æ„Ÿå™¨: {temperature_sensor.device_id}")
    
    robot_arm = platform.register_device(
        manufacturer="ABB",
        model="IRB-1200",
        serial_number="RA2024001",
        role=DeviceRole.ACTUATOR,
        zone="zone_b",
        security_level=SecurityLevel.HIGH
    )
    print(f"  æœºæ¢°è‡‚: {robot_arm.device_id}")
    
    print("\n[2] è¯ä¹¦éªŒè¯")
    is_valid = platform.ca.verify_certificate(plc_controller.certificate_pem)
    print(f"  PLCè¯ä¹¦æœ‰æ•ˆæ€§: {'âœ“ æœ‰æ•ˆ' if is_valid else 'âœ— æ— æ•ˆ'}")
    
    print("\n[3] è·¨åŒºåŸŸè®¿é—®æ§åˆ¶")
    can_access = platform.check_cross_zone_access(
        temperature_sensor.device_id,
        robot_arm.device_id
    )
    print(f"  ä¼ æ„Ÿå™¨(zone_a) -> æœºæ¢°è‡‚(zone_b): {'âœ“ å…è®¸' if can_access else 'âœ— æ‹’ç»'}")
    
    print("\n[4] è¯ä¹¦æ’¤é”€")
    platform.revoke_device(robot_arm.device_id)
    
    is_valid = platform.ca.verify_certificate(robot_arm.certificate_pem)
    print(f"  æ’¤é”€åè¯ä¹¦æœ‰æ•ˆæ€§: {'âœ“ æœ‰æ•ˆ' if is_valid else 'âœ— å·²æ’¤é”€'}")
    
    print("\n" + "=" * 70)
    print("æ¼”ç¤ºå®Œæˆ")
    print("=" * 70)
```

### 3.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| é€šä¿¡åŠ å¯†è¦†ç›–ç‡ | 12% | 100% | +733% |
| è®¾å¤‡èº«ä»½è®¤è¯ç‡ | 15% | 100% | +567% |
| ä¸­é—´äººæ”»å‡»é˜»æ–­ | 0% | 100% | +100% |
| è¯ä¹¦ç­¾å‘æ•ˆç‡ | æ‰‹åŠ¨/å¤© | è‡ªåŠ¨/<10s | è‡ªåŠ¨åŒ– |
| TLSæ¡æ‰‹å»¶è¿Ÿ | N/A | 4.2ms | æ»¡è¶³è¦æ±‚ |
| ç«¯åˆ°ç«¯å»¶è¿Ÿ | 8ms | 11.5ms | +43% (å¯æ¥å—) |
| è¯ä¹¦è½®æ¢æˆåŠŸç‡ | N/A | 99.97% | é«˜å¯é  |
| å®‰å…¨äº‹ä»¶æ£€å‡ºç‡ | 45% | 98.5% | +118% |

**ä¸šåŠ¡ä»·å€¼**ï¼š

1. **ç”Ÿäº§å®‰å…¨**ï¼šéƒ¨ç½²å6ä¸ªæœˆå†…æˆåŠŸé˜»æ–­3æ¬¡å‹’ç´¢è½¯ä»¶å°è¯•æ¸—é€OTç½‘ç»œï¼Œé¿å…åœäº§æŸå¤±estimated Â¥4500ä¸‡/æ¬¡
2. **åˆè§„è®¤è¯**ï¼šé€šè¿‡ç­‰ä¿2.0ä¸‰çº§å’ŒIEC 62443 SL-2è®¤è¯ï¼Œæˆä¸ºè¡Œä¸šæ ‡æ†ï¼Œè·å¾—æ”¿åºœæ™ºèƒ½åˆ¶é€ è¡¥è´´Â¥800ä¸‡
3. **ä¾›åº”é“¾ä¿¡ä»»**ï¼šX.509è¯ä¹¦ä½“ç³»ä½¿å®¢æˆ·å¯éªŒè¯è®¾å¤‡çœŸå®æ€§ï¼Œäº§å“æº¢ä»·èƒ½åŠ›æå‡8%
4. **è¿ç»´æ•ˆç‡**ï¼šè‡ªåŠ¨åŒ–è¯ä¹¦ç®¡ç†å‡å°‘äººå·¥è¯ä¹¦ç»´æŠ¤å·¥ä½œé‡95%ï¼Œå¹´èŠ‚çº¦äººåŠ›æˆæœ¬Â¥180ä¸‡
5. **ä¿é™©é™è´¹**ï¼šç½‘ç»œå®‰å…¨ä¿é™©ä¿è´¹ä¸‹é™35%ï¼Œå¹´èŠ‚çº¦Â¥45ä¸‡

**ç»éªŒæ•™è®­**ï¼š

1. **åˆ†é˜¶æ®µè¿ç§»**ï¼šOTç½‘ç»œä¸èƒ½ä¸­æ–­ï¼Œé‡‡ç”¨"æ—è·¯ç›‘æµ‹-å½±å­æ¨¡å¼-ä¸»å¤‡åˆ‡æ¢"ä¸‰é˜¶æ®µè¿ç§»ç­–ç•¥
2. **è¯ä¹¦ç”Ÿå‘½å‘¨æœŸ**ï¼šè®¾ç½®è¯ä¹¦æœ‰æ•ˆæœŸ1å¹´è€Œé3å¹´ï¼Œé™ä½å¯†é’¥æ³„éœ²é£é™©ï¼ŒåŒæ—¶è‡ªåŠ¨åŒ–è½®æ¢é¿å…è¿‡æœŸäº‹æ•…
3. **ç½‘ç»œå¾®åˆ†æ®µ**ï¼šæŒ‰äº§çº¿å’Œå®‰å…¨çº§åˆ«åˆ’åˆ†6ä¸ªå®‰å…¨åŸŸï¼Œå®æ–½é›¶ä¿¡ä»»è®¿é—®æ§åˆ¶ï¼Œé™åˆ¶æ¨ªå‘ç§»åŠ¨
4. **HSMå¿…è¦**ï¼šæ ¹CAå¯†é’¥å¿…é¡»å­˜å‚¨åœ¨HSMä¸­ï¼Œæˆ‘ä»¬çš„æµ‹è¯•ç¯å¢ƒæ›¾å‘ç”Ÿç§é’¥æ³„éœ²ï¼Œå¹¸äºåŠæ—¶å‘ç°
5. **åº”æ€¥å“åº”**ï¼šå»ºç«‹è¯ä¹¦ç´§æ€¥æ’¤é”€æµç¨‹ï¼Œå¯åœ¨5åˆ†é’Ÿå†…é˜»æ–­è¢«å…¥ä¾µè®¾å¤‡çš„ç½‘ç»œè®¿é—®

---

## 4. æ¡ˆä¾‹3ï¼šåŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç³»ç»Ÿ

### 4.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸä¸‰ç”²åŒ»é™¢"åº·å®åŒ»ç–—é›†å›¢"ï¼Œæ‹¥æœ‰3000å¼ åºŠä½ï¼Œå¹´é—¨è¯Šé‡è¶…è¿‡200ä¸‡äººæ¬¡ã€‚åŒ»é™¢éƒ¨ç½²äº†è¶…è¿‡5000å°è”ç½‘åŒ»ç–—è®¾å¤‡ï¼ŒåŒ…æ‹¬MRIã€CTã€è¶…å£°ã€ç›‘æŠ¤ä»ªã€è¾“æ¶²æ³µã€æ™ºèƒ½ç—…åºŠç­‰ã€‚2022å¹´èµ·ï¼ŒåŒ»é™¢å¯åŠ¨æ™ºæ…§åŒ»é™¢å»ºè®¾é¡¹ç›®ï¼Œæ„å»ºç»Ÿä¸€çš„åŒ»ç–—ç‰©è”ç½‘å¹³å°ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **æ‚£è€…éšç§æ³„éœ²é£é™©**ï¼šåŒ»ç–—æ•°æ®åœ¨é»‘å¸‚ä»·å€¼é«˜ï¼Œæ›¾å‘ç”Ÿå®ä¹ ç”Ÿç§è‡ªå¯¼å‡º celebrity æ‚£è€…ç—…å†äº‹ä»¶
2. **è®¾å¤‡æ§åˆ¶è¢«åŠ«æŒ**ï¼šéƒ¨åˆ†è¾“æ¶²æ³µã€å‘¼å¸æœºä½¿ç”¨é»˜è®¤å¯†ç ï¼Œå­˜åœ¨è¢«è¿œç¨‹æ“æ§é£é™©
3. **åˆè§„å®¡è®¡å›°éš¾**ï¼šHIPAAå’Œã€Šä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ã€‹è¦æ±‚å®Œæ•´çš„è®¿é—®è®°å½•ï¼Œä½†ç°æœ‰ç³»ç»Ÿæ—¥å¿—åˆ†æ•£ä¸”æ˜“è¢«ç¯¡æ”¹
4. **å†…éƒ¨å¨èƒ**ï¼šåŒ»æŠ¤äººå‘˜å¯æŸ¥çœ‹æ‰€æœ‰æ‚£è€…æ•°æ®ï¼Œç¼ºä¹"æŒ‰éœ€çŸ¥å¯†"åŸåˆ™çš„é™åˆ¶
5. **æ•°æ®è·¨å¢ƒé£é™©**ï¼šåŒ»é™¢ä½¿ç”¨éƒ¨åˆ†æµ·å¤–äº‘æœåŠ¡ï¼Œæ‚£è€…æ•°æ®å‡ºå¢ƒåˆè§„æ€§å­˜ç–‘

**ä¸šåŠ¡ç›®æ ‡**ï¼š

- å»ºç«‹ç¬¦åˆHIPAAå’ŒGDPRæ ‡å‡†çš„æ‚£è€…æ•°æ®ä¿æŠ¤ä½“ç³»
- å®æ–½åŸºäºå±æ€§çš„ç»†ç²’åº¦è®¿é—®æ§åˆ¶ï¼ˆABACï¼‰ï¼Œå®ç°"æ­£ç¡®çš„è§’è‰²åœ¨æ­£ç¡®çš„æ—¶é—´è®¿é—®æ­£ç¡®çš„æ•°æ®"
- å»ºç«‹ä¸å¯ç¯¡æ”¹çš„å®¡è®¡æ—¥å¿—é“¾ï¼Œæ”¯æŒ10å¹´æ•°æ®ä¿ç•™
- å®ç°åŒ»ç–—è®¾å¤‡çš„å¼ºèº«ä»½è®¤è¯å’ŒåŠ å¯†é€šä¿¡
- é€šè¿‡HIMSS EMRAM 7çº§å’Œç­‰ä¿2.0ä¸‰çº§è®¤è¯

### 4.2 æŠ€æœ¯æŒ‘æˆ˜

1. **ç´§æ€¥æ•‘æ²»åœºæ™¯**ï¼šæ€¥æ•‘æ—¶éœ€è¦ç«‹å³è®¿é—®æ‚£è€…æ•°æ®ï¼Œä¸èƒ½å› è®¤è¯å»¶è¿Ÿå½±å“æ•‘æ²»ï¼ˆ<3ç§’å®Œæˆè®¿é—®æˆæƒï¼‰
2. **å¤æ‚è§’è‰²å…³ç³»**ï¼šæ¶‰åŠåŒ»ç”Ÿã€æŠ¤å£«ã€æŠ€å¸ˆã€å®ä¹ ç”Ÿã€ä¼šè¯Šä¸“å®¶ã€å®¶å±ç­‰å¤šç§è§’è‰²ï¼Œæƒé™å…³ç³»åŠ¨æ€å˜åŒ–
3. **è®¾å¤‡å¼‚æ„æ€§**ï¼šåŒ»ç–—è®¾å¤‡æ¥è‡ª200+å‚å•†ï¼Œæ“ä½œç³»ç»Ÿä»Windows XPåˆ°LinuxåµŒå…¥å¼éƒ½æœ‰ï¼Œå®‰å…¨èƒ½åŠ›å‚å·®ä¸é½
4. **æ•°æ®å¯ç”¨æ€§**ï¼šåŠ å¯†ä¸èƒ½å½±å“åŒ»ç–—å›¾åƒï¼ˆDICOMï¼‰çš„å¿«é€Ÿè°ƒé˜…ï¼Œéœ€è¦æ”¯æŒåŠ å¯†æ•°æ®çš„å¿«é€Ÿæ£€ç´¢
5. **æ³•è§„å¤šé‡è¦æ±‚**ï¼šåŒæ—¶æ»¡è¶³HIPAAï¼ˆç¾å›½ï¼‰ã€GDPRï¼ˆæ¬§ç›Ÿæ‚£è€…ï¼‰ã€ä¸­å›½ã€Šä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•ã€‹ä¸‰é‡åˆè§„è¦æ±‚

### 4.3 Schemaå®šä¹‰

**åŒ»ç–—è®¾å¤‡å®‰å…¨Schema**ï¼š

```dsl
schema MedicalDeviceSecurity {
  authentication: {
    method: Enum { SmartCard, Biometric, Certificate }
    multi_factor: {
      enabled: Bool @default(true)
      methods: [SmartCard, Fingerprint, Face]
      emergency_bypass: {
        enabled: Bool @default(true)
        require_two_physicians: Bool @default(true)
        audit_level: "critical"
      }
    }
    session: {
      timeout: Duration @default(15min)
      inactivity_timeout: Duration @default(5min)
      concurrent_sessions: Int @default(1)
    }
  }

  access_control: {
    policy_model: Enum { ABAC }
    attributes: {
      subject: [
        { name: "role", values: [physician, nurse, technician, resident, intern] },
        { name: "department", values: [cardiology, neurology, emergency, icu, surgery] },
        { name: "seniority", values: [attending, fellow, resident, intern] },
        { name: "shift_status", values: [on_duty, on_call, off_duty] }
      ]
      resource: [
        { name: "data_type", values: [ehr, imaging, lab, prescription, billing] },
        { name: "sensitivity", values: [routine, sensitive, critical, restricted] },
        { name: "patient_consent", values: [general, research, marketing] }
      ]
      environment: [
        { name: "location", values: [ward, or, icu, emergency, remote] },
        { name: "time", values: [business_hours, after_hours, emergency] },
        { name: "device_trust", values: [high, medium, low] }
      ]
    }
    policies: [
      {
        name: "emergency_access"
        rule: "environment.time == emergency OR subject.shift_status == on_duty"
        permissions: [read, write]
        constraints: { require_justification: true }
      },
      {
        name: "attending_physician_full"
        rule: "subject.role == physician AND subject.seniority == attending"
        permissions: [read, write, sign]
        scope: "assigned_patients"
      }
    ]
  }

  encryption: {
    algorithms: {
      data_at_rest: Enum { AES_256_GCM }
      data_in_transit: Enum { TLS_1.3 }
      data_in_use: Enum { Intel_SGX, AMD_SEV }
    }
    key_management: {
      hsm_protected: Bool @default(true)
      key_rotation: Duration @default(90days)
      patient_specific_keys: Bool @default(true)
    }
    searchable_encryption: {
      enabled: Bool @default(true)
      indexable_fields: [patient_id, diagnosis_code, date_range]
    }
  }

  audit: {
    logging: {
      enabled: Bool @default(true)
      immutable: Bool @default(true)
      blockchain_verified: Bool @default(true)
      events: [access, modification, export, print, share]
    }
    retention: {
      duration: Duration @default(10years)
      tiered_storage: [hot_1year, warm_5years, cold_10years]
    }
  }

  compliance: {
    hipaa: { safeguards: [administrative, physical, technical], required: Bool @default(true) }
    gdpr: { data_portability: Bool @default(true), right_to_deletion: Bool @default(true) }
  }
} @standard("HIPAA", "GDPR", "Personal_Information_Protection_Law")
```

### 4.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
åŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç³»ç»Ÿ - å®Œæ•´å®ç°
è¦†ç›–ï¼šABACè®¿é—®æ§åˆ¶ã€æ‚£è€…æ•°æ®åŠ å¯†ã€å®¡è®¡æ—¥å¿—é“¾ã€åˆè§„æ€§æ£€æŸ¥
"""

import os
import json
import hashlib
import uuid
import base64
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
import threading


# ============ æšä¸¾å®šä¹‰ ============

class UserRole(str, Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    TECHNICIAN = "technician"
    RESIDENT = "resident"
    INTERN = "intern"
    ADMIN = "admin"


class Seniority(str, Enum):
    ATTENDING = "attending"
    FELLOW = "fellow"
    RESIDENT = "resident"
    INTERN = "intern"


class Department(str, Enum):
    CARDIOLOGY = "cardiology"
    NEUROLOGY = "neurology"
    EMERGENCY = "emergency"
    ICU = "icu"
    SURGERY = "surgery"


class DataType(str, Enum):
    EHR = "ehr"
    IMAGING = "imaging"
    LAB = "lab"
    PRESCRIPTION = "prescription"
    BILLING = "billing"


class DataSensitivity(str, Enum):
    ROUTINE = "routine"
    SENSITIVE = "sensitive"
    CRITICAL = "critical"
    RESTRICTED = "restricted"


class Location(str, Enum):
    WARD = "ward"
    OR = "or"
    ICU = "icu"
    EMERGENCY = "emergency"
    REMOTE = "remote"


class AccessResult(str, Enum):
    GRANTED = "granted"
    DENIED = "denied"
    EMERGENCY_OVERRIDE = "emergency_override"
    MFA_REQUIRED = "mfa_required"


# ============ æ•°æ®æ¨¡å‹ ============

@dataclass
class UserAttributes:
    """ç”¨æˆ·å±æ€§ï¼ˆABAC Subjectï¼‰"""
    user_id: str
    role: UserRole
    department: Department
    seniority: Seniority
    employee_id: str
    assigned_patients: Set[str] = field(default_factory=set)
    shift_status: str = "off_duty"
    certifications: Set[str] = field(default_factory=set)
    clearance_level: int = 1


@dataclass
class ResourceAttributes:
    """èµ„æºå±æ€§ï¼ˆABAC Resourceï¼‰"""
    resource_id: str
    data_type: DataType
    sensitivity: DataSensitivity
    patient_id: str
    owner_department: Department
    created_at: datetime = field(default_factory=datetime.now)
    consent_flags: Set[str] = field(default_factory=lambda: {"general"})


@dataclass
class EnvironmentAttributes:
    """ç¯å¢ƒå±æ€§ï¼ˆABAC Environmentï¼‰"""
    location: Location
    timestamp: datetime = field(default_factory=datetime.now)
    device_trust_level: str = "medium"
    network_type: str = "internal"
    emergency_mode: bool = False


@dataclass
class PatientRecord:
    """æ‚£è€…è®°å½•"""
    patient_id: str
    name: str
    date_of_birth: datetime
    diagnosis: str
    medications: List[str] = field(default_factory=list)
    encrypted_data: Optional[bytes] = None
    data_key_id: Optional[str] = None


@dataclass
class ImmutableAuditLog:
    """ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—æ¡ç›®"""
    log_id: str
    timestamp: datetime
    previous_hash: str
    current_hash: str
    event_type: str
    user_id: str
    patient_id: str
    action: str
    resource: str
    result: AccessResult
    justification: Optional[str] = None


@dataclass
class ABACPolicy:
    """ABACç­–ç•¥å®šä¹‰"""
    policy_id: str
    name: str
    description: str
    priority: int
    subject_conditions: Dict[str, Any]
    resource_conditions: Dict[str, Any]
    environment_conditions: Dict[str, Any]
    permissions: Set[str]
    require_justification: bool = False
    require_mfa: bool = False


# ============ æ ¸å¿ƒå®‰å…¨ç±» ============

class PatientDataEncryption:
    """æ‚£è€…æ•°æ®åŠ å¯†ç®¡ç†å™¨"""
    
    def __init__(self, master_key: Optional[bytes] = None):
        self.master_key = master_key or os.urandom(32)
        self._patient_keys: Dict[str, bytes] = {}
        self._lock = threading.RLock()
    
    def generate_patient_key(self, patient_id: str) -> bytes:
        """ä¸ºæ¯ä¸ªæ‚£è€…ç”Ÿæˆç‹¬ç«‹çš„æ•°æ®å¯†é’¥"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=patient_id.encode(),
            iterations=100000,
            backend=default_backend()
        )
        key = kdf.derive(self.master_key + patient_id.encode())
        
        with self._lock:
            self._patient_keys[patient_id] = key
        return key
    
    def encrypt_patient_data(self, patient_id: str, data: str) -> Tuple[bytes, bytes, bytes]:
        """åŠ å¯†æ‚£è€…æ•°æ®ï¼ˆAES-256-GCMï¼‰"""
        key = self._patient_keys.get(patient_id)
        if not key:
            key = self.generate_patient_key(patient_id)
        
        iv = os.urandom(12)
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv), backend=default_backend())
        encryptor = cipher.encryptor()
        ciphertext = encryptor.update(data.encode()) + encryptor.finalize()
        return iv, ciphertext, encryptor.tag
    
    def decrypt_patient_data(self, patient_id: str, iv: bytes, 
                             ciphertext: bytes, tag: bytes) -> str:
        """è§£å¯†æ‚£è€…æ•°æ®"""
        key = self._patient_keys.get(patient_id)
        if not key:
            raise ValueError(f"Patient key not found: {patient_id}")
        
        cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag), backend=default_backend())
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        return plaintext.decode()


class BlockchainAuditLog:
    """åŸºäºå“ˆå¸Œé“¾çš„ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—"""
    
    def __init__(self):
        self._logs: List[ImmutableAuditLog] = []
        self._last_hash = "0" * 64
        self._lock = threading.RLock()
    
    def _calculate_hash(self, log: ImmutableAuditLog) -> str:
        """è®¡ç®—æ—¥å¿—æ¡ç›®çš„å“ˆå¸Œ"""
        data = f"{log.log_id}{log.timestamp}{log.previous_hash}{log.user_id}{log.patient_id}{log.action}"
        return hashlib.sha256(data.encode()).hexdigest()
    
    def log_access(self, user_id: str, patient_id: str, action: str,
                   resource: str, result: AccessResult,
                   justification: Optional[str] = None) -> ImmutableAuditLog:
        """è®°å½•è®¿é—®æ—¥å¿—"""
        with self._lock:
            log_id = str(uuid.uuid4())
            log = ImmutableAuditLog(
                log_id=log_id,
                timestamp=datetime.now(),
                previous_hash=self._last_hash,
                current_hash="",
                event_type="patient_data_access",
                user_id=user_id,
                patient_id=patient_id,
                action=action,
                resource=resource,
                result=result,
                justification=justification
            )
            log.current_hash = self._calculate_hash(log)
            self._logs.append(log)
            self._last_hash = log.current_hash
        
        return log
    
    def verify_integrity(self) -> Tuple[bool, List[int]]:
        """éªŒè¯æ—¥å¿—é“¾å®Œæ•´æ€§"""
        tampered = []
        for i, log in enumerate(self._logs):
            if log.current_hash != self._calculate_hash(log):
                tampered.append(i)
            if i > 0 and log.previous_hash != self._logs[i-1].current_hash:
                tampered.append(i)
        return len(tampered) == 0, tampered


class ABACAccessControl:
    """åŸºäºå±æ€§çš„è®¿é—®æ§åˆ¶ç³»ç»Ÿ"""
    
    def __init__(self):
        self._policies: List[ABACPolicy] = []
        self._user_attributes: Dict[str, UserAttributes] = {}
        self._init_default_policies()
    
    def _init_default_policies(self):
        """åˆå§‹åŒ–é»˜è®¤ABACç­–ç•¥"""
        self._policies = [
            ABACPolicy(
                policy_id="P001",
                name="Attending Physician Full Access",
                description="ä¸»æ²»åŒ»ç”Ÿå¯¹åˆ†é…æ‚£è€…æœ‰å®Œå…¨è®¿é—®æƒé™",
                priority=100,
                subject_conditions={"role": ["physician"], "seniority": ["attending"]},
                resource_conditions={"data_type": ["ehr", "imaging", "lab"]},
                environment_conditions={},
                permissions={"read", "write", "sign"}
            ),
            ABACPolicy(
                policy_id="P002",
                name="Nurse Ward Access",
                description="æŠ¤å£«åªèƒ½è®¿é—®å…¶æ‰€åœ¨ç—…åŒºæ‚£è€…çš„åŸºæœ¬ä¿¡æ¯",
                priority=90,
                subject_conditions={"role": ["nurse"]},
                resource_conditions={"data_type": ["ehr", "lab"]},
                environment_conditions={"location": ["ward", "icu"]},
                permissions={"read", "write"}
            ),
            ABACPolicy(
                policy_id="P003",
                name="Emergency Override",
                description="æ€¥æ•‘æ¨¡å¼ä¸‹å¯è®¿é—®ä»»ä½•æ‚£è€…æ•°æ®",
                priority=200,
                subject_conditions={},
                resource_conditions={},
                environment_conditions={"emergency_mode": [True]},
                permissions={"read", "write"},
                require_justification=True
            ),
        ]
        self._policies.sort(key=lambda p: -p.priority)
    
    def register_user(self, user_attrs: UserAttributes):
        """æ³¨å†Œç”¨æˆ·å±æ€§"""
        self._user_attributes[user_attrs.user_id] = user_attrs
    
    def evaluate_access(self, user_id: str, resource: ResourceAttributes,
                        env: EnvironmentAttributes, requested_permissions: Set[str],
                        mfa_provided: bool = False) -> Tuple[AccessResult, str]:
        """è¯„ä¼°è®¿é—®è¯·æ±‚"""
        user = self._user_attributes.get(user_id)
        if not user:
            return AccessResult.DENIED, "User not found"
        
        if resource.sensitivity in (DataSensitivity.CRITICAL, DataSensitivity.RESTRICTED):
            if not mfa_provided:
                return AccessResult.MFA_REQUIRED, "MFA required for critical data"
        
        for policy in self._policies:
            if self._matches_policy(user, resource, env, policy):
                if requested_permissions.issubset(policy.permissions):
                    if policy.require_justification and not env.emergency_mode:
                        return AccessResult.GRANTED, f"Policy {policy.name} matched - justification required"
                    return AccessResult.GRANTED, f"Policy {policy.name} matched"
        
        return AccessResult.DENIED, "No matching policy found"
    
    def _matches_policy(self, user: UserAttributes, resource: ResourceAttributes,
                        env: EnvironmentAttributes, policy: ABACPolicy) -> bool:
        """æ£€æŸ¥æ˜¯å¦åŒ¹é…ç­–ç•¥æ¡ä»¶"""
        for attr, values in policy.subject_conditions.items():
            if getattr(user, attr, None) not in values:
                return False
        for attr, values in policy.resource_conditions.items():
            if getattr(resource, attr, None) not in values:
                return False
        for attr, values in policy.environment_conditions.items():
            if getattr(env, attr, None) not in values:
                return False
        return True


class MedicalSecurityCompliance:
    """åŒ»ç–—å®‰å…¨åˆè§„æ£€æŸ¥å™¨"""
    
    def __init__(self, access_control: ABACAccessControl, 
                 audit_log: BlockchainAuditLog,
                 encryption: PatientDataEncryption):
        self.access_control = access_control
        self.audit_log = audit_log
        self.encryption = encryption
    
    def check_hipaa_compliance(self) -> Dict[str, bool]:
        """æ£€æŸ¥HIPAAåˆè§„æ€§"""
        return {
            "administrative_safeguards": len(self.access_control._policies) > 0,
            "technical_safeguards": self.encryption.master_key is not None,
            "audit_controls": len(self.audit_log._logs) > 0,
            "integrity_controls": self.audit_log.verify_integrity()[0]
        }
    
    def generate_compliance_report(self) -> Dict:
        """ç”Ÿæˆåˆè§„æŠ¥å‘Š"""
        hipaa = self.check_hipaa_compliance()
        return {
            "generated_at": datetime.now().isoformat(),
            "hipaa": {"compliant": all(hipaa.values()), "details": hipaa},
            "audit_summary": {
                "total_logs": len(self.audit_log._logs),
                "integrity_verified": self.audit_log.verify_integrity()[0]
            }
        }


# ============ ä¸»ç³»ç»Ÿç±» ============

class MedicalDeviceSecuritySystem:
    """åŒ»ç–—è®¾å¤‡å®‰å…¨ç³»ç»Ÿ - ä¸»ç±»"""
    
    def __init__(self):
        self.encryption = PatientDataEncryption()
        self.audit_log = BlockchainAuditLog()
        self.access_control = ABACAccessControl()
        self.compliance = MedicalSecurityCompliance(
            self.access_control, self.audit_log, self.encryption
        )
        self._patients: Dict[str, PatientRecord] = {}
        self._lock = threading.RLock()
    
    def register_patient(self, patient_id: str, name: str, 
                         date_of_birth: datetime) -> PatientRecord:
        """æ³¨å†Œæ‚£è€…"""
        self.encryption.generate_patient_key(patient_id)
        
        record = PatientRecord(
            patient_id=patient_id,
            name=name,
            date_of_birth=date_of_birth,
            diagnosis="",
            data_key_id=patient_id
        )
        
        with self._lock:
            self._patients[patient_id] = record
        
        return record
    
    def create_patient_record(self, user_id: str, patient_id: str,
                              diagnosis: str, medications: List[str],
                              env: EnvironmentAttributes) -> bool:
        """åˆ›å»ºæ‚£è€…ç—…å†"""
        resource = ResourceAttributes(
            resource_id=str(uuid.uuid4()),
            data_type=DataType.EHR,
            sensitivity=DataSensitivity.SENSITIVE,
            patient_id=patient_id,
            owner_department=Department.CARDIOLOGY
        )
        
        result, msg = self.access_control.evaluate_access(
            user_id, resource, env, {"write"}
        )
        
        if result not in (AccessResult.GRANTED, AccessResult.EMERGENCY_OVERRIDE):
            self.audit_log.log_access(
                user_id, patient_id, "create_record", "ehr",
                AccessResult.DENIED
            )
            return False
        
        patient = self._patients.get(patient_id)
        if patient:
            data = json.dumps({
                "diagnosis": diagnosis,
                "medications": medications,
                "created_by": user_id,
                "created_at": datetime.now().isoformat()
            })
            iv, ciphertext, tag = self.encryption.encrypt_patient_data(patient_id, data)
            patient.encrypted_data = json.dumps({
                "iv": base64.b64encode(iv).decode(),
                "ciphertext": base64.b64encode(ciphertext).decode(),
                "tag": base64.b64encode(tag).decode()
            }).encode()
            patient.diagnosis = diagnosis
            patient.medications = medications
        
        self.audit_log.log_access(
            user_id, patient_id, "create_record", "ehr",
            result,
            justification="Emergency" if env.emergency_mode else None
        )
        
        return True
    
    def access_patient_record(self, user_id: str, patient_id: str,
                              env: EnvironmentAttributes,
                              mfa_provided: bool = False) -> Optional[Dict]:
        """è®¿é—®æ‚£è€…ç—…å†"""
        patient = self._patients.get(patient_id)
        if not patient:
            return None
        
        sensitivity = DataSensitivity.SENSITIVE
        if "HIV" in patient.diagnosis:
            sensitivity = DataSensitivity.RESTRICTED
        
        resource = ResourceAttributes(
            resource_id=patient_id,
            data_type=DataType.EHR,
            sensitivity=sensitivity,
            patient_id=patient_id,
            owner_department=Department.CARDIOLOGY
        )
        
        result, msg = self.access_control.evaluate_access(
            user_id, resource, env, {"read"}, mfa_provided
        )
        
        if result == AccessResult.MFA_REQUIRED:
            return {"error": "MFA_REQUIRED", "message": msg}
        
        if result not in (AccessResult.GRANTED, AccessResult.EMERGENCY_OVERRIDE):
            self.audit_log.log_access(
                user_id, patient_id, "read_record", "ehr",
                AccessResult.DENIED
            )
            return None
        
        decrypted_data = None
        if patient.encrypted_data:
            encrypted = json.loads(patient.encrypted_data)
            iv = base64.b64decode(encrypted["iv"])
            ciphertext = base64.b64decode(encrypted["ciphertext"])
            tag = base64.b64decode(encrypted["tag"])
            decrypted_data = self.encryption.decrypt_patient_data(
                patient_id, iv, ciphertext, tag
            )
        
        self.audit_log.log_access(
            user_id, patient_id, "read_record", "ehr",
            result,
            justification="Emergency" if env.emergency_mode else None
        )
        
        return {
            "patient_id": patient_id,
            "name": patient.name,
            "diagnosis": patient.diagnosis,
            "medications": patient.medications,
            "full_record": json.loads(decrypted_data) if decrypted_data else None
        }


# ============ ä½¿ç”¨ç¤ºä¾‹ ============

if __name__ == "__main__":
    print("=" * 70)
    print("åŒ»ç–—è®¾å¤‡å®‰å…¨åˆè§„ç³»ç»Ÿæ¼”ç¤º")
    print("=" * 70)
    
    system = MedicalDeviceSecuritySystem()
    
    print("\n[1] æ³¨å†ŒåŒ»æŠ¤äººå‘˜")
    
    attending = UserAttributes(
        user_id="DOC001",
        role=UserRole.PHYSICIAN,
        department=Department.CARDIOLOGY,
        seniority=Seniority.ATTENDING,
        employee_id="E12345",
        assigned_patients={"P001", "P002"},
        shift_status="on_duty",
        clearance_level=4
    )
    system.access_control.register_user(attending)
    print(f"  ä¸»æ²»åŒ»ç”Ÿ: {attending.user_id} (å¿ƒå†…ç§‘)")
    
    nurse = UserAttributes(
        user_id="NUR001",
        role=UserRole.NURSE,
        department=Department.CARDIOLOGY,
        seniority=Seniority.RESIDENT,
        employee_id="E67890",
        assigned_patients={"P001"},
        shift_status="on_duty",
        clearance_level=2
    )
    system.access_control.register_user(nurse)
    print(f"  æŠ¤å£«: {nurse.user_id} (å¿ƒå†…ç§‘ç—…æˆ¿)")
    
    intern = UserAttributes(
        user_id="INT001",
        role=UserRole.INTERN,
        department=Department.CARDIOLOGY,
        seniority=Seniority.INTERN,
        employee_id="E11111",
        assigned_patients=set(),
        shift_status="on_duty",
        clearance_level=1
    )
    system.access_control.register_user(intern)
    print(f"  å®ä¹ ç”Ÿ: {intern.user_id}")
    
    print("\n[2] æ³¨å†Œæ‚£è€…")
    patient = system.register_patient("P001", "å¼ ä¸‰", datetime(1980, 5, 15))
    print(f"  æ‚£è€…: {patient.name} (ID: {patient.patient_id})")
    
    print("\n[3] åˆ›å»ºæ‚£è€…ç—…å†")
    env_normal = EnvironmentAttributes(
        location=Location.WARD,
        device_trust_level="high",
        emergency_mode=False
    )
    
    success = system.create_patient_record(
        "DOC001", "P001",
        diagnosis="å† å¿ƒç—…ï¼Œé«˜è¡€å‹",
        medications=["é˜¿å¸åŒ¹æ—", "é™å‹è¯"],
        env=env_normal
    )
    print(f"  ä¸»æ²»åŒ»ç”Ÿåˆ›å»ºç—…å†: {'âœ“ æˆåŠŸ' if success else 'âœ— å¤±è´¥'}")
    
    print("\n[4] è®¿é—®æ§åˆ¶æµ‹è¯•")
    
    result = system.access_patient_record("DOC001", "P001", env_normal)
    print(f"  ä¸»æ²»åŒ»ç”Ÿè®¿é—®æ‚£è€…P001: {'âœ“ æˆåŠŸ' if result and 'error' not in result else 'âœ— å¤±è´¥'}")
    
    result = system.access_patient_record("NUR001", "P001", env_normal)
    print(f"  æŠ¤å£«è®¿é—®æ‚£è€…P001: {'âœ“ æˆåŠŸ' if result and 'error' not in result else 'âœ— å¤±è´¥'}")
    
    result = system.access_patient_record("INT001", "P001", env_normal)
    print(f"  å®ä¹ ç”Ÿè®¿é—®æ‚£è€…P001: {'âœ“ æˆåŠŸ' if result and 'error' not in result else 'âœ— æ‹’ç»'}")
    
    print("\n[5] æ€¥æ•‘æ¨¡å¼è®¿é—®æµ‹è¯•")
    env_emergency = EnvironmentAttributes(
        location=Location.EMERGENCY,
        device_trust_level="high",
        emergency_mode=True
    )
    
    result = system.access_patient_record("INT001", "P001", env_emergency)
    print(f"  å®ä¹ ç”Ÿæ€¥æ•‘æ¨¡å¼è®¿é—®: {'âœ“ æˆåŠŸ' if result and 'error' not in result else 'âœ— å¤±è´¥'}")
    
    print("\n[6] å®¡è®¡æ—¥å¿—éªŒè¯")
    integrity_ok, tampered = system.audit_log.verify_integrity()
    print(f"  æ—¥å¿—é“¾å®Œæ•´æ€§: {'âœ“ é€šè¿‡' if integrity_ok else 'âœ— å¤±è´¥'}")
    print(f"  æ€»æ—¥å¿—æ¡ç›®: {len(system.audit_log._logs)}")
    
    print("\n[7] åˆè§„æ€§æ£€æŸ¥")
    report = system.compliance.generate_compliance_report()
    print(f"  HIPAAåˆè§„: {'âœ“ é€šè¿‡' if report['hipaa']['compliant'] else 'âœ— æœªé€šè¿‡'}")
    
    print("\n" + "=" * 70)
    print("æ¼”ç¤ºå®Œæˆ")
    print("=" * 70)
```

### 4.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| æ‚£è€…æ•°æ®åŠ å¯†ç‡ | 0% | 100% | +100% |
| è®¿é—®æˆæƒå“åº”æ—¶é—´ | >10s | 1.8s | -82% |
| å®¡è®¡æ—¥å¿—å®Œæ•´æ€§ | ä¸å¯éªŒè¯ | 100%å¯éªŒè¯ | +100% |
| æœªæˆæƒè®¿é—®æ£€å‡º | 35% | 99.7% | +185% |
| å†…éƒ¨å¨èƒæ£€å‡ºç‡ | 12% | 87% | +625% |
| æ‰¹é‡è®¿é—®å‘Šè­¦ | N/A | <5åˆ†é’Ÿ | å®æ—¶ |
| æ•°æ®æ£€ç´¢æ€§èƒ½ï¼ˆåŠ å¯†ï¼‰ | N/A | <200ms | å¯æ¥å— |
| ç³»ç»Ÿå¯ç”¨æ€§ | 99.5% | 99.98% | +0.48% |

**ä¸šåŠ¡ä»·å€¼**ï¼š

1. **åˆè§„æ”¶ç›Š**ï¼šé€šè¿‡HIMSS EMRAM 7çº§è¯„å®¡ï¼Œè·å¾—æ”¿åºœæ™ºæ…§åŒ»é™¢è¡¥è´´Â¥1200ä¸‡ï¼›é€šè¿‡ç­‰ä¿2.0ä¸‰çº§è®¤è¯
2. **é£é™©é™ä½**ï¼šéƒ¨ç½²åæ‚£è€…éšç§æ³„éœ²äº‹ä»¶ä»å¹´å‡4èµ·é™è‡³0èµ·ï¼Œé¿å…æ³•å¾‹è¯‰è®¼å’Œå£°èª‰æŸå¤±estimated Â¥3000ä¸‡/èµ·
3. **è¿è¥æ•ˆç‡**ï¼šABACè‡ªåŠ¨åŒ–æˆæƒå‡å°‘äººå·¥å®¡æ‰¹å·¥ä½œé‡80%ï¼ŒåŒ»æŠ¤äººå‘˜æ—¥å‡èŠ‚çœ45åˆ†é’Ÿ
4. **æ‚£è€…ä¿¡ä»»**ï¼šæ‚£è€…æ•°æ®å®‰å…¨è¯„åˆ†ä»3.1æå‡è‡³4.9ï¼Œæ‚£è€…æ»¡æ„åº¦æå‡23%
5. **ç ”ç©¶åˆè§„**ï¼šæ»¡è¶³ä¸´åºŠç§‘ç ”æ•°æ®è„±æ•è¦æ±‚ï¼Œæ”¯æŒåˆè§„çš„å¤šä¸­å¿ƒç ”ç©¶é¡¹ç›®15ä¸ª

**ç»éªŒæ•™è®­**ï¼š

1. **æ€¥æ•‘ç»¿è‰²é€šé“**ï¼šæ€¥æ•‘åœºæ™¯ä¸‹å¿…é¡»æ”¯æŒå¿«é€Ÿæˆæƒï¼ˆ<3ç§’ï¼‰ï¼Œæˆ‘ä»¬çš„åˆå§‹è®¾è®¡è¿‡äºä¸¥æ ¼å½±å“æ•‘æ²»
2. **MFAé€‰æ‹©**ï¼šåŒ»æŠ¤äººå‘˜ä¸æ¥å—å¤æ‚MFAï¼Œé‡‡ç”¨æ™ºèƒ½å¡+æŒ‡çº¹çš„è½»é‡çº§æ–¹æ¡ˆï¼Œæ¥å—åº¦è¾¾96%
3. **æ•°æ®åˆ†çº§**ï¼šå°†æ‚£è€…æ•°æ®åˆ†ä¸º4çº§æ•æ„Ÿåº¦ï¼Œä¸åŒçº§åˆ«é‡‡ç”¨ä¸åŒåŠ å¯†å’Œè®¿é—®ç­–ç•¥ï¼Œå¹³è¡¡å®‰å…¨ä¸æ•ˆç‡
4. **å®¡è®¡é“¾å¤‡ä»½**ï¼šåŒºå—é“¾å®¡è®¡æ—¥å¿—å¿…é¡»åœ¨3ä¸ªç‰©ç†ä½ç½®å¤‡ä»½ï¼Œé˜²æ­¢å•ç‚¹æ•…éšœå¯¼è‡´è¯æ®ä¸¢å¤±
5. **åŸ¹è®­è‡³å…³é‡è¦**ï¼šåŒ»æŠ¤äººå‘˜å®‰å…¨æ„è¯†åŸ¹è®­ä½¿ç¤¾ä¼šå·¥ç¨‹æ”»å‡»æˆåŠŸç‡ä»23%é™è‡³2%

---

## 5. æ¡ˆä¾‹4ï¼šIoTå®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿ

### 5.1 ä¸šåŠ¡èƒŒæ™¯

**ä¼ä¸šèƒŒæ™¯**ï¼š
æŸå…¨å›½æ€§IoTè¿è¥å•†"æ™ºè”ä¸‡ç‰©"ï¼Œç®¡ç†è¶…è¿‡5000ä¸‡å°IoTè®¾å¤‡ï¼Œæ¶µç›–è½¦è”ç½‘ã€æ™ºèƒ½è¡¨è®¡ã€å®‰é˜²ç›‘æ§ã€ç¯å¢ƒç›‘æµ‹ç­‰é¢†åŸŸã€‚å¹³å°æ—¥å‡å¤„ç†æ•°æ®è¶…è¿‡100TBï¼ŒAPIè°ƒç”¨è¶…è¿‡50äº¿æ¬¡ã€‚2023å¹´ï¼Œå…¬å¸å‘ç°å¤šèµ·å¤§è§„æ¨¡DDoSæ”»å‡»æºè‡ªè¢«å…¥ä¾µçš„IoTè®¾å¤‡ï¼Œå†³å®šå»ºè®¾ç»Ÿä¸€çš„å®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”å¹³å°ã€‚

**ä¸šåŠ¡ç—›ç‚¹**ï¼š

1. **åƒµå°¸ç½‘ç»œå¨èƒ**ï¼šå¤§é‡å¼±å¯†ç IoTè®¾å¤‡è¢«Miraiå˜ç§æ„ŸæŸ“ï¼Œæˆä¸ºDDoSæ”»å‡»æº
2. **å¼‚å¸¸è¡Œä¸ºéš¾å‘ç°**ï¼šæ­£å¸¸è®¾å¤‡è¡Œä¸ºä¸æ¶æ„è¡Œä¸ºè¾¹ç•Œæ¨¡ç³Šï¼Œä¼ ç»Ÿè§„åˆ™æ£€æµ‹è¯¯æŠ¥ç‡é«˜
3. **å“åº”æ»å**ï¼šä»æ”»å‡»å‘ç”Ÿåˆ°äººå·¥å“åº”å¹³å‡éœ€è¦45åˆ†é’Ÿï¼ŒæŸå¤±æƒ¨é‡
4. **è·¨å¹³å°å­¤å²›**ï¼šå„ä¸šåŠ¡çº¿å®‰å…¨æ•°æ®åˆ†æ•£ï¼Œæ— æ³•å½¢æˆå…¨å±€å¨èƒè§†å›¾
5. **é›¶æ—¥æ¼æ´åˆ©ç”¨**ï¼šè®¾å¤‡å›ºä»¶æ¼æ´è¢«åˆ©ç”¨ï¼Œç¼ºä¹è¡Œä¸ºæ£€æµ‹èƒ½åŠ›

**ä¸šåŠ¡ç›®æ ‡**ï¼š

- å»ºç«‹å®æ—¶å¨èƒæ£€æµ‹ç³»ç»Ÿï¼Œæ£€æµ‹å»¶è¿Ÿ<100ms
- å®ç°è‡ªåŠ¨åŒ–å“åº”ï¼ˆéš”ç¦»ã€é˜»æ–­ã€å‘Šè­¦ï¼‰ï¼Œå“åº”æ—¶é—´<5ç§’
- æ„å»ºè®¾å¤‡è¡Œä¸ºåŸºçº¿ï¼Œå¼‚å¸¸æ£€æµ‹å‡†ç¡®ç‡>95%
- å»ºç«‹å¨èƒæƒ…æŠ¥å…±äº«æœºåˆ¶ï¼Œè·¨å¹³å°è”åŠ¨é˜²å¾¡
- æ”¯æŒæ—¥å‡100äº¿äº‹ä»¶å¤„ç†è§„æ¨¡çš„åˆ†å¸ƒå¼æ¶æ„

### 5.2 æŠ€æœ¯æŒ‘æˆ˜

1. **æµ·é‡æ•°æ®å¤„ç†**ï¼š5000ä¸‡å°è®¾å¤‡æ¯ç§’äº§ç”Ÿæ•°ç™¾ä¸‡äº‹ä»¶ï¼Œä¼ ç»ŸSIEMæ— æ³•æ‰¿è½½
2. **è¾¹ç¼˜è®¡ç®—é™åˆ¶**ï¼šæ£€æµ‹æ¨¡å‹éœ€è¦åœ¨è¾¹ç¼˜ç½‘å…³è¿è¡Œï¼Œèµ„æºå—é™ï¼ˆ<512MBå†…å­˜ï¼‰
3. **æ¨¡å‹å¯è§£é‡Šæ€§**ï¼šå®‰å…¨äº‹ä»¶éœ€è¦ç»™å‡ºæ˜ç¡®çš„æ£€æµ‹ä¾æ®ï¼Œæ»¡è¶³å®¡è®¡è¦æ±‚
4. **å¯¹æŠ—æ ·æœ¬æ”»å‡»**ï¼šæ”»å‡»è€…å°è¯•ç»•è¿‡MLæ£€æµ‹æ¨¡å‹ï¼Œéœ€è¦æ¨¡å‹é²æ£’æ€§
5. **å¤šç§Ÿæˆ·éš”ç¦»**ï¼šä¸åŒå®¢æˆ·æ•°æ®éœ€è¦é€»è¾‘éš”ç¦»ï¼ŒåŒæ—¶å…±äº«å¨èƒæƒ…æŠ¥

### 5.3 Schemaå®šä¹‰

**IoTå¨èƒæ£€æµ‹Schema**ï¼š

```dsl
schema IoTThreatDetection {
  data_collection: {
    sources: [DeviceLogs, NetworkFlows, AuthenticationEvents, APIAccess]
    sampling_rate: Float @default(1.0)
    retention: {
      hot: Duration @default(7days)
      warm: Duration @default(90days)
      cold: Duration @default(1year)
    }
  }

  detection: {
    real_time: {
      enabled: Bool @default(true)
      latency_target_ms: Int @default(100)
      rules: [
        { name: "brute_force", threshold: 5, window: "1min" },
        { name: "ddos_participation", threshold: 1000, window: "10s" },
        { name: "lateral_movement", pattern: "port_scan" },
        { name: "data_exfiltration", threshold: "1GB/hour" }
      ]
    }
    behavioral_ml: {
      enabled: Bool @default(true)
      model_type: Enum { Autoencoder, IsolationForest, LSTM }
      features: [packet_size, interval, destination, protocol]
      training_window: Duration @default(30days)
      detection_threshold: Float @default(0.95)
    }
    threat_intelligence: {
      feeds: [MISP, AlienVault, Commercial_Feeds]
      update_frequency: Duration @default(1hour)
      ioc_types: [IP, Domain, Hash, URL]
    }
  }

  response: {
    automated: {
      enabled: Bool @default(true)
      actions: [
        { threat_level: "low", action: "alert" },
        { threat_level: "medium", action: "rate_limit" },
        { threat_level: "high", action: "isolate" },
        { threat_level: "critical", action: "block" }
      ]
      response_time_target_ms: Int @default(5000)
    }
  }

  analytics: {
    dashboard: {
      metrics: [threat_score, detection_rate, response_time, false_positive_rate]
      refresh_interval: Duration @default(5s)
    }
  }
} @standard("MITRE_ATT&CK_IoT", "NIST_CSF")
```

### 5.4 å®Œæ•´ä»£ç å®ç°

```python
#!/usr/bin/env python3
"""
IoTå®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿ - å®Œæ•´å®ç°
è¦†ç›–ï¼šå®æ—¶è§„åˆ™æ£€æµ‹ã€è¡Œä¸ºå¼‚å¸¸æ£€æµ‹ã€è‡ªåŠ¨åŒ–å“åº”ã€å¨èƒæƒ…æŠ¥ã€äº‹ä»¶å…³è”
"""

import os
import json
import hashlib
import time
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set, Tuple, Callable, Any
from dataclasses import dataclass, field
from enum import Enum
from collections import defaultdict, deque
import threading
import statistics


# ============ æšä¸¾å®šä¹‰ ============

class ThreatLevel(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ThreatType(str, Enum):
    BRUTE_FORCE = "brute_force"
    DDoS_PARTICIPATION = "ddos_participation"
    LATERAL_MOVEMENT = "lateral_movement"
    DATA_EXFILTRATION = "data_exfiltration"
    CnC_COMMUNICATION = "cnc_communication"
    ANOMALY_BEHAVIOR = "anomaly_behavior"
    FIRMWARE_TAMPERING = "firmware_tampering"


class ResponseAction(str, Enum):
    ALERT = "alert"
    RATE_LIMIT = "rate_limit"
    ISOLATE = "isolate"
    BLOCK = "block"
    QUARANTINE = "quarantine"


class EventType(str, Enum):
    AUTHENTICATION = "authentication"
    NETWORK_FLOW = "network_flow"
    API_ACCESS = "api_access"
    FIRMWARE_UPDATE = "firmware_update"
    CONFIG_CHANGE = "config_change"
    ALERT = "alert"


# ============ æ•°æ®æ¨¡å‹ ============

@dataclass
class SecurityEvent:
    """å®‰å…¨äº‹ä»¶"""
    event_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    event_type: EventType = EventType.AUTHENTICATION
    device_id: str = ""
    source_ip: str = ""
    destination_ip: Optional[str] = None
    destination_port: Optional[int] = None
    protocol: Optional[str] = None
    bytes_transferred: int = 0
    metadata: Dict = field(default_factory=dict)


@dataclass
class ThreatIndicator:
    """å¨èƒæŒ‡æ ‡ï¼ˆIOCï¼‰"""
    ioc_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    ioc_type: str = ""
    value: str = ""
    threat_type: ThreatType = ThreatType.CnC_COMMUNICATION
    confidence: float = 0.0
    source: str = ""
    first_seen: datetime = field(default_factory=datetime.now)
    tags: Set[str] = field(default_factory=set)


@dataclass
class DeviceBehaviorProfile:
    """è®¾å¤‡è¡Œä¸ºç”»åƒ"""
    device_id: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    normal_destinations: Set[str] = field(default_factory=set)
    normal_ports: Set[int] = field(default_factory=set)
    avg_packet_size: float = 0.0
    std_packet_size: float = 0.0
    packet_sizes: deque = field(default_factory=lambda: deque(maxlen=1000))


@dataclass
class DetectionResult:
    """æ£€æµ‹ç»“æœ"""
    detection_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    threat_type: ThreatType = ThreatType.ANOMALY_BEHAVIOR
    threat_level: ThreatLevel = ThreatLevel.LOW
    device_id: str = ""
    confidence: float = 0.0
    description: str = ""
    evidence: Dict = field(default_factory=dict)
    recommended_action: ResponseAction = ResponseAction.ALERT


@dataclass
class ResponseTask:
    """å“åº”ä»»åŠ¡"""
    task_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    detection_id: str = ""
    created_at: datetime = field(default_factory=datetime.now)
    executed_at: Optional[datetime] = None
    action: ResponseAction = ResponseAction.ALERT
    target_device: str = ""
    parameters: Dict = field(default_factory=dict)
    status: str = "pending"
    result: Optional[str] = None


# ============ å®æ—¶è§„åˆ™æ£€æµ‹å¼•æ“ ============

class RealTimeRuleEngine:
    """å®æ—¶è§„åˆ™æ£€æµ‹å¼•æ“"""
    
    def __init__(self):
        self._rules: List[Dict] = []
        self._event_windows: Dict[str, deque] = defaultdict(lambda: deque(maxlen=10000))
        self._lock = threading.RLock()
        self._init_default_rules()
    
    def _init_default_rules(self):
        """åˆå§‹åŒ–é»˜è®¤æ£€æµ‹è§„åˆ™"""
        self._rules = [
            {
                "rule_id": "R001",
                "name": "Brute Force Attack",
                "threat_type": ThreatType.BRUTE_FORCE,
                "threat_level": ThreatLevel.HIGH,
                "condition": lambda events: len([e for e in events if e.event_type == EventType.AUTHENTICATION]) >= 5,
                "window_seconds": 60,
                "description": "Multiple failed authentication attempts"
            },
            {
                "rule_id": "R002",
                "name": "DDoS Participation",
                "threat_type": ThreatType.DDoS_PARTICIPATION,
                "threat_level": ThreatLevel.CRITICAL,
                "condition": lambda events: len(events) >= 1000 and statistics.mean([e.bytes_transferred for e in events]) > 10000,
                "window_seconds": 10,
                "description": "High volume outbound traffic indicating DDoS participation"
            },
            {
                "rule_id": "R003",
                "name": "Port Scan Detection",
                "threat_type": ThreatType.LATERAL_MOVEMENT,
                "threat_level": ThreatLevel.MEDIUM,
                "condition": lambda events: len(set([e.destination_port for e in events if e.destination_port])) >= 20,
                "window_seconds": 30,
                "description": "Sequential port scanning detected"
            },
        ]
    
    def process_event(self, event: SecurityEvent) -> Optional[DetectionResult]:
        """å¤„ç†å•ä¸ªäº‹ä»¶"""
        with self._lock:
            device_window = self._event_windows[event.device_id]
            device_window.append(event)
            
            cutoff = datetime.now() - timedelta(seconds=3600)
            while device_window and device_window[0].timestamp < cutoff:
                device_window.popleft()
            
            for rule in self._rules:
                window_events = [
                    e for e in device_window
                    if (datetime.now() - e.timestamp).total_seconds() <= rule["window_seconds"]
                ]
                
                if rule["condition"](window_events):
                    return DetectionResult(
                        threat_type=rule["threat_type"],
                        threat_level=rule["threat_level"],
                        device_id=event.device_id,
                        confidence=0.85,
                        description=rule["description"],
                        evidence={"rule_id": rule["rule_id"], "matched_events": len(window_events)},
                        recommended_action=self._get_action_for_level(rule["threat_level"])
                    )
        
        return None
    
    def _get_action_for_level(self, level: ThreatLevel) -> ResponseAction:
        """æ ¹æ®å¨èƒçº§åˆ«è·å–å“åº”åŠ¨ä½œ"""
        mapping = {
            ThreatLevel.LOW: ResponseAction.ALERT,
            ThreatLevel.MEDIUM: ResponseAction.RATE_LIMIT,
            ThreatLevel.HIGH: ResponseAction.ISOLATE,
            ThreatLevel.CRITICAL: ResponseAction.BLOCK
        }
        return mapping.get(level, ResponseAction.ALERT)


# ============ è¡Œä¸ºå¼‚å¸¸æ£€æµ‹å¼•æ“ ============

class BehavioralAnomalyDetection:
    """åŸºäºè®¾å¤‡è¡Œä¸ºç”»åƒçš„å¼‚å¸¸æ£€æµ‹"""
    
    def __init__(self):
        self._profiles: Dict[str, DeviceBehaviorProfile] = {}
        self._learning_mode: Set[str] = set()
        self._profile_lock = threading.RLock()
    
    def create_profile(self, device_id: str) -> DeviceBehaviorProfile:
        """åˆ›å»ºè®¾å¤‡è¡Œä¸ºç”»åƒ"""
        profile = DeviceBehaviorProfile(device_id=device_id)
        with self._profile_lock:
            self._profiles[device_id] = profile
            self._learning_mode.add(device_id)
        return profile
    
    def update_profile(self, event: SecurityEvent):
        """ä½¿ç”¨äº‹ä»¶æ›´æ–°è¡Œä¸ºç”»åƒ"""
        with self._profile_lock:
            if event.device_id not in self._profiles:
                self.create_profile(event.device_id)
            
            profile = self._profiles[event.device_id]
            profile.updated_at = datetime.now()
            
            if event.event_type == EventType.NETWORK_FLOW:
                if event.destination_ip:
                    profile.normal_destinations.add(event.destination_ip)
                if event.destination_port:
                    profile.normal_ports.add(event.destination_port)
                if event.bytes_transferred > 0:
                    profile.packet_sizes.append(event.bytes_transferred)
                    if len(profile.packet_sizes) >= 10:
                        profile.avg_packet_size = statistics.mean(profile.packet_sizes)
                        profile.std_packet_size = statistics.stdev(profile.packet_sizes) if len(profile.packet_sizes) > 1 else 0
            
            if (datetime.now() - profile.created_at).days >= 1:
                self._learning_mode.discard(event.device_id)
    
    def detect_anomaly(self, event: SecurityEvent) -> Optional[DetectionResult]:
        """åŸºäºè¡Œä¸ºç”»åƒæ£€æµ‹å¼‚å¸¸"""
        with self._profile_lock:
            if event.device_id not in self._profiles:
                self.create_profile(event.device_id)
                return None
            
            profile = self._profiles[event.device_id]
            
            if event.device_id in self._learning_mode:
                return None
            
            anomalies = []
            evidence = {}
            
            if event.destination_ip and event.destination_ip not in profile.normal_destinations:
                anomalies.append("new_destination")
                evidence["destination_ip"] = event.destination_ip
            
            if event.destination_port and event.destination_port not in profile.normal_ports:
                anomalies.append("new_port")
                evidence["destination_port"] = event.destination_port
            
            if event.bytes_transferred > 0 and profile.std_packet_size > 0:
                z_score = abs(event.bytes_transferred - profile.avg_packet_size) / profile.std_packet_size
                if z_score > 3:
                    anomalies.append("anomalous_packet_size")
                    evidence["z_score"] = z_score
            
            if anomalies:
                return DetectionResult(
                    threat_type=ThreatType.ANOMALY_BEHAVIOR,
                    threat_level=ThreatLevel.MEDIUM if len(anomalies) < 3 else ThreatLevel.HIGH,
                    device_id=event.device_id,
                    confidence=min(0.5 + 0.15 * len(anomalies), 0.95),
                    description=f"Behavioral anomalies detected: {', '.join(anomalies)}",
                    evidence=evidence,
                    recommended_action=ResponseAction.RATE_LIMIT if len(anomalies) < 3 else ResponseAction.ISOLATE
                )
        
        return None


# ============ å¨èƒæƒ…æŠ¥ç®¡ç† ============

class ThreatIntelligenceManager:
    """å¨èƒæƒ…æŠ¥ç®¡ç†å™¨"""
    
    def __init__(self):
        self._iocs: Dict[str, ThreatIndicator] = {}
        self._ip_iocs: Set[str] = set()
        self._domain_iocs: Set[str] = set()
        self._hash_iocs: Set[str] = set()
        self._lock = threading.RLock()
        self._init_default_iocs()
    
    def _init_default_iocs(self):
        """åˆå§‹åŒ–é»˜è®¤å¨èƒæƒ…æŠ¥"""
        default_iocs = [
            ThreatIndicator(ioc_type="ip", value="185.220.101.42", threat_type=ThreatType.CnC_COMMUNICATION, confidence=0.95, source="MISP", tags={"mirai", "c2"}),
            ThreatIndicator(ioc_type="ip", value="192.168.100.100", threat_type=ThreatType.CnC_COMMUNICATION, confidence=0.90, source="AlienVault", tags={"suspicious"}),
            ThreatIndicator(ioc_type="domain", value="badc2.example.com", threat_type=ThreatType.CnC_COMMUNICATION, confidence=0.88, source="Commercial", tags={"botnet"}),
        ]
        for ioc in default_iocs:
            self.add_ioc(ioc)
    
    def add_ioc(self, ioc: ThreatIndicator):
        """æ·»åŠ å¨èƒæŒ‡æ ‡"""
        with self._lock:
            self._iocs[ioc.value] = ioc
            if ioc.ioc_type == "ip":
                self._ip_iocs.add(ioc.value)
            elif ioc.ioc_type == "domain":
                self._domain_iocs.add(ioc.value)
            elif ioc.ioc_type == "hash":
                self._hash_iocs.add(ioc.value)
    
    def check_event(self, event: SecurityEvent) -> Optional[DetectionResult]:
        """æ£€æŸ¥äº‹ä»¶æ˜¯å¦åŒ¹é…å¨èƒæƒ…æŠ¥"""
        with self._lock:
            if event.destination_ip and event.destination_ip in self._ip_iocs:
                ioc = self._iocs[event.destination_ip]
                return DetectionResult(
                    threat_type=ioc.threat_type,
                    threat_level=ThreatLevel.CRITICAL,
                    device_id=event.device_id,
                    confidence=ioc.confidence,
                    description=f"Communication with known malicious IP: {event.destination_ip}",
                    evidence={"ioc_type": "ip", "ioc_value": event.destination_ip, "tags": list(ioc.tags)},
                    recommended_action=ResponseAction.BLOCK
                )
            
            domain = event.metadata.get("domain")
            if domain and domain in self._domain_iocs:
                ioc = self._iocs[domain]
                return DetectionResult(
                    threat_type=ioc.threat_type,
                    threat_level=ThreatLevel.HIGH,
                    device_id=event.device_id,
                    confidence=ioc.confidence,
                    description=f"DNS query for malicious domain: {domain}",
                    evidence={"ioc_type": "domain", "ioc_value": domain},
                    recommended_action=ResponseAction.BLOCK
                )
        
        return None


# ============ è‡ªåŠ¨åŒ–å“åº”ç³»ç»Ÿ ============

class AutomatedResponseSystem:
    """è‡ªåŠ¨åŒ–å“åº”ç³»ç»Ÿ"""
    
    def __init__(self):
        self._tasks: Dict[str, ResponseTask] = {}
        self._device_status: Dict[str, str] = {}
        self._action_handlers: Dict[ResponseAction, Callable] = {}
        self._init_handlers()
    
    def _init_handlers(self):
        """åˆå§‹åŒ–å“åº”å¤„ç†å™¨"""
        self._action_handlers = {
            ResponseAction.ALERT: self._handle_alert,
            ResponseAction.RATE_LIMIT: self._handle_rate_limit,
            ResponseAction.ISOLATE: self._handle_isolate,
            ResponseAction.BLOCK: self._handle_block,
            ResponseAction.QUARANTINE: self._handle_quarantine
        }
    
    def execute_response(self, detection: DetectionResult) -> ResponseTask:
        """æ‰§è¡Œå“åº”"""
        task = ResponseTask(
            detection_id=detection.detection_id,
            action=detection.recommended_action,
            target_device=detection.device_id,
            parameters={"reason": detection.description, "confidence": detection.confidence}
        )
        
        handler = self._action_handlers.get(detection.recommended_action)
        if handler:
            task.status = "executing"
            try:
                result = handler(detection.device_id, task.parameters)
                task.result = result
                task.status = "completed"
            except Exception as e:
                task.result = f"Failed: {str(e)}"
                task.status = "failed"
        
        task.executed_at = datetime.now()
        self._tasks[task.task_id] = task
        
        return task
    
    def _handle_alert(self, device_id: str, params: Dict) -> str:
        """å¤„ç†å‘Šè­¦"""
        print(f"[ALERT] Device {device_id}: {params.get('reason')}")
        return f"Alert sent to security team"
    
    def _handle_rate_limit(self, device_id: str, params: Dict) -> str:
        """å¤„ç†é€Ÿç‡é™åˆ¶"""
        self._device_status[device_id] = "rate_limited"
        print(f"[RATE_LIMIT] Device {device_id} traffic rate limited to 10kbps")
        return f"Rate limit applied: 10kbps"
    
    def _handle_isolate(self, device_id: str, params: Dict) -> str:
        """å¤„ç†éš”ç¦»"""
        self._device_status[device_id] = "isolated"
        print(f"[ISOLATE] Device {device_id} moved to isolation VLAN")
        return f"Device isolated in VLAN 999"
    
    def _handle_block(self, device_id: str, params: Dict) -> str:
        """å¤„ç†é˜»æ–­"""
        self._device_status[device_id] = "blocked"
        print(f"[BLOCK] Device {device_id} network access blocked")
        return f"All traffic blocked"
    
    def _handle_quarantine(self, device_id: str, params: Dict) -> str:
        """å¤„ç†éš”ç¦»åŒº"""
        self._device_status[device_id] = "quarantined"
        print(f"[QUARANTINE] Device {device_id} moved to quarantine network")
        return f"Device quarantined, firmware analysis initiated"


# ============ ä¸»ç³»ç»Ÿç±» ============

class IoTThreatDetectionSystem:
    """IoTå¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿ - ä¸»ç±»"""
    
    def __init__(self):
        self.rule_engine = RealTimeRuleEngine()
        self.behavioral_detection = BehavioralAnomalyDetection()
        self.threat_intel = ThreatIntelligenceManager()
        self.response_system = AutomatedResponseSystem()
        
        self._detections: List[DetectionResult] = []
        self._events_processed: int = 0
        self._detection_count: int = 0
        self._lock = threading.RLock()
    
    def process_event(self, event: SecurityEvent) -> Optional[DetectionResult]:
        """å¤„ç†å®‰å…¨äº‹ä»¶"""
        with self._lock:
            self._events_processed += 1
        
        self.behavioral_detection.update_profile(event)
        
        detections = []
        
        rule_detection = self.rule_engine.process_event(event)
        if rule_detection:
            detections.append(rule_detection)
        
        anomaly_detection = self.behavioral_detection.detect_anomaly(event)
        if anomaly_detection:
            detections.append(anomaly_detection)
        
        intel_detection = self.threat_intel.check_event(event)
        if intel_detection:
            detections.append(intel_detection)
        
        if detections:
            priority = {ThreatLevel.CRITICAL: 4, ThreatLevel.HIGH: 3, ThreatLevel.MEDIUM: 2, ThreatLevel.LOW: 1}
            best_detection = max(detections, key=lambda d: priority.get(d.threat_level, 0))
            
            with self._lock:
                self._detections.append(best_detection)
                self._detection_count += 1
            
            response = self.response_system.execute_response(best_detection)
            print(f"[RESPONSE] {response.action.value} executed for {event.device_id}")
            
            return best_detection
        
        return None
    
    def get_statistics(self) -> Dict:
        """è·å–æ£€æµ‹ç»Ÿè®¡"""
        with self._lock:
            threat_type_counts = defaultdict(int)
            threat_level_counts = defaultdict(int)
            
            for d in self._detections:
                threat_type_counts[d.threat_type.value] += 1
                threat_level_counts[d.threat_level.value] += 1
            
            return {
                "events_processed": self._events_processed,
                "detections": self._detection_count,
                "detection_rate": self._detection_count / max(self._events_processed, 1),
                "threat_type_distribution": dict(threat_type_counts),
                "threat_level_distribution": dict(threat_level_counts),
                "active_profiles": len(self.behavioral_detection._profiles),
                "iocs_loaded": len(self.threat_intel._iocs)
            }


# ============ ä½¿ç”¨ç¤ºä¾‹ ============

if __name__ == "__main__":
    print("=" * 70)
    print("IoTå®‰å…¨å¨èƒæ£€æµ‹ä¸å“åº”ç³»ç»Ÿæ¼”ç¤º")
    print("=" * 70)
    
    system = IoTThreatDetectionSystem()
    
    print("\n[1] è®¾å¤‡è¡Œä¸ºå­¦ä¹ é˜¶æ®µï¼ˆæ¨¡æ‹Ÿ7å¤©æ­£å¸¸è¡Œä¸ºï¼‰")
    
    device_id = "CAM_001"
    
    for i in range(100):
        event = SecurityEvent(
            event_type=EventType.NETWORK_FLOW,
            device_id=device_id,
            source_ip="10.0.1.100",
            destination_ip="203.0.113.10",
            destination_port=443,
            protocol="TCP",
            bytes_transferred=5000 + (i % 1000)
        )
        system.process_event(event)
    
    print(f"  è®¾å¤‡ {device_id} è¡Œä¸ºç”»åƒå·²å»ºç«‹")
    
    print("\n[2] æš´åŠ›ç ´è§£æ”»å‡»æ£€æµ‹")
    
    for i in range(7):
        event = SecurityEvent(
            event_type=EventType.AUTHENTICATION,
            device_id=device_id,
            source_ip="192.168.1.50",
            metadata={"result": "failed", "attempt": i + 1}
        )
        detection = system.process_event(event)
        if detection:
            print(f"  æ”»å‡»æ£€æµ‹: {detection.description}")
            print(f"  å¨èƒçº§åˆ«: {detection.threat_level.value}")
            print(f"  å»ºè®®åŠ¨ä½œ: {detection.recommended_action.value}")
    
    print("\n[3] C&Cé€šä¿¡æ£€æµ‹ï¼ˆå¨èƒæƒ…æŠ¥åŒ¹é…ï¼‰")
    
    event = SecurityEvent(
        event_type=EventType.NETWORK_FLOW,
        device_id=device_id,
        source_ip="10.0.1.100",
        destination_ip="185.220.101.42",
        destination_port=4444,
        protocol="TCP",
        bytes_transferred=1024
    )
    detection = system.process_event(event)
    if detection:
        print(f"  å¨èƒæ£€æµ‹: {detection.description}")
        print(f"  ç½®ä¿¡åº¦: {detection.confidence:.0%}")
        print(f"  å“åº”åŠ¨ä½œ: {detection.recommended_action.value}")
    
    print("\n[4] å¼‚å¸¸è¡Œä¸ºæ£€æµ‹")
    
    event = SecurityEvent(
        event_type=EventType.NETWORK_FLOW,
        device_id=device_id,
        source_ip="10.0.1.100",
        destination_ip="198.51.100.50",
        destination_port=12345,
        protocol="TCP",
        bytes_transferred=100000
    )
    detection = system.process_event(event)
    if detection:
        print(f"  å¼‚å¸¸æ£€æµ‹: {detection.description}")
        print(f"  è¯æ®: {detection.evidence}")
    
    print("\n[5] æ£€æµ‹ç³»ç»Ÿç»Ÿè®¡")
    stats = system.get_statistics()
    print(f"  å¤„ç†äº‹ä»¶æ€»æ•°: {stats['events_processed']}")
    print(f"  å¨èƒæ£€æµ‹æ•°: {stats['detections']}")
    print(f"  æ£€æµ‹ç‡: {stats['detection_rate']:.2%}")
    print(f"  å¨èƒçº§åˆ«åˆ†å¸ƒ: {stats['threat_level_distribution']}")
    
    print("\n[6] è®¾å¤‡å®‰å…¨çŠ¶æ€")
    for device, status in system.response_system._device_status.items():
        print(f"  è®¾å¤‡ {device}: {status}")
    
    print("\n" + "=" * 70)
    print("æ¼”ç¤ºå®Œæˆ")
    print("=" * 70)
```

### 5.5 æ•ˆæœè¯„ä¼°

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | æ”¹è¿›å‰ | æ”¹è¿›å | æå‡ |
|------|--------|--------|------|
| å¨èƒæ£€æµ‹å»¶è¿Ÿ | 45åˆ†é’Ÿ | 85ms | -99.97% |
| è‡ªåŠ¨å“åº”æ—¶é—´ | äººå·¥/45åˆ†é’Ÿ | 4.2ç§’ | -99.8% |
| æ£€æµ‹å‡†ç¡®ç‡ | 65% | 97.3% | +49.7% |
| è¯¯æŠ¥ç‡ | 35% | 4.8% | -86.3% |
| åƒµå°¸ç½‘ç»œæ£€å‡º | 23% | 94% | +308% |
| DDoSæ”»å‡»ç¼“è§£æ—¶é—´ | 2å°æ—¶ | 30ç§’ | -99.6% |
| æ—¥å¤„ç†äº‹ä»¶é‡ | 1äº¿ | 150äº¿ | +14900% |
| ç³»ç»Ÿå¯ç”¨æ€§ | 99.5% | 99.99% | +0.49% |

**ä¸šåŠ¡ä»·å€¼**ï¼š

1. **æ”»å‡»æŸå¤±é™ä½**ï¼šDDoSæ”»å‡»å¹³å‡æ¢å¤æ—¶é—´ä»4å°æ—¶é™è‡³5åˆ†é’Ÿï¼Œå¹´åº¦é¿å…ä¸šåŠ¡æŸå¤±estimated Â¥8000ä¸‡
2. **è¿è¥æ•ˆç‡**ï¼šè‡ªåŠ¨åŒ–å“åº”å‡å°‘å®‰å…¨è¿è¥å›¢é˜Ÿå·¥ä½œé‡70%ï¼Œç­‰æ•ˆèŠ‚çº¦äººåŠ›æˆæœ¬Â¥600ä¸‡/å¹´
3. **å®¢æˆ·ä¿¡ä»»**ï¼šå®‰å…¨SLAè¾¾æˆç‡ä»92%æå‡è‡³99.97%ï¼Œå¤§å®¢æˆ·ç»­çº¦ç‡æå‡18%
4. **ä¿é™©é™è´¹**ï¼šç½‘ç»œå®‰å…¨ä¿é™©ä¿è´¹ä¸‹é™40%ï¼Œå¹´èŠ‚çº¦Â¥120ä¸‡
5. **åˆè§„æ”¶ç›Š**ï¼šé€šè¿‡SOC2 Type IIè®¤è¯ï¼Œè·å¾—æµ·å¤–å®¢æˆ·å‡†å…¥èµ„æ ¼ï¼Œæ–°å¢å¹´æ”¶å…¥Â¥3500ä¸‡

**ç»éªŒæ•™è®­**ï¼š

1. **åˆ†å±‚æ£€æµ‹æ¶æ„**ï¼šè§„åˆ™å¼•æ“+è¡Œä¸ºML+å¨èƒæƒ…æŠ¥ä¸‰å±‚æ¶æ„æœ‰æ•ˆé™ä½è¯¯æŠ¥ï¼Œå•ä¸€æ–¹æ³•è¯¯æŠ¥ç‡éƒ½è¶…è¿‡20%
2. **è¾¹ç¼˜è®¡ç®—ä¼˜å…ˆ**ï¼š70%æ£€æµ‹åœ¨è¾¹ç¼˜ç½‘å…³å®Œæˆï¼Œåªæœ‰å¯ç–‘äº‹ä»¶ä¸Šäº‘ï¼Œå¸¦å®½æˆæœ¬é™ä½60%
3. **äººæœºååŒ**ï¼šé«˜ç½®ä¿¡åº¦å¨èƒè‡ªåŠ¨å“åº”ï¼Œä¸­ç­‰ç½®ä¿¡åº¦äººå·¥ç¡®è®¤ï¼Œé¿å…è¯¯æ€å½±å“ä¸šåŠ¡
4. **æ¨¡å‹æŒç»­å­¦ä¹ **ï¼šæ¯æœˆä½¿ç”¨æ–°æ•°æ®é‡è®­ç»ƒè¡Œä¸ºæ¨¡å‹ï¼Œæ£€æµ‹å‡†ç¡®ç‡æŒç»­æå‡
5. **å¨èƒæƒ…æŠ¥å…±äº«**ï¼šåŠ å…¥è¡Œä¸šå¨èƒæƒ…æŠ¥è”ç›Ÿï¼ŒIOCæ›´æ–°é€Ÿåº¦ä»24å°æ—¶é™è‡³15åˆ†é’Ÿ

---

## 6. æ¡ˆä¾‹æ€»ç»“

### 6.1 æˆåŠŸå› ç´ 

**å…³é”®æˆåŠŸå› ç´ **ï¼š

1. **æ ‡å‡†åŒ–Schemaå…ˆè¡Œ**ï¼šæ‰€æœ‰æ¡ˆä¾‹å‡é‡‡ç”¨å…ˆå®šä¹‰å®‰å…¨Schemaå†å®æ–½çš„ç­–ç•¥ï¼Œç¡®ä¿è®¾è®¡ä¸€è‡´æ€§
2. **çºµæ·±é˜²å¾¡æ¶æ„**ï¼šæ¯ä¸ªæ¡ˆä¾‹éƒ½å®æ–½äº†å¤šå±‚å®‰å…¨é˜²æŠ¤ï¼ˆèº«ä»½ã€ç½‘ç»œã€æ•°æ®ã€åº”ç”¨ï¼‰
3. **é›¶ä¿¡ä»»åŸåˆ™**ï¼šé»˜è®¤ä¸ä¿¡ä»»ä»»ä½•è®¾å¤‡æˆ–ç”¨æˆ·ï¼ŒæŒç»­éªŒè¯èº«ä»½å’Œæƒé™
4. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**ï¼šå…³é”®å®‰å…¨å†³ç­–è‡ªåŠ¨åŒ–ï¼Œå‡å°‘äººä¸ºå»¶è¿Ÿå’Œé”™è¯¯
5. **å¯è§‚æµ‹æ€§**ï¼šå®Œæ•´çš„å®¡è®¡æ—¥å¿—å’Œç›‘æ§ä½“ç³»ï¼Œæ”¯æŒäº‹åè¿½æº¯å’ŒæŒç»­ä¼˜åŒ–
6. **åˆè§„é©±åŠ¨è®¾è®¡**ï¼šå®‰å…¨è®¾è®¡åŒæ—¶æ»¡è¶³å¤šé¡¹æ³•è§„è¦æ±‚ï¼Œé¿å…é‡å¤å»ºè®¾

### 6.2 æœ€ä½³å®è·µ

**å®è·µå»ºè®®**ï¼š

1. **å®‰å…¨å·¦ç§»**ï¼šåœ¨è®¾å¤‡è®¾è®¡é˜¶æ®µå°±åµŒå…¥å®‰å…¨èƒ½åŠ›ï¼Œè€ŒéåæœŸè¡¥ä¸
2. **æœ€å°æƒé™åŸåˆ™**ï¼šæ¯ä¸ªè®¾å¤‡ã€æ¯ä¸ªç”¨æˆ·åªæ‹¥æœ‰å®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™
3. **åŠ å¯†ä¸€åˆ‡**ï¼šä¼ è¾“ä¸­ã€å­˜å‚¨ä¸­ã€ä½¿ç”¨ä¸­çš„æ•°æ®éƒ½åº”åŠ å¯†ä¿æŠ¤
4. **æŒç»­ç›‘æ§**ï¼š7x24å°æ—¶å®‰å…¨è¿è¥ä¸­å¿ƒæ˜¯åŠæ—¶å‘ç°å’Œå“åº”å¨èƒçš„å…³é”®
5. **çº¢é˜Ÿæ¼”ç»ƒ**ï¼šæ¯å­£åº¦è¿›è¡Œæ¸—é€æµ‹è¯•å’Œæ”»å‡»æ¼”ç»ƒï¼ŒéªŒè¯é˜²å¾¡æœ‰æ•ˆæ€§
6. **ä¾›åº”é“¾å®‰å…¨**ï¼šè¦æ±‚è®¾å¤‡å‚å•†æä¾›å®‰å…¨SDKå’Œæ¼æ´å“åº”æ‰¿è¯º
7. **ç¾éš¾æ¢å¤**ï¼šå®šæœŸæ¼”ç»ƒå¯†é’¥æ³„éœ²ã€CAè¢«æ”»ç ´ç­‰æç«¯åœºæ™¯çš„æ¢å¤æµç¨‹

---

## 7. å‚è€ƒæ–‡çŒ®

### 7.1 æ ‡å‡†æ–‡æ¡£

- GB/T 37033-2018 ä¿¡æ¯å®‰å…¨æŠ€æœ¯ ç‰©è”ç½‘å®‰å…¨å‚è€ƒæ¨¡å‹åŠé€šç”¨è¦æ±‚
- ISO/IEC 27001:2022 Information security management systems
- IEC 62443 Industrial automation and control systems security
- NIST Cybersecurity Framework v1.1
- HIPAA Security Rule (45 CFR Part 160 and Subparts A and C of Part 164)
- GDPR (EU) 2016/679 General Data Protection Regulation
- ä¸­åäººæ°‘å…±å’Œå›½ä¸ªäººä¿¡æ¯ä¿æŠ¤æ³•
- ç½‘ç»œå®‰å…¨ç­‰çº§ä¿æŠ¤2.0æ ‡å‡†ï¼ˆç­‰ä¿2.0ï¼‰

### 7.2 æŠ€æœ¯æ–‡æ¡£

- OWASP Internet of Things Project - Top 10 IoT Vulnerabilities
- CSA IoT Security Controls Framework
- IoT Security Foundation Best Practice Guidelines
- MITRE ATT&CK for ICS/IoT
- IIC Industrial Internet Security Framework
- ENISA Baseline Security Recommendations for IoT

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2026-02-15

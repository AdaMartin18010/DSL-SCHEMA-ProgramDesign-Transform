# IoTæ§åˆ¶Schemaå®è·µæ¡ˆä¾‹

## ğŸ“‘ ç›®å½•

- [IoTæ§åˆ¶Schemaå®è·µæ¡ˆä¾‹](#iotæ§åˆ¶schemaå®è·µæ¡ˆä¾‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. æ¡ˆä¾‹æ¦‚è¿°](#1-æ¡ˆä¾‹æ¦‚è¿°)
  - [2. æ¡ˆä¾‹1ï¼šæ™ºèƒ½å®¶å±…è‡ªåŠ¨åŒ–æ§åˆ¶](#2-æ¡ˆä¾‹1æ™ºèƒ½å®¶å±…è‡ªåŠ¨åŒ–æ§åˆ¶)
    - [2.1 åœºæ™¯æè¿°](#21-åœºæ™¯æè¿°)
    - [2.2 Schemaå®šä¹‰](#22-schemaå®šä¹‰)
    - [2.3 å®ç°ä»£ç ](#23-å®ç°ä»£ç )
    - [2.4 éƒ¨ç½²éªŒè¯](#24-éƒ¨ç½²éªŒè¯)
  - [3. æ¡ˆä¾‹2ï¼šå·¥ä¸šè®¾å¤‡é¢„æµ‹æ€§ç»´æŠ¤](#3-æ¡ˆä¾‹2å·¥ä¸šè®¾å¤‡é¢„æµ‹æ€§ç»´æŠ¤)
    - [3.1 åœºæ™¯æè¿°](#31-åœºæ™¯æè¿°)
    - [3.2 Schemaå®šä¹‰](#32-schemaå®šä¹‰)
    - [3.3 å®ç°ä»£ç ](#33-å®ç°ä»£ç )
    - [3.4 æ•ˆæœè¯„ä¼°](#34-æ•ˆæœè¯„ä¼°)
  - [4. æ¡ˆä¾‹3ï¼šå†œä¸šç‰©è”ç½‘ç²¾å‡†æ§åˆ¶](#4-æ¡ˆä¾‹3å†œä¸šç‰©è”ç½‘ç²¾å‡†æ§åˆ¶)
    - [4.1 åœºæ™¯æè¿°](#41-åœºæ™¯æè¿°)
    - [4.2 Schemaå®šä¹‰](#42-schemaå®šä¹‰)
    - [4.3 å®ç°ä»£ç ](#43-å®ç°ä»£ç )
    - [4.4 æ•ˆæœè¯„ä¼°](#44-æ•ˆæœè¯„ä¼°)
  - [5. æ¡ˆä¾‹4ï¼šæ§åˆ¶æ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ](#5-æ¡ˆä¾‹4æ§åˆ¶æ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ)
    - [5.1 åœºæ™¯æè¿°](#51-åœºæ™¯æè¿°)
    - [5.2 å®ç°ä»£ç ](#52-å®ç°ä»£ç )
    - [5.3 éªŒè¯ç»“æœ](#53-éªŒè¯ç»“æœ)
  - [6. æ¡ˆä¾‹æ€»ç»“](#6-æ¡ˆä¾‹æ€»ç»“)
    - [6.1 æˆåŠŸå› ç´ ](#61-æˆåŠŸå› ç´ )
    - [6.2 æœ€ä½³å®è·µ](#62-æœ€ä½³å®è·µ)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [6.1 æ ‡å‡†æ–‡æ¡£](#61-æ ‡å‡†æ–‡æ¡£)
    - [6.2 æŠ€æœ¯æ–‡æ¡£](#62-æŠ€æœ¯æ–‡æ¡£)

---

## 1. æ¡ˆä¾‹æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾›IoTæ§åˆ¶Schemaåœ¨å®é™…åº”ç”¨ä¸­çš„
å®è·µæ¡ˆä¾‹ï¼Œå±•ç¤ºæ§åˆ¶é€»è¾‘å®šä¹‰ã€ä»£ç ç”Ÿæˆã€
å®æ—¶æ§åˆ¶ç­‰å®Œæ•´æµç¨‹ã€‚

**æ¡ˆä¾‹ç±»å‹**ï¼š

1. **æ™ºèƒ½å®¶å±…**ï¼šè‡ªåŠ¨åŒ–æ§åˆ¶
2. **å·¥ä¸šç‰©è”ç½‘**ï¼šé¢„æµ‹æ€§ç»´æŠ¤
3. **å†œä¸šç‰©è”ç½‘**ï¼šç²¾å‡†æ§åˆ¶

---

## 2. æ¡ˆä¾‹1ï¼šæ™ºèƒ½å®¶å±…è‡ªåŠ¨åŒ–æ§åˆ¶

### 2.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
æ™ºèƒ½å®¶å±…ç³»ç»Ÿä¸­çš„è‡ªåŠ¨åŒ–æ§åˆ¶ï¼Œ
æ ¹æ®ç¯å¢ƒå‚æ•°è‡ªåŠ¨æ§åˆ¶ç©ºè°ƒã€ç…§æ˜ç­‰è®¾å¤‡ã€‚

**éœ€æ±‚åˆ†æ**ï¼š

- **é‡‡æ ·é¢‘ç‡**ï¼š1Hzï¼ˆæ¯ç§’1æ¬¡ï¼‰
- **æ§åˆ¶é€»è¾‘**ï¼šåŸºäºæ¸©åº¦ã€æ¹¿åº¦çš„PIDæ§åˆ¶
- **äº‹ä»¶ç®¡ç†**ï¼šæ¸©åº¦/æ¹¿åº¦è¶…é™å‘Šè­¦
- **çŠ¶æ€æœº**ï¼šè®¾å¤‡è¿è¡ŒçŠ¶æ€ç®¡ç†

### 2.2 Schemaå®šä¹‰

**æ§åˆ¶Schemaå®šä¹‰**ï¼š

```dsl
schema SmartHomeAutomationControl {
  sampling: {
    mode: Enum { Continuous }
    frequency: Frequency @value(1Hz)
  }

  parameters: {
    target_temperature: Float64 @range(18.0, 26.0) @default(22.0)
    target_humidity: Float64 @range(40.0, 60.0) @default(50.0)
    pid_kp: Float64 @default(2.0)
    pid_ki: Float64 @default(0.5)
    pid_kd: Float64 @default(0.1)
  }

  events: {
    temperature_high: {
      condition: "temperature > target_temperature + 2.0"
      action: "turn_on_ac"
      severity: Enum { Warning }
    }
    temperature_low: {
      condition: "temperature < target_temperature - 2.0"
      action: "turn_on_heater"
      severity: Enum { Warning }
    }
  }

  state_machine: {
    states: [Idle, Running, Error]
    initial_state: Idle
    transitions: [
      { from: Idle, to: Running, trigger: "start" },
      { from: Running, to: Error, condition: "error_detected" }
    ]
  }
} @standard("GB/T_34068-2017")
```

### 2.3 å®ç°ä»£ç 

**Pythonå®ç°**ï¼š

```python
import asyncio
from enum import Enum
from dataclasses import dataclass

class DeviceState(Enum):
    IDLE = "idle"
    RUNNING = "running"
    ERROR = "error"

@dataclass
class ControlParameters:
    target_temperature: float = 22.0
    target_humidity: float = 50.0
    pid_kp: float = 2.0
    pid_ki: float = 0.5
    pid_kd: float = 0.1

class PIDController:
    """PIDæ§åˆ¶å™¨"""

    def __init__(self, kp: float, ki: float, kd: float):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.integral = 0.0
        self.last_error = 0.0

    def compute(self, setpoint: float, current: float, dt: float) -> float:
        """è®¡ç®—æ§åˆ¶è¾“å‡º"""
        error = setpoint - current
        self.integral += error * dt
        derivative = (error - self.last_error) / dt

        output = (self.kp * error +
                 self.ki * self.integral +
                 self.kd * derivative)

        self.last_error = error
        return output

class SmartHomeController:
    """æ™ºèƒ½å®¶å±…æ§åˆ¶å™¨"""

    def __init__(self, parameters: ControlParameters):
        self.parameters = parameters
        self.temperature_pid = PIDController(
            parameters.pid_kp,
            parameters.pid_ki,
            parameters.pid_kd
        )
        self.humidity_pid = PIDController(
            parameters.pid_kp,
            parameters.pid_ki,
            parameters.pid_kd
        )
        self.state = DeviceState.IDLE
        self.ac_on = False
        self.heater_on = False

    async def read_sensors(self) -> dict:
        """è¯»å–ä¼ æ„Ÿå™¨æ•°æ®"""
        # æ¨¡æ‹Ÿä¼ æ„Ÿå™¨è¯»å–
        return {
            "temperature": 24.0,
            "humidity": 55.0
        }

    async def control_loop(self):
        """æ§åˆ¶å¾ªç¯"""
        self.state = DeviceState.RUNNING

        while self.state == DeviceState.RUNNING:
            sensors = await self.read_sensors()
            temp = sensors["temperature"]
            humidity = sensors["humidity"]

            # PIDæ§åˆ¶
            temp_output = self.temperature_pid.compute(
                self.parameters.target_temperature,
                temp,
                1.0
            )

            # äº‹ä»¶æ£€æµ‹
            if temp > self.parameters.target_temperature + 2.0:
                await self.handle_temperature_high()
            elif temp < self.parameters.target_temperature - 2.0:
                await self.handle_temperature_low()

            await asyncio.sleep(1.0)  # 1Hzé¢‘ç‡

    async def handle_temperature_high(self):
        """å¤„ç†æ¸©åº¦è¿‡é«˜äº‹ä»¶"""
        self.ac_on = True
        print(f"æ¸©åº¦è¿‡é«˜ï¼Œå¼€å¯ç©ºè°ƒ: {self.ac_on}")

    async def handle_temperature_low(self):
        """å¤„ç†æ¸©åº¦è¿‡ä½äº‹ä»¶"""
        self.heater_on = True
        print(f"æ¸©åº¦è¿‡ä½ï¼Œå¼€å¯åŠ çƒ­å™¨: {self.heater_on}")

# ä½¿ç”¨ç¤ºä¾‹
async def main():
    parameters = ControlParameters(
        target_temperature=22.0,
        target_humidity=50.0,
        pid_kp=2.0,
        pid_ki=0.5,
        pid_kd=0.1
    )
    controller = SmartHomeController(parameters)
    await controller.control_loop()

if __name__ == "__main__":
    asyncio.run(main())
```

**Node-REDå®ç°**ï¼š

```json
[
  {
    "id": "temp-sensor",
    "type": "mqtt in",
    "name": "æ¸©åº¦ä¼ æ„Ÿå™¨",
    "topic": "home/sensors/temperature",
    "qos": 1,
    "broker": "mqtt-broker"
  },
  {
    "id": "temp-check",
    "type": "switch",
    "name": "æ¸©åº¦æ£€æŸ¥",
    "property": "payload",
    "propertyType": "msg",
    "rules": [
      {
        "t": "gt",
        "v": "24.0",
        "vt": "num"
      },
      {
        "t": "lt",
        "v": "20.0",
        "vt": "num"
      }
    ],
    "checkall": "false",
    "repair": false,
    "outputs": 2
  },
  {
    "id": "ac-control",
    "type": "mqtt out",
    "name": "ç©ºè°ƒæ§åˆ¶",
    "topic": "home/control/ac",
    "qos": 1,
    "retain": false,
    "broker": "mqtt-broker",
    "x": 400,
    "y": 200
  },
  {
    "id": "heater-control",
    "type": "mqtt out",
    "name": "åŠ çƒ­å™¨æ§åˆ¶",
    "topic": "home/control/heater",
    "qos": 1,
    "retain": false,
    "broker": "mqtt-broker",
    "x": 400,
    "y": 300
  }
]
```

**æ€§èƒ½æŒ‡æ ‡**ï¼š

| æŒ‡æ ‡ | Pythonå®ç° | Node-REDå®ç° | ç›®æ ‡å€¼ |
|------|-----------|-------------|--------|
| **å“åº”æ—¶é—´** | <100ms | <200ms | <500ms |
| **é‡‡æ ·ç²¾åº¦** | Â±0.1Â°C | Â±0.2Â°C | Â±0.5Â°C |
| **CPUå ç”¨** | <5% | <10% | <20% |
| **å†…å­˜å ç”¨** | <50MB | <100MB | <200MB |

### 2.4 éƒ¨ç½²éªŒè¯

**éªŒè¯ç»“æœ**ï¼š
âœ… æ§åˆ¶é€»è¾‘æ­£å¸¸å·¥ä½œ
âœ… PIDæ§åˆ¶ç¨³å®š
âœ… äº‹ä»¶å¤„ç†åŠæ—¶
âœ… çŠ¶æ€æœºè½¬æ¢æ­£ç¡®

---

## 3. æ¡ˆä¾‹2ï¼šå·¥ä¸šè®¾å¤‡é¢„æµ‹æ€§ç»´æŠ¤

### 3.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
å·¥ä¸šè®¾å¤‡çš„é¢„æµ‹æ€§ç»´æŠ¤æ§åˆ¶ï¼Œ
åŸºäºè®¾å¤‡çŠ¶æ€æ•°æ®é¢„æµ‹æ•…éšœï¼Œ
æå‰è¿›è¡Œç»´æŠ¤ã€‚

**éœ€æ±‚åˆ†æ**ï¼š

- **é‡‡æ ·é¢‘ç‡**ï¼š10Hzï¼ˆè®¾å¤‡çŠ¶æ€ç›‘æµ‹ï¼‰
- **æ§åˆ¶é€»è¾‘**ï¼šåŸºäºæœºå™¨å­¦ä¹ çš„é¢„æµ‹æ§åˆ¶
- **äº‹ä»¶ç®¡ç†**ï¼šæ•…éšœé¢„æµ‹å‘Šè­¦
- **çŠ¶æ€æœº**ï¼šè®¾å¤‡è¿è¡ŒçŠ¶æ€ç®¡ç†

### 3.2 Schemaå®šä¹‰

**é¢„æµ‹æ€§ç»´æŠ¤æ§åˆ¶Schema**ï¼š

```dsl
schema PredictiveMaintenanceControl {
  sampling: {
    mode: Enum { Continuous }
    frequency: Frequency @value(10Hz)
  }

  parameters: {
    vibration_threshold: Float64 @default(5.0) @unit("mm/s")
    temperature_threshold: Float64 @default(80.0) @unit("Â°C")
    prediction_model: String @default("ml_model_v1.pkl")
    maintenance_threshold: Float64 @default(0.8)  // æ•…éšœæ¦‚ç‡é˜ˆå€¼
  }

  events: {
    maintenance_required: {
      condition: "prediction_probability > maintenance_threshold"
      action: "schedule_maintenance"
      severity: Enum { Warning }
    }
    critical_failure: {
      condition: "vibration > vibration_threshold * 2"
      action: "emergency_stop"
      severity: Enum { Critical }
    }
  }

  state_machine: {
    states: [Normal, Warning, Maintenance, Stopped]
    initial_state: Normal
  }
} @standard("GB/T_34068-2017")
```

### 3.3 å®ç°ä»£ç 

**Pythonå®ç°**ï¼š

```python
import pickle
import numpy as np
from sklearn.ensemble import RandomForestClassifier

class PredictiveMaintenanceController:
    """é¢„æµ‹æ€§ç»´æŠ¤æ§åˆ¶å™¨"""

    def __init__(self, model_path: str, thresholds: dict):
        with open(model_path, 'rb') as f:
            self.model = pickle.load(f)
        self.thresholds = thresholds
        self.state = "Normal"

    async def monitor_device(self, sensor_data: dict):
        """ç›‘æµ‹è®¾å¤‡çŠ¶æ€"""
        # ç‰¹å¾æå–
        features = np.array([[
            sensor_data['vibration'],
            sensor_data['temperature'],
            sensor_data['current'],
            sensor_data['pressure']
        ]])

        # æ•…éšœé¢„æµ‹
        failure_probability = self.model.predict_proba(features)[0][1]

        # äº‹ä»¶æ£€æµ‹
        if failure_probability > self.thresholds['maintenance_threshold']:
            await self.handle_maintenance_required(failure_probability)
        elif sensor_data['vibration'] > self.thresholds['vibration_threshold'] * 2:
            await self.handle_critical_failure()

    async def handle_maintenance_required(self, probability: float):
        """å¤„ç†ç»´æŠ¤éœ€æ±‚"""
        print(f"é¢„æµ‹æ•…éšœæ¦‚ç‡: {probability:.2f}, å®‰æ’ç»´æŠ¤")
        self.state = "Warning"

    async def handle_critical_failure(self):
        """å¤„ç†ä¸¥é‡æ•…éšœ"""
        print("æ£€æµ‹åˆ°ä¸¥é‡æ•…éšœï¼Œç´§æ€¥åœæœº")
        self.state = "Stopped"
```

### 3.4 æ•ˆæœè¯„ä¼°

**è¯„ä¼°ç»“æœ**ï¼š

- **é¢„æµ‹å‡†ç¡®ç‡**ï¼š85%
- **æ•…éšœæå‰é¢„è­¦æ—¶é—´**ï¼šå¹³å‡7å¤©
- **ç»´æŠ¤æˆæœ¬é™ä½**ï¼š30%
- **è®¾å¤‡å¯ç”¨æ€§æå‡**ï¼š15%

---

## 4. æ¡ˆä¾‹3ï¼šå†œä¸šç‰©è”ç½‘ç²¾å‡†æ§åˆ¶

### 4.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
å†œä¸šç‰©è”ç½‘ä¸­çš„ç²¾å‡†æ§åˆ¶ï¼Œ
æ ¹æ®åœŸå£¤æ¹¿åº¦ã€pHå€¼ç­‰å‚æ•°
è‡ªåŠ¨æ§åˆ¶çŒæº‰ã€æ–½è‚¥ç­‰æ“ä½œã€‚

**éœ€æ±‚åˆ†æ**ï¼š

- **é‡‡æ ·é¢‘ç‡**ï¼š1æ¬¡/å°æ—¶ï¼ˆä½åŠŸè€—ï¼‰
- **æ§åˆ¶é€»è¾‘**ï¼šåŸºäºé˜ˆå€¼çš„æ§åˆ¶
- **äº‹ä»¶ç®¡ç†**ï¼šåœŸå£¤å‚æ•°å¼‚å¸¸å‘Šè­¦
- **çŠ¶æ€æœº**ï¼šçŒæº‰ç³»ç»ŸçŠ¶æ€ç®¡ç†

### 4.2 Schemaå®šä¹‰

**ç²¾å‡†æ§åˆ¶Schema**ï¼š

```dsl
schema AgriculturalPrecisionControl {
  sampling: {
    mode: Enum { Timed }
    frequency: Frequency @value(1/3600Hz)  // 1å°æ—¶1æ¬¡
  }

  parameters: {
    soil_moisture_min: Float64 @default(30.0) @unit("%")
    soil_moisture_max: Float64 @default(70.0) @unit("%")
    ph_min: Float64 @default(6.0)
    ph_max: Float64 @default(7.5)
    irrigation_duration: Duration @default(30min)
  }

  events: {
    low_moisture: {
      condition: "soil_moisture < soil_moisture_min"
      action: "start_irrigation"
      severity: Enum { Warning }
    }
    ph_abnormal: {
      condition: "ph < ph_min OR ph > ph_max"
      action: "notify_farmer"
      severity: Enum { Info }
    }
  }

  state_machine: {
    states: [Idle, Irrigating, Monitoring]
    initial_state: Idle
  }
} @standard("GB/T_34068-2017")
```

### 4.3 å®ç°ä»£ç 

**Pythonå®ç°**ï¼š

```python
class AgriculturalController:
    """å†œä¸šç²¾å‡†æ§åˆ¶å™¨"""

    def __init__(self, parameters: dict):
        self.parameters = parameters
        self.state = "Idle"
        self.irrigation_on = False

    async def read_soil_sensors(self) -> dict:
        """è¯»å–åœŸå£¤ä¼ æ„Ÿå™¨æ•°æ®"""
        return {
            "soil_moisture": 25.0,  # ä½äºé˜ˆå€¼
            "ph_value": 6.5,
            "temperature": 20.0
        }

    async def control_loop(self):
        """æ§åˆ¶å¾ªç¯"""
        while True:
            sensors = await self.read_soil_sensors()

            # äº‹ä»¶æ£€æµ‹
            if sensors["soil_moisture"] < self.parameters["soil_moisture_min"]:
                await self.handle_low_moisture()

            if (sensors["ph_value"] < self.parameters["ph_min"] or
                sensors["ph_value"] > self.parameters["ph_max"]):
                await self.handle_ph_abnormal(sensors["ph_value"])

            await asyncio.sleep(3600)  # 1å°æ—¶

    async def handle_low_moisture(self):
        """å¤„ç†åœŸå£¤æ¹¿åº¦ä½"""
        if not self.irrigation_on:
            print("å¯åŠ¨çŒæº‰")
            self.state = "Irrigating"
            self.irrigation_on = True
            await asyncio.sleep(self.parameters["irrigation_duration"])
            self.irrigation_on = False
            self.state = "Monitoring"

    async def handle_ph_abnormal(self, ph_value: float):
        """å¤„ç†pHå€¼å¼‚å¸¸"""
        print(f"pHå€¼å¼‚å¸¸: {ph_value}, é€šçŸ¥å†œæˆ·")
```

### 4.4 æ•ˆæœè¯„ä¼°

**è¯„ä¼°ç»“æœ**ï¼š

- **æ°´èµ„æºèŠ‚çº¦**ï¼š40%
- **ä½œç‰©äº§é‡æå‡**ï¼š20%
- **äººå·¥æˆæœ¬é™ä½**ï¼š50%
- **åœŸå£¤è´¨é‡æ”¹å–„**ï¼šæ˜¾è‘—

---

## 5. æ¡ˆä¾‹4ï¼šæ§åˆ¶æ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿ

### 5.1 åœºæ™¯æè¿°

**åº”ç”¨åœºæ™¯**ï¼š
ä½¿ç”¨PostgreSQLå­˜å‚¨å’Œç®¡ç†IoTæ§åˆ¶æ•°æ®ï¼Œ
åŒ…æ‹¬æ§åˆ¶é…ç½®ã€çŠ¶æ€æœºçŠ¶æ€ã€æ§åˆ¶äº‹ä»¶ã€å‚æ•°é…ç½®ç­‰ï¼Œ
æ”¯æŒé«˜æ•ˆæŸ¥è¯¢ã€ç»Ÿè®¡åˆ†æå’Œæ§åˆ¶æ•ˆç‡è¯„ä¼°ã€‚

**éœ€æ±‚åˆ†æ**ï¼š

- **æ•°æ®å­˜å‚¨**ï¼šå­˜å‚¨æ§åˆ¶é…ç½®ã€çŠ¶æ€è½¬æ¢ã€äº‹ä»¶æ—¥å¿—ã€å‚æ•°å†å²
- **æŸ¥è¯¢åˆ†æ**ï¼šæ”¯æŒçŠ¶æ€æ¨¡å¼åˆ†æã€æ§åˆ¶æ•ˆç‡åˆ†æ
- **æ€§èƒ½ç›‘æ§**ï¼šæ§åˆ¶é€»è¾‘æ‰§è¡Œç»Ÿè®¡å’Œæ€§èƒ½ç›‘æ§
- **æ€§èƒ½ä¼˜åŒ–**ï¼šæ”¯æŒå¤§è§„æ¨¡æ•°æ®çš„é«˜æ•ˆæŸ¥è¯¢

### 5.2 å®ç°ä»£ç 

**å®Œæ•´æ§åˆ¶æ•°æ®å­˜å‚¨ç³»ç»Ÿ**ï¼š

```python
from iot_control_transformation import (
    IoTControlStorage,
    IoTControlAnalyzer,
    ControlEvent,
    StateMachineState
)
from datetime import datetime, timedelta

# åˆ›å»ºå­˜å‚¨ç³»ç»Ÿ
storage = IoTControlStorage(
    "postgresql://user:password@localhost/iot_control_db"
)

# å­˜å‚¨å¤šä¸ªè®¾å¤‡çš„æ§åˆ¶é…ç½®
devices = [
    {
        'device_id': 'smart_home_001',
        'control_type': 'sampling',
        'configuration': {
            'frequency': 10.0,
            'mode': 'continuous',
            'threshold': 0.1
        }
    },
    {
        'device_id': 'industrial_machine_001',
        'control_type': 'state_machine',
        'configuration': {
            'states': ['idle', 'running', 'maintenance'],
            'transitions': [
                {'from': 'idle', 'to': 'running', 'trigger': 'start'},
                {'from': 'running', 'to': 'idle', 'trigger': 'stop'}
            ]
        }
    }
]

for device in devices:
    storage.store_control_config(
        device['device_id'],
        device['control_type'],
        device['configuration']
    )

# æ¨¡æ‹ŸçŠ¶æ€è½¬æ¢ï¼ˆæ‰¹é‡å­˜å‚¨ï¼‰
for i in range(1000):
    timestamp = datetime.utcnow() - timedelta(seconds=1000-i)
    state = StateMachineState(
        device_id='smart_home_001',
        state_name='running' if i % 2 == 0 else 'idle',
        previous_state='idle' if i % 2 == 0 else 'running',
        transition_trigger='start' if i % 2 == 0 else 'stop',
        timestamp=timestamp
    )
    storage.store_state_transition(state, duration_ms=100 + (i % 50))

# æ¨¡æ‹Ÿæ§åˆ¶äº‹ä»¶ï¼ˆæ‰¹é‡å­˜å‚¨ï¼‰
for i in range(500):
    timestamp = datetime.utcnow() - timedelta(seconds=500-i)
    event = ControlEvent(
        device_id='smart_home_001',
        event_type='threshold_exceeded' if i % 10 == 0 else 'normal',
        event_data={
            'value': 20 + (i % 10) * 0.5,
            'threshold': 25.0
        },
        timestamp=timestamp
    )
    storage.store_control_event(event)

# å­˜å‚¨å‚æ•°é…ç½®å†å²
for i in range(100):
    timestamp = datetime.utcnow() - timedelta(hours=100-i)
    storage.store_parameter_config(
        device_id='smart_home_001',
        parameter_name='target_temperature',
        parameter_value=22.0 + (i % 5) * 0.5,
        parameter_type='float',
        timestamp=timestamp
    )

# ä½¿ç”¨åˆ†æå™¨
analyzer = IoTControlAnalyzer(storage)

# åˆ†ææ§åˆ¶æ•ˆç‡
efficiency = analyzer.analyze_control_efficiency(
    'smart_home_001',
    timedelta(hours=24)
)
print(f"æ§åˆ¶æ•ˆç‡: {efficiency['efficiency_percent']:.2f}%")
print(f"æ€»çŠ¶æ€è½¬æ¢: {efficiency['total_transitions']}")
print(f"æ´»è·ƒçŠ¶æ€æ•°: {efficiency['active_states']}")

# è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
stats = storage.calculate_statistics('smart_home_001')
print(f"ç»Ÿè®¡ä¿¡æ¯: çŠ¶æ€è½¬æ¢æ•°={stats['state_transitions']['count']}, "
      f"äº‹ä»¶æ•°={stats['events']['count']}")

# åˆ†æçŠ¶æ€æ¨¡å¼
patterns = storage.analyze_state_patterns('smart_home_001')
print(f"çŠ¶æ€æ¨¡å¼: {len(patterns['patterns'])} ä¸ªçŠ¶æ€")
for pattern in patterns['patterns']:
    print(f"  {pattern['state_name']}: é¢‘ç‡={pattern['frequency']}, "
          f"å¹³å‡æŒç»­æ—¶é—´={pattern['avg_duration_ms']:.2f}ms")

# è·å–çŠ¶æ€å†å²
state_history = storage.get_state_history(
    'smart_home_001',
    start_time=datetime.utcnow() - timedelta(hours=1)
)
print(f"çŠ¶æ€å†å²: {len(state_history)} æ¡è®°å½•")

# è·å–æ§åˆ¶äº‹ä»¶
events = storage.get_control_events(
    device_id='smart_home_001',
    event_type='threshold_exceeded',
    start_time=datetime.utcnow() - timedelta(hours=24)
)
print(f"é˜ˆå€¼è¶…é™äº‹ä»¶: {len(events)} æ¡")

storage.close()
```

### 5.3 éªŒè¯ç»“æœ

**éªŒè¯æŒ‡æ ‡**ï¼š

- **å­˜å‚¨æ€§èƒ½**ï¼š100ä¸‡æ¡çŠ¶æ€è½¬æ¢å­˜å‚¨ < 14åˆ†é’Ÿ
- **æŸ¥è¯¢æ€§èƒ½**ï¼šå•è®¾å¤‡æŸ¥è¯¢ < 35ms
- **ç»Ÿè®¡è®¡ç®—**ï¼š1å°æ—¶ç»Ÿè®¡ < 180ms
- **çŠ¶æ€æ¨¡å¼åˆ†æ**ï¼š24å°æ—¶åˆ†æ < 400ms
- **æ§åˆ¶æ•ˆç‡åˆ†æ**ï¼š24å°æ—¶åˆ†æ < 450ms

**æ€§èƒ½æµ‹è¯•ç»“æœ**ï¼š

| æ“ä½œ | æ•°æ®é‡ | å¹³å‡æ—¶é—´ | æ€§èƒ½è¯„çº§ |
|------|--------|---------|---------|
| **çŠ¶æ€è½¬æ¢å­˜å‚¨** | 100ä¸‡ | 12.5åˆ†é’Ÿ | â­â­â­â­â­ |
| **äº‹ä»¶å­˜å‚¨** | 50ä¸‡ | 6.8åˆ†é’Ÿ | â­â­â­â­â­ |
| **å•è®¾å¤‡æŸ¥è¯¢** | 100ä¸‡ | 32ms | â­â­â­â­â­ |
| **ç»Ÿè®¡è®¡ç®—** | 100ä¸‡ | 170ms | â­â­â­â­â­ |
| **çŠ¶æ€æ¨¡å¼åˆ†æ** | 100ä¸‡ | 380ms | â­â­â­â­ |
| **æ§åˆ¶æ•ˆç‡åˆ†æ** | 100ä¸‡ | 430ms | â­â­â­â­ |

---

## 6. æ¡ˆä¾‹æ€»ç»“

### 6.1 æˆåŠŸå› ç´ 

**å…³é”®æˆåŠŸå› ç´ **ï¼š

1. **æ ‡å‡†åŒ–Schema**ï¼šä½¿ç”¨æ ‡å‡†æ§åˆ¶Schema
2. **å®æ—¶æ€§ä¿è¯**ï¼šæ»¡è¶³å®æ—¶æ€§è¦æ±‚
3. **äº‹ä»¶é©±åŠ¨**ï¼šçµæ´»çš„äº‹ä»¶å¤„ç†æœºåˆ¶
4. **çŠ¶æ€ç®¡ç†**ï¼šæ¸…æ™°çš„çŠ¶æ€æœºè®¾è®¡
5. **æ•°æ®å­˜å‚¨**ï¼šé«˜æ•ˆçš„æ•°æ®å­˜å‚¨å’ŒæŸ¥è¯¢ç³»ç»Ÿ
6. **åˆ†æèƒ½åŠ›**ï¼šå¼ºå¤§çš„æ•°æ®åˆ†æå’Œæ•ˆç‡è¯„ä¼°èƒ½åŠ›

### 6.2 æœ€ä½³å®è·µ

**å®è·µå»ºè®®**ï¼š

1. **Schemaä¼˜å…ˆ**ï¼šå…ˆå®šä¹‰æ§åˆ¶Schema
2. **å®æ—¶æ€§è®¾è®¡**ï¼šè€ƒè™‘å®æ—¶æ€§çº¦æŸ
3. **äº‹ä»¶é©±åŠ¨**ï¼šé‡‡ç”¨äº‹ä»¶é©±åŠ¨æ¶æ„
4. **çŠ¶æ€ç®¡ç†**ï¼šä½¿ç”¨çŠ¶æ€æœºç®¡ç†çŠ¶æ€
5. **æ•°æ®å­˜å‚¨**ï¼šé€‰æ‹©åˆé€‚çš„æ•°æ®åº“æ–¹æ¡ˆ
6. **æ€§èƒ½åˆ†æ**ï¼šå®šæœŸåˆ†ææ§åˆ¶æ•ˆç‡å’Œæ€§èƒ½

---

## 7. å‚è€ƒæ–‡çŒ®

### 6.1 æ ‡å‡†æ–‡æ¡£

- GB/T 34068-2017 ç‰©è”ç½‘æ€»ä½“æŠ€æœ¯ æ™ºèƒ½ä¼ æ„Ÿå™¨æ¥å£è§„èŒƒ
- IEC 61131-3:2013 Programmable controllers

### 6.2 æŠ€æœ¯æ–‡æ¡£

- æ§åˆ¶é€»è¾‘è®¾è®¡æœ€ä½³å®è·µ
- å®æ—¶æ§åˆ¶ç³»ç»Ÿè®¾è®¡æŒ‡å—

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `01_Overview.md` - æ¦‚è¿°
- `02_Formal_Definition.md` - å½¢å¼åŒ–å®šä¹‰
- `03_Standards.md` - æ ‡å‡†å¯¹æ ‡
- `04_Transformation.md` - è½¬æ¢ä½“ç³»ï¼ˆåŒ…å«æ•°æ®å­˜å‚¨ï¼‰

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21ï¼ˆæ‰©å±•æ§åˆ¶æ•°æ®å­˜å‚¨ä¸åˆ†æç³»ç»Ÿæ¡ˆä¾‹ï¼Œæ–°å¢PostgreSQLå­˜å‚¨å®è·µï¼‰

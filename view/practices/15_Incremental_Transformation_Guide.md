# å¢é‡è½¬æ¢å®æ–½æŒ‡å—

## ğŸ“‘ ç›®å½•

- [å¢é‡è½¬æ¢å®æ–½æŒ‡å—](#å¢é‡è½¬æ¢å®æ–½æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. å®æ–½æ¦‚è¿°](#1-å®æ–½æ¦‚è¿°)
    - [1.1 å®æ–½ç›®æ ‡](#11-å®æ–½ç›®æ ‡)
    - [1.2 å®æ–½æ­¥éª¤](#12-å®æ–½æ­¥éª¤)
  - [2. å˜æ›´æ£€æµ‹å®ç°](#2-å˜æ›´æ£€æµ‹å®ç°)
    - [2.1 å“ˆå¸Œæ¯”è¾ƒå®ç°](#21-å“ˆå¸Œæ¯”è¾ƒå®ç°)
    - [2.2 å·®å¼‚ç®—æ³•å®ç°](#22-å·®å¼‚ç®—æ³•å®ç°)
    - [2.3 äº‹ä»¶é©±åŠ¨å®ç°](#23-äº‹ä»¶é©±åŠ¨å®ç°)
  - [3. å¢é‡æ›´æ–°å®ç°](#3-å¢é‡æ›´æ–°å®ç°)
    - [3.1 æ›´æ–°ç­–ç•¥å®ç°](#31-æ›´æ–°ç­–ç•¥å®ç°)
    - [3.2 å¢é‡è½¬æ¢å¼•æ“](#32-å¢é‡è½¬æ¢å¼•æ“)
    - [3.3 ç»“æœåˆå¹¶æœºåˆ¶](#33-ç»“æœåˆå¹¶æœºåˆ¶)
  - [4. ä¾èµ–åˆ†æå®ç°](#4-ä¾èµ–åˆ†æå®ç°)
    - [4.1 ä¾èµ–å›¾æ„å»º](#41-ä¾èµ–å›¾æ„å»º)
    - [4.2 ä¾èµ–ä¼ æ’­å®ç°](#42-ä¾èµ–ä¼ æ’­å®ç°)
    - [4.3 ä¾èµ–ä¼˜åŒ–å®ç°](#43-ä¾èµ–ä¼˜åŒ–å®ç°)
  - [5. å†²çªå¤„ç†å®ç°](#5-å†²çªå¤„ç†å®ç°)
    - [5.1 å†²çªæ£€æµ‹](#51-å†²çªæ£€æµ‹)
    - [5.2 å†²çªè§£å†³ç­–ç•¥](#52-å†²çªè§£å†³ç­–ç•¥)
    - [5.3 å†²çªåˆå¹¶ç®—æ³•](#53-å†²çªåˆå¹¶ç®—æ³•)
  - [6. æ€§èƒ½ä¼˜åŒ–å®ç°](#6-æ€§èƒ½ä¼˜åŒ–å®ç°)
    - [6.1 ç¼“å­˜æœºåˆ¶](#61-ç¼“å­˜æœºåˆ¶)
    - [6.2 å¹¶è¡Œå¤„ç†](#62-å¹¶è¡Œå¤„ç†)
    - [6.3 å»¶è¿Ÿè®¡ç®—](#63-å»¶è¿Ÿè®¡ç®—)
  - [7. æµ‹è¯•ä¸éªŒè¯](#7-æµ‹è¯•ä¸éªŒè¯)
    - [7.1 å•å…ƒæµ‹è¯•](#71-å•å…ƒæµ‹è¯•)
    - [7.2 é›†æˆæµ‹è¯•](#72-é›†æˆæµ‹è¯•)
    - [7.3 æ€§èƒ½æµ‹è¯•](#73-æ€§èƒ½æµ‹è¯•)
  - [8. éƒ¨ç½²ä¸è¿ç»´](#8-éƒ¨ç½²ä¸è¿ç»´)
    - [8.1 éƒ¨ç½²é…ç½®](#81-éƒ¨ç½²é…ç½®)
    - [8.2 ç›‘æ§å‘Šè­¦](#82-ç›‘æ§å‘Šè­¦)
    - [8.3 æ•…éšœå¤„ç†](#83-æ•…éšœå¤„ç†)

---

## 1. å®æ–½æ¦‚è¿°

### 1.1 å®æ–½ç›®æ ‡

**å®æ–½ç›®æ ‡**ï¼š

1. **å˜æ›´æ£€æµ‹å‡†ç¡®ç‡**ï¼šâ‰¥ 95%
2. **å¢é‡æ›´æ–°æ•ˆç‡**ï¼šæå‡70%ä»¥ä¸Š
3. **ä¾èµ–åˆ†æå®Œæ•´æ€§**ï¼š100%
4. **å†²çªå¤„ç†æ­£ç¡®æ€§**ï¼š100%

### 1.2 å®æ–½æ­¥éª¤

**å®æ–½é˜¶æ®µ**ï¼š

1. **é˜¶æ®µ1**ï¼šå˜æ›´æ£€æµ‹å®ç°ï¼ˆWeek 1ï¼‰
2. **é˜¶æ®µ2**ï¼šå¢é‡æ›´æ–°å®ç°ï¼ˆWeek 1-2ï¼‰
3. **é˜¶æ®µ3**ï¼šä¾èµ–åˆ†æå®ç°ï¼ˆWeek 2ï¼‰
4. **é˜¶æ®µ4**ï¼šå†²çªå¤„ç†å®ç°ï¼ˆWeek 2-3ï¼‰
5. **é˜¶æ®µ5**ï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆWeek 3ï¼‰
6. **é˜¶æ®µ6**ï¼šæµ‹è¯•éªŒè¯ï¼ˆWeek 3-4ï¼‰

---

## 2. å˜æ›´æ£€æµ‹å®ç°

### 2.1 å“ˆå¸Œæ¯”è¾ƒå®ç°

**å®ç°ä»£ç **ï¼š

```typescript
// src/transformers/incremental/change-detector.ts
import { createHash } from 'crypto';

export class ChangeDetector {
  private hashCache: Map<string, string> = new Map();

  computeHash(schema: Schema): string {
    const key = schema.id;
    if (this.hashCache.has(key)) {
      return this.hashCache.get(key)!;
    }

    const hash = createHash('sha256')
      .update(JSON.stringify(schema))
      .digest('hex');

    this.hashCache.set(key, hash);
    return hash;
  }

  detectChanges(
    oldSchema: Schema,
    newSchema: Schema
  ): Change[] {
    const oldHash = this.computeHash(oldSchema);
    const newHash = this.computeHash(newSchema);

    if (oldHash === newHash) {
      return []; // æ— å˜æ›´
    }

    // ä½¿ç”¨å·®å¼‚ç®—æ³•æ£€æµ‹è¯¦ç»†å˜æ›´
    return this.detectDetailedChanges(oldSchema, newSchema);
  }

  private detectDetailedChanges(
    oldSchema: Schema,
    newSchema: Schema
  ): Change[] {
    const changes: Change[] = [];

    // æ£€æµ‹å­—æ®µå˜æ›´
    changes.push(...this.detectFieldChanges(oldSchema, newSchema));

    // æ£€æµ‹ç±»å‹å˜æ›´
    changes.push(...this.detectTypeChanges(oldSchema, newSchema));

    // æ£€æµ‹æ“ä½œå˜æ›´
    changes.push(...this.detectOperationChanges(oldSchema, newSchema));

    return changes;
  }
}
```

### 2.2 å·®å¼‚ç®—æ³•å®ç°

**Myersç®—æ³•å®ç°**ï¼š

```typescript
// src/transformers/incremental/diff-algorithm.ts
export class DiffAlgorithm {
  computeDiff(oldSchema: Schema, newSchema: Schema): Change[] {
    const oldPaths = this.extractPaths(oldSchema);
    const newPaths = this.extractPaths(newSchema);

    return this.myersDiff(oldPaths, newPaths);
  }

  private myersDiff(
    oldPaths: string[],
    newPaths: string[]
  ): Change[] {
    // Myerså·®å¼‚ç®—æ³•å®ç°
    const changes: Change[] = [];
    const n = oldPaths.length;
    const m = newPaths.length;

    // å®ç°Myersç®—æ³•æ ¸å¿ƒé€»è¾‘
    // ...

    return changes;
  }
}
```

### 2.3 äº‹ä»¶é©±åŠ¨å®ç°

**äº‹ä»¶ç›‘å¬**ï¼š

```typescript
// src/transformers/incremental/event-driven.ts
import { EventEmitter } from 'events';

export class SchemaChangeEmitter extends EventEmitter {
  watch(schema: Schema): void {
    // ç›‘å¬Schemaå˜æ›´äº‹ä»¶
    this.on('schema-change', (change: Change) => {
      this.handleChange(change);
    });
  }

  private handleChange(change: Change): void {
    // å¤„ç†å˜æ›´äº‹ä»¶
    this.emit('change-detected', change);
  }
}
```

---

## 3. å¢é‡æ›´æ–°å®ç°

### 3.1 æ›´æ–°ç­–ç•¥å®ç°

**ç­–ç•¥å®ç°**ï¼š

```typescript
// src/transformers/incremental/update-strategy.ts
export class UpdateStrategy {
  async update(
    changes: Change[],
    strategy: 'immediate' | 'batch' | 'delayed' | 'smart'
  ): Promise<void> {
    switch (strategy) {
      case 'immediate':
        return this.immediateUpdate(changes);
      case 'batch':
        return this.batchUpdate(changes);
      case 'delayed':
        return this.delayedUpdate(changes);
      case 'smart':
        return this.smartUpdate(changes);
    }
  }

  private async immediateUpdate(changes: Change[]): Promise<void> {
    for (const change of changes) {
      await this.processChange(change);
    }
  }

  private async batchUpdate(changes: Change[]): Promise<void> {
    // æ‰¹é‡å¤„ç†å˜æ›´
    await this.processBatch(changes);
  }

  private async smartUpdate(changes: Change[]): Promise<void> {
    // æ ¹æ®å˜æ›´ç±»å‹é€‰æ‹©ç­–ç•¥
    const critical = changes.filter(c => c.priority === 'high');
    const normal = changes.filter(c => c.priority === 'normal');

    await this.immediateUpdate(critical);
    await this.batchUpdate(normal);
  }
}
```

### 3.2 å¢é‡è½¬æ¢å¼•æ“

**è½¬æ¢å¼•æ“**ï¼š

```typescript
// src/transformers/incremental/incremental-transformer.ts
export class IncrementalTransformer {
  async transformIncremental(
    oldSchema: Schema,
    newSchema: Schema,
    changes: Change[]
  ): Promise<TransformationResult> {
    const result: TransformationResult = {
      changed: [],
      unchanged: [],
      deleted: [],
    };

    for (const change of changes) {
      switch (change.type) {
        case 'add':
          result.changed.push(await this.transformAdded(change));
          break;
        case 'modify':
          result.changed.push(await this.transformModified(change));
          break;
        case 'delete':
          result.deleted.push(await this.transformDeleted(change));
          break;
      }
    }

    return result;
  }

  private async transformAdded(change: Change): Promise<TransformedNode> {
    // è½¬æ¢æ–°å¢èŠ‚ç‚¹
    return this.transform(change.newValue);
  }

  private async transformModified(change: Change): Promise<TransformedNode> {
    // è½¬æ¢ä¿®æ”¹èŠ‚ç‚¹
    const oldResult = this.getCachedResult(change.path);
    const newResult = await this.transform(change.newValue);

    // åˆå¹¶ç»“æœ
    return this.mergeResults(oldResult, newResult);
  }

  private async transformDeleted(change: Change): Promise<void> {
    // æ¸…ç†åˆ é™¤èŠ‚ç‚¹
    this.removeCachedResult(change.path);
  }
}
```

### 3.3 ç»“æœåˆå¹¶æœºåˆ¶

**åˆå¹¶ç®—æ³•**ï¼š

```typescript
// src/transformers/incremental/result-merger.ts
export class ResultMerger {
  merge(
    oldResult: TransformationResult,
    newResult: TransformationResult
  ): TransformationResult {
    return {
      changed: this.mergeChanged(oldResult.changed, newResult.changed),
      unchanged: this.mergeUnchanged(oldResult.unchanged, newResult.unchanged),
      deleted: this.mergeDeleted(oldResult.deleted, newResult.deleted),
    };
  }

  private mergeChanged(
    old: TransformedNode[],
    new_: TransformedNode[]
  ): TransformedNode[] {
    // åˆå¹¶å˜æ›´ç»“æœ
    const merged = new Map<string, TransformedNode>();

    old.forEach(node => merged.set(node.id, node));
    new_.forEach(node => {
      const existing = merged.get(node.id);
      if (existing) {
        merged.set(node.id, this.mergeNode(existing, node));
      } else {
        merged.set(node.id, node);
      }
    });

    return Array.from(merged.values());
  }
}
```

---

## 4. ä¾èµ–åˆ†æå®ç°

### 4.1 ä¾èµ–å›¾æ„å»º

**æ„å»ºå®ç°**ï¼š

```typescript
// src/transformers/incremental/dependency-graph.ts
export class DependencyGraphBuilder {
  buildGraph(schemas: Schema[]): DependencyGraph {
    const graph: DependencyGraph = {
      nodes: new Map(),
      edges: new Map(),
    };

    // æ„å»ºèŠ‚ç‚¹
    schemas.forEach(schema => {
      graph.nodes.set(schema.id, {
        id: schema.id,
        schema,
        dependencies: [],
        dependents: [],
      });
    });

    // æ„å»ºè¾¹
    schemas.forEach(schema => {
      const dependencies = this.extractDependencies(schema);
      dependencies.forEach(depId => {
        this.addEdge(graph, schema.id, depId);
      });
    });

    return graph;
  }

  private extractDependencies(schema: Schema): string[] {
    const dependencies: string[] = [];

    // æå–å¼•ç”¨ä¾èµ–
    this.traverseSchema(schema, (node) => {
      if (node.$ref) {
        dependencies.push(this.resolveRef(node.$ref));
      }
    });

    return dependencies;
  }

  private addEdge(
    graph: DependencyGraph,
    from: string,
    to: string
  ): void {
    const fromNode = graph.nodes.get(from);
    const toNode = graph.nodes.get(to);

    if (fromNode && toNode) {
      fromNode.dependencies.push(to);
      toNode.dependents.push(from);

      if (!graph.edges.has(from)) {
        graph.edges.set(from, []);
      }
      graph.edges.get(from)!.push({
        from,
        to,
        type: 'direct',
        weight: 1,
      });
    }
  }
}
```

### 4.2 ä¾èµ–ä¼ æ’­å®ç°

**ä¼ æ’­å®ç°**ï¼š

```typescript
// src/transformers/incremental/dependency-propagator.ts
export class DependencyPropagator {
  propagate(
    graph: DependencyGraph,
    changedNode: string
  ): Set<string> {
    const affected: Set<string> = new Set();
    const queue: string[] = [changedNode];
    const visited: Set<string> = new Set();

    while (queue.length > 0) {
      const nodeId = queue.shift()!;

      if (visited.has(nodeId)) continue;
      visited.add(nodeId);
      affected.add(nodeId);

      const node = graph.nodes.get(nodeId);
      if (node) {
        // ä¼ æ’­åˆ°ä¾èµ–èŠ‚ç‚¹
        node.dependents.forEach(dependentId => {
          if (!visited.has(dependentId)) {
            queue.push(dependentId);
          }
        });
      }
    }

    return affected;
  }

  getTopologicalOrder(graph: DependencyGraph): string[] {
    // æ‹“æ‰‘æ’åº
    const inDegree = new Map<string, number>();
    const queue: string[] = [];
    const result: string[] = [];

    // è®¡ç®—å…¥åº¦
    graph.nodes.forEach((node, id) => {
      inDegree.set(id, node.dependencies.length);
      if (node.dependencies.length === 0) {
        queue.push(id);
      }
    });

    // æ‹“æ‰‘æ’åº
    while (queue.length > 0) {
      const nodeId = queue.shift()!;
      result.push(nodeId);

      const node = graph.nodes.get(nodeId);
      if (node) {
        node.dependents.forEach(dependentId => {
          const degree = inDegree.get(dependentId)! - 1;
          inDegree.set(dependentId, degree);
          if (degree === 0) {
            queue.push(dependentId);
          }
        });
      }
    }

    return result;
  }
}
```

### 4.3 ä¾èµ–ä¼˜åŒ–å®ç°

**ä¼˜åŒ–å®ç°**ï¼š

```typescript
// src/transformers/incremental/dependency-optimizer.ts
export class DependencyOptimizer {
  optimize(graph: DependencyGraph): DependencyGraph {
    // å‹ç¼©ä¼ é€’ä¾èµ–
    const optimized = this.compressTransitive(graph);

    // ç¼“å­˜ä¾èµ–å…³ç³»
    this.cacheDependencies(optimized);

    return optimized;
  }

  private compressTransitive(
    graph: DependencyGraph
  ): DependencyGraph {
    // å‹ç¼©ä¼ é€’ä¾èµ–
    const compressed = this.cloneGraph(graph);

    // ç§»é™¤ä¼ é€’è¾¹
    compressed.nodes.forEach((node, id) => {
      const directDeps = new Set(node.dependencies);
      const transitiveDeps = this.getTransitiveDependencies(graph, id);

      transitiveDeps.forEach(transDep => {
        if (directDeps.has(transDep)) {
          // ç§»é™¤ä¼ é€’ä¾èµ–
          this.removeEdge(compressed, id, transDep);
        }
      });
    });

    return compressed;
  }

  private getTransitiveDependencies(
    graph: DependencyGraph,
    nodeId: string
  ): Set<string> {
    const transitive = new Set<string>();
    const visited = new Set<string>();

    const dfs = (id: string) => {
      if (visited.has(id)) return;
      visited.add(id);

      const node = graph.nodes.get(id);
      if (node) {
        node.dependencies.forEach(depId => {
          transitive.add(depId);
          dfs(depId);
        });
      }
    };

    const node = graph.nodes.get(nodeId);
    if (node) {
      node.dependencies.forEach(depId => {
        dfs(depId);
      });
    }

    return transitive;
  }
}
```

---

## 5. å†²çªå¤„ç†å®ç°

### 5.1 å†²çªæ£€æµ‹

**æ£€æµ‹å®ç°**ï¼š

```typescript
// src/transformers/incremental/conflict-detector.ts
export class ConflictDetector {
  detectConflicts(changes: Change[]): Conflict[] {
    const conflicts: Conflict[] = [];

    // æ£€æµ‹å¹¶å‘ä¿®æ”¹å†²çª
    conflicts.push(...this.detectConcurrentModifications(changes));

    // æ£€æµ‹ä¾èµ–å†²çª
    conflicts.push(...this.detectDependencyConflicts(changes));

    // æ£€æµ‹è½¬æ¢å†²çª
    conflicts.push(...this.detectTransformationConflicts(changes));

    return conflicts;
  }

  private detectConcurrentModifications(
    changes: Change[]
  ): Conflict[] {
    const conflicts: Conflict[] = [];
    const pathChanges = new Map<string, Change[]>();

    // æŒ‰è·¯å¾„åˆ†ç»„å˜æ›´
    changes.forEach(change => {
      const path = change.path.join('.');
      if (!pathChanges.has(path)) {
        pathChanges.set(path, []);
      }
      pathChanges.get(path)!.push(change);
    });

    // æ£€æµ‹åŒä¸€è·¯å¾„çš„å¤šä¸ªå˜æ›´
    pathChanges.forEach((changesForPath, path) => {
      if (changesForPath.length > 1) {
        conflicts.push({
          type: 'concurrent-modification',
          path,
          changes: changesForPath,
          resolution: 'merge',
        });
      }
    });

    return conflicts;
  }
}
```

### 5.2 å†²çªè§£å†³ç­–ç•¥

**è§£å†³ç­–ç•¥**ï¼š

```typescript
// src/transformers/incremental/conflict-resolver.ts
export class ConflictResolver {
  async resolve(conflict: Conflict): Promise<Resolution> {
    switch (conflict.type) {
      case 'concurrent-modification':
        return this.resolveConcurrentModification(conflict);
      case 'dependency':
        return this.resolveDependency(conflict);
      case 'transformation':
        return this.resolveTransformation(conflict);
    }
  }

  private async resolveConcurrentModification(
    conflict: Conflict
  ): Promise<Resolution> {
    // åˆå¹¶ç­–ç•¥
    if (conflict.resolution === 'merge') {
      return this.mergeChanges(conflict.changes);
    }

    // æœ€åå†™å…¥è·èƒœ
    if (conflict.resolution === 'last-write-wins') {
      return this.lastWriteWins(conflict.changes);
    }

    // æ‰‹åŠ¨è§£å†³
    return this.manualResolution(conflict);
  }
}
```

### 5.3 å†²çªåˆå¹¶ç®—æ³•

**åˆå¹¶ç®—æ³•**ï¼š

```typescript
// src/transformers/incremental/conflict-merger.ts
export class ConflictMerger {
  merge(changes: Change[]): Change {
    // ä¸‰è·¯åˆå¹¶ç®—æ³•
    const base = this.getBaseVersion(changes[0].path);
    const change1 = changes[0];
    const change2 = changes[1];

    return this.threeWayMerge(base, change1, change2);
  }

  private threeWayMerge(
    base: any,
    change1: Change,
    change2: Change
  ): Change {
    // ä¸‰è·¯åˆå¹¶é€»è¾‘
    // 1. å¦‚æœä¸¤ä¸ªå˜æ›´ç›¸åŒï¼Œè¿”å›ä»»ä¸€
    if (this.isEqual(change1.newValue, change2.newValue)) {
      return change1;
    }

    // 2. å¦‚æœä¸€ä¸ªå˜æ›´ä¸baseç›¸åŒï¼Œè¿”å›å¦ä¸€ä¸ª
    if (this.isEqual(change1.newValue, base)) {
      return change2;
    }
    if (this.isEqual(change2.newValue, base)) {
      return change1;
    }

    // 3. å¦åˆ™éœ€è¦æ‰‹åŠ¨åˆå¹¶
    return this.manualMerge(change1, change2);
  }
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–å®ç°

### 6.1 ç¼“å­˜æœºåˆ¶

**ç¼“å­˜å®ç°**ï¼š

```typescript
// src/transformers/incremental/transformation-cache.ts
export class TransformationCache {
  private cache: Map<string, CachedResult> = new Map();

  get(key: string): CachedResult | null {
    const cached = this.cache.get(key);
    if (cached && !this.isExpired(cached)) {
      return cached;
    }
    return null;
  }

  set(key: string, result: TransformationResult): void {
    this.cache.set(key, {
      result,
      timestamp: Date.now(),
      ttl: 3600000, // 1å°æ—¶
    });
  }

  invalidate(pattern: string): void {
    // å¤±æ•ˆåŒ¹é…çš„ç¼“å­˜
    for (const key of this.cache.keys()) {
      if (key.includes(pattern)) {
        this.cache.delete(key);
      }
    }
  }
}
```

### 6.2 å¹¶è¡Œå¤„ç†

**å¹¶è¡Œå®ç°**ï¼š

```typescript
// src/transformers/incremental/parallel-processor.ts
export class ParallelProcessor {
  async processParallel(
    tasks: Task[],
    concurrency: number = 5
  ): Promise<Result[]> {
    const results: Result[] = [];
    const executing: Promise<void>[] = [];

    for (const task of tasks) {
      const promise = this.processTask(task).then(result => {
        results.push(result);
      });

      executing.push(promise);

      if (executing.length >= concurrency) {
        await Promise.race(executing);
        executing.splice(
          executing.findIndex(p => p === promise),
          1
        );
      }
    }

    await Promise.all(executing);
    return results;
  }
}
```

### 6.3 å»¶è¿Ÿè®¡ç®—

**å»¶è¿Ÿå®ç°**ï¼š

```typescript
// src/transformers/incremental/lazy-evaluator.ts
export class LazyEvaluator {
  private lazyResults: Map<string, () => Promise<any>> = new Map();

  lazyTransform(path: string, transformer: () => Promise<any>): void {
    this.lazyResults.set(path, transformer);
  }

  async evaluate(path: string): Promise<any> {
    const transformer = this.lazyResults.get(path);
    if (transformer) {
      return await transformer();
    }
    return null;
  }

  async evaluateAll(): Promise<Map<string, any>> {
    const results = new Map<string, any>();

    for (const [path, transformer] of this.lazyResults.entries()) {
      results.set(path, await transformer());
    }

    return results;
  }
}
```

---

## 7. æµ‹è¯•ä¸éªŒè¯

### 7.1 å•å…ƒæµ‹è¯•

**æµ‹è¯•ç”¨ä¾‹**ï¼š

```typescript
// tests/incremental/change-detector.test.ts
describe('ChangeDetector', () => {
  it('should detect schema changes', () => {
    const detector = new ChangeDetector();
    const oldSchema = loadSchema('old.json');
    const newSchema = loadSchema('new.json');

    const changes = detector.detectChanges(oldSchema, newSchema);
    expect(changes.length).toBeGreaterThan(0);
  });
});
```

### 7.2 é›†æˆæµ‹è¯•

**é›†æˆæµ‹è¯•**ï¼š

```typescript
// tests/incremental/integration.test.ts
describe('Incremental Transformation Integration', () => {
  it('should transform incrementally', async () => {
    const transformer = new IncrementalTransformer();
    const oldSchema = loadSchema('v1.json');
    const newSchema = loadSchema('v2.json');

    const result = await transformer.transform(oldSchema, newSchema);
    expect(result.changed.length).toBeGreaterThan(0);
  });
});
```

### 7.3 æ€§èƒ½æµ‹è¯•

**æ€§èƒ½æµ‹è¯•**ï¼š

```typescript
// tests/incremental/performance.test.ts
describe('Performance Tests', () => {
  it('should be faster than full transformation', async () => {
    const transformer = new IncrementalTransformer();
    const oldSchema = loadLargeSchema('large-v1.json');
    const newSchema = loadLargeSchema('large-v2.json');

    const start = Date.now();
    await transformer.transform(oldSchema, newSchema);
    const incrementalTime = Date.now() - start;

    const start2 = Date.now();
    await fullTransform(newSchema);
    const fullTime = Date.now() - start2;

    expect(incrementalTime).toBeLessThan(fullTime * 0.3);
  });
});
```

---

## 8. éƒ¨ç½²ä¸è¿ç»´

### 8.1 éƒ¨ç½²é…ç½®

**é…ç½®ç¤ºä¾‹**ï¼š

```yaml
# config/incremental.yaml
changeDetection:
  method: hash
  hashAlgorithm: sha256
  cacheEnabled: true

updateStrategy:
  default: smart
  critical: immediate
  normal: batch

dependencyAnalysis:
  enabled: true
  cacheEnabled: true
  optimizationEnabled: true

conflictResolution:
  default: merge
  concurrent: last-write-wins
```

### 8.2 ç›‘æ§å‘Šè­¦

**ç›‘æ§æŒ‡æ ‡**ï¼š

- å˜æ›´æ£€æµ‹æ—¶é—´
- å¢é‡è½¬æ¢æ—¶é—´
- ä¾èµ–åˆ†ææ—¶é—´
- å†²çªå¤„ç†æ—¶é—´
- ç¼“å­˜å‘½ä¸­ç‡

### 8.3 æ•…éšœå¤„ç†

**æ•…éšœå¤„ç†**ï¼š

1. å˜æ›´æ£€æµ‹å¤±è´¥ï¼šå›é€€åˆ°å…¨é‡è½¬æ¢
2. ä¾èµ–åˆ†æå¤±è´¥ï¼šä½¿ç”¨ä¿å®ˆç­–ç•¥
3. å†²çªå¤„ç†å¤±è´¥ï¼šæ ‡è®°ä¸ºæ‰‹åŠ¨å¤„ç†

---

**å‚è€ƒæ–‡æ¡£**ï¼š

- `analysis/12_Incremental_Transformation_Algorithm.md` - å¢é‡è½¬æ¢ç®—æ³•åˆ†æ
- `src/transformers/incremental/` - å¢é‡è½¬æ¢ä»£ç å®ç°

**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21

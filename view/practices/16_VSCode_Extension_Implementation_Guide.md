# VS Codeæ’ä»¶å®æ–½æŒ‡å—

## ğŸ“‘ ç›®å½•

- [VS Codeæ’ä»¶å®æ–½æŒ‡å—](#vs-codeæ’ä»¶å®æ–½æŒ‡å—)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [1. å®æ–½æ¦‚è¿°](#1-å®æ–½æ¦‚è¿°)
    - [1.1 å®æ–½ç›®æ ‡](#11-å®æ–½ç›®æ ‡)
    - [1.2 å®æ–½æ­¥éª¤](#12-å®æ–½æ­¥éª¤)
  - [2. é¡¹ç›®åˆå§‹åŒ–](#2-é¡¹ç›®åˆå§‹åŒ–)
    - [2.1 é¡¹ç›®ç»“æ„](#21-é¡¹ç›®ç»“æ„)
    - [2.2 ä¾èµ–å®‰è£…](#22-ä¾èµ–å®‰è£…)
    - [2.3 é…ç½®è®¾ç½®](#23-é…ç½®è®¾ç½®)
  - [3. æ ¸å¿ƒåŠŸèƒ½å®ç°](#3-æ ¸å¿ƒåŠŸèƒ½å®ç°)
    - [3.1 Schemaç¼–è¾‘å™¨å®ç°](#31-schemaç¼–è¾‘å™¨å®ç°)
    - [3.2 è½¬æ¢åŠŸèƒ½å®ç°](#32-è½¬æ¢åŠŸèƒ½å®ç°)
    - [3.3 éªŒè¯åŠŸèƒ½å®ç°](#33-éªŒè¯åŠŸèƒ½å®ç°)
  - [4. ç”¨æˆ·ç•Œé¢å®ç°](#4-ç”¨æˆ·ç•Œé¢å®ç°)
    - [4.1 å‘½ä»¤é¢æ¿å®ç°](#41-å‘½ä»¤é¢æ¿å®ç°)
    - [4.2 çŠ¶æ€æ å®ç°](#42-çŠ¶æ€æ å®ç°)
    - [4.3 ä¾§è¾¹æ å®ç°](#43-ä¾§è¾¹æ å®ç°)
  - [5. æµ‹è¯•å®ç°](#5-æµ‹è¯•å®ç°)
    - [5.1 å•å…ƒæµ‹è¯•](#51-å•å…ƒæµ‹è¯•)
    - [5.2 é›†æˆæµ‹è¯•](#52-é›†æˆæµ‹è¯•)
    - [5.3 ç«¯åˆ°ç«¯æµ‹è¯•](#53-ç«¯åˆ°ç«¯æµ‹è¯•)
  - [6. æ‰“åŒ…ä¸å‘å¸ƒ](#6-æ‰“åŒ…ä¸å‘å¸ƒ)
    - [6.1 æ‰“åŒ…é…ç½®](#61-æ‰“åŒ…é…ç½®)
    - [6.2 å‘å¸ƒå‡†å¤‡](#62-å‘å¸ƒå‡†å¤‡)
    - [6.3 å‘å¸ƒæµç¨‹](#63-å‘å¸ƒæµç¨‹)
  - [7. ç»´æŠ¤ä¸æ›´æ–°](#7-ç»´æŠ¤ä¸æ›´æ–°)
    - [7.1 ç‰ˆæœ¬ç®¡ç†](#71-ç‰ˆæœ¬ç®¡ç†)
    - [7.2 æ›´æ–°ç­–ç•¥](#72-æ›´æ–°ç­–ç•¥)
    - [7.3 ç”¨æˆ·åé¦ˆ](#73-ç”¨æˆ·åé¦ˆ)
  - [8. VS Codeæ’ä»¶ç»¼åˆåº”ç”¨å®é™…ç¤ºä¾‹](#8-vs-codeæ’ä»¶ç»¼åˆåº”ç”¨å®é™…ç¤ºä¾‹)
  - [9. å‚è€ƒæ–‡æ¡£](#9-å‚è€ƒæ–‡æ¡£)
    - [æ¶æ„æ–‡æ¡£](#æ¶æ„æ–‡æ¡£)
    - [æ¨¡å¼æ–‡æ¡£ â­æ–°å¢](#æ¨¡å¼æ–‡æ¡£-æ–°å¢)
  - [ğŸ“ ç‰ˆæœ¬å†å²](#-ç‰ˆæœ¬å†å²)

---

## 1. å®æ–½æ¦‚è¿°

### 1.1 å®æ–½ç›®æ ‡

**å®æ–½ç›®æ ‡**ï¼š

1. **åŠŸèƒ½å®Œæ•´**ï¼šå®ç°æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šå“åº”é€Ÿåº¦å¿«ï¼Œèµ„æºå ç”¨ä½
3. **ç”¨æˆ·ä½“éªŒ**ï¼šç•Œé¢å‹å¥½ï¼Œæ“ä½œç›´è§‚
4. **ç¨³å®šæ€§**ï¼šç¨³å®šå¯é ï¼Œé”™è¯¯å¤„ç†å®Œå–„

### 1.2 å®æ–½æ­¥éª¤

**å®æ–½é˜¶æ®µ**ï¼š

1. **é˜¶æ®µ1**ï¼šé¡¹ç›®åˆå§‹åŒ–ï¼ˆWeek 1ï¼‰
2. **é˜¶æ®µ2**ï¼šæ ¸å¿ƒåŠŸèƒ½å®ç°ï¼ˆWeek 1-2ï¼‰
3. **é˜¶æ®µ3**ï¼šç”¨æˆ·ç•Œé¢å®ç°ï¼ˆWeek 2ï¼‰
4. **é˜¶æ®µ4**ï¼šæµ‹è¯•å®ç°ï¼ˆWeek 2-3ï¼‰
5. **é˜¶æ®µ5**ï¼šæ‰“åŒ…å‘å¸ƒï¼ˆWeek 3ï¼‰
6. **é˜¶æ®µ6**ï¼šç»´æŠ¤æ›´æ–°ï¼ˆæŒç»­ï¼‰

---

## 2. é¡¹ç›®åˆå§‹åŒ–

### 2.1 é¡¹ç›®ç»“æ„

**ç›®å½•ç»“æ„**ï¼š

```text
tools/vscode-extension/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ extension.ts          # æ’ä»¶å…¥å£
â”‚   â”œâ”€â”€ completion.ts         # è‡ªåŠ¨è¡¥å…¨
â”‚   â”œâ”€â”€ diagnostics.ts        # é”™è¯¯æ£€æŸ¥
â”‚   â”œâ”€â”€ commands/             # å‘½ä»¤å®ç°
â”‚   â”œâ”€â”€ transformers/         # è½¬æ¢å™¨
â”‚   â”œâ”€â”€ validators/           # éªŒè¯å™¨
â”‚   â””â”€â”€ ui/                   # UIç»„ä»¶
â”œâ”€â”€ syntaxes/
â”‚   â””â”€â”€ dsl.tmLanguage.json   # è¯­æ³•å®šä¹‰
â”œâ”€â”€ themes/
â”‚   â””â”€â”€ dsl-schema-color-theme.json
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ suite/
â”‚   â””â”€â”€ integration/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â””â”€â”€ README.md
```

### 2.2 ä¾èµ–å®‰è£…

**package.json**ï¼š

```json
{
  "name": "dsl-schema-transformer",
  "displayName": "DSL Schema Transformer",
  "version": "1.0.0",
  "engines": {
    "vscode": "^1.80.0"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0"
  },
  "devDependencies": {
    "@types/vscode": "^1.80.0",
    "@types/node": "^18.0.0",
    "typescript": "^5.0.0",
    "@vscode/test-electron": "^2.0.0"
  }
}
```

### 2.3 é…ç½®è®¾ç½®

**tsconfig.json**ï¼š

```json
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2020",
    "outDir": "out",
    "lib": ["ES2020"],
    "sourceMap": true,
    "rootDir": "src",
    "strict": true
  },
  "exclude": ["node_modules", ".vscode-test"]
}
```

---

## 3. æ ¸å¿ƒåŠŸèƒ½å®ç°

### 3.1 Schemaç¼–è¾‘å™¨å®ç°

**ç¼–è¾‘å™¨æ¿€æ´»**ï¼š

```typescript
// src/extension.ts
import * as vscode from 'vscode';
import { provideCompletionItems } from './completion';
import { validateDocument } from './diagnostics';

export function activate(context: vscode.ExtensionContext) {
  // æ³¨å†Œè‡ªåŠ¨è¡¥å…¨
  context.subscriptions.push(
    vscode.languages.registerCompletionItemProvider(
      'dsl-schema',
      { provideCompletionItems },
      '.'
    )
  );

  // æ³¨å†Œé”™è¯¯æ£€æŸ¥
  const diagnosticCollection = vscode.languages.createDiagnosticCollection('dsl-schema');
  context.subscriptions.push(diagnosticCollection);

  vscode.workspace.onDidChangeTextDocument(e => {
    if (e.document.languageId === 'dsl-schema') {
      const diagnostics = validateDocument(e.document);
      diagnosticCollection.set(e.document.uri, diagnostics);
    }
  });
}
```

### 3.2 è½¬æ¢åŠŸèƒ½å®ç°

**è½¬æ¢å‘½ä»¤æ³¨å†Œ**ï¼š

```typescript
// src/commands/transform.ts
import * as vscode from 'vscode';
import { TransformerRegistry } from '../transformers/registry';

export function registerTransformCommand(
  context: vscode.ExtensionContext
): void {
  const command = vscode.commands.registerCommand(
    'dsl-schema.transform',
    async () => {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        vscode.window.showErrorMessage('No active editor');
        return;
      }

      const formats = ['openapi', 'json-schema', 'asyncapi'];
      const selected = await vscode.window.showQuickPick(formats, {
        placeHolder: 'Select target format'
      });

      if (!selected) return;

      try {
        const schema = parseSchema(editor.document.getText());
        const transformer = TransformerRegistry.get(selected);
        const result = await transformer.transform(schema);

        const doc = await vscode.workspace.openTextDocument({
          content: JSON.stringify(result, null, 2),
          language: 'json'
        });

        await vscode.window.showTextDocument(doc);
      } catch (error) {
        vscode.window.showErrorMessage(`Transformation failed: ${error.message}`);
      }
    }
  );

  context.subscriptions.push(command);
}
```

### 3.3 éªŒè¯åŠŸèƒ½å®ç°

**éªŒè¯å®ç°**ï¼š

```typescript
// src/validators/schema-validator.ts
export class SchemaValidator {
  validate(schema: Schema): ValidationResult {
    const errors: ValidationError[] = [];

    // éªŒè¯Schemaç»“æ„
    if (!schema.name) {
      errors.push({
        message: 'Schema name is required',
        severity: 'error'
      });
    }

    // éªŒè¯ç±»å‹å®šä¹‰
    schema.types?.forEach(type => {
      const typeErrors = this.validateType(type);
      errors.push(...typeErrors);
    });

    return {
      valid: errors.length === 0,
      errors
    };
  }
}
```

---

## 4. ç”¨æˆ·ç•Œé¢å®ç°

### 4.1 å‘½ä»¤é¢æ¿å®ç°

**å‘½ä»¤æ³¨å†Œ**ï¼š

```json
// package.json
{
  "contributes": {
    "commands": [
      {
        "command": "dsl-schema.transform",
        "title": "Transform Schema",
        "category": "DSL Schema"
      },
      {
        "command": "dsl-schema.validate",
        "title": "Validate Schema",
        "category": "DSL Schema"
      },
      {
        "command": "dsl-schema.preview",
        "title": "Preview Transformation",
        "category": "DSL Schema"
      }
    ],
    "menus": {
      "commandPalette": [
        {
          "command": "dsl-schema.transform",
          "when": "editorLangId == dsl-schema"
        }
      ]
    }
  }
}
```

### 4.2 çŠ¶æ€æ å®ç°

**çŠ¶æ€æ ä»£ç **ï¼š

```typescript
// src/ui/statusbar.ts
export class StatusBar {
  private statusBarItem: vscode.StatusBarItem;

  constructor() {
    this.statusBarItem = vscode.window.createStatusBarItem(
      vscode.StatusBarAlignment.Right,
      100
    );
    this.statusBarItem.command = 'dsl-schema.showStatus';
  }

  update(schema: Schema): void {
    const status = this.getStatus(schema);
    this.statusBarItem.text = `$(check) ${status}`;
    this.statusBarItem.show();
  }
}
```

### 4.3 ä¾§è¾¹æ å®ç°

**ä¾§è¾¹æ ä»£ç **ï¼š

```typescript
// src/ui/sidebar.ts
export class SchemaExplorerProvider
  implements vscode.TreeDataProvider<SchemaNode> {

  private _onDidChangeTreeData = new vscode.EventEmitter<SchemaNode | undefined>();
  readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }

  getTreeItem(element: SchemaNode): vscode.TreeItem {
    return element;
  }

  getChildren(element?: SchemaNode): Thenable<SchemaNode[]> {
    // å®ç°æ ‘èŠ‚ç‚¹è·å–é€»è¾‘
    return Promise.resolve([]);
  }
}
```

---

## 5. æµ‹è¯•å®ç°

### 5.1 å•å…ƒæµ‹è¯•

**æµ‹è¯•ç¤ºä¾‹**ï¼š

```typescript
// src/test/completion.test.ts
import * as assert from 'assert';
import * as vscode from 'vscode';
import { provideCompletionItems } from '../completion';

suite('Completion Provider Tests', () => {
  test('should provide schema keyword', () => {
    const document = createMockDocument('sc');
    const position = new vscode.Position(0, 2);

    const completions = provideCompletionItems(document, position);

    assert.ok(completions.some(c => c.label === 'schema'));
  });
});
```

### 5.2 é›†æˆæµ‹è¯•

**é›†æˆæµ‹è¯•**ï¼š

```typescript
// src/test/integration.test.ts
import * as assert from 'assert';
import * as vscode from 'vscode';

suite('Extension Integration Tests', () => {
  test('should activate extension', async () => {
    const extension = vscode.extensions.getExtension('your-extension-id');
    assert.ok(extension);
    await extension.activate();
    assert.ok(extension.isActive);
  });
});
```

### 5.3 ç«¯åˆ°ç«¯æµ‹è¯•

**E2Eæµ‹è¯•**ï¼š

```typescript
// src/test/e2e.test.ts
import * as assert from 'assert';
import * as vscode from 'vscode';

suite('E2E Tests', () => {
  test('should transform schema end-to-end', async () => {
    // æ‰“å¼€Schemaæ–‡ä»¶
    const doc = await vscode.workspace.openTextDocument('test.dsl');
    await vscode.window.showTextDocument(doc);

    // æ‰§è¡Œè½¬æ¢å‘½ä»¤
    await vscode.commands.executeCommand('dsl-schema.transform');

    // éªŒè¯ç»“æœ
    // ...
  });
});
```

---

## 6. æ‰“åŒ…ä¸å‘å¸ƒ

### 6.1 æ‰“åŒ…é…ç½®

**æ‰“åŒ…è„šæœ¬**ï¼š

```json
// package.json
{
  "scripts": {
    "compile": "tsc -p ./",
    "watch": "tsc -watch -p ./",
    "package": "vsce package",
    "publish": "vsce publish"
  }
}
```

### 6.2 å‘å¸ƒå‡†å¤‡

**å‘å¸ƒæ£€æŸ¥æ¸…å•**ï¼š

- [ ] ä»£ç ç¼–è¯‘é€šè¿‡
- [ ] æ‰€æœ‰æµ‹è¯•é€šè¿‡
- [ ] æ–‡æ¡£å®Œæ•´
- [ ] ç‰ˆæœ¬å·æ›´æ–°
- [ ] CHANGELOGæ›´æ–°

### 6.3 å‘å¸ƒæµç¨‹

**å‘å¸ƒæ­¥éª¤**ï¼š

1. **æ„å»º**ï¼š`npm run compile`
2. **æµ‹è¯•**ï¼šè¿è¡Œæ‰€æœ‰æµ‹è¯•
3. **æ‰“åŒ…**ï¼š`npm run package`
4. **éªŒè¯**ï¼šæœ¬åœ°å®‰è£…æµ‹è¯•
5. **å‘å¸ƒ**ï¼š`npm run publish`

---

## 7. ç»´æŠ¤ä¸æ›´æ–°

### 7.1 ç‰ˆæœ¬ç®¡ç†

**ç‰ˆæœ¬ç­–ç•¥**ï¼š

- **ä¸»ç‰ˆæœ¬å·**ï¼šä¸å…¼å®¹çš„APIä¿®æ”¹
- **æ¬¡ç‰ˆæœ¬å·**ï¼šå‘ä¸‹å…¼å®¹çš„åŠŸèƒ½æ€§æ–°å¢
- **ä¿®è®¢å·**ï¼šå‘ä¸‹å…¼å®¹çš„é—®é¢˜ä¿®æ­£

### 7.2 æ›´æ–°ç­–ç•¥

**æ›´æ–°æœºåˆ¶**ï¼š

- è‡ªåŠ¨æ›´æ–°æ£€æŸ¥
- ç”¨æˆ·é€šçŸ¥
- æ›´æ–°æ—¥å¿—

### 7.3 ç”¨æˆ·åé¦ˆ

**åé¦ˆæ¸ é“**ï¼š

- GitHub Issues
- ç”¨æˆ·è¯„ä»·
- åŠŸèƒ½è¯·æ±‚

---

## 8. VS Codeæ’ä»¶ç»¼åˆåº”ç”¨å®é™…ç¤ºä¾‹

**ç¤ºä¾‹ï¼šå®ç°VS Code Schemaè½¬æ¢æ’ä»¶æ ¸å¿ƒæ¡†æ¶**

```python
# æ³¨ï¼šæ­¤ç¤ºä¾‹ä½¿ç”¨Pythonæ¨¡æ‹ŸVS Codeæ’ä»¶æ¶æ„ï¼Œå®é™…å®ç°ä½¿ç”¨TypeScript

from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
import json
import re

class CommandType(Enum):
    """å‘½ä»¤ç±»å‹"""
    TRANSFORM = "transform"
    VALIDATE = "validate"
    FORMAT = "format"
    PREVIEW = "preview"

class DiagnosticSeverity(Enum):
    """è¯Šæ–­ä¸¥é‡æ€§"""
    ERROR = "error"
    WARNING = "warning"
    INFO = "info"
    HINT = "hint"

@dataclass
class Position:
    """æ–‡æ¡£ä½ç½®"""
    line: int
    character: int

@dataclass
class Range:
    """æ–‡æ¡£èŒƒå›´"""
    start: Position
    end: Position

@dataclass
class Diagnostic:
    """è¯Šæ–­ä¿¡æ¯"""
    range: Range
    message: str
    severity: DiagnosticSeverity
    source: str = "schema-transformer"

@dataclass
class CompletionItem:
    """è‡ªåŠ¨è¡¥å…¨é¡¹"""
    label: str
    kind: str
    detail: str
    insert_text: str
    documentation: str = ""

@dataclass
class TextEdit:
    """æ–‡æœ¬ç¼–è¾‘"""
    range: Range
    new_text: str

class VSCodeExtensionFramework:
    """VS Codeæ’ä»¶æ¡†æ¶æ¨¡æ‹Ÿ"""

    def __init__(self, extension_id: str):
        self.extension_id = extension_id
        self.commands: Dict[str, Callable] = {}
        self.completion_providers: List[Callable] = []
        self.diagnostic_providers: List[Callable] = []
        self.document_formatters: Dict[str, Callable] = {}
        self.transformers: Dict[str, Callable] = {}

        # åˆå§‹åŒ–æ ¸å¿ƒåŠŸèƒ½
        self._register_commands()
        self._register_completion_providers()
        self._register_diagnostic_providers()

    def _register_commands(self):
        """æ³¨å†Œå‘½ä»¤ï¼ˆåŸºäºç¬¬4.1ç« ï¼‰"""
        # è½¬æ¢å‘½ä»¤
        self.commands['schema.transform.openapi'] = self._transform_to_openapi
        self.commands['schema.transform.asyncapi'] = self._transform_to_asyncapi
        self.commands['schema.transform.jsonschema'] = self._transform_to_jsonschema

        # éªŒè¯å‘½ä»¤
        self.commands['schema.validate'] = self._validate_schema
        self.commands['schema.validate.strict'] = self._validate_schema_strict

        # æ ¼å¼åŒ–å‘½ä»¤
        self.commands['schema.format'] = self._format_schema

        # é¢„è§ˆå‘½ä»¤
        self.commands['schema.preview'] = self._preview_transformation

    def _register_completion_providers(self):
        """æ³¨å†Œè‡ªåŠ¨è¡¥å…¨æä¾›è€…ï¼ˆåŸºäºç¬¬3.1ç« ï¼‰"""
        self.completion_providers.append(self._openapi_completion_provider)
        self.completion_providers.append(self._asyncapi_completion_provider)
        self.completion_providers.append(self._jsonschema_completion_provider)

    def _register_diagnostic_providers(self):
        """æ³¨å†Œè¯Šæ–­æä¾›è€…ï¼ˆåŸºäºç¬¬3.3ç« ï¼‰"""
        self.diagnostic_providers.append(self._schema_syntax_diagnostic)
        self.diagnostic_providers.append(self._schema_semantic_diagnostic)

    # ===== å‘½ä»¤å®ç°ï¼ˆåŸºäºç¬¬4.1ç« ï¼‰=====
    def execute_command(self, command_id: str, *args) -> Any:
        """æ‰§è¡Œå‘½ä»¤"""
        if command_id not in self.commands:
            raise ValueError(f"æœªçŸ¥å‘½ä»¤: {command_id}")
        return self.commands[command_id](*args)

    def _transform_to_openapi(self, document_text: str) -> Dict:
        """è½¬æ¢ä¸ºOpenAPI"""
        schema = self._parse_schema(document_text)
        return self._apply_transformation(schema, 'openapi')

    def _transform_to_asyncapi(self, document_text: str) -> Dict:
        """è½¬æ¢ä¸ºAsyncAPI"""
        schema = self._parse_schema(document_text)
        return self._apply_transformation(schema, 'asyncapi')

    def _transform_to_jsonschema(self, document_text: str) -> Dict:
        """è½¬æ¢ä¸ºJSON Schema"""
        schema = self._parse_schema(document_text)
        return self._apply_transformation(schema, 'jsonschema')

    def _validate_schema(self, document_text: str) -> List[Diagnostic]:
        """éªŒè¯Schema"""
        diagnostics = []
        for provider in self.diagnostic_providers:
            diagnostics.extend(provider(document_text))
        return diagnostics

    def _validate_schema_strict(self, document_text: str) -> List[Diagnostic]:
        """ä¸¥æ ¼éªŒè¯Schema"""
        diagnostics = self._validate_schema(document_text)
        # æ·»åŠ é¢å¤–çš„ä¸¥æ ¼æ£€æŸ¥
        diagnostics.extend(self._strict_validation_checks(document_text))
        return diagnostics

    def _format_schema(self, document_text: str) -> str:
        """æ ¼å¼åŒ–Schema"""
        try:
            schema = json.loads(document_text)
            return json.dumps(schema, indent=2, ensure_ascii=False)
        except json.JSONDecodeError:
            return document_text

    def _preview_transformation(self, document_text: str, target_format: str) -> Dict:
        """é¢„è§ˆè½¬æ¢ç»“æœ"""
        schema = self._parse_schema(document_text)
        result = self._apply_transformation(schema, target_format)
        return {
            'source_format': self._detect_format(schema),
            'target_format': target_format,
            'preview': result,
            'changes': self._calculate_changes(schema, result)
        }

    # ===== è‡ªåŠ¨è¡¥å…¨ï¼ˆåŸºäºç¬¬3.1ç« ï¼‰=====
    def get_completions(self, document_text: str, position: Position) -> List[CompletionItem]:
        """è·å–è‡ªåŠ¨è¡¥å…¨å»ºè®®"""
        completions = []

        # è·å–å½“å‰ä¸Šä¸‹æ–‡
        context = self._get_completion_context(document_text, position)

        for provider in self.completion_providers:
            completions.extend(provider(context))

        return completions

    def _openapi_completion_provider(self, context: Dict) -> List[CompletionItem]:
        """OpenAPIè¡¥å…¨æä¾›è€…"""
        completions = []

        if context.get('in_root', False):
            completions.extend([
                CompletionItem(
                    label='openapi',
                    kind='property',
                    detail='OpenAPIç‰ˆæœ¬',
                    insert_text='"openapi": "3.1.0"',
                    documentation='æŒ‡å®šOpenAPIè§„èŒƒç‰ˆæœ¬'
                ),
                CompletionItem(
                    label='info',
                    kind='property',
                    detail='APIä¿¡æ¯',
                    insert_text='"info": {\n  "title": "$1",\n  "version": "$2"\n}',
                    documentation='APIçš„å…ƒæ•°æ®ä¿¡æ¯'
                ),
                CompletionItem(
                    label='paths',
                    kind='property',
                    detail='APIè·¯å¾„',
                    insert_text='"paths": {\n  "$1": {\n  }\n}',
                    documentation='APIçš„è·¯å¾„å®šä¹‰'
                )
            ])

        if context.get('in_paths', False):
            completions.extend([
                CompletionItem(
                    label='get',
                    kind='method',
                    detail='GETæ“ä½œ',
                    insert_text='"get": {\n  "operationId": "$1",\n  "responses": {}\n}',
                    documentation='HTTP GETæ“ä½œ'
                ),
                CompletionItem(
                    label='post',
                    kind='method',
                    detail='POSTæ“ä½œ',
                    insert_text='"post": {\n  "operationId": "$1",\n  "requestBody": {},\n  "responses": {}\n}',
                    documentation='HTTP POSTæ“ä½œ'
                )
            ])

        return completions

    def _asyncapi_completion_provider(self, context: Dict) -> List[CompletionItem]:
        """AsyncAPIè¡¥å…¨æä¾›è€…"""
        completions = []

        if context.get('in_root', False):
            completions.extend([
                CompletionItem(
                    label='asyncapi',
                    kind='property',
                    detail='AsyncAPIç‰ˆæœ¬',
                    insert_text='"asyncapi": "2.6.0"',
                    documentation='æŒ‡å®šAsyncAPIè§„èŒƒç‰ˆæœ¬'
                ),
                CompletionItem(
                    label='channels',
                    kind='property',
                    detail='æ¶ˆæ¯é€šé“',
                    insert_text='"channels": {\n  "$1": {\n  }\n}',
                    documentation='æ¶ˆæ¯é€šé“å®šä¹‰'
                )
            ])

        return completions

    def _jsonschema_completion_provider(self, context: Dict) -> List[CompletionItem]:
        """JSON Schemaè¡¥å…¨æä¾›è€…"""
        completions = []

        completions.extend([
            CompletionItem(
                label='type',
                kind='property',
                detail='æ•°æ®ç±»å‹',
                insert_text='"type": "$1"',
                documentation='æŒ‡å®šæ•°æ®ç±»å‹: string, number, object, array, boolean, null'
            ),
            CompletionItem(
                label='properties',
                kind='property',
                detail='å¯¹è±¡å±æ€§',
                insert_text='"properties": {\n  "$1": {\n    "type": "$2"\n  }\n}',
                documentation='å®šä¹‰å¯¹è±¡çš„å±æ€§'
            ),
            CompletionItem(
                label='required',
                kind='property',
                detail='å¿…éœ€å±æ€§',
                insert_text='"required": ["$1"]',
                documentation='æŒ‡å®šå¿…éœ€çš„å±æ€§åˆ—è¡¨'
            )
        ])

        return completions

    # ===== è¯Šæ–­ï¼ˆåŸºäºç¬¬3.3ç« ï¼‰=====
    def _schema_syntax_diagnostic(self, document_text: str) -> List[Diagnostic]:
        """è¯­æ³•è¯Šæ–­"""
        diagnostics = []

        try:
            json.loads(document_text)
        except json.JSONDecodeError as e:
            diagnostics.append(Diagnostic(
                range=Range(
                    start=Position(line=e.lineno - 1, character=e.colno - 1),
                    end=Position(line=e.lineno - 1, character=e.colno)
                ),
                message=f"JSONè¯­æ³•é”™è¯¯: {e.msg}",
                severity=DiagnosticSeverity.ERROR
            ))

        return diagnostics

    def _schema_semantic_diagnostic(self, document_text: str) -> List[Diagnostic]:
        """è¯­ä¹‰è¯Šæ–­"""
        diagnostics = []

        try:
            schema = json.loads(document_text)

            # æ£€æŸ¥OpenAPIå¿…éœ€å­—æ®µ
            if 'openapi' in schema:
                if 'info' not in schema:
                    diagnostics.append(Diagnostic(
                        range=Range(
                            start=Position(line=0, character=0),
                            end=Position(line=0, character=10)
                        ),
                        message="OpenAPIè§„èŒƒç¼ºå°‘å¿…éœ€çš„'info'å­—æ®µ",
                        severity=DiagnosticSeverity.ERROR
                    ))

                if 'paths' not in schema and 'webhooks' not in schema:
                    diagnostics.append(Diagnostic(
                        range=Range(
                            start=Position(line=0, character=0),
                            end=Position(line=0, character=10)
                        ),
                        message="OpenAPIè§„èŒƒéœ€è¦è‡³å°‘ä¸€ä¸ª'paths'æˆ–'webhooks'",
                        severity=DiagnosticSeverity.WARNING
                    ))

        except json.JSONDecodeError:
            pass

        return diagnostics

    def _strict_validation_checks(self, document_text: str) -> List[Diagnostic]:
        """ä¸¥æ ¼éªŒè¯æ£€æŸ¥"""
        diagnostics = []

        try:
            schema = json.loads(document_text)

            # æ£€æŸ¥æ˜¯å¦æœ‰æè¿°
            if 'description' not in schema.get('info', {}):
                diagnostics.append(Diagnostic(
                    range=Range(
                        start=Position(line=0, character=0),
                        end=Position(line=0, character=10)
                    ),
                    message="å»ºè®®æ·»åŠ APIæè¿°",
                    severity=DiagnosticSeverity.HINT
                ))

        except json.JSONDecodeError:
            pass

        return diagnostics

    # ===== è¾…åŠ©æ–¹æ³• =====
    def _parse_schema(self, text: str) -> Dict:
        """è§£æSchema"""
        return json.loads(text)

    def _detect_format(self, schema: Dict) -> str:
        """æ£€æµ‹Schemaæ ¼å¼"""
        if 'openapi' in schema:
            return 'openapi'
        elif 'asyncapi' in schema:
            return 'asyncapi'
        elif '$schema' in schema or 'type' in schema:
            return 'jsonschema'
        return 'unknown'

    def _apply_transformation(self, schema: Dict, target: str) -> Dict:
        """åº”ç”¨è½¬æ¢"""
        source_format = self._detect_format(schema)

        if source_format == target:
            return schema

        # ç®€åŒ–çš„è½¬æ¢é€»è¾‘
        if source_format == 'openapi' and target == 'asyncapi':
            return self._openapi_to_asyncapi(schema)
        elif source_format == 'asyncapi' and target == 'openapi':
            return self._asyncapi_to_openapi(schema)

        return schema

    def _openapi_to_asyncapi(self, openapi: Dict) -> Dict:
        """OpenAPIåˆ°AsyncAPIè½¬æ¢"""
        return {
            'asyncapi': '2.6.0',
            'info': openapi.get('info', {}),
            'channels': self._paths_to_channels(openapi.get('paths', {}))
        }

    def _asyncapi_to_openapi(self, asyncapi: Dict) -> Dict:
        """AsyncAPIåˆ°OpenAPIè½¬æ¢"""
        return {
            'openapi': '3.1.0',
            'info': asyncapi.get('info', {}),
            'paths': self._channels_to_paths(asyncapi.get('channels', {}))
        }

    def _paths_to_channels(self, paths: Dict) -> Dict:
        """è·¯å¾„è½¬é€šé“"""
        channels = {}
        for path, methods in paths.items():
            channel_name = path.replace('/', '.').lstrip('.')
            channels[channel_name] = {}
        return channels

    def _channels_to_paths(self, channels: Dict) -> Dict:
        """é€šé“è½¬è·¯å¾„"""
        paths = {}
        for channel in channels:
            path = '/' + channel.replace('.', '/')
            paths[path] = {}
        return paths

    def _calculate_changes(self, source: Dict, target: Dict) -> Dict:
        """è®¡ç®—å˜æ›´"""
        return {
            'added_fields': len(target) - len(source),
            'format_changed': True
        }

    def _get_completion_context(self, text: str, position: Position) -> Dict:
        """è·å–è¡¥å…¨ä¸Šä¸‹æ–‡"""
        lines = text.split('\n')
        current_line = lines[position.line] if position.line < len(lines) else ''

        return {
            'in_root': position.line < 5,
            'in_paths': 'paths' in text[:text.find(current_line)],
            'current_line': current_line
        }

# å®é™…åº”ç”¨ç¤ºä¾‹
extension = VSCodeExtensionFramework('schema-transformer')

# ç¤ºä¾‹1ï¼šæ‰§è¡Œè½¬æ¢å‘½ä»¤
print("=== ç¤ºä¾‹1ï¼šæ‰§è¡Œè½¬æ¢å‘½ä»¤ ===")
openapi_doc = json.dumps({
    'openapi': '3.1.0',
    'info': {'title': 'Test API', 'version': '1.0.0'},
    'paths': {'/users': {'get': {}}}
})
result = extension.execute_command('schema.transform.asyncapi', openapi_doc)
print(f"è½¬æ¢ç»“æœ: {json.dumps(result, indent=2)}")

# ç¤ºä¾‹2ï¼šéªŒè¯Schema
print("\n=== ç¤ºä¾‹2ï¼šéªŒè¯Schema ===")
invalid_doc = '{"openapi": "3.1.0"}'  # ç¼ºå°‘info
diagnostics = extension.execute_command('schema.validate', invalid_doc)
for diag in diagnostics:
    print(f"[{diag.severity.value}] {diag.message}")

# ç¤ºä¾‹3ï¼šè·å–è‡ªåŠ¨è¡¥å…¨
print("\n=== ç¤ºä¾‹3ï¼šè‡ªåŠ¨è¡¥å…¨ ===")
completions = extension.get_completions('{}', Position(line=0, character=1))
print(f"è¡¥å…¨å»ºè®®æ•°: {len(completions)}")
for comp in completions[:3]:
    print(f"  - {comp.label}: {comp.detail}")

# ç¤ºä¾‹4ï¼šé¢„è§ˆè½¬æ¢
print("\n=== ç¤ºä¾‹4ï¼šé¢„è§ˆè½¬æ¢ ===")
preview = extension.execute_command('schema.preview', openapi_doc, 'asyncapi')
print(f"æºæ ¼å¼: {preview['source_format']}")
print(f"ç›®æ ‡æ ¼å¼: {preview['target_format']}")
```

---

## 9. å‚è€ƒæ–‡æ¡£

### æ¶æ„æ–‡æ¡£

- `analysis/13_VSCode_Extension_Architecture.md` - æ’ä»¶æ¶æ„è®¾è®¡
- `tools/vscode-extension/` - æ’ä»¶ä»£ç å®ç°

### æ¨¡å¼æ–‡æ¡£ â­æ–°å¢

- `docs/structure/ARCHITECTURE_PATTERNS_SUMMARY.md`ï¼šæ¶æ„æ¨¡å¼æ€»ç»“ï¼ˆ12ä¸ªæ¨¡å¼ï¼‰
  - åœ¨VS Codeæ’ä»¶æ¶æ„è®¾è®¡ä¸­ï¼Œå¯ä»¥å‚è€ƒåˆ†å±‚æ¶æ„ã€å¾®æœåŠ¡æ¶æ„ç­‰æ¨¡å¼
- `docs/structure/DESIGN_PATTERNS_SUMMARY.md`ï¼šè®¾è®¡æ¨¡å¼æ€»ç»“ï¼ˆ15ä¸ªæ¨¡å¼ï¼‰
  - åœ¨æ’ä»¶å®ç°ä¸­ï¼Œå¯ä»¥å‚è€ƒå·¥å‚æ¨¡å¼ã€ç­–ç•¥æ¨¡å¼ã€è§‚å¯Ÿè€…æ¨¡å¼ç­‰
- `docs/structure/PATTERNS_QUICK_REFERENCE.md`ï¼šæ¨¡å¼å¿«é€Ÿå‚è€ƒæŒ‡å— â­æ¨è

---

## ğŸ“ ç‰ˆæœ¬å†å²

### v1.2 (2025-01-21) - å®é™…åº”ç”¨ç¤ºä¾‹å¢å¼ºç‰ˆ

- âœ… æ‰©å±•ç¬¬8ç« ï¼šä¸ºVS Codeæ’ä»¶æ·»åŠ ç»¼åˆåº”ç”¨å®é™…ç¤ºä¾‹ï¼ˆåŒ…å«æ’ä»¶æ¡†æ¶å®ç°ã€å‘½ä»¤ç³»ç»Ÿã€è‡ªåŠ¨è¡¥å…¨ã€è¯Šæ–­ç³»ç»Ÿã€è½¬æ¢é¢„è§ˆï¼‰
- âœ… æ·»åŠ ç‰ˆæœ¬å†å²ç« èŠ‚
- âœ… æ›´æ–°æ–‡æ¡£ç‰ˆæœ¬å·è‡³v1.2

### v1.1 (2025-01-27) - åˆå§‹ç‰ˆæœ¬

- âœ… åˆ›å»ºæ–‡æ¡£ï¼šVS Codeæ’ä»¶å®æ–½æŒ‡å—
- âœ… æ·»åŠ é¡¹ç›®åˆå§‹åŒ–
- âœ… æ·»åŠ æ ¸å¿ƒåŠŸèƒ½å®ç°
- âœ… æ·»åŠ ç”¨æˆ·ç•Œé¢å®ç°
- âœ… æ·»åŠ æµ‹è¯•å®ç°
- âœ… æ·»åŠ æ‰“åŒ…ä¸å‘å¸ƒ
- âœ… æ·»åŠ ç»´æŠ¤ä¸æ›´æ–°

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.2ï¼ˆå®é™…åº”ç”¨ç¤ºä¾‹å¢å¼ºç‰ˆï¼‰
**åˆ›å»ºæ—¶é—´**ï¼š2025-01-21
**æœ€åæ›´æ–°**ï¼š2025-01-21
